// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Template Only api.test.domain 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.1.0
// 
// License  : MIT
// 


export type ResponseContentType$getIncludeLocalReference = keyof Response$getIncludeLocalReference$Status$200;
export interface Params$getIncludeLocalReference {
    parameter: Parameter$getIncludeLocalReference;
}
export type RequestContentType$getIncludeRemoteReference = keyof RequestBody$getIncludeRemoteReference;
export interface Params$getIncludeRemoteReference {
    parameter: Parameter$getIncludeRemoteReference;
    requestBody: RequestBody$getIncludeRemoteReference["application/json"];
}
export type ResponseContentType$getFullRemoteReference = keyof Response$getFullRemoteReference$Status$200;
export interface Params$getFullRemoteReference {
    parameter: Parameter$getFullRemoteReference;
}
export type ResponseContentType$i$have$dot = keyof Response$i$have$dot$Status$200;
export type ResponseContentType$getReferenceItems = keyof Response$getReferenceItems$Status$200;
export type ResponseContentType$searchBook = keyof Response$searchBook$Status$200;
export interface Params$searchBook {
    parameter: Parameter$searchBook;
}
export type ResponseContentType$getBookById = keyof Response$getBookById$Status$200;
export interface Params$getBookById {
    parameter: Parameter$getBookById;
}
export type ResponseContentType$deleteBook = keyof Response$deleteBook$Status$200;
export interface Params$deleteBook {
    parameter: Parameter$deleteBook;
}
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$getIncludeLocalReference$Status$200 | Response$getFullRemoteReference$Status$200 | Response$i$have$dot$Status$200 | Response$getReferenceItems$Status$200 | Response$searchBook$Status$200 | Response$getBookById$Status$200 | Response$deleteBook$Status$200;
export namespace ErrorResponse {
    export type getIncludeLocalReference = void;
    export type getIncludeRemoteReference = void;
    export type getFullRemoteReference = void;
    export type i$have$dot = void;
    export type getReferenceItems = void;
    export type searchBook = void;
    export type getBookById = void;
    export type deleteBook = void;
}
export interface Encoding {
    contentType?: string;
    headers?: Record<string, any>;
    style?: string;
    explode?: boolean;
    allowReserved?: boolean;
}
export interface RequestArgs {
    httpMethod: HttpMethod;
    url: string;
    headers: ObjectLike | any;
    requestBody?: ObjectLike | any;
    requestBodyEncoding?: Record<string, Encoding>;
    queryParameters?: QueryParameters | undefined;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(requestArgs: RequestArgs, options?: RequestOption) => Promise<T>;
}
export const createClient = <RequestOption>(apiClient: ApiClient<RequestOption>, baseUrl: string) => {
    const _baseUrl = baseUrl.replace(/\\/$/, "");
    return {
        getIncludeLocalReference: (params: Params$getIncludeLocalReference, option?: RequestOption): Promise<Response$getIncludeLocalReference$Status$200["application/json"]> => {
            const url = _baseUrl + \`/get/IncludeLocalReference\`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                StringQuery: { value: params.parameter.StringQuery, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        getIncludeRemoteReference: (params: Params$getIncludeRemoteReference, option?: RequestOption): Promise<void> => {
            const url = _baseUrl + \`/get/IncludeRemoteReference\`;
            const headers = {
                "Content-Type": "application/json"
            };
            const queryParameters: QueryParameters = {
                IncludeRemoteReference: { value: params.parameter.IncludeRemoteReference, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                requestBody: params.requestBody,
                requestBodyEncoding: requestEncodings["application/json"],
                queryParameters: queryParameters
            }, option);
        },
        getFullRemoteReference: (params: Params$getFullRemoteReference, option?: RequestOption): Promise<Response$getFullRemoteReference$Status$200["application/json"]> => {
            const url = _baseUrl + \`/FullRemoteReference\`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                FullRemoteReferenceQuery: { value: params.parameter.FullRemoteReferenceQuery, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        i$have$dot: (option?: RequestOption): Promise<Response$i$have$dot$Status$200["application/json"]> => {
            const url = _baseUrl + \`/i/have/dot\`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        getReferenceItems: (option?: RequestOption): Promise<Response$getReferenceItems$Status$200["application/json"]> => {
            const url = _baseUrl + \`/get/reference/items\`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        searchBook: (params: Params$searchBook, option?: RequestOption): Promise<Response$searchBook$Status$200["application/json"]> => {
            const url = _baseUrl + \`/get/search/\${params.parameter["book.name"]}\`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                "from.publishedAt": { value: params.parameter["from.publishedAt"], explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        getBookById: (params: Params$getBookById, option?: RequestOption): Promise<Response$getBookById$Status$200["application/json"]> => {
            const url = _baseUrl + \`/get/books/\${params.parameter.id}\`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        deleteBook: (params: Params$deleteBook, option?: RequestOption): Promise<Response$deleteBook$Status$200["application/json"]> => {
            const url = _baseUrl + \`/get/books/\${params.parameter.id}\`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "DELETE",
                url,
                headers
            }, option);
        }
    };
};
type ClientFunction<RequestOption> = typeof createClient<RequestOption>;
export type Client<RequestOption> = ReturnType<ClientFunction<RequestOption>>;
"
`;

exports[`Template Only async-api.test.domain 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.1.0
// 
// License  : MIT
// 


export type ResponseContentType$getIncludeLocalReference = keyof Response$getIncludeLocalReference$Status$200;
export interface Params$getIncludeLocalReference {
    parameter: Parameter$getIncludeLocalReference;
}
export type RequestContentType$getIncludeRemoteReference = keyof RequestBody$getIncludeRemoteReference;
export interface Params$getIncludeRemoteReference {
    parameter: Parameter$getIncludeRemoteReference;
    requestBody: RequestBody$getIncludeRemoteReference["application/json"];
}
export type ResponseContentType$getFullRemoteReference = keyof Response$getFullRemoteReference$Status$200;
export interface Params$getFullRemoteReference {
    parameter: Parameter$getFullRemoteReference;
}
export type ResponseContentType$i$have$dot = keyof Response$i$have$dot$Status$200;
export type ResponseContentType$getReferenceItems = keyof Response$getReferenceItems$Status$200;
export type ResponseContentType$searchBook = keyof Response$searchBook$Status$200;
export interface Params$searchBook {
    parameter: Parameter$searchBook;
}
export type ResponseContentType$getBookById = keyof Response$getBookById$Status$200;
export interface Params$getBookById {
    parameter: Parameter$getBookById;
}
export type ResponseContentType$deleteBook = keyof Response$deleteBook$Status$200;
export interface Params$deleteBook {
    parameter: Parameter$deleteBook;
}
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$getIncludeLocalReference$Status$200 | Response$getFullRemoteReference$Status$200 | Response$i$have$dot$Status$200 | Response$getReferenceItems$Status$200 | Response$searchBook$Status$200 | Response$getBookById$Status$200 | Response$deleteBook$Status$200;
export namespace ErrorResponse {
    export type getIncludeLocalReference = void;
    export type getIncludeRemoteReference = void;
    export type getFullRemoteReference = void;
    export type i$have$dot = void;
    export type getReferenceItems = void;
    export type searchBook = void;
    export type getBookById = void;
    export type deleteBook = void;
}
export interface Encoding {
    contentType?: string;
    headers?: Record<string, any>;
    style?: string;
    explode?: boolean;
    allowReserved?: boolean;
}
export interface RequestArgs {
    httpMethod: HttpMethod;
    url: string;
    headers: ObjectLike | any;
    requestBody?: ObjectLike | any;
    requestBodyEncoding?: Record<string, Encoding>;
    queryParameters?: QueryParameters | undefined;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(requestArgs: RequestArgs, options?: RequestOption) => T;
}
export const createClient = <RequestOption>(apiClient: ApiClient<RequestOption>, baseUrl: string) => {
    const _baseUrl = baseUrl.replace(/\\/$/, "");
    return {
        getIncludeLocalReference: (params: Params$getIncludeLocalReference, option?: RequestOption): Response$getIncludeLocalReference$Status$200["application/json"] => {
            const url = _baseUrl + \`/get/IncludeLocalReference\`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                StringQuery: { value: params.parameter.StringQuery, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        getIncludeRemoteReference: (params: Params$getIncludeRemoteReference, option?: RequestOption): void => {
            const url = _baseUrl + \`/get/IncludeRemoteReference\`;
            const headers = {
                "Content-Type": "application/json"
            };
            const queryParameters: QueryParameters = {
                IncludeRemoteReference: { value: params.parameter.IncludeRemoteReference, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                requestBody: params.requestBody,
                requestBodyEncoding: requestEncodings["application/json"],
                queryParameters: queryParameters
            }, option);
        },
        getFullRemoteReference: (params: Params$getFullRemoteReference, option?: RequestOption): Response$getFullRemoteReference$Status$200["application/json"] => {
            const url = _baseUrl + \`/FullRemoteReference\`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                FullRemoteReferenceQuery: { value: params.parameter.FullRemoteReferenceQuery, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        i$have$dot: (option?: RequestOption): Response$i$have$dot$Status$200["application/json"] => {
            const url = _baseUrl + \`/i/have/dot\`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        getReferenceItems: (option?: RequestOption): Response$getReferenceItems$Status$200["application/json"] => {
            const url = _baseUrl + \`/get/reference/items\`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        searchBook: (params: Params$searchBook, option?: RequestOption): Response$searchBook$Status$200["application/json"] => {
            const url = _baseUrl + \`/get/search/\${params.parameter["book.name"]}\`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                "from.publishedAt": { value: params.parameter["from.publishedAt"], explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        getBookById: (params: Params$getBookById, option?: RequestOption): Response$getBookById$Status$200["application/json"] => {
            const url = _baseUrl + \`/get/books/\${params.parameter.id}\`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        deleteBook: (params: Params$deleteBook, option?: RequestOption): Response$deleteBook$Status$200["application/json"] => {
            const url = _baseUrl + \`/get/books/\${params.parameter.id}\`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "DELETE",
                url,
                headers
            }, option);
        }
    };
};
type ClientFunction<RequestOption> = typeof createClient<RequestOption>;
export type Client<RequestOption> = ReturnType<ClientFunction<RequestOption>>;
"
`;

exports[`Template Only infer.domain 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.1.0
// 
// License  : MIT
// 


export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = void;
export namespace ErrorResponse { }
export interface Encoding {
    contentType?: string;
    headers?: Record<string, any>;
    style?: string;
    explode?: boolean;
    allowReserved?: boolean;
}
export interface RequestArgs {
    httpMethod: HttpMethod;
    url: string;
    headers: ObjectLike | any;
    requestBody?: ObjectLike | any;
    requestBodyEncoding?: Record<string, Encoding>;
    queryParameters?: QueryParameters | undefined;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(requestArgs: RequestArgs, options?: RequestOption) => T;
}
export const createClient = <RequestOption>(apiClient: ApiClient<RequestOption>, baseUrl: string) => {
    const _baseUrl = baseUrl.replace(/\\/$/, "");
    return {};
};
type ClientFunction<RequestOption> = typeof createClient<RequestOption>;
export type Client<RequestOption> = ReturnType<ClientFunction<RequestOption>>;
"
`;
