// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Unknown client.ts 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.0.3
// 
// License  : BSD-3-Clause
// Url      : https://opensource.org/licenses/BSD-3-Clause
// 


export namespace Schemas {
    export type ApQU2qAj_advanced_certificate_pack_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: {
            certificate_authority?: Schemas.ApQU2qAj_schemas$certificate_authority;
            cloudflare_branding?: Schemas.ApQU2qAj_cloudflare_branding;
            hosts?: Schemas.ApQU2qAj_schemas$hosts;
            id?: Schemas.ApQU2qAj_identifier;
            status?: Schemas.ApQU2qAj_certificate$packs_components$schemas$status;
            type?: Schemas.ApQU2qAj_advanced_type;
            validation_method?: Schemas.ApQU2qAj_validation_method;
            validity_days?: Schemas.ApQU2qAj_validity_days;
        };
    };
    /** Type of certificate pack. */
    export type ApQU2qAj_advanced_type = "advanced";
    export type ApQU2qAj_api$response$collection = Schemas.ApQU2qAj_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.ApQU2qAj_result_info;
    };
    export interface ApQU2qAj_api$response$common {
        errors: Schemas.ApQU2qAj_messages;
        messages: Schemas.ApQU2qAj_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface ApQU2qAj_api$response$common$failure {
        errors: Schemas.ApQU2qAj_messages;
        messages: Schemas.ApQU2qAj_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type ApQU2qAj_api$response$single = Schemas.ApQU2qAj_api$response$common & {
        result?: {} | string;
    };
    export type ApQU2qAj_association_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_associationObject[];
    };
    export interface ApQU2qAj_associationObject {
        service?: Schemas.ApQU2qAj_service;
        status?: Schemas.ApQU2qAj_mtls$management_components$schemas$status;
    }
    export interface ApQU2qAj_base {
        /** When the Keyless SSL was created. */
        readonly created_on: Date;
        enabled: Schemas.ApQU2qAj_enabled;
        host: Schemas.ApQU2qAj_host;
        id: Schemas.ApQU2qAj_schemas$identifier;
        /** When the Keyless SSL was last modified. */
        readonly modified_on: Date;
        name: Schemas.ApQU2qAj_name;
        /** Available permissions for the Keyless SSL for the current user requesting the item. */
        readonly permissions: {}[];
        port: Schemas.ApQU2qAj_port;
        status: Schemas.ApQU2qAj_schemas$status;
        tunnel?: Schemas.ApQU2qAj_keyless_tunnel;
    }
    /** Certificate Authority is manually reviewing the order. */
    export type ApQU2qAj_brand_check = boolean;
    /** A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. */
    export type ApQU2qAj_bundle_method = "ubiquitous" | "optimal" | "force";
    /** Indicates whether the certificate is a CA or leaf certificate. */
    export type ApQU2qAj_ca = boolean;
    /** Certificate identifier tag. */
    export type ApQU2qAj_cert_id = string;
    /** Certificate Pack UUID. */
    export type ApQU2qAj_cert_pack_uuid = string;
    /** The zone's SSL certificate or certificate and the intermediate(s). */
    export type ApQU2qAj_certificate = string;
    /** Status of certificate pack. */
    export type ApQU2qAj_certificate$packs_components$schemas$status = "initializing" | "pending_validation" | "deleted" | "pending_issuance" | "pending_deployment" | "pending_deletion" | "pending_expiration" | "expired" | "active" | "initializing_timed_out" | "validation_timed_out" | "issuance_timed_out" | "deployment_timed_out" | "deletion_timed_out" | "pending_cleanup" | "staging_deployment" | "staging_active" | "deactivating" | "inactive" | "backup_issued" | "holding_deployment";
    export type ApQU2qAj_certificate_analyze_response = Schemas.ApQU2qAj_api$response$single & {
        result?: {};
    };
    /** The Certificate Authority that will issue the certificate */
    export type ApQU2qAj_certificate_authority = "digicert" | "google" | "lets_encrypt";
    export type ApQU2qAj_certificate_pack_quota_response = Schemas.ApQU2qAj_api$response$single & {
        result?: {
            advanced?: Schemas.ApQU2qAj_quota;
        };
    };
    export type ApQU2qAj_certificate_pack_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: {}[];
    };
    export type ApQU2qAj_certificate_pack_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: {};
    };
    export type ApQU2qAj_certificate_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_custom$certificate[];
    };
    export type ApQU2qAj_certificate_response_id_only = Schemas.ApQU2qAj_api$response$single & {
        result?: {
            id?: Schemas.ApQU2qAj_identifier;
        };
    };
    export type ApQU2qAj_certificate_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: {};
    };
    export type ApQU2qAj_certificate_response_single_id = Schemas.ApQU2qAj_schemas$certificate_response_single & {
        result?: {
            id?: Schemas.ApQU2qAj_identifier;
        };
    };
    export type ApQU2qAj_certificate_response_single_post = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_certificateObjectPost;
    };
    /** Current status of certificate. */
    export type ApQU2qAj_certificate_status = "initializing" | "authorizing" | "active" | "expired" | "issuing" | "timing_out" | "pending_deployment";
    export interface ApQU2qAj_certificateObject {
        certificate?: Schemas.ApQU2qAj_zone$authenticated$origin$pull_components$schemas$certificate;
        expires_on?: Schemas.ApQU2qAj_components$schemas$expires_on;
        id?: Schemas.ApQU2qAj_identifier;
        issuer?: Schemas.ApQU2qAj_issuer;
        signature?: Schemas.ApQU2qAj_signature;
        status?: Schemas.ApQU2qAj_zone$authenticated$origin$pull_components$schemas$status;
        uploaded_on?: Schemas.ApQU2qAj_schemas$uploaded_on;
    }
    export interface ApQU2qAj_certificateObjectPost {
        ca?: Schemas.ApQU2qAj_ca;
        certificates?: Schemas.ApQU2qAj_schemas$certificates;
        expires_on?: Schemas.ApQU2qAj_mtls$management_components$schemas$expires_on;
        id?: Schemas.ApQU2qAj_identifier;
        issuer?: Schemas.ApQU2qAj_schemas$issuer;
        name?: Schemas.ApQU2qAj_schemas$name;
        serial_number?: Schemas.ApQU2qAj_schemas$serial_number;
        signature?: Schemas.ApQU2qAj_signature;
        updated_at?: Schemas.ApQU2qAj_schemas$updated_at;
        uploaded_on?: Schemas.ApQU2qAj_mtls$management_components$schemas$uploaded_on;
    }
    export interface ApQU2qAj_certificates {
        certificate?: Schemas.ApQU2qAj_components$schemas$certificate;
        csr: Schemas.ApQU2qAj_csr;
        expires_on?: Schemas.ApQU2qAj_schemas$expires_on;
        hostnames: Schemas.ApQU2qAj_hostnames;
        id?: Schemas.ApQU2qAj_identifier;
        request_type: Schemas.ApQU2qAj_request_type;
        requested_validity: Schemas.ApQU2qAj_requested_validity;
    }
    /** The Client Certificate PEM */
    export type ApQU2qAj_client$certificates_components$schemas$certificate = string;
    /** Certificate Authority used to issue the Client Certificate */
    export interface ApQU2qAj_client$certificates_components$schemas$certificate_authority {
        id?: string;
        name?: string;
    }
    /** Client Certificates may be active or revoked, and the pending_reactivation or pending_revocation represent in-progress asynchronous transitions */
    export type ApQU2qAj_client$certificates_components$schemas$status = "active" | "pending_reactivation" | "pending_revocation" | "revoked";
    export interface ApQU2qAj_client_certificate {
        certificate?: Schemas.ApQU2qAj_client$certificates_components$schemas$certificate;
        certificate_authority?: Schemas.ApQU2qAj_client$certificates_components$schemas$certificate_authority;
        common_name?: Schemas.ApQU2qAj_common_name;
        country?: Schemas.ApQU2qAj_country;
        csr?: Schemas.ApQU2qAj_schemas$csr;
        expires_on?: Schemas.ApQU2qAj_expired_on;
        fingerprint_sha256?: Schemas.ApQU2qAj_fingerprint_sha256;
        id?: Schemas.ApQU2qAj_identifier;
        issued_on?: Schemas.ApQU2qAj_issued_on;
        location?: Schemas.ApQU2qAj_location;
        organization?: Schemas.ApQU2qAj_organization;
        organizational_unit?: Schemas.ApQU2qAj_organizational_unit;
        serial_number?: Schemas.ApQU2qAj_components$schemas$serial_number;
        signature?: Schemas.ApQU2qAj_components$schemas$signature;
        ski?: Schemas.ApQU2qAj_ski;
        state?: Schemas.ApQU2qAj_state;
        status?: Schemas.ApQU2qAj_client$certificates_components$schemas$status;
        validity_days?: Schemas.ApQU2qAj_components$schemas$validity_days;
    }
    export type ApQU2qAj_client_certificate_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_client_certificate[];
    };
    export type ApQU2qAj_client_certificate_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_client_certificate;
    };
    /** Whether or not to add Cloudflare Branding for the order.  This will add sni.cloudflaressl.com as the Common Name if set true. */
    export type ApQU2qAj_cloudflare_branding = boolean;
    /** Common Name of the Client Certificate */
    export type ApQU2qAj_common_name = string;
    /** The Origin CA certificate. Will be newline-encoded. */
    export type ApQU2qAj_components$schemas$certificate = string;
    /** The Certificate Authority that Total TLS certificates will be issued through. */
    export type ApQU2qAj_components$schemas$certificate_authority = "google" | "lets_encrypt";
    export type ApQU2qAj_components$schemas$certificate_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_zone$authenticated$origin$pull[];
    };
    export type ApQU2qAj_components$schemas$certificate_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_schemas$certificateObject;
    };
    export interface ApQU2qAj_components$schemas$certificateObject {
        ca?: Schemas.ApQU2qAj_ca;
        certificates?: Schemas.ApQU2qAj_schemas$certificates;
        expires_on?: Schemas.ApQU2qAj_mtls$management_components$schemas$expires_on;
        id?: Schemas.ApQU2qAj_identifier;
        issuer?: Schemas.ApQU2qAj_schemas$issuer;
        name?: Schemas.ApQU2qAj_schemas$name;
        serial_number?: Schemas.ApQU2qAj_schemas$serial_number;
        signature?: Schemas.ApQU2qAj_signature;
        uploaded_on?: Schemas.ApQU2qAj_mtls$management_components$schemas$uploaded_on;
    }
    /** This is the time the tls setting was originally created for this hostname. */
    export type ApQU2qAj_components$schemas$created_at = Date;
    /** If enabled, Total TLS will order a hostname specific TLS certificate for any proxied A, AAAA, or CNAME record in your zone. */
    export type ApQU2qAj_components$schemas$enabled = boolean;
    /** When the certificate from the authority expires. */
    export type ApQU2qAj_components$schemas$expires_on = Date;
    /** The hostname for which the tls settings are set. */
    export type ApQU2qAj_components$schemas$hostname = string;
    /** The private key for the certificate */
    export type ApQU2qAj_components$schemas$private_key = string;
    /** The serial number on the created Client Certificate. */
    export type ApQU2qAj_components$schemas$serial_number = string;
    /** The type of hash used for the Client Certificate.. */
    export type ApQU2qAj_components$schemas$signature = string;
    /** Status of the hostname's activation. */
    export type ApQU2qAj_components$schemas$status = "active" | "pending" | "active_redeploying" | "moved" | "pending_deletion" | "deleted" | "pending_blocked" | "pending_migration" | "pending_provisioned" | "test_pending" | "test_active" | "test_active_apex" | "test_blocked" | "test_failed" | "provisioned" | "blocked";
    /** This is the time the tls setting was updated. */
    export type ApQU2qAj_components$schemas$updated_at = Date;
    /** The time when the certificate was uploaded. */
    export type ApQU2qAj_components$schemas$uploaded_on = Date;
    export interface ApQU2qAj_components$schemas$validation_method {
        validation_method: Schemas.ApQU2qAj_validation_method_definition;
    }
    /** The number of days the Client Certificate will be valid after the issued_on date */
    export type ApQU2qAj_components$schemas$validity_days = number;
    export type ApQU2qAj_config = Schemas.ApQU2qAj_hostname_certid_input[];
    /** Country, provided by the CSR */
    export type ApQU2qAj_country = string;
    /** This is the time the hostname was created. */
    export type ApQU2qAj_created_at = Date;
    /** The Certificate Signing Request (CSR). Must be newline-encoded. */
    export type ApQU2qAj_csr = string;
    export interface ApQU2qAj_custom$certificate {
        bundle_method: Schemas.ApQU2qAj_bundle_method;
        expires_on: Schemas.ApQU2qAj_expires_on;
        geo_restrictions?: Schemas.ApQU2qAj_geo_restrictions;
        hosts: Schemas.ApQU2qAj_hosts;
        id: Schemas.ApQU2qAj_identifier;
        issuer: Schemas.ApQU2qAj_issuer;
        keyless_server?: Schemas.ApQU2qAj_keyless$certificate;
        modified_on: Schemas.ApQU2qAj_modified_on;
        policy?: Schemas.ApQU2qAj_policy;
        priority: Schemas.ApQU2qAj_priority;
        signature: Schemas.ApQU2qAj_signature;
        status: Schemas.ApQU2qAj_status;
        uploaded_on: Schemas.ApQU2qAj_uploaded_on;
        zone_id: Schemas.ApQU2qAj_identifier;
    }
    export type ApQU2qAj_custom$hostname = Schemas.ApQU2qAj_customhostname;
    export type ApQU2qAj_custom_hostname_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_custom$hostname[];
    };
    export type ApQU2qAj_custom_hostname_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_custom$hostname;
    };
    export type ApQU2qAj_custom_metadata = {
        /** Unique metadata for this hostname. */
        key?: string;
    };
    /** a valid hostname thatâ€™s been added to your DNS zone as an A, AAAA, or CNAME record. */
    export type ApQU2qAj_custom_origin_server = string;
    /** A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server. */
    export type ApQU2qAj_custom_origin_sni = string;
    export interface ApQU2qAj_customhostname {
        created_at?: Schemas.ApQU2qAj_created_at;
        custom_metadata?: Schemas.ApQU2qAj_custom_metadata;
        custom_origin_server?: Schemas.ApQU2qAj_custom_origin_server;
        custom_origin_sni?: Schemas.ApQU2qAj_custom_origin_sni;
        hostname?: Schemas.ApQU2qAj_hostname;
        id?: Schemas.ApQU2qAj_identifier;
        ownership_verification?: Schemas.ApQU2qAj_ownership_verification;
        ownership_verification_http?: Schemas.ApQU2qAj_ownership_verification_http;
        ssl?: Schemas.ApQU2qAj_ssl;
        status?: Schemas.ApQU2qAj_components$schemas$status;
        verification_errors?: Schemas.ApQU2qAj_verification_errors;
    }
    export type ApQU2qAj_dcv_delegation_response = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_uuidObject;
    };
    export type ApQU2qAj_delete_advanced_certificate_pack_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: {
            id?: Schemas.ApQU2qAj_identifier;
        };
    };
    /** Whether or not the Keyless SSL is on or off. */
    export type ApQU2qAj_enabled = boolean;
    export type ApQU2qAj_enabled_response = Schemas.ApQU2qAj_api$response$single & {
        result?: {
            enabled?: Schemas.ApQU2qAj_zone$authenticated$origin$pull_components$schemas$enabled;
        };
    };
    /** Whether or not the Keyless SSL is on or off. */
    export type ApQU2qAj_enabled_write = boolean;
    /** Date that the Client Certificate expires */
    export type ApQU2qAj_expired_on = string;
    /** When the certificate from the authority expires. */
    export type ApQU2qAj_expires_on = Date;
    export type ApQU2qAj_fallback_origin_response = Schemas.ApQU2qAj_api$response$single & {
        result?: {};
    };
    /** Unique identifier of the Client Certificate */
    export type ApQU2qAj_fingerprint_sha256 = string;
    /** Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance. */
    export interface ApQU2qAj_geo_restrictions {
        label?: "us" | "eu" | "highest_security";
    }
    /** The keyless SSL name. */
    export type ApQU2qAj_host = string;
    /** The custom hostname that will point to your hostname via CNAME. */
    export type ApQU2qAj_hostname = string;
    export type ApQU2qAj_hostname$authenticated$origin$pull = Schemas.ApQU2qAj_hostname_certid_object;
    /** The hostname certificate. */
    export type ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$certificate = string;
    export type ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$certificate_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull[];
    };
    /** Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association. */
    export type ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$enabled = boolean | null;
    /** The date when the certificate expires. */
    export type ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$expires_on = Date;
    /** Status of the certificate or the association. */
    export type ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$status = "initializing" | "pending_deployment" | "pending_deletion" | "active" | "deleted" | "deployment_timed_out" | "deletion_timed_out";
    /** Deployment status for the given tls setting. */
    export type ApQU2qAj_hostname$tls$settings_components$schemas$status = string;
    export type ApQU2qAj_hostname_aop_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull[];
    };
    export type ApQU2qAj_hostname_aop_single_response = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_hostname_certid_object;
    };
    export interface ApQU2qAj_hostname_association {
        hostnames?: string[];
        /** The UUID for a certificate that was uploaded to the mTLS Certificate Management endpoint. If no mtls_certificate_id is given, the hostnames will be associated to your active Cloudflare Managed CA. */
        mtls_certificate_id?: string;
    }
    export type ApQU2qAj_hostname_associations_response = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_hostname_association;
    };
    export interface ApQU2qAj_hostname_certid_input {
        cert_id?: Schemas.ApQU2qAj_cert_id;
        enabled?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$enabled;
        hostname?: Schemas.ApQU2qAj_schemas$hostname;
    }
    export interface ApQU2qAj_hostname_certid_object {
        cert_id?: Schemas.ApQU2qAj_identifier;
        cert_status?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$status;
        cert_updated_at?: Schemas.ApQU2qAj_updated_at;
        cert_uploaded_on?: Schemas.ApQU2qAj_components$schemas$uploaded_on;
        certificate?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$certificate;
        created_at?: Schemas.ApQU2qAj_schemas$created_at;
        enabled?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$enabled;
        expires_on?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$expires_on;
        hostname?: Schemas.ApQU2qAj_schemas$hostname;
        issuer?: Schemas.ApQU2qAj_issuer;
        serial_number?: Schemas.ApQU2qAj_serial_number;
        signature?: Schemas.ApQU2qAj_signature;
        status?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$status;
        updated_at?: Schemas.ApQU2qAj_updated_at;
    }
    /** The custom hostname that will point to your hostname via CNAME. */
    export type ApQU2qAj_hostname_post = string;
    /** Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate. */
    export type ApQU2qAj_hostnames = {}[];
    export type ApQU2qAj_hosts = string[];
    /** Identifier */
    export type ApQU2qAj_identifier = string;
    /** Date that the Client Certificate was issued by the Certificate Authority */
    export type ApQU2qAj_issued_on = string;
    /** The certificate authority that issued the certificate. */
    export type ApQU2qAj_issuer = string;
    export type ApQU2qAj_keyless$certificate = Schemas.ApQU2qAj_base;
    /** Private IP of the Key Server Host */
    export type ApQU2qAj_keyless_private_ip = string;
    export type ApQU2qAj_keyless_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_keyless$certificate[];
    };
    export type ApQU2qAj_keyless_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_base;
    };
    export type ApQU2qAj_keyless_response_single_id = Schemas.ApQU2qAj_api$response$single & {
        result?: {
            id?: Schemas.ApQU2qAj_identifier;
        };
    };
    /** Configuration for using Keyless SSL through a Cloudflare Tunnel */
    export interface ApQU2qAj_keyless_tunnel {
        private_ip: Schemas.ApQU2qAj_keyless_private_ip;
        vnet_id: Schemas.ApQU2qAj_keyless_vnet_id;
    }
    /** Cloudflare Tunnel Virtual Network ID */
    export type ApQU2qAj_keyless_vnet_id = string;
    /** Location, provided by the CSR */
    export type ApQU2qAj_location = string;
    export type ApQU2qAj_messages = {
        code: number;
        message: string;
    }[];
    /** When the certificate was last modified. */
    export type ApQU2qAj_modified_on = Date;
    export type ApQU2qAj_mtls$management_components$schemas$certificate_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_components$schemas$certificateObject[];
    } & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
            total_pages?: any;
        };
    };
    export type ApQU2qAj_mtls$management_components$schemas$certificate_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_components$schemas$certificateObject;
    };
    /** When the certificate expires. */
    export type ApQU2qAj_mtls$management_components$schemas$expires_on = Date;
    /** Certificate deployment status for the given service. */
    export type ApQU2qAj_mtls$management_components$schemas$status = string;
    /** This is the time the certificate was uploaded. */
    export type ApQU2qAj_mtls$management_components$schemas$uploaded_on = Date;
    /** The keyless SSL name. */
    export type ApQU2qAj_name = string;
    /** The keyless SSL name. */
    export type ApQU2qAj_name_write = string;
    /** Organization, provided by the CSR */
    export type ApQU2qAj_organization = string;
    /** Organizational Unit, provided by the CSR */
    export type ApQU2qAj_organizational_unit = string;
    /** Your origin hostname that requests to your custom hostnames will be sent to. */
    export type ApQU2qAj_origin = string;
    export type ApQU2qAj_ownership_verification = {
        /** DNS Name for record. */
        name?: string;
        /** DNS Record type. */
        type?: "txt";
        /** Content for the record. */
        value?: string;
    };
    export type ApQU2qAj_ownership_verification_http = {
        /** Token to be served. */
        http_body?: string;
        /** The HTTP URL that will be checked during custom hostname verification and where the customer should host the token. */
        http_url?: string;
    };
    export type ApQU2qAj_per_hostname_settings_response = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_settingObject;
    };
    export type ApQU2qAj_per_hostname_settings_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: {
            created_at?: Schemas.ApQU2qAj_components$schemas$created_at;
            hostname?: Schemas.ApQU2qAj_components$schemas$hostname;
            status?: Schemas.ApQU2qAj_hostname$tls$settings_components$schemas$status;
            updated_at?: Schemas.ApQU2qAj_components$schemas$updated_at;
            value?: Schemas.ApQU2qAj_value;
        }[];
    } & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
            /** Total pages available of results */
            total_pages?: number;
        };
    };
    export type ApQU2qAj_per_hostname_settings_response_delete = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_settingObjectDelete;
    };
    /** Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected. */
    export type ApQU2qAj_policy = string;
    /** The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server. */
    export type ApQU2qAj_port = number;
    /** The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates. */
    export type ApQU2qAj_priority = number;
    /** The zone's private key. */
    export type ApQU2qAj_private_key = string;
    export interface ApQU2qAj_quota {
        /** Quantity Allocated. */
        allocated?: number;
        /** Quantity Used. */
        used?: number;
    }
    /** Signature type desired on certificate ("origin-rsa" (rsa), "origin-ecc" (ecdsa), or "keyless-certificate" (for Keyless SSL servers). */
    export type ApQU2qAj_request_type = "origin-rsa" | "origin-ecc" | "keyless-certificate";
    /** The number of days for which the certificate should be valid. */
    export type ApQU2qAj_requested_validity = 7 | 30 | 90 | 365 | 730 | 1095 | 5475;
    export interface ApQU2qAj_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** The zone's SSL certificate or SSL certificate and intermediate(s). */
    export type ApQU2qAj_schemas$certificate = string;
    /** Certificate Authority selected for the order.  For information on any certificate authority specific details or restrictions  [see this page for more details.](https://developers.cloudflare.com/ssl/reference/certificate-authorities) */
    export type ApQU2qAj_schemas$certificate_authority = "google" | "lets_encrypt";
    export type ApQU2qAj_schemas$certificate_response_collection = Schemas.ApQU2qAj_api$response$collection & {
        result?: Schemas.ApQU2qAj_certificates[];
    };
    export type ApQU2qAj_schemas$certificate_response_single = Schemas.ApQU2qAj_api$response$single & {
        result?: {};
    };
    export interface ApQU2qAj_schemas$certificateObject {
        certificate?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$certificate;
        expires_on?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$expires_on;
        id?: Schemas.ApQU2qAj_identifier;
        issuer?: Schemas.ApQU2qAj_issuer;
        serial_number?: Schemas.ApQU2qAj_serial_number;
        signature?: Schemas.ApQU2qAj_signature;
        status?: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$status;
        uploaded_on?: Schemas.ApQU2qAj_components$schemas$uploaded_on;
    }
    /** The uploaded root CA certificate. */
    export type ApQU2qAj_schemas$certificates = string;
    /** The time when the certificate was created. */
    export type ApQU2qAj_schemas$created_at = Date;
    /** The Certificate Signing Request (CSR). Must be newline-encoded. */
    export type ApQU2qAj_schemas$csr = string;
    /**
     * Disabling Universal SSL removes any currently active Universal SSL certificates for your zone from the edge and prevents any future Universal SSL certificates from being ordered. If there are no advanced certificates or custom certificates uploaded for the domain, visitors will be unable to access the domain over HTTPS.
     *
     * By disabling Universal SSL, you understand that the following Cloudflare settings and preferences will result in visitors being unable to visit your domain unless you have uploaded a custom certificate or purchased an advanced certificate.
     *
     * * HSTS
     * * Always Use HTTPS
     * * Opportunistic Encryption
     * * Onion Routing
     * * Any Page Rules redirecting traffic to HTTPS
     *
     * Similarly, any HTTP redirect to HTTPS at the origin while the Cloudflare proxy is enabled will result in users being unable to visit your site without a valid certificate at Cloudflare's edge.
     *
     * If you do not have a valid custom or advanced certificate at Cloudflare's edge and are unsure if any of the above Cloudflare settings are enabled, or if any HTTP redirects exist at your origin, we advise leaving Universal SSL enabled for your domain.
     */
    export type ApQU2qAj_schemas$enabled = boolean;
    /** When the certificate will expire. */
    export type ApQU2qAj_schemas$expires_on = Date;
    /** The hostname on the origin for which the client certificate uploaded will be used. */
    export type ApQU2qAj_schemas$hostname = string;
    /** Comma separated list of valid host names for the certificate packs. Must contain the zone apex, may not contain more than 50 hosts, and may not be empty. */
    export type ApQU2qAj_schemas$hosts = string[];
    /** Keyless certificate identifier tag. */
    export type ApQU2qAj_schemas$identifier = string;
    /** The certificate authority that issued the certificate. */
    export type ApQU2qAj_schemas$issuer = string;
    /** Optional unique name for the certificate. Only used for human readability. */
    export type ApQU2qAj_schemas$name = string;
    /** The hostname certificate's private key. */
    export type ApQU2qAj_schemas$private_key = string;
    /** The certificate serial number. */
    export type ApQU2qAj_schemas$serial_number = string;
    /** Certificate's signature algorithm. */
    export type ApQU2qAj_schemas$signature = "ECDSAWithSHA256" | "SHA1WithRSA" | "SHA256WithRSA";
    /** Status of the Keyless SSL. */
    export type ApQU2qAj_schemas$status = "active" | "deleted";
    /** This is the time the certificate was updated. */
    export type ApQU2qAj_schemas$updated_at = Date;
    /** This is the time the certificate was uploaded. */
    export type ApQU2qAj_schemas$uploaded_on = Date;
    /** Validation method in use for a certificate pack order. */
    export type ApQU2qAj_schemas$validation_method = "http" | "cname" | "txt";
    /** The validity period in days for the certificates ordered via Total TLS. */
    export type ApQU2qAj_schemas$validity_days = 90;
    /** The serial number on the uploaded certificate. */
    export type ApQU2qAj_serial_number = string;
    /** The service using the certificate. */
    export type ApQU2qAj_service = string;
    export interface ApQU2qAj_settingObject {
        created_at?: Schemas.ApQU2qAj_components$schemas$created_at;
        hostname?: Schemas.ApQU2qAj_components$schemas$hostname;
        status?: Schemas.ApQU2qAj_hostname$tls$settings_components$schemas$status;
        updated_at?: Schemas.ApQU2qAj_components$schemas$updated_at;
        value?: Schemas.ApQU2qAj_value;
    }
    export interface ApQU2qAj_settingObjectDelete {
        created_at?: Schemas.ApQU2qAj_components$schemas$created_at;
        hostname?: Schemas.ApQU2qAj_components$schemas$hostname;
        status?: any;
        updated_at?: Schemas.ApQU2qAj_components$schemas$updated_at;
        value?: any;
    }
    /** The type of hash used for the certificate. */
    export type ApQU2qAj_signature = string;
    /** Subject Key Identifier */
    export type ApQU2qAj_ski = string;
    export type ApQU2qAj_ssl = {
        /** A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. */
        bundle_method?: "ubiquitous" | "optimal" | "force";
        certificate_authority?: Schemas.ApQU2qAj_certificate_authority;
        /** If a custom uploaded certificate is used. */
        custom_certificate?: string;
        /** The identifier for the Custom CSR that was used. */
        custom_csr_id?: string;
        /** The key for a custom uploaded certificate. */
        custom_key?: string;
        /** The time the custom certificate expires on. */
        expires_on?: Date;
        /** A list of Hostnames on a custom uploaded certificate. */
        hosts?: {}[];
        /** Custom hostname SSL identifier tag. */
        id?: string;
        /** The issuer on a custom uploaded certificate. */
        issuer?: string;
        /** Domain control validation (DCV) method used for this hostname. */
        method?: "http" | "txt" | "email";
        /** The serial number on a custom uploaded certificate. */
        serial_number?: string;
        settings?: Schemas.ApQU2qAj_sslsettings;
        /** The signature on a custom uploaded certificate. */
        signature?: string;
        /** Status of the hostname's SSL certificates. */
        readonly status?: "initializing" | "pending_validation" | "deleted" | "pending_issuance" | "pending_deployment" | "pending_deletion" | "pending_expiration" | "expired" | "active" | "initializing_timed_out" | "validation_timed_out" | "issuance_timed_out" | "deployment_timed_out" | "deletion_timed_out" | "pending_cleanup" | "staging_deployment" | "staging_active" | "deactivating" | "inactive" | "backup_issued" | "holding_deployment";
        /** Level of validation to be used for this hostname. Domain validation (dv) must be used. */
        readonly type?: "dv";
        /** The time the custom certificate was uploaded. */
        uploaded_on?: Date;
        /** Domain validation errors that have been received by the certificate authority (CA). */
        validation_errors?: {
            /** A domain validation error. */
            message?: string;
        }[];
        validation_records?: Schemas.ApQU2qAj_validation_record[];
        /** Indicates whether the certificate covers a wildcard. */
        wildcard?: boolean;
    };
    export type ApQU2qAj_ssl_universal_settings_response = Schemas.ApQU2qAj_api$response$single & {
        result?: Schemas.ApQU2qAj_universal;
    };
    export type ApQU2qAj_ssl_validation_method_response_collection = Schemas.ApQU2qAj_api$response$single & {
        result?: {
            status?: Schemas.ApQU2qAj_validation_method_components$schemas$status;
            validation_method?: Schemas.ApQU2qAj_validation_method_definition;
        };
    };
    export type ApQU2qAj_ssl_verification_response_collection = {
        result?: Schemas.ApQU2qAj_verification[];
    };
    export type ApQU2qAj_sslpost = {
        /** A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. */
        bundle_method?: "ubiquitous" | "optimal" | "force";
        certificate_authority?: Schemas.ApQU2qAj_certificate_authority;
        /** If a custom uploaded certificate is used. */
        custom_certificate?: string;
        /** The key for a custom uploaded certificate. */
        custom_key?: string;
        /** Domain control validation (DCV) method used for this hostname. */
        method?: "http" | "txt" | "email";
        settings?: Schemas.ApQU2qAj_sslsettings;
        /** Level of validation to be used for this hostname. Domain validation (dv) must be used. */
        type?: "dv";
        /** Indicates whether the certificate covers a wildcard. */
        wildcard?: boolean;
    };
    /** SSL specific settings. */
    export interface ApQU2qAj_sslsettings {
        /** An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format. */
        ciphers?: string[];
        /** Whether or not Early Hints is enabled. */
        early_hints?: "on" | "off";
        /** Whether or not HTTP2 is enabled. */
        http2?: "on" | "off";
        /** The minimum TLS version supported. */
        min_tls_version?: "1.0" | "1.1" | "1.2" | "1.3";
        /** Whether or not TLS 1.3 is enabled. */
        tls_1_3?: "on" | "off";
    }
    /** State, provided by the CSR */
    export type ApQU2qAj_state = string;
    /** Status of the zone's custom SSL. */
    export type ApQU2qAj_status = "active" | "expired" | "deleted" | "pending" | "initializing";
    /** The TLS Setting name. */
    export type ApQU2qAj_tls_setting = "ciphers" | "min_tls_version" | "http2";
    export type ApQU2qAj_total_tls_settings_response = Schemas.ApQU2qAj_api$response$single & {
        result?: {
            certificate_authority?: Schemas.ApQU2qAj_components$schemas$certificate_authority;
            enabled?: Schemas.ApQU2qAj_components$schemas$enabled;
            validity_days?: Schemas.ApQU2qAj_schemas$validity_days;
        };
    };
    /** The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake. */
    export type ApQU2qAj_type = "legacy_custom" | "sni_custom";
    export interface ApQU2qAj_universal {
        enabled?: Schemas.ApQU2qAj_schemas$enabled;
    }
    /** The time when the certificate was updated. */
    export type ApQU2qAj_updated_at = Date;
    /** When the certificate was uploaded to Cloudflare. */
    export type ApQU2qAj_uploaded_on = Date;
    /** The DCV Delegation unique identifier. */
    export type ApQU2qAj_uuid = string;
    export interface ApQU2qAj_uuidObject {
        uuid?: Schemas.ApQU2qAj_uuid;
    }
    /** Validation Method selected for the order. */
    export type ApQU2qAj_validation_method = "txt" | "http" | "email";
    /** Result status. */
    export type ApQU2qAj_validation_method_components$schemas$status = string;
    /** Desired validation method. */
    export type ApQU2qAj_validation_method_definition = "http" | "cname" | "txt" | "email";
    /** Certificate's required validation record. */
    export interface ApQU2qAj_validation_record {
        /** The set of email addresses that the certificate authority (CA) will use to complete domain validation. */
        emails?: {}[];
        /** The content that the certificate authority (CA) will expect to find at the http_url during the domain validation. */
        http_body?: string;
        /** The url that will be checked during domain validation. */
        http_url?: string;
        /** The hostname that the certificate authority (CA) will check for a TXT record during domain validation . */
        txt_name?: string;
        /** The TXT record that the certificate authority (CA) will check during domain validation. */
        txt_value?: string;
    }
    /** Validity Days selected for the order. */
    export type ApQU2qAj_validity_days = 14 | 30 | 90 | 365;
    export type ApQU2qAj_value = number | string | string[];
    export interface ApQU2qAj_verification {
        brand_check?: Schemas.ApQU2qAj_brand_check;
        cert_pack_uuid?: Schemas.ApQU2qAj_cert_pack_uuid;
        certificate_status: Schemas.ApQU2qAj_certificate_status;
        signature?: Schemas.ApQU2qAj_schemas$signature;
        validation_method?: Schemas.ApQU2qAj_schemas$validation_method;
        verification_info?: Schemas.ApQU2qAj_verification_info;
        verification_status?: Schemas.ApQU2qAj_verification_status;
        verification_type?: Schemas.ApQU2qAj_verification_type;
    }
    /** These are errors that were encountered while trying to activate a hostname. */
    export type ApQU2qAj_verification_errors = {}[];
    /** Certificate's required verification information. */
    export interface ApQU2qAj_verification_info {
        /** Name of CNAME record. */
        record_name?: "record_name" | "http_url" | "cname" | "txt_name";
        /** Target of CNAME record. */
        record_target?: "record_value" | "http_body" | "cname_target" | "txt_value";
    }
    /** Status of the required verification information, omitted if verification status is unknown. */
    export type ApQU2qAj_verification_status = boolean;
    /** Method of verification. */
    export type ApQU2qAj_verification_type = "cname" | "meta tag";
    export type ApQU2qAj_zone$authenticated$origin$pull = Schemas.ApQU2qAj_certificateObject;
    /** The zone's leaf certificate. */
    export type ApQU2qAj_zone$authenticated$origin$pull_components$schemas$certificate = string;
    /** Indicates whether zone-level authenticated origin pulls is enabled. */
    export type ApQU2qAj_zone$authenticated$origin$pull_components$schemas$enabled = boolean;
    /** Status of the certificate activation. */
    export type ApQU2qAj_zone$authenticated$origin$pull_components$schemas$status = "initializing" | "pending_deployment" | "pending_deletion" | "active" | "deleted" | "deployment_timed_out" | "deletion_timed_out";
    export interface GRP4pb9k_Everything {
        purge_everything?: boolean;
    }
    export type GRP4pb9k_File = string;
    export interface GRP4pb9k_Files {
        files?: (Schemas.GRP4pb9k_File | Schemas.GRP4pb9k_UrlAndHeaders)[];
    }
    export type GRP4pb9k_Flex = Schemas.GRP4pb9k_Tags | Schemas.GRP4pb9k_Hosts | Schemas.GRP4pb9k_Prefixes;
    export interface GRP4pb9k_Hosts {
        hosts?: string[];
    }
    export interface GRP4pb9k_Prefixes {
        prefixes?: string[];
    }
    export interface GRP4pb9k_Tags {
        tags?: string[];
    }
    export interface GRP4pb9k_UrlAndHeaders {
        headers?: {};
        url?: string;
    }
    export interface GRP4pb9k_api$response$common {
        errors: Schemas.GRP4pb9k_messages;
        messages: Schemas.GRP4pb9k_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface GRP4pb9k_api$response$common$failure {
        errors: Schemas.GRP4pb9k_messages;
        messages: Schemas.GRP4pb9k_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type GRP4pb9k_api$response$single$id = Schemas.GRP4pb9k_api$response$common & {
        result?: {
            id: Schemas.GRP4pb9k_schemas$identifier;
        } | null;
    };
    export type GRP4pb9k_identifier = string;
    export type GRP4pb9k_messages = {
        code: number;
        message: string;
    }[];
    /** Identifier */
    export type GRP4pb9k_schemas$identifier = string;
    export type NQKiZdJe_api$response$collection = Schemas.NQKiZdJe_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.NQKiZdJe_result_info;
    };
    export interface NQKiZdJe_api$response$common {
        errors: Schemas.NQKiZdJe_messages;
        messages: Schemas.NQKiZdJe_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface NQKiZdJe_api$response$common$failure {
        errors: Schemas.NQKiZdJe_messages;
        messages: Schemas.NQKiZdJe_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type NQKiZdJe_api$response$single = Schemas.NQKiZdJe_api$response$common & {
        result?: ({} | string) | null;
    };
    export type NQKiZdJe_custom_pages_response_collection = Schemas.NQKiZdJe_api$response$collection & {
        result?: {}[];
    };
    export type NQKiZdJe_custom_pages_response_single = Schemas.NQKiZdJe_api$response$single & {
        result?: {};
    };
    /** Identifier */
    export type NQKiZdJe_identifier = string;
    export type NQKiZdJe_messages = {
        code: number;
        message: string;
    }[];
    export interface NQKiZdJe_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** The custom page state. */
    export type NQKiZdJe_state = "default" | "customized";
    /** The URL associated with the custom page. */
    export type NQKiZdJe_url = string;
    export type SxDaNi5K_api$response$collection = Schemas.SxDaNi5K_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.SxDaNi5K_result_info;
    };
    export interface SxDaNi5K_api$response$common {
        errors: Schemas.SxDaNi5K_messages;
        messages: Schemas.SxDaNi5K_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface SxDaNi5K_api$response$common$failure {
        errors: Schemas.SxDaNi5K_messages;
        messages: Schemas.SxDaNi5K_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type SxDaNi5K_api$response$single = Schemas.SxDaNi5K_api$response$common & {
        result?: {} | string;
    };
    /** Identifier */
    export type SxDaNi5K_identifier = string;
    export type SxDaNi5K_messages = {
        code: number;
        message: string;
    }[];
    /** The maximum number of bytes to capture. This field only applies to \`full\` packet captures. */
    export type SxDaNi5K_pcaps_byte_limit = number;
    export type SxDaNi5K_pcaps_collection_response = Schemas.SxDaNi5K_api$response$collection & {
        result?: (Schemas.SxDaNi5K_pcaps_response_simple | Schemas.SxDaNi5K_pcaps_response_full)[];
    };
    /** The name of the data center used for the packet capture. This can be a specific colo (ord02) or a multi-colo name (ORD). This field only applies to \`full\` packet captures. */
    export type SxDaNi5K_pcaps_colo_name = string;
    /** The full URI for the bucket. This field only applies to \`full\` packet captures. */
    export type SxDaNi5K_pcaps_destination_conf = string;
    /** An error message that describes why the packet capture failed. This field only applies to \`full\` packet captures. */
    export type SxDaNi5K_pcaps_error_message = string;
    /** The packet capture filter. When this field is empty, all packets are captured. */
    export interface SxDaNi5K_pcaps_filter_v1 {
        /** The destination IP address of the packet. */
        destination_address?: string;
        /** The destination port of the packet. */
        destination_port?: number;
        /** The protocol number of the packet. */
        protocol?: number;
        /** The source IP address of the packet. */
        source_address?: string;
        /** The source port of the packet. */
        source_port?: number;
    }
    /** The ID for the packet capture. */
    export type SxDaNi5K_pcaps_id = string;
    /** The ownership challenge filename stored in the bucket. */
    export type SxDaNi5K_pcaps_ownership_challenge = string;
    export type SxDaNi5K_pcaps_ownership_collection = Schemas.SxDaNi5K_api$response$collection & {
        result?: Schemas.SxDaNi5K_pcaps_ownership_response[] | null;
    };
    export interface SxDaNi5K_pcaps_ownership_request {
        destination_conf: Schemas.SxDaNi5K_pcaps_destination_conf;
    }
    export interface SxDaNi5K_pcaps_ownership_response {
        destination_conf: Schemas.SxDaNi5K_pcaps_destination_conf;
        filename: Schemas.SxDaNi5K_pcaps_ownership_challenge;
        /** The bucket ID associated with the packet captures API. */
        id: string;
        /** The status of the ownership challenge. Can be pending, success or failed. */
        status: "pending" | "success" | "failed";
        /** The RFC 3339 timestamp when the bucket was added to packet captures API. */
        submitted: string;
        /** The RFC 3339 timestamp when the bucket was validated. */
        validated?: string;
    }
    export type SxDaNi5K_pcaps_ownership_single_response = Schemas.SxDaNi5K_api$response$common & {
        result?: Schemas.SxDaNi5K_pcaps_ownership_response;
    };
    export interface SxDaNi5K_pcaps_ownership_validate_request {
        destination_conf: Schemas.SxDaNi5K_pcaps_destination_conf;
        ownership_challenge: Schemas.SxDaNi5K_pcaps_ownership_challenge;
    }
    /** The limit of packets contained in a packet capture. */
    export type SxDaNi5K_pcaps_packet_limit = number;
    export interface SxDaNi5K_pcaps_request_full {
        byte_limit?: Schemas.SxDaNi5K_pcaps_byte_limit;
        colo_name: Schemas.SxDaNi5K_pcaps_colo_name;
        destination_conf: Schemas.SxDaNi5K_pcaps_destination_conf;
        filter_v1?: Schemas.SxDaNi5K_pcaps_filter_v1;
        packet_limit?: Schemas.SxDaNi5K_pcaps_packet_limit;
        system: Schemas.SxDaNi5K_pcaps_system;
        time_limit: Schemas.SxDaNi5K_pcaps_time_limit;
        type: Schemas.SxDaNi5K_pcaps_type;
    }
    export type SxDaNi5K_pcaps_request_pcap = Schemas.SxDaNi5K_pcaps_request_simple | Schemas.SxDaNi5K_pcaps_request_full;
    export interface SxDaNi5K_pcaps_request_simple {
        filter_v1?: Schemas.SxDaNi5K_pcaps_filter_v1;
        packet_limit: Schemas.SxDaNi5K_pcaps_packet_limit;
        system: Schemas.SxDaNi5K_pcaps_system;
        time_limit: Schemas.SxDaNi5K_pcaps_time_limit;
        type: Schemas.SxDaNi5K_pcaps_type;
    }
    export interface SxDaNi5K_pcaps_response_full {
        byte_limit?: Schemas.SxDaNi5K_pcaps_byte_limit;
        colo_name?: Schemas.SxDaNi5K_pcaps_colo_name;
        destination_conf?: Schemas.SxDaNi5K_pcaps_destination_conf;
        error_message?: Schemas.SxDaNi5K_pcaps_error_message;
        filter_v1?: Schemas.SxDaNi5K_pcaps_filter_v1;
        id?: Schemas.SxDaNi5K_pcaps_id;
        status?: Schemas.SxDaNi5K_pcaps_status;
        submitted?: Schemas.SxDaNi5K_pcaps_submitted;
        system?: Schemas.SxDaNi5K_pcaps_system;
        time_limit?: Schemas.SxDaNi5K_pcaps_time_limit;
        type?: Schemas.SxDaNi5K_pcaps_type;
    }
    export interface SxDaNi5K_pcaps_response_simple {
        filter_v1?: Schemas.SxDaNi5K_pcaps_filter_v1;
        id?: Schemas.SxDaNi5K_pcaps_id;
        status?: Schemas.SxDaNi5K_pcaps_status;
        submitted?: Schemas.SxDaNi5K_pcaps_submitted;
        system?: Schemas.SxDaNi5K_pcaps_system;
        time_limit?: Schemas.SxDaNi5K_pcaps_time_limit;
        type?: Schemas.SxDaNi5K_pcaps_type;
    }
    export type SxDaNi5K_pcaps_single_response = Schemas.SxDaNi5K_api$response$single & {
        result?: Schemas.SxDaNi5K_pcaps_response_simple | Schemas.SxDaNi5K_pcaps_response_full;
    };
    /** The status of the packet capture request. */
    export type SxDaNi5K_pcaps_status = "unknown" | "success" | "pending" | "running" | "conversion_pending" | "conversion_running" | "complete" | "failed";
    /** The RFC 3339 timestamp when the packet capture was created. */
    export type SxDaNi5K_pcaps_submitted = string;
    /** The system used to collect packet captures. */
    export type SxDaNi5K_pcaps_system = "magic-transit";
    /** The packet capture duration in seconds. */
    export type SxDaNi5K_pcaps_time_limit = number;
    /** The type of packet capture. \`Simple\` captures sampled packets, and \`full\` captures entire payloads and non-sampled packets. */
    export type SxDaNi5K_pcaps_type = "simple" | "full";
    export interface SxDaNi5K_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type X3uh9Izk_api$response$collection = Schemas.X3uh9Izk_api$response$common;
    export interface X3uh9Izk_api$response$common {
        errors: Schemas.X3uh9Izk_messages;
        messages: Schemas.X3uh9Izk_messages;
        /** Whether the API call was successful. */
        success: boolean;
    }
    export interface X3uh9Izk_api$response$common$failure {
        errors: Schemas.X3uh9Izk_messages;
        messages: Schemas.X3uh9Izk_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type X3uh9Izk_api$response$single = Schemas.X3uh9Izk_api$response$common;
    /** If enabled, the JavaScript snippet is automatically injected for orange-clouded sites. */
    export type X3uh9Izk_auto_install = boolean;
    export interface X3uh9Izk_create$rule$request {
        host?: string;
        /** Whether the rule includes or excludes traffic from being measured. */
        inclusive?: boolean;
        /** Whether the rule is paused or not. */
        is_paused?: boolean;
        paths?: string[];
    }
    export interface X3uh9Izk_create$site$request {
        auto_install?: Schemas.X3uh9Izk_auto_install;
        /** The hostname to use for gray-clouded sites. */
        host?: string;
        zone_tag?: Schemas.X3uh9Izk_zone_tag;
    }
    export type X3uh9Izk_created = Schemas.X3uh9Izk_timestamp;
    /** Identifier */
    export type X3uh9Izk_identifier = string;
    /** Whether to match the hostname using a regular expression. */
    export type X3uh9Izk_is_host_regex = boolean;
    export type X3uh9Izk_messages = {
        code: number;
        message: string;
    }[];
    export interface X3uh9Izk_modify$rules$request {
        /** A list of rule identifiers to delete. */
        delete_rules?: Schemas.X3uh9Izk_rule_identifier[];
        /** A list of rules to create or update. */
        rules?: {
            host?: string;
            id?: Schemas.X3uh9Izk_rule_identifier;
            inclusive?: boolean;
            is_paused?: boolean;
            paths?: string[];
        }[];
    }
    /** The property used to sort the list of results. */
    export type X3uh9Izk_order_by = "host" | "created";
    /** Current page within the paginated list of results. */
    export type X3uh9Izk_page = number;
    /** Number of items to return per page of results. */
    export type X3uh9Izk_per_page = number;
    export interface X3uh9Izk_result_info {
        /** The total number of items on the current page. */
        count?: number;
        /** Current page within the paginated list of results. */
        page?: number;
        /** The maximum number of items to return per page of results. */
        per_page?: number;
        /** The total number of items. */
        total_count?: number;
        /** The total number of pages. */
        total_pages?: number | null;
    }
    export interface X3uh9Izk_rule {
        created?: Schemas.X3uh9Izk_timestamp;
        /** The hostname the rule will be applied to. */
        host?: string;
        id?: Schemas.X3uh9Izk_rule_identifier;
        /** Whether the rule includes or excludes traffic from being measured. */
        inclusive?: boolean;
        /** Whether the rule is paused or not. */
        is_paused?: boolean;
        /** The paths the rule will be applied to. */
        paths?: string[];
        priority?: number;
    }
    export type X3uh9Izk_rule$id$response$single = Schemas.X3uh9Izk_api$response$single & {
        result?: {
            id?: Schemas.X3uh9Izk_rule_identifier;
        };
    };
    export type X3uh9Izk_rule$response$single = Schemas.X3uh9Izk_api$response$single & {
        result?: Schemas.X3uh9Izk_rule;
    };
    /** The Web Analytics rule identifier. */
    export type X3uh9Izk_rule_identifier = string;
    /** A list of rules. */
    export type X3uh9Izk_rules = Schemas.X3uh9Izk_rule[];
    export type X3uh9Izk_rules$response$collection = Schemas.X3uh9Izk_api$response$collection & {
        result?: {
            rules?: Schemas.X3uh9Izk_rules;
            ruleset?: Schemas.X3uh9Izk_ruleset;
        };
    };
    export interface X3uh9Izk_ruleset {
        /** Whether the ruleset is enabled. */
        enabled?: boolean;
        id?: Schemas.X3uh9Izk_ruleset_identifier;
        zone_name?: string;
        zone_tag?: Schemas.X3uh9Izk_zone_tag;
    }
    /** The Web Analytics ruleset identifier. */
    export type X3uh9Izk_ruleset_identifier = string;
    export interface X3uh9Izk_site {
        auto_install?: Schemas.X3uh9Izk_auto_install;
        created?: Schemas.X3uh9Izk_timestamp;
        rules?: Schemas.X3uh9Izk_rules;
        ruleset?: Schemas.X3uh9Izk_ruleset;
        site_tag?: Schemas.X3uh9Izk_site_tag;
        site_token?: Schemas.X3uh9Izk_site_token;
        snippet?: Schemas.X3uh9Izk_snippet;
    }
    export type X3uh9Izk_site$response$single = Schemas.X3uh9Izk_api$response$single & {
        result?: Schemas.X3uh9Izk_site;
    };
    export type X3uh9Izk_site$tag$response$single = Schemas.X3uh9Izk_api$response$single & {
        result?: {
            site_tag?: Schemas.X3uh9Izk_site_tag;
        };
    };
    /** The Web Analytics site identifier. */
    export type X3uh9Izk_site_tag = string;
    /** The Web Analytics site token. */
    export type X3uh9Izk_site_token = string;
    export type X3uh9Izk_sites$response$collection = Schemas.X3uh9Izk_api$response$collection & {
        result?: Schemas.X3uh9Izk_site[];
        result_info?: Schemas.X3uh9Izk_result_info;
    };
    /** Encoded JavaScript snippet. */
    export type X3uh9Izk_snippet = string;
    export type X3uh9Izk_timestamp = Date;
    /** The zone identifier. */
    export type X3uh9Izk_zone_tag = string;
    export type YSGOQLq3_api$response$collection = Schemas.YSGOQLq3_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.YSGOQLq3_result_info;
    };
    export interface YSGOQLq3_api$response$common {
        errors: Schemas.YSGOQLq3_messages;
        messages: Schemas.YSGOQLq3_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface YSGOQLq3_api$response$common$failure {
        errors: Schemas.YSGOQLq3_messages;
        messages: Schemas.YSGOQLq3_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type YSGOQLq3_api$response$single = Schemas.YSGOQLq3_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export type YSGOQLq3_api$response$single$id = Schemas.YSGOQLq3_api$response$common & {
        result?: {
            id: Schemas.YSGOQLq3_identifier;
        } | null;
    };
    export type YSGOQLq3_collection_response = Schemas.YSGOQLq3_api$response$collection & {
        result?: Schemas.YSGOQLq3_web3$hostname[];
    };
    /** Behavior of the content list. */
    export type YSGOQLq3_content_list_action = "block";
    export interface YSGOQLq3_content_list_details {
        action?: Schemas.YSGOQLq3_content_list_action;
    }
    export type YSGOQLq3_content_list_details_response = Schemas.YSGOQLq3_api$response$single & {
        result?: Schemas.YSGOQLq3_content_list_details;
    };
    /** Content list entries. */
    export type YSGOQLq3_content_list_entries = Schemas.YSGOQLq3_content_list_entry[];
    /** Content list entry to be blocked. */
    export interface YSGOQLq3_content_list_entry {
        content?: Schemas.YSGOQLq3_content_list_entry_content;
        created_on?: Schemas.YSGOQLq3_timestamp;
        description?: Schemas.YSGOQLq3_content_list_entry_description;
        id?: Schemas.YSGOQLq3_identifier;
        modified_on?: Schemas.YSGOQLq3_timestamp;
        type?: Schemas.YSGOQLq3_content_list_entry_type;
    }
    export type YSGOQLq3_content_list_entry_collection_response = Schemas.YSGOQLq3_api$response$collection & {
        result?: {
            entries?: Schemas.YSGOQLq3_content_list_entries;
        };
    };
    /** CID or content path of content to block. */
    export type YSGOQLq3_content_list_entry_content = string;
    export interface YSGOQLq3_content_list_entry_create_request {
        content: Schemas.YSGOQLq3_content_list_entry_content;
        description?: Schemas.YSGOQLq3_content_list_entry_description;
        type: Schemas.YSGOQLq3_content_list_entry_type;
    }
    /** An optional description of the content list entry. */
    export type YSGOQLq3_content_list_entry_description = string;
    export type YSGOQLq3_content_list_entry_single_response = Schemas.YSGOQLq3_api$response$single & {
        result?: Schemas.YSGOQLq3_content_list_entry;
    };
    /** Type of content list entry to block. */
    export type YSGOQLq3_content_list_entry_type = "cid" | "content_path";
    export interface YSGOQLq3_content_list_update_request {
        action: Schemas.YSGOQLq3_content_list_action;
        entries: Schemas.YSGOQLq3_content_list_entries;
    }
    export interface YSGOQLq3_create_request {
        description?: Schemas.YSGOQLq3_description;
        dnslink?: Schemas.YSGOQLq3_dnslink;
        name: Schemas.YSGOQLq3_name;
        target: Schemas.YSGOQLq3_target;
    }
    /** An optional description of the hostname. */
    export type YSGOQLq3_description = string;
    /** DNSLink value used if the target is ipfs. */
    export type YSGOQLq3_dnslink = string;
    /** Identifier */
    export type YSGOQLq3_identifier = string;
    export type YSGOQLq3_messages = {
        code: number;
        message: string;
    }[];
    export interface YSGOQLq3_modify_request {
        description?: Schemas.YSGOQLq3_description;
        dnslink?: Schemas.YSGOQLq3_dnslink;
    }
    /** The hostname that will point to the target gateway via CNAME. */
    export type YSGOQLq3_name = string;
    export interface YSGOQLq3_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type YSGOQLq3_single_response = Schemas.YSGOQLq3_api$response$single & {
        result?: Schemas.YSGOQLq3_web3$hostname;
    };
    /** Status of the hostname's activation. */
    export type YSGOQLq3_status = "active" | "pending" | "deleting" | "error";
    /** Target gateway of the hostname. */
    export type YSGOQLq3_target = "ethereum" | "ipfs" | "ipfs_universal_path";
    export type YSGOQLq3_timestamp = Date;
    export interface YSGOQLq3_web3$hostname {
        created_on?: Schemas.YSGOQLq3_timestamp;
        description?: Schemas.YSGOQLq3_description;
        dnslink?: Schemas.YSGOQLq3_dnslink;
        id?: Schemas.YSGOQLq3_identifier;
        modified_on?: Schemas.YSGOQLq3_timestamp;
        name?: Schemas.YSGOQLq3_name;
        status?: Schemas.YSGOQLq3_status;
        target?: Schemas.YSGOQLq3_target;
    }
    export type Zzhfoun1_account_identifier = Schemas.Zzhfoun1_identifier;
    export interface Zzhfoun1_api$response$common {
        errors: Schemas.Zzhfoun1_messages;
        messages: Schemas.Zzhfoun1_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface Zzhfoun1_api$response$common$failure {
        errors: Schemas.Zzhfoun1_messages;
        messages: Schemas.Zzhfoun1_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    /** Identifier */
    export type Zzhfoun1_identifier = string;
    export type Zzhfoun1_messages = {
        code: number;
        message: string;
    }[];
    export type Zzhfoun1_trace = {
        /** If step type is rule, then action performed by this rule */
        action?: string;
        /** If step type is rule, then action parameters of this rule as JSON */
        action_parameters?: {};
        /** If step type is rule or ruleset, the description of this entity */
        description?: string;
        /** If step type is rule, then expression used to match for this rule */
        expression?: string;
        /** If step type is ruleset, then kind of this ruleset */
        kind?: string;
        /** Whether tracing step affected tracing request/response */
        matched?: boolean;
        /** If step type is ruleset, then name of this ruleset */
        name?: string;
        /** Tracing step identifying name */
        step_name?: string;
        trace?: Schemas.Zzhfoun1_trace;
        /** Tracing step type */
        type?: string;
    }[];
    export type aMMS9DAQ_api$response$collection = Schemas.aMMS9DAQ_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.aMMS9DAQ_result_info;
    };
    export interface aMMS9DAQ_api$response$common {
        errors: Schemas.aMMS9DAQ_messages;
        messages: Schemas.aMMS9DAQ_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface aMMS9DAQ_api$response$common$failure {
        errors: Schemas.aMMS9DAQ_messages;
        messages: Schemas.aMMS9DAQ_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    /** AS number associated with the node object. */
    export type aMMS9DAQ_asn = string;
    export interface aMMS9DAQ_colo {
        city?: Schemas.aMMS9DAQ_colo_city;
        name?: Schemas.aMMS9DAQ_colo_name;
    }
    /** Source colo city. */
    export type aMMS9DAQ_colo_city = string;
    /** Source colo name. */
    export type aMMS9DAQ_colo_name = string;
    export interface aMMS9DAQ_colo_result {
        colo?: Schemas.aMMS9DAQ_colo;
        error?: Schemas.aMMS9DAQ_error;
        hops?: Schemas.aMMS9DAQ_hop_result[];
        target_summary?: Schemas.aMMS9DAQ_target_summary;
        traceroute_time_ms?: Schemas.aMMS9DAQ_traceroute_time_ms;
    }
    /** If no source colo names specified, all colos will be used. China colos are unavailable for traceroutes. */
    export type aMMS9DAQ_colos = string[];
    /** Errors resulting from collecting traceroute from colo to target. */
    export type aMMS9DAQ_error = "" | "Could not gather traceroute data: Code 1" | "Could not gather traceroute data: Code 2" | "Could not gather traceroute data: Code 3" | "Could not gather traceroute data: Code 4";
    export interface aMMS9DAQ_hop_result {
        /** An array of node objects. */
        nodes?: Schemas.aMMS9DAQ_node_result[];
        packets_lost?: Schemas.aMMS9DAQ_packets_lost;
        packets_sent?: Schemas.aMMS9DAQ_packets_sent;
        packets_ttl?: Schemas.aMMS9DAQ_packets_ttl;
    }
    /** Identifier */
    export type aMMS9DAQ_identifier = string;
    /** IP address of the node. */
    export type aMMS9DAQ_ip = string;
    /** Field appears if there is an additional annotation printed when the probe returns. Field also appears when running a GRE+ICMP traceroute to denote which traceroute a node comes from. */
    export type aMMS9DAQ_labels = string[];
    /** Maximum RTT in ms. */
    export type aMMS9DAQ_max_rtt_ms = number;
    /** Max TTL. */
    export type aMMS9DAQ_max_ttl = number;
    /** Mean RTT in ms. */
    export type aMMS9DAQ_mean_rtt_ms = number;
    export type aMMS9DAQ_messages = {
        code: number;
        message: string;
    }[];
    /** Minimum RTT in ms. */
    export type aMMS9DAQ_min_rtt_ms = number;
    /** Host name of the address, this may be the same as the IP address. */
    export type aMMS9DAQ_name = string;
    export interface aMMS9DAQ_node_result {
        asn?: Schemas.aMMS9DAQ_asn;
        ip?: Schemas.aMMS9DAQ_ip;
        labels?: Schemas.aMMS9DAQ_labels;
        max_rtt_ms?: Schemas.aMMS9DAQ_max_rtt_ms;
        mean_rtt_ms?: Schemas.aMMS9DAQ_mean_rtt_ms;
        min_rtt_ms?: Schemas.aMMS9DAQ_min_rtt_ms;
        name?: Schemas.aMMS9DAQ_name;
        packet_count?: Schemas.aMMS9DAQ_packet_count;
        std_dev_rtt_ms?: Schemas.aMMS9DAQ_std_dev_rtt_ms;
    }
    export interface aMMS9DAQ_options {
        max_ttl?: Schemas.aMMS9DAQ_max_ttl;
        packet_type?: Schemas.aMMS9DAQ_packet_type;
        packets_per_ttl?: Schemas.aMMS9DAQ_packets_per_ttl;
        port?: Schemas.aMMS9DAQ_port;
        wait_time?: Schemas.aMMS9DAQ_wait_time;
    }
    /** Number of packets with a response from this node. */
    export type aMMS9DAQ_packet_count = number;
    /** Type of packet sent. */
    export type aMMS9DAQ_packet_type = "icmp" | "tcp" | "udp" | "gre" | "gre+icmp";
    /** Number of packets where no response was received. */
    export type aMMS9DAQ_packets_lost = number;
    /** Number of packets sent at each TTL. */
    export type aMMS9DAQ_packets_per_ttl = number;
    /** Number of packets sent with specified TTL. */
    export type aMMS9DAQ_packets_sent = number;
    /** The time to live (TTL). */
    export type aMMS9DAQ_packets_ttl = number;
    /** For UDP and TCP, specifies the destination port. For ICMP, specifies the initial ICMP sequence value. Default value 0 will choose the best value to use for each protocol. */
    export type aMMS9DAQ_port = number;
    export interface aMMS9DAQ_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Standard deviation of the RTTs in ms. */
    export type aMMS9DAQ_std_dev_rtt_ms = number;
    /** The target hostname, IPv6, or IPv6 address. */
    export type aMMS9DAQ_target = string;
    export interface aMMS9DAQ_target_result {
        colos?: Schemas.aMMS9DAQ_colo_result[];
        target?: Schemas.aMMS9DAQ_target;
    }
    /** Aggregated statistics from all hops about the target. */
    export interface aMMS9DAQ_target_summary {
    }
    export type aMMS9DAQ_targets = string[];
    export type aMMS9DAQ_traceroute_response_collection = Schemas.aMMS9DAQ_api$response$collection & {
        result?: Schemas.aMMS9DAQ_target_result[];
    };
    /** Total time of traceroute in ms. */
    export type aMMS9DAQ_traceroute_time_ms = number;
    /** Set the time (in seconds) to wait for a response to a probe. */
    export type aMMS9DAQ_wait_time = number;
    export interface access_access$requests {
        action?: Schemas.access_action;
        allowed?: Schemas.access_allowed;
        app_domain?: Schemas.access_app_domain;
        app_uid?: Schemas.access_app_uid;
        connection?: Schemas.access_connection;
        created_at?: Schemas.access_timestamp;
        ip_address?: Schemas.access_ip;
        ray_id?: Schemas.access_ray_id;
        user_email?: Schemas.access_email;
    }
    export type access_access$requests_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_access$requests[];
    };
    /** Matches an Access group. */
    export interface access_access_group_rule {
        group: {
            /** The ID of a previously created Access group. */
            id: string;
        };
    }
    /** True if the seat is part of Access. */
    export type access_access_seat = boolean;
    /** The event that occurred, such as a login attempt. */
    export type access_action = string;
    /** The number of active devices registered to the user. */
    export type access_active_device_count = number;
    export type access_active_session_response = Schemas.access_api$response$single & {
        result?: Schemas.access_identity & {
            isActive?: boolean;
        };
    };
    export type access_active_sessions_response = Schemas.access_api$response$collection & {
        result?: {
            expiration?: number;
            metadata?: {
                apps?: {};
                expires?: number;
                iat?: number;
                nonce?: string;
                ttl?: number;
            };
            name?: string;
        }[];
    };
    /** Allows all HTTP request headers. */
    export type access_allow_all_headers = boolean;
    /** Allows all HTTP request methods. */
    export type access_allow_all_methods = boolean;
    /** Allows all origins. */
    export type access_allow_all_origins = boolean;
    /** When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value. */
    export type access_allow_authenticate_via_warp = boolean;
    /** When set to \`true\`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests. */
    export type access_allow_credentials = boolean;
    /** The result of the authentication event. */
    export type access_allowed = boolean;
    /** Allowed HTTP request headers. */
    export type access_allowed_headers = {}[];
    /** The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account. */
    export type access_allowed_idps = string[];
    /** Allowed HTTP request methods. */
    export type access_allowed_methods = ("GET" | "POST" | "HEAD" | "PUT" | "DELETE" | "CONNECT" | "OPTIONS" | "TRACE" | "PATCH")[];
    /** Allowed origins. */
    export type access_allowed_origins = {}[];
    /** Matches any valid Access Service Token */
    export interface access_any_valid_service_token_rule {
        /** An empty object which matches on all service tokens. */
        any_valid_service_token: {};
    }
    export type access_api$response$collection = Schemas.access_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.access_result_info;
    };
    export interface access_api$response$common {
        errors: Schemas.access_messages;
        messages: Schemas.access_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface access_api$response$common$failure {
        errors: Schemas.access_messages;
        messages: Schemas.access_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type access_api$response$single = Schemas.access_api$response$common & {
        result?: {} | string;
    };
    /** Number of apps the custom page is assigned to. */
    export type access_app_count = number;
    /** The URL of the Access application. */
    export type access_app_domain = string;
    export type access_app_id = Schemas.access_identifier | Schemas.access_uuid;
    export type access_app_launcher_props = Schemas.access_feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    /** Displays the application in the App Launcher. */
    export type access_app_launcher_visible = boolean;
    /** The unique identifier for the Access application. */
    export type access_app_uid = any;
    /** A group of email addresses that can approve a temporary authentication request. */
    export interface access_approval_group {
        /** The number of approvals needed to obtain access. */
        approvals_needed: number;
        /** A list of emails that can approve the access request. */
        email_addresses?: {}[];
        /** The UUID of an re-usable email list. */
        email_list_uuid?: string;
    }
    /** Administrators who can approve a temporary authentication request. */
    export type access_approval_groups = Schemas.access_approval_group[];
    /** Requires the user to request access from an administrator at the start of each session. */
    export type access_approval_required = boolean;
    export type access_apps = (Schemas.access_basic_app_response_props & Schemas.access_self_hosted_props) | (Schemas.access_basic_app_response_props & Schemas.access_saas_props) | (Schemas.access_basic_app_response_props & Schemas.access_ssh_props) | (Schemas.access_basic_app_response_props & Schemas.access_vnc_props) | (Schemas.access_basic_app_response_props & Schemas.access_app_launcher_props) | (Schemas.access_basic_app_response_props & Schemas.access_warp_props) | (Schemas.access_basic_app_response_props & Schemas.access_biso_props) | (Schemas.access_basic_app_response_props & Schemas.access_bookmark_props);
    /** The name of the application. */
    export type access_apps_components$schemas$name = string;
    export type access_apps_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_apps[];
    };
    export type access_apps_components$schemas$response_collection$2 = Schemas.access_api$response$collection & {
        result?: Schemas.access_schemas$apps[];
    };
    export type access_apps_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_apps;
    };
    export type access_apps_components$schemas$single_response$2 = Schemas.access_api$response$single & {
        result?: Schemas.access_schemas$apps;
    };
    /** The hostnames of the applications that will use this certificate. */
    export type access_associated_hostnames = string[];
    /** The Application Audience (AUD) tag. Identifies the application associated with the CA. */
    export type access_aud = string;
    /** The unique subdomain assigned to your Zero Trust organization. */
    export type access_auth_domain = string;
    /** Enforce different MFA options */
    export interface access_authentication_method_rule {
        auth_method: {
            /** The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176. */
            auth_method: string;
        };
    }
    /** When set to \`true\`, users skip the identity provider selection step during login. */
    export type access_auto_redirect_to_identity = boolean;
    /**
     * Matches an Azure group.
     * Requires an Azure identity provider.
     */
    export interface access_azure_group_rule {
        azureAD: {
            /** The ID of your Azure identity provider. */
            connection_id: string;
            /** The ID of an Azure group. */
            id: string;
        };
    }
    export type access_azureAD = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config & Schemas.access_custom$claims$support & {
            /** Should Cloudflare try to load authentication contexts from your account */
            conditional_access_enabled?: boolean;
            /** Your Azure directory uuid */
            directory_id?: string;
            /** Should Cloudflare try to load groups from your account */
            support_groups?: boolean;
        };
    };
    export interface access_basic_app_response_props {
        aud?: Schemas.access_schemas$aud;
        created_at?: Schemas.access_timestamp;
        id?: Schemas.access_uuid;
        updated_at?: Schemas.access_timestamp;
    }
    export type access_biso_props = Schemas.access_feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    export interface access_bookmark_props {
        app_launcher_visible?: any;
        /** The URL or domain of the bookmark. */
        domain?: any;
        logo_url?: Schemas.access_logo_url;
        name?: Schemas.access_apps_components$schemas$name;
        tags?: Schemas.access_tags;
        /** The application type. */
        type?: string;
    }
    export interface access_bookmarks {
        app_launcher_visible?: Schemas.access_schemas$app_launcher_visible;
        created_at?: Schemas.access_timestamp;
        domain?: Schemas.access_schemas$domain;
        /** The unique identifier for the Bookmark application. */
        id?: any;
        logo_url?: Schemas.access_logo_url;
        name?: Schemas.access_bookmarks_components$schemas$name;
        updated_at?: Schemas.access_timestamp;
    }
    /** The name of the Bookmark application. */
    export type access_bookmarks_components$schemas$name = string;
    export type access_bookmarks_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_bookmarks[];
    };
    export type access_bookmarks_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_bookmarks;
    };
    export interface access_ca {
        aud?: Schemas.access_aud;
        id?: Schemas.access_id;
        public_key?: Schemas.access_public_key;
    }
    export type access_ca_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_ca[];
    };
    export type access_ca_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: {};
    };
    export type access_centrify = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config & Schemas.access_custom$claims$support & {
            /** Your centrify account url */
            centrify_account?: string;
            /** Your centrify app id */
            centrify_app_id?: string;
        };
    };
    /** Matches any valid client certificate. */
    export interface access_certificate_rule {
        certificate: {};
    }
    export interface access_certificates {
        associated_hostnames?: Schemas.access_associated_hostnames;
        created_at?: Schemas.access_timestamp;
        expires_on?: Schemas.access_timestamp;
        fingerprint?: Schemas.access_fingerprint;
        /** The ID of the application that will use this certificate. */
        id?: any;
        name?: Schemas.access_certificates_components$schemas$name;
        updated_at?: Schemas.access_timestamp;
    }
    /** The name of the certificate. */
    export type access_certificates_components$schemas$name = string;
    export type access_certificates_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_certificates[];
    };
    export type access_certificates_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_certificates;
    };
    /** The Client ID for the service token. Access will check for this value in the \`CF-Access-Client-ID\` request header. */
    export type access_client_id = string;
    /** The Client Secret for the service token. Access will check for this value in the \`CF-Access-Client-Secret\` request header. */
    export type access_client_secret = string;
    /** The domain and path that Access will secure. */
    export type access_components$schemas$domain = string;
    export type access_components$schemas$id_response = Schemas.access_api$response$common & {
        result?: {
            id?: Schemas.access_uuid;
        };
    };
    /** The name of the Access group. */
    export type access_components$schemas$name = string;
    export type access_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_service$tokens[];
    };
    /** The amount of time that tokens issued for the application will be valid. Must be in the format \`300ms\` or \`2h45m\`. Valid time units are: ns, us (or Âµs), ms, s, m, h. */
    export type access_components$schemas$session_duration = string;
    export type access_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_groups;
    };
    /** The IdP used to authenticate. */
    export type access_connection = string;
    export interface access_cors_headers {
        allow_all_headers?: Schemas.access_allow_all_headers;
        allow_all_methods?: Schemas.access_allow_all_methods;
        allow_all_origins?: Schemas.access_allow_all_origins;
        allow_credentials?: Schemas.access_allow_credentials;
        allowed_headers?: Schemas.access_allowed_headers;
        allowed_methods?: Schemas.access_allowed_methods;
        allowed_origins?: Schemas.access_allowed_origins;
        max_age?: Schemas.access_max_age;
    }
    /** Matches a specific country */
    export interface access_country_rule {
        geo: {
            /** The country code that should be matched. */
            country_code: string;
        };
    }
    export type access_create_response = Schemas.access_api$response$single & {
        result?: {
            client_id?: Schemas.access_client_id;
            client_secret?: Schemas.access_client_secret;
            created_at?: Schemas.access_timestamp;
            duration?: Schemas.access_duration;
            /** The ID of the service token. */
            id?: any;
            name?: Schemas.access_service$tokens_components$schemas$name;
            updated_at?: Schemas.access_timestamp;
        };
    };
    export interface access_custom$claims$support {
        /** Custom claims */
        claims?: string[];
        /** The claim name for email in the id_token response. */
        email_claim_name?: string;
    }
    /** Custom page name. */
    export type access_custom$pages_components$schemas$name = string;
    export type access_custom$pages_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_custom_page_without_html[];
    };
    export type access_custom$pages_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_custom_page;
    };
    /** The custom error message shown to a user when they are denied access to the application. */
    export type access_custom_deny_message = string;
    /** The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules. */
    export type access_custom_deny_url = string;
    /** The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules. */
    export type access_custom_non_identity_deny_url = string;
    export interface access_custom_page {
        app_count?: Schemas.access_app_count;
        created_at?: Schemas.access_timestamp;
        /** Custom page HTML. */
        custom_html: string;
        name: Schemas.access_custom$pages_components$schemas$name;
        type: Schemas.access_schemas$type;
        uid?: Schemas.access_uuid;
        updated_at?: Schemas.access_timestamp;
    }
    export interface access_custom_page_without_html {
        app_count?: Schemas.access_app_count;
        created_at?: Schemas.access_timestamp;
        name: Schemas.access_custom$pages_components$schemas$name;
        type: Schemas.access_schemas$type;
        uid?: Schemas.access_uuid;
        updated_at?: Schemas.access_timestamp;
    }
    export interface access_custom_pages {
        /** The uid of the custom page to use when a user is denied access after failing a non-identity rule. */
        forbidden?: string;
        /** The uid of the custom page to use when a user is denied access. */
        identity_denied?: string;
    }
    /** The number of days until the next key rotation. */
    export type access_days_until_next_rotation = number;
    /** The action Access will take if a user matches this policy. */
    export type access_decision = "allow" | "deny" | "non_identity" | "bypass";
    export interface access_device_posture_check {
        exists?: boolean;
        path?: string;
    }
    /** Enforces a device posture rule has run successfully */
    export interface access_device_posture_rule {
        device_posture: {
            /** The ID of a device posture integration. */
            integration_uid: string;
        };
    }
    export interface access_device_session {
        last_authenticated?: number;
    }
    /** The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed. */
    export type access_domain = string;
    /** Match an entire email domain. */
    export interface access_domain_rule {
        email_domain: {
            /** The email domain to match. */
            domain: string;
        };
    }
    /** The duration for how long the service token will be valid. Must be in the format \`300ms\` or \`2h45m\`. Valid time units are: ns, us (or Âµs), ms, s, m, h. The default is 1 year in hours (8760h). */
    export type access_duration = string;
    /** The email address of the authenticating user. */
    export type access_email = string;
    /** Matches an email address from a list. */
    export interface access_email_list_rule {
        email_list: {
            /** The ID of a previously created email list. */
            id: string;
        };
    }
    /** Matches a specific email. */
    export interface access_email_rule {
        email: {
            /** The email of the user. */
            email: string;
        };
    }
    export type access_empty_response = {
        result?: true | false;
        success?: true | false;
    };
    /** Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks. */
    export type access_enable_binding_cookie = boolean;
    /** Matches everyone. */
    export interface access_everyone_rule {
        /** An empty object which matches on all users. */
        everyone: {};
    }
    /** Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules. */
    export type access_exclude = Schemas.access_rule[];
    /** Create Allow or Block policies which evaluate the user based on custom criteria. */
    export interface access_external_evaluation_rule {
        external_evaluation: {
            /** The API endpoint containing your business logic. */
            evaluate_url: string;
            /** The API endpoint containing the key that Access uses to verify that the response came from your API. */
            keys_url: string;
        };
    }
    export type access_facebook = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    export type access_failed_login_response = Schemas.access_api$response$collection & {
        result?: {
            expiration?: number;
            metadata?: {};
        }[];
    };
    export interface access_feature_app_props {
        allowed_idps?: Schemas.access_allowed_idps;
        auto_redirect_to_identity?: Schemas.access_schemas$auto_redirect_to_identity;
        domain?: Schemas.access_domain;
        name?: Schemas.access_apps_components$schemas$name;
        session_duration?: Schemas.access_schemas$session_duration;
        type: Schemas.access_type;
    }
    /** The MD5 fingerprint of the certificate. */
    export type access_fingerprint = string;
    /** True if the seat is part of Gateway. */
    export type access_gateway_seat = boolean;
    export interface access_generic$oauth$config {
        /** Your OAuth Client ID */
        client_id?: string;
        /** Your OAuth Client Secret */
        client_secret?: string;
    }
    export interface access_geo {
        country?: string;
    }
    export type access_github = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    /**
     * Matches a Github organization.
     * Requires a Github identity provider.
     */
    export interface access_github_organization_rule {
        "github-organization": {
            /** The ID of your Github identity provider. */
            connection_id: string;
            /** The name of the organization. */
            name: string;
        };
    }
    export type access_google = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config & Schemas.access_custom$claims$support;
    };
    export type access_google$apps = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config & Schemas.access_custom$claims$support & {
            /** Your companies TLD */
            apps_domain?: string;
        };
    };
    export interface access_groups {
        created_at?: Schemas.access_timestamp;
        exclude?: Schemas.access_exclude;
        id?: Schemas.access_uuid;
        include?: Schemas.access_include;
        is_default?: Schemas.access_require;
        name?: Schemas.access_components$schemas$name;
        require?: Schemas.access_require;
        updated_at?: Schemas.access_timestamp;
    }
    export type access_groups_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_schemas$groups[];
    };
    export type access_groups_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_schemas$groups;
    };
    /**
     * Matches a group in Google Workspace.
     * Requires a Google Workspace identity provider.
     */
    export interface access_gsuite_group_rule {
        gsuite: {
            /** The ID of your Google Workspace identity provider. */
            connection_id: string;
            /** The email of the Google Workspace group. */
            email: string;
        };
    }
    /** Enables the HttpOnly cookie attribute, which increases security against XSS attacks. */
    export type access_http_only_cookie_attribute = boolean;
    /** The ID of the CA. */
    export type access_id = string;
    export type access_id_response = Schemas.access_api$response$single & {
        result?: {
            id?: Schemas.access_uuid;
        };
    };
    /** Identifier */
    export type access_identifier = string;
    export interface access_identity {
        account_id?: string;
        auth_status?: string;
        common_name?: string;
        device_id?: string;
        device_sessions?: Schemas.access_string_key_map_device_session;
        devicePosture?: {};
        email?: string;
        geo?: Schemas.access_geo;
        iat?: number;
        idp?: {
            id?: string;
            type?: string;
        };
        ip?: string;
        is_gateway?: boolean;
        is_warp?: boolean;
        mtls_auth?: {
            auth_status?: string;
            cert_issuer_dn?: string;
            cert_issuer_ski?: string;
            cert_presented?: boolean;
            cert_serial?: string;
        };
        service_token_id?: string;
        service_token_status?: boolean;
        user_uuid?: string;
        version?: number;
    }
    export interface access_identity$provider {
        /** The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/). */
        config: {};
        id?: Schemas.access_uuid;
        name: Schemas.access_schemas$name;
        /** The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider. */
        scim_config?: {
            /** A flag to enable or disable SCIM for the identity provider. */
            enabled?: boolean;
            /** A flag to revoke a user's session in Access and force a reauthentication on the user's Gateway session when they have been added or removed from a group in the Identity Provider. */
            group_member_deprovision?: boolean;
            /** A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled. */
            seat_deprovision?: boolean;
            /** A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it token at /access/identity_providers/:idpID/refresh_scim_secret. */
            secret?: string;
            /** A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider. */
            user_deprovision?: boolean;
        };
        /** The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/). */
        type: "onetimepin" | "azureAD" | "saml" | "centrify" | "facebook" | "github" | "google-apps" | "google" | "linkedin" | "oidc" | "okta" | "onelogin" | "pingone" | "yandex";
    }
    export type access_identity$providers = Schemas.access_azureAD | Schemas.access_centrify | Schemas.access_facebook | Schemas.access_github | Schemas.access_google | Schemas.access_google$apps | Schemas.access_linkedin | Schemas.access_oidc | Schemas.access_okta | Schemas.access_onelogin | Schemas.access_pingone | Schemas.access_saml | Schemas.access_yandex | Schemas.access_onetimepin;
    export type access_identity$providers_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: (Schemas.access_schemas$azureAD | Schemas.access_schemas$centrify | Schemas.access_schemas$facebook | Schemas.access_schemas$github | Schemas.access_schemas$google | Schemas.access_schemas$google$apps | Schemas.access_schemas$linkedin | Schemas.access_schemas$oidc | Schemas.access_schemas$okta | Schemas.access_schemas$onelogin | Schemas.access_schemas$pingone | Schemas.access_schemas$saml | Schemas.access_schemas$yandex | Schemas.access_schemas$onetimepin)[];
    };
    export type access_identity$providers_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_schemas$identity$providers;
    };
    /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
    export type access_include = Schemas.access_rule[];
    /** The IP address of the authenticating user. */
    export type access_ip = string;
    /** Matches an IP address from a list. */
    export interface access_ip_list_rule {
        ip_list: {
            /** The ID of a previously created IP list. */
            id: string;
        };
    }
    /** Matches an IP address block. */
    export interface access_ip_rule {
        ip: {
            /** An IPv4 or IPv6 CIDR block. */
            ip: string;
        };
    }
    /** Whether this is the default group */
    export type access_is_default = boolean;
    /** Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled. */
    export type access_is_ui_read_only = boolean;
    /** Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature. */
    export type access_isolation_required = boolean;
    export interface access_key_config {
        days_until_next_rotation?: Schemas.access_days_until_next_rotation;
        key_rotation_interval_days?: Schemas.access_key_rotation_interval_days;
        last_key_rotation_at?: Schemas.access_last_key_rotation_at;
    }
    /** The number of days between key rotations. */
    export type access_key_rotation_interval_days = number;
    export type access_keys_components$schemas$single_response = Schemas.access_api$response$single & Schemas.access_key_config;
    /** The timestamp of the previous key rotation. */
    export type access_last_key_rotation_at = Date;
    export type access_last_seen_identity_response = Schemas.access_api$response$single & {
        result?: Schemas.access_identity;
    };
    /** The time at which the user last successfully logged in. */
    export type access_last_successful_login = Date;
    export type access_linkedin = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    export interface access_login_design {
        /** The background color on your login page. */
        background_color?: string;
        /** The text at the bottom of your login page. */
        footer_text?: string;
        /** The text at the top of your login page. */
        header_text?: string;
        /** The URL of the logo on your login page. */
        logo_path?: string;
        /** The text color on your login page. */
        text_color?: string;
    }
    /** The image URL for the logo shown in the App Launcher dashboard. */
    export type access_logo_url = string;
    /** The maximum number of seconds the results of a preflight request can be cached. */
    export type access_max_age = number;
    export type access_messages = {
        code: number;
        message: string;
    }[];
    /** The name of your Zero Trust organization. */
    export type access_name = string;
    export type access_name_response = Schemas.access_api$response$single & {
        result?: {
            name?: Schemas.access_tags_components$schemas$name;
        };
    };
    export type access_nonce = string;
    export type access_oidc = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config & Schemas.access_custom$claims$support & {
            /** The authorization_endpoint URL of your IdP */
            auth_url?: string;
            /** The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens */
            certs_url?: string;
            /** OAuth scopes */
            scopes?: string[];
            /** The token_endpoint URL of your IdP */
            token_url?: string;
        };
    };
    export type access_okta = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config & Schemas.access_custom$claims$support & {
            /** Your okta authorization server id */
            authorization_server_id?: string;
            /** Your okta account url */
            okta_account?: string;
        };
    };
    /**
     * Matches an Okta group.
     * Requires an Okta identity provider.
     */
    export interface access_okta_group_rule {
        okta: {
            /** The ID of your Okta identity provider. */
            connection_id: string;
            /** The email of the Okta group. */
            email: string;
        };
    }
    export type access_onelogin = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config & Schemas.access_custom$claims$support & {
            /** Your OneLogin account url */
            onelogin_account?: string;
        };
    };
    export type access_onetimepin = Schemas.access_identity$provider & {
        config?: {};
        type?: "onetimepin";
    };
    export interface access_organizations {
        allow_authenticate_via_warp?: Schemas.access_allow_authenticate_via_warp;
        auth_domain?: Schemas.access_auth_domain;
        auto_redirect_to_identity?: Schemas.access_auto_redirect_to_identity;
        created_at?: Schemas.access_timestamp;
        custom_pages?: Schemas.access_custom_pages;
        is_ui_read_only?: Schemas.access_is_ui_read_only;
        login_design?: Schemas.access_login_design;
        name?: Schemas.access_name;
        session_duration?: Schemas.access_session_duration;
        ui_read_only_toggle_reason?: Schemas.access_ui_read_only_toggle_reason;
        updated_at?: Schemas.access_timestamp;
        user_seat_expiration_inactive_time?: Schemas.access_user_seat_expiration_inactive_time;
        warp_auth_session_duration?: Schemas.access_warp_auth_session_duration;
    }
    export type access_organizations_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_schemas$organizations;
    };
    /** Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default */
    export type access_path_cookie_attribute = boolean;
    export type access_pingone = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config & Schemas.access_custom$claims$support & {
            /** Your PingOne environment identifier */
            ping_env_id?: string;
        };
    };
    export interface access_policies {
        approval_groups?: Schemas.access_approval_groups;
        approval_required?: Schemas.access_approval_required;
        created_at?: Schemas.access_timestamp;
        decision?: Schemas.access_decision;
        exclude?: Schemas.access_schemas$exclude;
        id?: Schemas.access_uuid;
        include?: Schemas.access_include;
        isolation_required?: Schemas.access_isolation_required;
        name?: Schemas.access_policies_components$schemas$name;
        precedence?: Schemas.access_precedence;
        purpose_justification_prompt?: Schemas.access_purpose_justification_prompt;
        purpose_justification_required?: Schemas.access_purpose_justification_required;
        require?: Schemas.access_schemas$require;
        session_duration?: Schemas.access_components$schemas$session_duration;
        updated_at?: Schemas.access_timestamp;
    }
    /** The name of the Access policy. */
    export type access_policies_components$schemas$name = string;
    export type access_policies_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_policies[];
    };
    export type access_policies_components$schemas$response_collection$2 = Schemas.access_api$response$collection & {
        result?: Schemas.access_schemas$policies[];
    };
    export type access_policies_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_policies;
    };
    export type access_policies_components$schemas$single_response$2 = Schemas.access_api$response$single & {
        result?: Schemas.access_schemas$policies;
    };
    export type access_policy_check_response = Schemas.access_api$response$single & {
        result?: {
            app_state?: {
                app_uid?: Schemas.access_uuid;
                aud?: string;
                hostname?: string;
                name?: string;
                policies?: {}[];
                status?: string;
            };
            user_identity?: {
                account_id?: string;
                device_sessions?: {};
                email?: string;
                geo?: {
                    country?: string;
                };
                iat?: number;
                id?: string;
                is_gateway?: boolean;
                is_warp?: boolean;
                name?: string;
                user_uuid?: Schemas.access_uuid;
                version?: number;
            };
        };
    };
    /** The order of execution for this policy. Must be unique for each policy. */
    export type access_precedence = number;
    /** The public key to add to your SSH server configuration. */
    export type access_public_key = string;
    /** A custom message that will appear on the purpose justification screen. */
    export type access_purpose_justification_prompt = string;
    /** Require users to enter a justification when they log in to the application. */
    export type access_purpose_justification_required = boolean;
    /** The unique identifier for the request to Cloudflare. */
    export type access_ray_id = string;
    /** Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
    export type access_require = Schemas.access_rule[];
    export type access_response_collection = Schemas.access_api$response$collection & {
        result?: (Schemas.access_azureAD | Schemas.access_centrify | Schemas.access_facebook | Schemas.access_github | Schemas.access_google | Schemas.access_google$apps | Schemas.access_linkedin | Schemas.access_oidc | Schemas.access_okta | Schemas.access_onelogin | Schemas.access_pingone | Schemas.access_saml | Schemas.access_yandex)[];
    };
    export type access_response_collection_hostnames = Schemas.access_api$response$collection & {
        result?: Schemas.access_settings[];
    };
    export interface access_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type access_rule = Schemas.access_email_rule | Schemas.access_email_list_rule | Schemas.access_domain_rule | Schemas.access_everyone_rule | Schemas.access_ip_rule | Schemas.access_ip_list_rule | Schemas.access_certificate_rule | Schemas.access_access_group_rule | Schemas.access_azure_group_rule | Schemas.access_github_organization_rule | Schemas.access_gsuite_group_rule | Schemas.access_okta_group_rule | Schemas.access_saml_group_rule | Schemas.access_service_token_rule | Schemas.access_any_valid_service_token_rule | Schemas.access_external_evaluation_rule | Schemas.access_country_rule | Schemas.access_authentication_method_rule | Schemas.access_device_posture_rule;
    export interface access_saas_app {
        /** The service provider's endpoint that is responsible for receiving and parsing a SAML assertion. */
        consumer_service_url?: string;
        created_at?: Schemas.access_timestamp;
        custom_attributes?: {
            /** The name of the attribute. */
            name?: string;
            /** A globally unique name for an identity or service provider. */
            name_format?: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified" | "urn:oasis:names:tc:SAML:2.0:attrname-format:basic" | "urn:oasis:names:tc:SAML:2.0:attrname-format:uri";
            source?: {
                /** The name of the IdP attribute. */
                name?: string;
            };
        };
        /** The URL that the user will be redirected to after a successful login for IDP initiated logins. */
        default_relay_state?: string;
        /** The unique identifier for your SaaS application. */
        idp_entity_id?: string;
        /** The format of the name identifier sent to the SaaS application. */
        name_id_format?: "id" | "email";
        /** The Access public certificate that will be used to verify your identity. */
        public_key?: string;
        /** A globally unique name for an identity or service provider. */
        sp_entity_id?: string;
        /** The endpoint where your SaaS application will send login requests. */
        sso_endpoint?: string;
        updated_at?: Schemas.access_timestamp;
    }
    export interface access_saas_props {
        allowed_idps?: Schemas.access_allowed_idps;
        app_launcher_visible?: Schemas.access_app_launcher_visible;
        auto_redirect_to_identity?: Schemas.access_schemas$auto_redirect_to_identity;
        custom_pages?: Schemas.access_schemas$custom_pages;
        logo_url?: Schemas.access_logo_url;
        name?: Schemas.access_apps_components$schemas$name;
        saas_app?: Schemas.access_saas_app;
        tags?: Schemas.access_tags;
        /** The application type. */
        type?: string;
    }
    /** Sets the SameSite cookie setting, which provides increased security against CSRF attacks. */
    export type access_same_site_cookie_attribute = string;
    export type access_saml = Schemas.access_identity$provider & {
        config?: {
            /** A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules. */
            attributes?: string[];
            /** The attribute name for email in the SAML response. */
            email_attribute_name?: string;
            /** Add a list of attribute names that will be returned in the response header from the Access callback. */
            header_attributes?: {
                /** attribute name from the IDP */
                attribute_name?: string;
                /** header that will be added on the request to the origin */
                header_name?: string;
            }[];
            /** X509 certificate to verify the signature in the SAML authentication response */
            idp_public_certs?: string[];
            /** IdP Entity ID or Issuer URL */
            issuer_url?: string;
            /** Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints. */
            sign_request?: boolean;
            /** URL to send the SAML authentication requests to */
            sso_target_url?: string;
        };
    };
    /**
     * Matches a SAML group.
     * Requires a SAML identity provider.
     */
    export interface access_saml_group_rule {
        saml: {
            /** The name of the SAML attribute. */
            attribute_name: string;
            /** The SAML attribute value to look for. */
            attribute_value: string;
        };
    }
    /** True if the user has authenticated with Cloudflare Access. */
    export type access_schemas$access_seat = boolean;
    /** When set to true, users can authenticate to this application using their WARP session.  When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication. */
    export type access_schemas$allow_authenticate_via_warp = boolean;
    export type access_schemas$app_launcher_props = Schemas.access_schemas$feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    /** Displays the application in the App Launcher. */
    export type access_schemas$app_launcher_visible = boolean;
    export type access_schemas$apps = (Schemas.access_basic_app_response_props & Schemas.access_schemas$self_hosted_props) | (Schemas.access_basic_app_response_props & Schemas.access_schemas$saas_props) | (Schemas.access_basic_app_response_props & Schemas.access_schemas$ssh_props) | (Schemas.access_basic_app_response_props & Schemas.access_schemas$vnc_props) | (Schemas.access_basic_app_response_props & Schemas.access_schemas$app_launcher_props) | (Schemas.access_basic_app_response_props & Schemas.access_schemas$warp_props) | (Schemas.access_basic_app_response_props & Schemas.access_schemas$biso_props) | (Schemas.access_basic_app_response_props & Schemas.access_schemas$bookmark_props);
    /** Audience tag. */
    export type access_schemas$aud = string;
    /** When set to \`true\`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps. */
    export type access_schemas$auto_redirect_to_identity = boolean;
    export type access_schemas$azureAD = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config & {
            /** Should Cloudflare try to load authentication contexts from your account */
            conditional_access_enabled?: boolean;
            /** Your Azure directory uuid */
            directory_id?: string;
            /** Should Cloudflare try to load groups from your account */
            support_groups?: boolean;
        };
    };
    export type access_schemas$biso_props = Schemas.access_schemas$feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    export interface access_schemas$bookmark_props {
        app_launcher_visible?: any;
        /** The URL or domain of the bookmark. */
        domain: any;
        logo_url?: Schemas.access_logo_url;
        name?: Schemas.access_apps_components$schemas$name;
        /** The application type. */
        type: string;
    }
    export type access_schemas$centrify = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config & {
            /** Your centrify account url */
            centrify_account?: string;
            /** Your centrify app id */
            centrify_app_id?: string;
        };
    };
    /** The custom URL a user is redirected to when they are denied access to the application. */
    export type access_schemas$custom_deny_url = string;
    /** The custom pages that will be displayed when applicable for this application */
    export type access_schemas$custom_pages = string[];
    export interface access_schemas$device_posture_rule {
        check?: Schemas.access_device_posture_check;
        data?: {};
        description?: string;
        error?: string;
        id?: string;
        rule_name?: string;
        success?: boolean;
        timestamp?: string;
        type?: string;
    }
    /** The domain of the Bookmark application. */
    export type access_schemas$domain = string;
    /** The email of the user. */
    export type access_schemas$email = string;
    export type access_schemas$empty_response = {
        result?: {} | null;
        success?: true | false;
    };
    /** Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
    export type access_schemas$exclude = Schemas.access_rule[];
    export type access_schemas$facebook = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    export interface access_schemas$feature_app_props {
        allowed_idps?: Schemas.access_allowed_idps;
        auto_redirect_to_identity?: Schemas.access_schemas$auto_redirect_to_identity;
        domain?: Schemas.access_components$schemas$domain;
        name?: Schemas.access_apps_components$schemas$name;
        session_duration?: Schemas.access_schemas$session_duration;
        type: Schemas.access_type;
    }
    /** True if the user has logged into the WARP client. */
    export type access_schemas$gateway_seat = boolean;
    export type access_schemas$github = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    export type access_schemas$google = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    export type access_schemas$google$apps = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config & {
            /** Your companies TLD */
            apps_domain?: string;
        };
    };
    export interface access_schemas$groups {
        created_at?: Schemas.access_timestamp;
        exclude?: Schemas.access_exclude;
        id?: Schemas.access_uuid;
        include?: Schemas.access_include;
        name?: Schemas.access_components$schemas$name;
        require?: Schemas.access_require;
        updated_at?: Schemas.access_timestamp;
    }
    export type access_schemas$id_response = Schemas.access_api$response$single & {
        result?: {
            id?: Schemas.access_id;
        };
    };
    export type access_schemas$identifier = any;
    export interface access_schemas$identity$provider {
        /** The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/). */
        config: {};
        id?: Schemas.access_uuid;
        name: Schemas.access_schemas$name;
        /** The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider. */
        scim_config?: {
            /** A flag to enable or disable SCIM for the identity provider. */
            enabled?: boolean;
            /** A flag to revoke a user's session in Access and force a reauthentication on the user's Gateway session when they have been added or removed from a group in the Identity Provider. */
            group_member_deprovision?: boolean;
            /** A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled. */
            seat_deprovision?: boolean;
            /** A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it token at /access/identity_providers/:idpID/refresh_scim_secret. */
            secret?: string;
            /** A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider. */
            user_deprovision?: boolean;
        };
        /** The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/). */
        type: "onetimepin" | "azureAD" | "saml" | "centrify" | "facebook" | "github" | "google-apps" | "google" | "linkedin" | "oidc" | "okta" | "onelogin" | "pingone" | "yandex";
    }
    export type access_schemas$identity$providers = Schemas.access_schemas$azureAD | Schemas.access_schemas$centrify | Schemas.access_schemas$facebook | Schemas.access_schemas$github | Schemas.access_schemas$google | Schemas.access_schemas$google$apps | Schemas.access_schemas$linkedin | Schemas.access_schemas$oidc | Schemas.access_schemas$okta | Schemas.access_schemas$onelogin | Schemas.access_schemas$pingone | Schemas.access_schemas$saml | Schemas.access_schemas$yandex;
    /** Require this application to be served in an isolated browser for users matching this policy. */
    export type access_schemas$isolation_required = boolean;
    export type access_schemas$linkedin = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    /** The name of the identity provider, shown to users on the login page. */
    export type access_schemas$name = string;
    export type access_schemas$oidc = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config & {
            /** The authorization_endpoint URL of your IdP */
            auth_url?: string;
            /** The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens */
            certs_url?: string;
            /** List of custom claims that will be pulled from your id_token and added to your signed Access JWT token. */
            claims?: string[];
            /** OAuth scopes */
            scopes?: string[];
            /** The token_endpoint URL of your IdP */
            token_url?: string;
        };
    };
    export type access_schemas$okta = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config & {
            /** Your okta account url */
            okta_account?: string;
        };
    };
    export type access_schemas$onelogin = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config & {
            /** Your OneLogin account url */
            onelogin_account?: string;
        };
    };
    export type access_schemas$onetimepin = Schemas.access_schemas$identity$provider & {
        config?: {};
        type?: "onetimepin";
    };
    export interface access_schemas$organizations {
        auth_domain?: Schemas.access_auth_domain;
        created_at?: Schemas.access_timestamp;
        is_ui_read_only?: Schemas.access_is_ui_read_only;
        login_design?: Schemas.access_login_design;
        name?: Schemas.access_name;
        ui_read_only_toggle_reason?: Schemas.access_ui_read_only_toggle_reason;
        updated_at?: Schemas.access_timestamp;
        user_seat_expiration_inactive_time?: Schemas.access_user_seat_expiration_inactive_time;
    }
    export type access_schemas$pingone = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config & {
            /** Your PingOne environment identifier */
            ping_env_id?: string;
        };
    };
    export interface access_schemas$policies {
        approval_groups?: Schemas.access_approval_groups;
        approval_required?: Schemas.access_approval_required;
        created_at?: Schemas.access_timestamp;
        decision?: Schemas.access_decision;
        exclude?: Schemas.access_schemas$exclude;
        id?: Schemas.access_uuid;
        include?: Schemas.access_include;
        isolation_required?: Schemas.access_schemas$isolation_required;
        name?: Schemas.access_policies_components$schemas$name;
        precedence?: Schemas.access_precedence;
        purpose_justification_prompt?: Schemas.access_purpose_justification_prompt;
        purpose_justification_required?: Schemas.access_purpose_justification_required;
        require?: Schemas.access_schemas$require;
        updated_at?: Schemas.access_timestamp;
    }
    /** Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
    export type access_schemas$require = Schemas.access_rule[];
    export type access_schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_groups[];
    };
    export interface access_schemas$saas_app {
        /** The service provider's endpoint that is responsible for receiving and parsing a SAML assertion. */
        consumer_service_url?: string;
        created_at?: Schemas.access_timestamp;
        custom_attributes?: {
            /** The name of the attribute. */
            name?: string;
            /** A globally unique name for an identity or service provider. */
            name_format?: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified" | "urn:oasis:names:tc:SAML:2.0:attrname-format:basic" | "urn:oasis:names:tc:SAML:2.0:attrname-format:uri";
            source?: {
                /** The name of the IdP attribute. */
                name?: string;
            };
        };
        /** The unique identifier for your SaaS application. */
        idp_entity_id?: string;
        /** The format of the name identifier sent to the SaaS application. */
        name_id_format?: "id" | "email";
        /** The Access public certificate that will be used to verify your identity. */
        public_key?: string;
        /** A globally unique name for an identity or service provider. */
        sp_entity_id?: string;
        /** The endpoint where your SaaS application will send login requests. */
        sso_endpoint?: string;
        updated_at?: Schemas.access_timestamp;
    }
    export interface access_schemas$saas_props {
        allowed_idps?: Schemas.access_allowed_idps;
        app_launcher_visible?: Schemas.access_app_launcher_visible;
        auto_redirect_to_identity?: Schemas.access_schemas$auto_redirect_to_identity;
        logo_url?: Schemas.access_logo_url;
        name?: Schemas.access_apps_components$schemas$name;
        saas_app?: Schemas.access_schemas$saas_app;
        /** The application type. */
        type?: string;
    }
    export type access_schemas$saml = Schemas.access_schemas$identity$provider & {
        config?: {
            /** A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules. */
            attributes?: string[];
            /** The attribute name for email in the SAML response. */
            email_attribute_name?: string;
            /** Add a list of attribute names that will be returned in the response header from the Access callback. */
            header_attributes?: {
                /** attribute name from the IDP */
                attribute_name?: string;
                /** header that will be added on the request to the origin */
                header_name?: string;
            }[];
            /** X509 certificate to verify the signature in the SAML authentication response */
            idp_public_certs?: string[];
            /** IdP Entity ID or Issuer URL */
            issuer_url?: string;
            /** Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints. */
            sign_request?: boolean;
            /** URL to send the SAML authentication requests to */
            sso_target_url?: string;
        };
    };
    export interface access_schemas$self_hosted_props {
        allowed_idps?: Schemas.access_allowed_idps;
        app_launcher_visible?: Schemas.access_app_launcher_visible;
        auto_redirect_to_identity?: Schemas.access_schemas$auto_redirect_to_identity;
        cors_headers?: Schemas.access_cors_headers;
        custom_deny_message?: Schemas.access_custom_deny_message;
        custom_deny_url?: Schemas.access_schemas$custom_deny_url;
        domain: Schemas.access_components$schemas$domain;
        enable_binding_cookie?: Schemas.access_enable_binding_cookie;
        http_only_cookie_attribute?: Schemas.access_http_only_cookie_attribute;
        logo_url?: Schemas.access_logo_url;
        name?: Schemas.access_apps_components$schemas$name;
        same_site_cookie_attribute?: Schemas.access_same_site_cookie_attribute;
        service_auth_401_redirect?: Schemas.access_service_auth_401_redirect;
        session_duration?: Schemas.access_schemas$session_duration;
        skip_interstitial?: Schemas.access_skip_interstitial;
        /** The application type. */
        type: string;
    }
    /** The amount of time that tokens issued for this application will be valid. Must be in the format \`300ms\` or \`2h45m\`. Valid time units are: ns, us (or Âµs), ms, s, m, h. */
    export type access_schemas$session_duration = string;
    export type access_schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_identity$providers;
    };
    export type access_schemas$ssh_props = Schemas.access_schemas$self_hosted_props & {
        /** The application type. */
        type?: string;
    };
    /** Custom page type. */
    export type access_schemas$type = "identity_denied" | "forbidden";
    export type access_schemas$vnc_props = Schemas.access_schemas$self_hosted_props & {
        /** The application type. */
        type?: string;
    };
    export type access_schemas$warp_props = Schemas.access_schemas$feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    export type access_schemas$yandex = Schemas.access_schemas$identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    export interface access_seat {
        access_seat: Schemas.access_access_seat;
        gateway_seat: Schemas.access_gateway_seat;
        seat_uid: Schemas.access_identifier;
    }
    /** The unique API identifier for the Zero Trust seat. */
    export type access_seat_uid = any;
    export interface access_seats {
        access_seat?: Schemas.access_access_seat;
        created_at?: Schemas.access_timestamp;
        gateway_seat?: Schemas.access_gateway_seat;
        seat_uid?: Schemas.access_identifier;
        updated_at?: Schemas.access_timestamp;
    }
    export type access_seats_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_seats[];
    };
    export type access_seats_definition = Schemas.access_seat[];
    /** List of domains that Access will secure. */
    export type access_self_hosted_domains = string[];
    export interface access_self_hosted_props {
        allow_authenticate_via_warp?: Schemas.access_schemas$allow_authenticate_via_warp;
        allowed_idps?: Schemas.access_allowed_idps;
        app_launcher_visible?: Schemas.access_app_launcher_visible;
        auto_redirect_to_identity?: Schemas.access_schemas$auto_redirect_to_identity;
        cors_headers?: Schemas.access_cors_headers;
        custom_deny_message?: Schemas.access_custom_deny_message;
        custom_deny_url?: Schemas.access_custom_deny_url;
        custom_non_identity_deny_url?: Schemas.access_custom_non_identity_deny_url;
        custom_pages?: Schemas.access_schemas$custom_pages;
        domain: Schemas.access_domain;
        enable_binding_cookie?: Schemas.access_enable_binding_cookie;
        http_only_cookie_attribute?: Schemas.access_http_only_cookie_attribute;
        logo_url?: Schemas.access_logo_url;
        name?: Schemas.access_apps_components$schemas$name;
        path_cookie_attribute?: Schemas.access_path_cookie_attribute;
        same_site_cookie_attribute?: Schemas.access_same_site_cookie_attribute;
        self_hosted_domains?: Schemas.access_self_hosted_domains;
        service_auth_401_redirect?: Schemas.access_service_auth_401_redirect;
        session_duration?: Schemas.access_schemas$session_duration;
        skip_interstitial?: Schemas.access_skip_interstitial;
        tags?: Schemas.access_tags;
        /** The application type. */
        type: string;
    }
    export interface access_service$tokens {
        client_id?: Schemas.access_client_id;
        created_at?: Schemas.access_timestamp;
        duration?: Schemas.access_duration;
        /** The ID of the service token. */
        id?: any;
        name?: Schemas.access_service$tokens_components$schemas$name;
        updated_at?: Schemas.access_timestamp;
    }
    /** The name of the service token. */
    export type access_service$tokens_components$schemas$name = string;
    export type access_service$tokens_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_service$tokens;
    };
    /** Returns a 401 status code when the request is blocked by a Service Auth policy. */
    export type access_service_auth_401_redirect = boolean;
    /** Matches a specific Access Service Token */
    export interface access_service_token_rule {
        service_token: {
            /** The ID of a Service Token. */
            token_id: string;
        };
    }
    /** The amount of time that tokens issued for applications will be valid. Must be in the format \`300ms\` or \`2h45m\`. Valid time units are: ns, us (or Âµs), ms, s, m, h. */
    export type access_session_duration = string;
    export interface access_settings {
        /** Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled. */
        china_network: boolean;
        /** Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin. */
        client_certificate_forwarding: boolean;
        /** The hostname that these settings apply to. */
        hostname: string;
    }
    export type access_single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_organizations;
    };
    export type access_single_response_without_html = Schemas.access_api$response$single & {
        result?: Schemas.access_custom_page_without_html;
    };
    /** Enables automatic authentication through cloudflared. */
    export type access_skip_interstitial = boolean;
    export type access_ssh_props = Schemas.access_self_hosted_props & {
        /** The application type. */
        type?: string;
    };
    export interface access_string_key_map_device_session {
    }
    /** A tag */
    export interface access_tag {
        /** The number of applications that have this tag */
        app_count?: number;
        created_at?: Schemas.access_timestamp;
        name: Schemas.access_tags_components$schemas$name;
        updated_at?: Schemas.access_timestamp;
    }
    /** A tag */
    export interface access_tag_without_app_count {
        created_at?: Schemas.access_timestamp;
        name: Schemas.access_tags_components$schemas$name;
        updated_at?: Schemas.access_timestamp;
    }
    /** The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard. */
    export type access_tags = string[];
    /** The name of the tag */
    export type access_tags_components$schemas$name = string;
    export type access_tags_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result?: Schemas.access_tag[];
    };
    export type access_tags_components$schemas$single_response = Schemas.access_api$response$single & {
        result?: Schemas.access_tag;
    };
    export type access_timestamp = Date;
    /** The application type. */
    export type access_type = "self_hosted" | "saas" | "ssh" | "vnc" | "app_launcher" | "warp" | "biso" | "bookmark" | "dash_sso";
    /** A description of the reason why the UI read only field is being toggled. */
    export type access_ui_read_only_toggle_reason = string;
    /** The unique API identifier for the user. */
    export type access_uid = any;
    /** The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format \`300ms\` or \`2h45m\`. Valid time units are: \`ns\`, \`us\` (or \`Âµs\`), \`ms\`, \`s\`, \`m\`, \`h\`. */
    export type access_user_seat_expiration_inactive_time = string;
    export interface access_users {
        access_seat?: Schemas.access_schemas$access_seat;
        active_device_count?: Schemas.access_active_device_count;
        created_at?: Schemas.access_timestamp;
        email?: Schemas.access_schemas$email;
        gateway_seat?: Schemas.access_schemas$gateway_seat;
        id?: Schemas.access_uuid;
        last_successful_login?: Schemas.access_last_successful_login;
        name?: Schemas.access_users_components$schemas$name;
        seat_uid?: Schemas.access_seat_uid;
        uid?: Schemas.access_uid;
        updated_at?: Schemas.access_timestamp;
    }
    /** The name of the user. */
    export type access_users_components$schemas$name = string;
    export type access_users_components$schemas$response_collection = Schemas.access_api$response$collection & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
        };
    } & {
        result?: Schemas.access_users[];
    };
    /** UUID */
    export type access_uuid = string;
    export type access_vnc_props = Schemas.access_self_hosted_props & {
        /** The application type. */
        type?: string;
    };
    /** The amount of time that tokens issued for applications will be valid. Must be in the format \`30m\` or \`2h45m\`. Valid time units are: m, h. */
    export type access_warp_auth_session_duration = string;
    export type access_warp_props = Schemas.access_feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    export type access_yandex = Schemas.access_identity$provider & {
        config?: Schemas.access_generic$oauth$config;
    };
    export interface addressing_address$maps {
        can_delete?: Schemas.addressing_can_delete;
        can_modify_ips?: Schemas.addressing_can_modify_ips;
        created_at?: Schemas.addressing_timestamp;
        default_sni?: Schemas.addressing_default_sni;
        description?: Schemas.addressing_schemas$description;
        enabled?: Schemas.addressing_enabled;
        id?: Schemas.addressing_identifier;
        modified_at?: Schemas.addressing_timestamp;
    }
    export interface addressing_address$maps$ip {
        created_at?: Schemas.addressing_timestamp;
        ip?: Schemas.addressing_ip;
    }
    export interface addressing_address$maps$membership {
        can_delete?: Schemas.addressing_schemas$can_delete;
        created_at?: Schemas.addressing_timestamp;
        identifier?: Schemas.addressing_identifier;
        kind?: Schemas.addressing_kind;
    }
    /** Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled. */
    export type addressing_advertised = boolean | null;
    export type addressing_advertised_response = Schemas.addressing_api$response$single & {
        result?: {
            advertised?: Schemas.addressing_schemas$advertised;
            advertised_modified_at?: Schemas.addressing_modified_at_nullable;
        };
    };
    export type addressing_api$response$collection = Schemas.addressing_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.addressing_result_info;
    };
    export interface addressing_api$response$common {
        errors: Schemas.addressing_messages;
        messages: Schemas.addressing_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface addressing_api$response$common$failure {
        errors: Schemas.addressing_messages;
        messages: Schemas.addressing_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type addressing_api$response$single = Schemas.addressing_api$response$common & {
        result?: {} | string;
    };
    /** Approval state of the prefix (P = pending, V = active). */
    export type addressing_approved = string;
    /** Autonomous System Number (ASN) the prefix will be advertised under. */
    export type addressing_asn = number | null;
    export interface addressing_bgp_on_demand {
        advertised?: Schemas.addressing_advertised;
        advertised_modified_at?: Schemas.addressing_modified_at_nullable;
        on_demand_enabled?: Schemas.addressing_on_demand_enabled;
        on_demand_locked?: Schemas.addressing_on_demand_locked;
    }
    export interface addressing_bgp_prefix_update_advertisement {
        on_demand?: {
            advertised?: boolean;
        };
    }
    export interface addressing_bgp_signal_opts {
        enabled?: Schemas.addressing_bgp_signaling_enabled;
        modified_at?: Schemas.addressing_bgp_signaling_modified_at;
    }
    /** Whether control of advertisement of the prefix to the Internet is enabled to be performed via BGP signal */
    export type addressing_bgp_signaling_enabled = boolean;
    /** Last time BGP signaling control was toggled. This field is null if BGP signaling has never been enabled. */
    export type addressing_bgp_signaling_modified_at = (Date) | null;
    /** If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps. */
    export type addressing_can_delete = boolean;
    /** If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps. */
    export type addressing_can_modify_ips = boolean;
    /** IP Prefix in Classless Inter-Domain Routing format. */
    export type addressing_cidr = string;
    export type addressing_components$schemas$response_collection = Schemas.addressing_api$response$collection & {
        result?: Schemas.addressing_address$maps[];
    };
    export type addressing_components$schemas$single_response = Schemas.addressing_api$response$single & {
        result?: Schemas.addressing_address$maps;
    };
    export interface addressing_create_binding_request {
        cidr?: Schemas.addressing_cidr;
        service_id?: Schemas.addressing_service_identifier;
    }
    /** If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account. */
    export type addressing_default_sni = string | null;
    /** Account identifier for the account to which prefix is being delegated. */
    export type addressing_delegated_account_identifier = string;
    /** Delegation identifier tag. */
    export type addressing_delegation_identifier = string;
    /** Description of the prefix. */
    export type addressing_description = string;
    /** Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled. */
    export type addressing_enabled = boolean | null;
    /** A digest of the IP data. Useful for determining if the data has changed. */
    export type addressing_etag = string;
    export type addressing_full_response = Schemas.addressing_api$response$single & {
        result?: Schemas.addressing_address$maps & {
            ips?: Schemas.addressing_schemas$ips;
            memberships?: Schemas.addressing_memberships;
        };
    };
    export type addressing_id_response = Schemas.addressing_api$response$single & {
        result?: {
            id?: Schemas.addressing_delegation_identifier;
        };
    };
    /** Identifier */
    export type addressing_identifier = string;
    /** An IPv4 or IPv6 address. */
    export type addressing_ip = string;
    /** An IPv4 or IPv6 address. */
    export type addressing_ip_address = string;
    export interface addressing_ipam$bgp$prefixes {
        asn?: Schemas.addressing_asn;
        bgp_signal_opts?: Schemas.addressing_bgp_signal_opts;
        cidr?: Schemas.addressing_cidr;
        created_at?: Schemas.addressing_timestamp;
        id?: Schemas.addressing_identifier;
        modified_at?: Schemas.addressing_timestamp;
        on_demand?: Schemas.addressing_bgp_on_demand;
    }
    export interface addressing_ipam$delegations {
        cidr?: Schemas.addressing_cidr;
        created_at?: Schemas.addressing_timestamp;
        delegated_account_id?: Schemas.addressing_delegated_account_identifier;
        id?: Schemas.addressing_delegation_identifier;
        modified_at?: Schemas.addressing_timestamp;
        parent_prefix_id?: Schemas.addressing_identifier;
    }
    export interface addressing_ipam$prefixes {
        account_id?: Schemas.addressing_identifier;
        advertised?: Schemas.addressing_advertised;
        advertised_modified_at?: Schemas.addressing_modified_at_nullable;
        approved?: Schemas.addressing_approved;
        asn?: Schemas.addressing_asn;
        cidr?: Schemas.addressing_cidr;
        created_at?: Schemas.addressing_timestamp;
        description?: Schemas.addressing_description;
        id?: Schemas.addressing_identifier;
        loa_document_id?: Schemas.addressing_loa_document_identifier;
        modified_at?: Schemas.addressing_timestamp;
        on_demand_enabled?: Schemas.addressing_on_demand_enabled;
        on_demand_locked?: Schemas.addressing_on_demand_locked;
    }
    export interface addressing_ips {
        etag?: Schemas.addressing_etag;
        ipv4_cidrs?: Schemas.addressing_ipv4_cidrs;
        ipv6_cidrs?: Schemas.addressing_ipv6_cidrs;
    }
    export interface addressing_ips_jdcloud {
        etag?: Schemas.addressing_etag;
        ipv4_cidrs?: Schemas.addressing_ipv4_cidrs;
        ipv6_cidrs?: Schemas.addressing_ipv6_cidrs;
        jdcloud_cidrs?: Schemas.addressing_jdcloud_cidrs;
    }
    /** List of Cloudflare IPv4 CIDR addresses. */
    export type addressing_ipv4_cidrs = string[];
    /** List of Cloudflare IPv6 CIDR addresses. */
    export type addressing_ipv6_cidrs = string[];
    /** List IPv4 and IPv6 CIDRs, only populated if \`?networks=jdcloud\` is used. */
    export type addressing_jdcloud_cidrs = string[];
    /** The type of the membership. */
    export type addressing_kind = "zone" | "account";
    /** Identifier for the uploaded LOA document. */
    export type addressing_loa_document_identifier = string | null;
    export type addressing_loa_upload_response = Schemas.addressing_api$response$single & {
        result?: {
            /** Name of LOA document. */
            filename?: string;
        };
    };
    /** Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership. */
    export type addressing_memberships = Schemas.addressing_address$maps$membership[];
    export type addressing_messages = {
        code: number;
        message: string;
    }[];
    /** Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled. */
    export type addressing_modified_at_nullable = (Date) | null;
    /** Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled. */
    export type addressing_on_demand_enabled = boolean;
    /** Whether advertisement status of the prefix is locked, meaning it cannot be changed. */
    export type addressing_on_demand_locked = boolean;
    /** Status of a Service Binding's deployment to the Cloudflare network */
    export interface addressing_provisioning {
        /** When a binding has been deployed to a majority of Cloudflare datacenters, the binding will become active and can be used with its associated service. */
        state?: "provisioning" | "active";
    }
    export type addressing_response_collection = Schemas.addressing_api$response$collection & {
        result?: Schemas.addressing_ipam$prefixes[];
    };
    export type addressing_response_collection_bgp = Schemas.addressing_api$response$collection & {
        result?: Schemas.addressing_ipam$bgp$prefixes[];
    };
    export interface addressing_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Enablement of prefix advertisement to the Internet. */
    export type addressing_schemas$advertised = boolean;
    /** Controls whether the membership can be deleted via the API or not. */
    export type addressing_schemas$can_delete = boolean;
    /** An optional description field which may be used to describe the types of IPs or zones on the map. */
    export type addressing_schemas$description = string | null;
    /** The set of IPs on the Address Map. */
    export type addressing_schemas$ips = Schemas.addressing_address$maps$ip[];
    export type addressing_schemas$response_collection = Schemas.addressing_api$response$collection & {
        result?: Schemas.addressing_ipam$delegations[];
    };
    export type addressing_schemas$single_response = Schemas.addressing_api$response$single & {
        result?: Schemas.addressing_ipam$delegations;
    };
    export interface addressing_service_binding {
        cidr?: Schemas.addressing_cidr;
        id?: Schemas.addressing_identifier;
        provisioning?: Schemas.addressing_provisioning;
        service_id?: Schemas.addressing_service_identifier;
        service_name?: Schemas.addressing_service_name;
    }
    /** Identifier */
    export type addressing_service_identifier = string;
    /** Name of a service running on the Cloudflare network */
    export type addressing_service_name = string;
    export type addressing_single_response = Schemas.addressing_api$response$single & {
        result?: Schemas.addressing_ipam$prefixes;
    };
    export type addressing_single_response_bgp = Schemas.addressing_api$response$single & {
        result?: Schemas.addressing_ipam$bgp$prefixes;
    };
    export type addressing_timestamp = Date;
    export interface ajfne3Yc_api$response$common {
        errors: Schemas.ajfne3Yc_messages;
        messages: Schemas.ajfne3Yc_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface ajfne3Yc_api$response$common$failure {
        errors: Schemas.ajfne3Yc_messages;
        messages: Schemas.ajfne3Yc_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    /** Identifier */
    export type ajfne3Yc_identifier = string;
    export type ajfne3Yc_messages = {
        code: number;
        message: string;
    }[];
    /** List of snippet rules */
    export type ajfne3Yc_rules = {
        description?: string;
        enabled?: boolean;
        expression?: string;
        snippet_name?: Schemas.ajfne3Yc_snippet_name;
    }[];
    /** Snippet Information */
    export interface ajfne3Yc_snippet {
        /** Creation time of the snippet */
        created_on?: string;
        /** Modification time of the snippet */
        modified_on?: string;
        snippet_name?: Schemas.ajfne3Yc_snippet_name;
    }
    /** Snippet identifying name */
    export type ajfne3Yc_snippet_name = string;
    export type ajfne3Yc_zone_identifier = Schemas.ajfne3Yc_identifier;
    export type api$shield_api$response$collection = Schemas.api$shield_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.api$shield_result_info;
    };
    export interface api$shield_api$response$common {
        errors: Schemas.api$shield_messages;
        messages: Schemas.api$shield_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: boolean;
    }
    export interface api$shield_api$response$common$failure {
        errors: Schemas.api$shield_messages;
        messages: Schemas.api$shield_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: boolean;
    }
    export type api$shield_api$response$single = Schemas.api$shield_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export type api$shield_api$shield = Schemas.api$shield_operation;
    /** * \`ML\` - Discovered operation was sourced using ML API Discovery * \`SessionIdentifier\` - Discovered operation was sourced using Session Identifier API Discovery */
    export type api$shield_api_discovery_origin = "ML" | "SessionIdentifier";
    export interface api$shield_api_discovery_patch_multiple_request {
    }
    /** Operation ID to patch state mappings */
    export interface api$shield_api_discovery_patch_multiple_request_entry {
        operation_id?: Schemas.api$shield_uuid;
        state?: Schemas.api$shield_api_discovery_state_patch;
    }
    /**
     * State of operation in API Discovery
     *   * \`review\` - Operation is not saved into API Shield Endpoint Management
     *   * \`saved\` - Operation is saved into API Shield Endpoint Management
     *   * \`ignored\` - Operation is marked as ignored
     */
    export type api$shield_api_discovery_state = "review" | "saved" | "ignored";
    /**
     * Mark state of operation in API Discovery
     *   * \`review\` - Mark operation as for review
     *   * \`ignored\` - Mark operation as ignored
     */
    export type api$shield_api_discovery_state_patch = "review" | "ignored";
    /** The total number of auth-ids seen across this calculation. */
    export type api$shield_auth_id_tokens = number;
    export interface api$shield_basic_operation {
        endpoint: Schemas.api$shield_endpoint;
        host: Schemas.api$shield_host;
        method: Schemas.api$shield_method;
    }
    export type api$shield_characteristics = {
        name: Schemas.api$shield_name;
        type: Schemas.api$shield_type;
    }[];
    export type api$shield_collection_response = Schemas.api$shield_api$response$collection & {
        result?: (Schemas.api$shield_api$shield & {
            features?: {};
        })[];
    };
    export type api$shield_collection_response_paginated = Schemas.api$shield_api$response$collection & {
        result?: Schemas.api$shield_api$shield[];
    };
    export interface api$shield_configuration {
        auth_id_characteristics?: Schemas.api$shield_characteristics;
    }
    /** The number of data points used for the threshold suggestion calculation. */
    export type api$shield_data_points = number;
    export type api$shield_default_response = Schemas.api$shield_api$response$single;
    export type api$shield_discovery_operation = {
        features?: Schemas.api$shield_traffic_stats;
        id: Schemas.api$shield_uuid;
        last_updated: Schemas.api$shield_timestamp;
        /** API discovery engine(s) that discovered this operation */
        origin: Schemas.api$shield_api_discovery_origin[];
        state: Schemas.api$shield_api_discovery_state;
    } & Schemas.api$shield_basic_operation;
    /** The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/. */
    export type api$shield_endpoint = string;
    /** RFC3986-compliant host. */
    export type api$shield_host = string;
    /** Identifier */
    export type api$shield_identifier = string;
    /** Kind of schema */
    export type api$shield_kind = "openapi_v3";
    export type api$shield_messages = {
        code: number;
        message: string;
    }[];
    /** The HTTP method used to access the endpoint. */
    export type api$shield_method = "GET" | "POST" | "HEAD" | "OPTIONS" | "PUT" | "DELETE" | "CONNECT" | "PATCH" | "TRACE";
    /** The name of the characteristic field, i.e., the header or cookie name. */
    export type api$shield_name = string;
    /** A OpenAPI 3.0.0 compliant schema. */
    export interface api$shield_openapi {
    }
    /** A OpenAPI 3.0.0 compliant schema. */
    export interface api$shield_openapiwiththresholds {
    }
    export type api$shield_operation = Schemas.api$shield_basic_operation & {
        features?: Schemas.api$shield_operation_features;
        last_updated: Schemas.api$shield_timestamp;
        operation_id: Schemas.api$shield_uuid;
    };
    export interface api$shield_operation_feature_parameter_schemas {
        parameter_schemas: {
            last_updated?: Schemas.api$shield_timestamp;
            parameter_schemas?: Schemas.api$shield_parameter_schemas_definition;
        };
    }
    export interface api$shield_operation_feature_thresholds {
        thresholds?: {
            auth_id_tokens?: Schemas.api$shield_auth_id_tokens;
            data_points?: Schemas.api$shield_data_points;
            last_updated?: Schemas.api$shield_timestamp;
            p50?: Schemas.api$shield_p50;
            p90?: Schemas.api$shield_p90;
            p99?: Schemas.api$shield_p99;
            period_seconds?: Schemas.api$shield_period_seconds;
            requests?: Schemas.api$shield_requests;
            suggested_threshold?: Schemas.api$shield_suggested_threshold;
        };
    }
    export type api$shield_operation_features = Schemas.api$shield_operation_feature_thresholds | Schemas.api$shield_operation_feature_parameter_schemas;
    /**
     * When set, this applies a mitigation action to this operation
     *
     *   - \`log\` log request when request does not conform to schema for this operation
     *   - \`block\` deny access to the site when request does not conform to schema for this operation
     *   - \`none\` will skip mitigation for this operation
     *   - \`null\` indicates that no operation level mitigation is in place, see Zone Level Schema Validation Settings for mitigation action that will be applied
     */
    export type api$shield_operation_mitigation_action = string | null;
    export interface api$shield_operation_schema_validation_settings {
        mitigation_action?: Schemas.api$shield_operation_mitigation_action;
    }
    export interface api$shield_operation_schema_validation_settings_multiple_request {
    }
    /** Operation ID to mitigation action mappings */
    export interface api$shield_operation_schema_validation_settings_multiple_request_entry {
        mitigation_action?: Schemas.api$shield_operation_mitigation_action;
    }
    /** The p50 quantile of requests (in period_seconds). */
    export type api$shield_p50 = number;
    /** The p90 quantile of requests (in period_seconds). */
    export type api$shield_p90 = number;
    /** The p99 quantile of requests (in period_seconds). */
    export type api$shield_p99 = number;
    /** An operation schema object containing a response. */
    export interface api$shield_parameter_schemas_definition {
        /** An array containing the learned parameter schemas. */
        readonly parameters?: {}[];
        /** An empty response object. This field is required to yield a valid operation schema. */
        readonly responses?: {} | null;
    }
    export type api$shield_patch_discoveries_response = Schemas.api$shield_api$response$single & {
        result?: Schemas.api$shield_api_discovery_patch_multiple_request;
    };
    export type api$shield_patch_discovery_response = Schemas.api$shield_api$response$single & {
        result?: {
            state?: Schemas.api$shield_api_discovery_state;
        };
    };
    /** The period over which this threshold is suggested. */
    export type api$shield_period_seconds = number;
    /** Requests information about certain properties. */
    export type api$shield_properties = ("auth_id_characteristics")[];
    export interface api$shield_public_schema {
        created_at: Schemas.api$shield_timestamp;
        kind: Schemas.api$shield_kind;
        /** Name of the schema */
        name: string;
        schema_id: Schemas.api$shield_uuid;
        /** Source of the schema */
        source?: string;
        validation_enabled?: Schemas.api$shield_validation_enabled;
    }
    /** The estimated number of requests covered by these calculations. */
    export type api$shield_requests = number;
    export interface api$shield_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type api$shield_schema_response_discovery = Schemas.api$shield_api$response$single & {
        result?: {
            schemas?: Schemas.api$shield_openapi[];
            timestamp?: Schemas.api$shield_timestamp;
        };
    };
    export type api$shield_schema_response_with_thresholds = Schemas.api$shield_default_response & {
        result?: {
            schemas?: Schemas.api$shield_openapiwiththresholds[];
            timestamp?: string;
        };
    };
    export interface api$shield_schema_upload_details_errors_critical {
        /** Diagnostic critical error events that occurred during processing. */
        critical?: Schemas.api$shield_schema_upload_log_event[];
        /** Diagnostic error events that occurred during processing. */
        errors?: Schemas.api$shield_schema_upload_log_event[];
    }
    export interface api$shield_schema_upload_details_warnings_only {
        /** Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema. */
        warnings?: Schemas.api$shield_schema_upload_log_event[];
    }
    export type api$shield_schema_upload_failure = {
        upload_details?: Schemas.api$shield_schema_upload_details_errors_critical;
    } & Schemas.api$shield_api$response$common$failure;
    export interface api$shield_schema_upload_log_event {
        /** Code that identifies the event that occurred. */
        code: number;
        /** JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification. */
        locations?: string[];
        /** Diagnostic message that describes the event. */
        message?: string;
    }
    export interface api$shield_schema_upload_response {
        schema: Schemas.api$shield_public_schema;
        upload_details?: Schemas.api$shield_schema_upload_details_warnings_only;
    }
    export type api$shield_schemas$single_response = Schemas.api$shield_api$response$single & {
        result?: Schemas.api$shield_api$shield;
    };
    export type api$shield_single_response = Schemas.api$shield_api$response$single & {
        result?: Schemas.api$shield_configuration;
    };
    /** The suggested threshold in requests done by the same auth_id or period_seconds. */
    export type api$shield_suggested_threshold = number;
    export type api$shield_timestamp = Date;
    export interface api$shield_traffic_stats {
        traffic_stats?: {
            last_updated: Schemas.api$shield_timestamp;
            /** The period in seconds these statistics were computed over */
            readonly period_seconds: number;
            /** The average number of requests seen during this period */
            readonly requests: number;
        };
    }
    /** The type of characteristic. */
    export type api$shield_type = "header" | "cookie";
    /** UUID identifier */
    export type api$shield_uuid = string;
    /**
     * The default mitigation action used when there is no mitigation action defined on the operation
     *
     * Mitigation actions are as follows:
     *
     *   * \`log\` - log request when request does not conform to schema
     *   * \`block\` - deny access to the site when request does not conform to schema
     *
     * A special value of of \`none\` will skip running schema validation entirely for the request when there is no mitigation action defined on the operation
     */
    export type api$shield_validation_default_mitigation_action = "none" | "log" | "block";
    /**
     * The default mitigation action used when there is no mitigation action defined on the operation
     * Mitigation actions are as follows:
     *
     *   * \`log\` - log request when request does not conform to schema
     *   * \`block\` - deny access to the site when request does not conform to schema
     *
     * A special value of of \`none\` will skip running schema validation entirely for the request when there is no mitigation action defined on the operation
     *
     * \`null\` will have no effect.
     */
    export type api$shield_validation_default_mitigation_action_patch = string | null;
    /** Flag whether schema is enabled for validation. */
    export type api$shield_validation_enabled = boolean;
    /**
     * When set, this overrides both zone level and operation level mitigation actions.
     *
     *   - \`none\` will skip running schema validation entirely for the request
     *   - \`null\` indicates that no override is in place
     */
    export type api$shield_validation_override_mitigation_action = string | null;
    /**
     * When set, this overrides both zone level and operation level mitigation actions.
     *
     *   - \`none\` will skip running schema validation entirely for the request
     *
     * To clear any override, use the special value \`disable_override\`
     *
     * \`null\` will have no effect.
     */
    export type api$shield_validation_override_mitigation_action_patch = string | null;
    /**
     * When set, this overrides both zone level and operation level mitigation actions.
     *
     *   - \`none\` will skip running schema validation entirely for the request
     *   - \`null\` indicates that no override is in place
     *
     * To clear any override, use the special value \`disable_override\` or \`null\`
     */
    export type api$shield_validation_override_mitigation_action_write = string | null;
    export interface api$shield_zone_schema_validation_settings {
        validation_default_mitigation_action?: Schemas.api$shield_validation_default_mitigation_action;
        validation_override_mitigation_action?: Schemas.api$shield_validation_override_mitigation_action;
    }
    export interface api$shield_zone_schema_validation_settings_patch {
        validation_default_mitigation_action?: Schemas.api$shield_validation_default_mitigation_action_patch;
        validation_override_mitigation_action?: Schemas.api$shield_validation_override_mitigation_action_patch;
    }
    export interface api$shield_zone_schema_validation_settings_put {
        validation_default_mitigation_action: Schemas.api$shield_validation_default_mitigation_action;
        validation_override_mitigation_action?: Schemas.api$shield_validation_override_mitigation_action_write;
    }
    export interface argo$analytics_api$response$common {
        errors: Schemas.argo$analytics_messages;
        messages: Schemas.argo$analytics_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface argo$analytics_api$response$common$failure {
        errors: Schemas.argo$analytics_messages;
        messages: Schemas.argo$analytics_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type argo$analytics_api$response$single = Schemas.argo$analytics_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    /** Identifier */
    export type argo$analytics_identifier = string;
    export type argo$analytics_messages = {
        code: number;
        message: string;
    }[];
    export type argo$analytics_response_single = Schemas.argo$analytics_api$response$single & {
        result?: {};
    };
    export interface argo$config_api$response$common {
        errors: Schemas.argo$config_messages;
        messages: Schemas.argo$config_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface argo$config_api$response$common$failure {
        errors: Schemas.argo$config_messages;
        messages: Schemas.argo$config_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type argo$config_api$response$single = Schemas.argo$config_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    /** Identifier */
    export type argo$config_identifier = string;
    export type argo$config_messages = {
        code: number;
        message: string;
    }[];
    /** Update enablement of Argo Smart Routing */
    export interface argo$config_patch {
        value: Schemas.argo$config_value;
    }
    export type argo$config_response_single = Schemas.argo$config_api$response$single & {
        result?: {};
    };
    /** Enables Argo Smart Routing. */
    export type argo$config_value = "on" | "off";
    export type bill$subs$api_account_identifier = any;
    export type bill$subs$api_account_subscription_response_collection = Schemas.bill$subs$api_api$response$collection & {
        result?: Schemas.bill$subs$api_subscription[];
    };
    export type bill$subs$api_account_subscription_response_single = Schemas.bill$subs$api_api$response$single & {
        result?: {};
    };
    /** The billing item action. */
    export type bill$subs$api_action = string;
    /** The amount associated with this billing item. */
    export type bill$subs$api_amount = number;
    export type bill$subs$api_api$response$collection = Schemas.bill$subs$api_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.bill$subs$api_result_info;
    };
    export interface bill$subs$api_api$response$common {
        errors: Schemas.bill$subs$api_messages;
        messages: Schemas.bill$subs$api_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface bill$subs$api_api$response$common$failure {
        errors: Schemas.bill$subs$api_messages;
        messages: Schemas.bill$subs$api_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type bill$subs$api_api$response$single = Schemas.bill$subs$api_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export interface bill$subs$api_available$rate$plan {
        can_subscribe?: Schemas.bill$subs$api_can_subscribe;
        currency?: Schemas.bill$subs$api_currency;
        externally_managed?: Schemas.bill$subs$api_externally_managed;
        frequency?: Schemas.bill$subs$api_schemas$frequency;
        id?: Schemas.bill$subs$api_identifier;
        is_subscribed?: Schemas.bill$subs$api_is_subscribed;
        legacy_discount?: Schemas.bill$subs$api_legacy_discount;
        legacy_id?: Schemas.bill$subs$api_legacy_id;
        name?: Schemas.bill$subs$api_schemas$name;
        price?: Schemas.bill$subs$api_schemas$price;
    }
    export interface bill$subs$api_billing$history {
        action: Schemas.bill$subs$api_action;
        amount: Schemas.bill$subs$api_amount;
        currency: Schemas.bill$subs$api_currency;
        description: Schemas.bill$subs$api_description;
        id: Schemas.bill$subs$api_components$schemas$identifier;
        occurred_at: Schemas.bill$subs$api_occurred_at;
        type: Schemas.bill$subs$api_type;
        zone: Schemas.bill$subs$api_schemas$zone;
    }
    export type bill$subs$api_billing_history_collection = Schemas.bill$subs$api_api$response$collection & {
        result?: Schemas.bill$subs$api_billing$history[];
    };
    export type bill$subs$api_billing_response_single = Schemas.bill$subs$api_api$response$single & {
        result?: {};
    };
    /** Indicates whether you can subscribe to this plan. */
    export type bill$subs$api_can_subscribe = boolean;
    export interface bill$subs$api_component$value {
        default?: Schemas.bill$subs$api_default;
        name?: Schemas.bill$subs$api_components$schemas$name;
        unit_price?: Schemas.bill$subs$api_unit_price;
    }
    /** A component value for a subscription. */
    export interface bill$subs$api_component_value {
        /** The default amount assigned. */
        default?: number;
        /** The name of the component value. */
        name?: string;
        /** The unit price for the component value. */
        price?: number;
        /** The amount of the component value assigned. */
        value?: number;
    }
    /** The list of add-ons subscribed to. */
    export type bill$subs$api_component_values = Schemas.bill$subs$api_component_value[];
    /** Billing item identifier tag. */
    export type bill$subs$api_components$schemas$identifier = string;
    /** The unique component. */
    export type bill$subs$api_components$schemas$name = "zones" | "page_rules" | "dedicated_certificates" | "dedicated_certificates_custom";
    /** The monetary unit in which pricing information is displayed. */
    export type bill$subs$api_currency = string;
    /** The end of the current period and also when the next billing is due. */
    export type bill$subs$api_current_period_end = Date;
    /** When the current billing period started. May match initial_period_start if this is the first period. */
    export type bill$subs$api_current_period_start = Date;
    /** The default amount allocated. */
    export type bill$subs$api_default = number;
    /** The billing item description. */
    export type bill$subs$api_description = string;
    /** The duration of the plan subscription. */
    export type bill$subs$api_duration = number;
    /** Indicates whether this plan is managed externally. */
    export type bill$subs$api_externally_managed = boolean;
    /** How often the subscription is renewed automatically. */
    export type bill$subs$api_frequency = "weekly" | "monthly" | "quarterly" | "yearly";
    /** Identifier */
    export type bill$subs$api_identifier = string;
    /** app install id. */
    export type bill$subs$api_install_id = string;
    /** Indicates whether you are currently subscribed to this plan. */
    export type bill$subs$api_is_subscribed = boolean;
    /** Indicates whether this plan has a legacy discount applied. */
    export type bill$subs$api_legacy_discount = boolean;
    /** The legacy identifier for this rate plan, if any. */
    export type bill$subs$api_legacy_id = string;
    export type bill$subs$api_messages = {
        code: number;
        message: string;
    }[];
    /** The domain name */
    export type bill$subs$api_name = string;
    /** When the billing item was created. */
    export type bill$subs$api_occurred_at = Date;
    export type bill$subs$api_plan_response_collection = Schemas.bill$subs$api_api$response$collection & {
        result?: Schemas.bill$subs$api_schemas$rate$plan[];
    };
    /** The price of the subscription that will be billed, in US dollars. */
    export type bill$subs$api_price = number;
    export interface bill$subs$api_rate$plan {
        components?: Schemas.bill$subs$api_schemas$component_values;
        currency?: Schemas.bill$subs$api_currency;
        duration?: Schemas.bill$subs$api_duration;
        frequency?: Schemas.bill$subs$api_schemas$frequency;
        id?: Schemas.bill$subs$api_rate$plan_components$schemas$identifier;
        name?: Schemas.bill$subs$api_schemas$name;
    }
    /** Plan identifier tag. */
    export type bill$subs$api_rate$plan_components$schemas$identifier = string;
    /** The rate plan applied to the subscription. */
    export interface bill$subs$api_rate_plan {
        /** The currency applied to the rate plan subscription. */
        currency?: string;
        /** Whether this rate plan is managed externally from Cloudflare. */
        externally_managed?: boolean;
        /** The ID of the rate plan. */
        id?: any;
        /** Whether a rate plan is enterprise-based (or newly adopted term contract). */
        is_contract?: boolean;
        /** The full name of the rate plan. */
        public_name?: string;
        /** The scope that this rate plan applies to. */
        scope?: string;
        /** The list of sets this rate plan applies to. */
        sets?: string[];
    }
    export interface bill$subs$api_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Array of available components values for the plan. */
    export type bill$subs$api_schemas$component_values = Schemas.bill$subs$api_component$value[];
    /** The frequency at which you will be billed for this plan. */
    export type bill$subs$api_schemas$frequency = "weekly" | "monthly" | "quarterly" | "yearly";
    /** Subscription identifier tag. */
    export type bill$subs$api_schemas$identifier = string;
    /** The plan name. */
    export type bill$subs$api_schemas$name = string;
    /** The amount you will be billed for this plan. */
    export type bill$subs$api_schemas$price = number;
    export type bill$subs$api_schemas$rate$plan = Schemas.bill$subs$api_rate$plan;
    export interface bill$subs$api_schemas$zone {
        readonly name?: any;
    }
    /** The state that the subscription is in. */
    export type bill$subs$api_state = "Trial" | "Provisioned" | "Paid" | "AwaitingPayment" | "Cancelled" | "Failed" | "Expired";
    export type bill$subs$api_subscription = Schemas.bill$subs$api_subscription$v2;
    export interface bill$subs$api_subscription$v2 {
        app?: {
            install_id?: Schemas.bill$subs$api_install_id;
        };
        component_values?: Schemas.bill$subs$api_component_values;
        currency?: Schemas.bill$subs$api_currency;
        current_period_end?: Schemas.bill$subs$api_current_period_end;
        current_period_start?: Schemas.bill$subs$api_current_period_start;
        frequency?: Schemas.bill$subs$api_frequency;
        id?: Schemas.bill$subs$api_schemas$identifier;
        price?: Schemas.bill$subs$api_price;
        rate_plan?: Schemas.bill$subs$api_rate_plan;
        state?: Schemas.bill$subs$api_state;
        zone?: Schemas.bill$subs$api_zone;
    }
    /** The billing item type. */
    export type bill$subs$api_type = string;
    /** The unit price of the addon. */
    export type bill$subs$api_unit_price = number;
    export type bill$subs$api_user_subscription_response_collection = Schemas.bill$subs$api_api$response$collection & {
        result?: Schemas.bill$subs$api_subscription[];
    };
    export type bill$subs$api_user_subscription_response_single = Schemas.bill$subs$api_api$response$single & {
        result?: {};
    };
    /** A simple zone object. May have null properties if not a zone subscription. */
    export interface bill$subs$api_zone {
        id?: Schemas.bill$subs$api_identifier;
        name?: Schemas.bill$subs$api_name;
    }
    export type bill$subs$api_zone_subscription_response_single = Schemas.bill$subs$api_api$response$single & {
        result?: {};
    };
    export interface bot$management_api$response$common {
        errors: Schemas.bot$management_messages;
        messages: Schemas.bot$management_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface bot$management_api$response$common$failure {
        errors: Schemas.bot$management_messages;
        messages: Schemas.bot$management_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type bot$management_api$response$single = Schemas.bot$management_api$response$common & {
        result?: {} | string;
    };
    /** Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes) */
    export type bot$management_auto_update_model = boolean;
    export type bot$management_base_config = {
        enable_js?: Schemas.bot$management_enable_js;
        using_latest_model?: Schemas.bot$management_using_latest_model;
    };
    export type bot$management_bm_subscription_config = Schemas.bot$management_base_config & {
        auto_update_model?: Schemas.bot$management_auto_update_model;
        suppress_session_score?: Schemas.bot$management_suppress_session_score;
    };
    export type bot$management_bot_fight_mode_config = Schemas.bot$management_base_config & {
        fight_mode?: Schemas.bot$management_fight_mode;
    };
    export type bot$management_bot_management_response_body = Schemas.bot$management_api$response$single & {
        result?: Schemas.bot$management_bot_fight_mode_config | Schemas.bot$management_sbfm_definitely_config | Schemas.bot$management_sbfm_likely_config | Schemas.bot$management_bm_subscription_config;
    };
    export type bot$management_config_single = Schemas.bot$management_bot_fight_mode_config | Schemas.bot$management_sbfm_definitely_config | Schemas.bot$management_sbfm_likely_config | Schemas.bot$management_bm_subscription_config;
    /** Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/). */
    export type bot$management_enable_js = boolean;
    /** Whether to enable Bot Fight Mode. */
    export type bot$management_fight_mode = boolean;
    /** Identifier */
    export type bot$management_identifier = string;
    export type bot$management_messages = {
        code: number;
        message: string;
    }[];
    /** Whether to optimize Super Bot Fight Mode protections for Wordpress. */
    export type bot$management_optimize_wordpress = boolean;
    /** Super Bot Fight Mode (SBFM) action to take on definitely automated requests. */
    export type bot$management_sbfm_definitely_automated = "allow" | "block" | "managed_challenge";
    export type bot$management_sbfm_definitely_config = Schemas.bot$management_base_config & {
        optimize_wordpress?: Schemas.bot$management_optimize_wordpress;
        sbfm_definitely_automated?: Schemas.bot$management_sbfm_definitely_automated;
        sbfm_static_resource_protection?: Schemas.bot$management_sbfm_static_resource_protection;
        sbfm_verified_bots?: Schemas.bot$management_sbfm_verified_bots;
    };
    /** Super Bot Fight Mode (SBFM) action to take on likely automated requests. */
    export type bot$management_sbfm_likely_automated = "allow" | "block" | "managed_challenge";
    export type bot$management_sbfm_likely_config = Schemas.bot$management_sbfm_definitely_config & {
        sbfm_likely_automated?: Schemas.bot$management_sbfm_likely_automated;
    };
    /**
     * Super Bot Fight Mode (SBFM) to enable static resource protection.
     * Enable if static resources on your application need bot protection.
     * Note: Static resource protection can also result in legitimate traffic being blocked.
     */
    export type bot$management_sbfm_static_resource_protection = boolean;
    /** Super Bot Fight Mode (SBFM) action to take on verified bots requests. */
    export type bot$management_sbfm_verified_bots = "allow" | "block";
    /** Whether to disable tracking the highest bot score for a session in the Bot Management cookie. */
    export type bot$management_suppress_session_score = boolean;
    /** A read-only field that indicates whether the zone currently is running the latest ML model. */
    export type bot$management_using_latest_model = boolean;
    export interface cache_api$response$common {
        errors: Schemas.cache_messages;
        messages: Schemas.cache_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface cache_api$response$common$failure {
        errors: Schemas.cache_messages;
        messages: Schemas.cache_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type cache_api$response$single = Schemas.cache_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export interface cache_base {
        /** Identifier of the zone setting. */
        id: string;
        /** last time this setting was modified. */
        readonly modified_on: Date;
    }
    export type cache_cache_reserve = Schemas.cache_base & {
        /** ID of the zone setting. */
        id?: "cache_reserve";
    };
    export type cache_cache_reserve_clear = Schemas.cache_base & {
        /** ID of the zone setting. */
        id?: "cache_reserve_clear";
    };
    /** The time that the latest Cache Reserve Clear operation completed. */
    export type cache_cache_reserve_clear_end_ts = Date;
    /** The POST request body does not carry any information. */
    export type cache_cache_reserve_clear_post_request_body = string;
    export interface cache_cache_reserve_clear_response_value {
        result?: Schemas.cache_cache_reserve_clear & {
            end_ts?: Schemas.cache_cache_reserve_clear_end_ts;
            start_ts: Schemas.cache_cache_reserve_clear_start_ts;
            state: Schemas.cache_cache_reserve_clear_state;
        };
    }
    /** The time that the latest Cache Reserve Clear operation started. */
    export type cache_cache_reserve_clear_start_ts = Date;
    /** The current state of the Cache Reserve Clear operation. */
    export type cache_cache_reserve_clear_state = "In-progress" | "Completed";
    export interface cache_cache_reserve_response_value {
        result?: Schemas.cache_cache_reserve & {
            value: Schemas.cache_cache_reserve_value;
        };
    }
    /** Value of the Cache Reserve zone setting. */
    export type cache_cache_reserve_value = "on" | "off";
    /** Identifier */
    export type cache_identifier = string;
    export type cache_messages = {
        code: number;
        message: string;
    }[];
    export type cache_origin_post_quantum_encryption = Schemas.cache_base & {
        /** Value of the zone setting. */
        id?: "origin_pqe";
    };
    export interface cache_origin_post_quantum_encryption_response_value {
        result?: Schemas.cache_origin_post_quantum_encryption & {
            value: Schemas.cache_origin_post_quantum_encryption;
        };
    }
    /** Value of the Origin Post Quantum Encryption Setting. */
    export type cache_origin_post_quantum_encryption_value = "preferred" | "supported" | "off";
    /** Update enablement of Tiered Caching */
    export interface cache_patch {
        value: Schemas.cache_value;
    }
    export type cache_regional_tiered_cache = Schemas.cache_base & {
        /** ID of the zone setting. */
        id?: "tc_regional";
    };
    export interface cache_regional_tiered_cache_response_value {
        result?: Schemas.cache_regional_tiered_cache & {
            value: Schemas.cache_regional_tiered_cache;
        };
    }
    /** Value of the Regional Tiered Cache zone setting. */
    export type cache_regional_tiered_cache_value = "on" | "off";
    export type cache_response_single = Schemas.cache_api$response$single & {
        result?: {};
    };
    /** Update enablement of Smart Tiered Cache */
    export interface cache_schemas$patch {
        value: Schemas.cache_schemas$value;
    }
    /** Enables Tiered Cache. */
    export type cache_schemas$value = "on" | "off";
    /** Enables Tiered Caching. */
    export type cache_value = "on" | "off";
    export type cache_variants = Schemas.cache_base & {
        /** ID of the zone setting. */
        id?: "variants";
    };
    export interface cache_variants_response_value {
        result?: Schemas.cache_variants & {
            value: Schemas.cache_variants_value;
        };
    }
    /** Value of the zone setting. */
    export interface cache_variants_value {
        /** List of strings with the MIME types of all the variants that should be served for avif. */
        avif?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for bmp. */
        bmp?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for gif. */
        gif?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for jp2. */
        jp2?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for jpeg. */
        jpeg?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for jpg. */
        jpg?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for jpg2. */
        jpg2?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for png. */
        png?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for tif. */
        tif?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for tiff. */
        tiff?: {}[];
        /** List of strings with the MIME types of all the variants that should be served for webp. */
        webp?: {}[];
    }
    export type cache_zone_cache_settings_response_single = Schemas.cache_api$response$single & {
        result?: {};
    };
    /** Account identifier tag. */
    export type d1_account$identifier = string;
    export interface d1_api$response$common {
        errors: Schemas.d1_messages;
        messages: Schemas.d1_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface d1_api$response$common$failure {
        errors: Schemas.d1_messages;
        messages: Schemas.d1_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type d1_api$response$single = Schemas.d1_api$response$common & {
        result?: {} | string;
    };
    export interface d1_create$database$response {
        /** Specifies the timestamp the resource was created as an ISO8601 string. */
        readonly created_at?: any;
        name?: Schemas.d1_database$name;
        uuid?: Schemas.d1_database$identifier;
        version?: Schemas.d1_database$version;
    }
    export interface d1_database$details$response {
        /** Specifies the timestamp the resource was created as an ISO8601 string. */
        readonly created_at?: any;
        file_size?: Schemas.d1_file$size;
        name?: Schemas.d1_database$name;
        num_tables?: Schemas.d1_table$count;
        uuid?: Schemas.d1_database$identifier;
        version?: Schemas.d1_database$version;
    }
    export type d1_database$identifier = string;
    export type d1_database$name = string;
    export type d1_database$version = string;
    export type d1_deleted_response = Schemas.d1_api$response$single & {
        result?: {};
    };
    /** The D1 database's size, in bytes. */
    export type d1_file$size = number;
    export type d1_messages = {
        code: number;
        message: string;
    }[];
    export type d1_params = string[];
    export interface d1_query$meta {
        changed_db?: boolean;
        changes?: number;
        duration?: number;
        last_row_id?: number;
        rows_read?: number;
        rows_written?: number;
        size_after?: number;
    }
    export interface d1_query$result$response {
        meta?: Schemas.d1_query$meta;
        results?: {}[];
        success?: boolean;
    }
    export type d1_sql = string;
    export type d1_table$count = number;
    export interface dFBpZBFx_api$response$common {
        errors: Schemas.dFBpZBFx_messages;
        messages: Schemas.dFBpZBFx_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface dFBpZBFx_api$response$common$failure {
        errors: Schemas.dFBpZBFx_messages;
        messages: Schemas.dFBpZBFx_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type dFBpZBFx_api$response$single = Schemas.dFBpZBFx_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    /** Breakdown of totals for bandwidth in the form of bytes. */
    export interface dFBpZBFx_bandwidth {
        /** The total number of bytes served within the time frame. */
        all?: number;
        /** The number of bytes that were cached (and served) by Cloudflare. */
        cached?: number;
        /** A variable list of key/value pairs where the key represents the type of content served, and the value is the number in bytes served. */
        content_type?: {};
        /** A variable list of key/value pairs where the key is a two-digit country code and the value is the number of bytes served to that country. */
        country?: {};
        /** A break down of bytes served over HTTPS. */
        ssl?: {
            /** The number of bytes served over HTTPS. */
            encrypted?: number;
            /** The number of bytes served over HTTP. */
            unencrypted?: number;
        };
        /** A breakdown of requests by their SSL protocol. */
        ssl_protocols?: {
            /** The number of requests served over TLS v1.0. */
            TLSv1?: number;
            /** The number of requests served over TLS v1.1. */
            "TLSv1.1"?: number;
            /** The number of requests served over TLS v1.2. */
            "TLSv1.2"?: number;
            /** The number of requests served over TLS v1.3. */
            "TLSv1.3"?: number;
            /** The number of requests served over HTTP. */
            none?: number;
        };
        /** The number of bytes that were fetched and served from the origin server. */
        uncached?: number;
    }
    /** Breakdown of totals for bandwidth in the form of bytes. */
    export interface dFBpZBFx_bandwidth_by_colo {
        /** The total number of bytes served within the time frame. */
        all?: number;
        /** The number of bytes that were cached (and served) by Cloudflare. */
        cached?: number;
        /** The number of bytes that were fetched and served from the origin server. */
        uncached?: number;
    }
    export type dFBpZBFx_colo_response = Schemas.dFBpZBFx_api$response$single & {
        query?: Schemas.dFBpZBFx_query_response;
        result?: Schemas.dFBpZBFx_datacenters;
    };
    /** Totals and timeseries data. */
    export interface dFBpZBFx_dashboard {
        timeseries?: Schemas.dFBpZBFx_timeseries;
        totals?: Schemas.dFBpZBFx_totals;
    }
    export type dFBpZBFx_dashboard_response = Schemas.dFBpZBFx_api$response$single & {
        query?: Schemas.dFBpZBFx_query_response;
        result?: Schemas.dFBpZBFx_dashboard;
    };
    /**
     * Analytics data by datacenter
     *
     * A breakdown of all dashboard analytics data by co-locations. This is limited to Enterprise zones only.
     */
    export type dFBpZBFx_datacenters = {
        /** The airport code identifer for the co-location. */
        colo_id?: string;
        timeseries?: Schemas.dFBpZBFx_timeseries_by_colo;
        totals?: Schemas.dFBpZBFx_totals_by_colo;
    }[];
    export type dFBpZBFx_end = string | number;
    export interface dFBpZBFx_fields_response {
        key?: string;
    }
    /** The log retention flag for Logpull API. */
    export type dFBpZBFx_flag = boolean;
    export type dFBpZBFx_flag_response = Schemas.dFBpZBFx_api$response$single & {
        result?: {
            flag?: boolean;
        };
    };
    /** Identifier */
    export type dFBpZBFx_identifier = string;
    export type dFBpZBFx_logs = string | {};
    export type dFBpZBFx_messages = {
        code: number;
        message: string;
    }[];
    /** Breakdown of totals for pageviews. */
    export interface dFBpZBFx_pageviews {
        /** The total number of pageviews served within the time range. */
        all?: number;
        /** A variable list of key/value pairs representing the search engine and number of hits. */
        search_engine?: {};
    }
    /** The exact parameters/timestamps the analytics service used to return data. */
    export interface dFBpZBFx_query_response {
        since?: Schemas.dFBpZBFx_since;
        /** The amount of time (in minutes) that each data point in the timeseries represents. The granularity of the time-series returned (e.g. each bucket in the time series representing 1-minute vs 1-day) is calculated by the API based on the time-range provided to the API. */
        time_delta?: number;
        until?: Schemas.dFBpZBFx_until;
    }
    /** Ray identifier. */
    export type dFBpZBFx_ray_identifier = string;
    /** Breakdown of totals for requests. */
    export interface dFBpZBFx_requests {
        /** Total number of requests served. */
        all?: number;
        /** Total number of cached requests served. */
        cached?: number;
        /** A variable list of key/value pairs where the key represents the type of content served, and the value is the number of requests. */
        content_type?: {};
        /** A variable list of key/value pairs where the key is a two-digit country code and the value is the number of requests served to that country. */
        country?: {};
        /** Key/value pairs where the key is a HTTP status code and the value is the number of requests served with that code. */
        http_status?: {};
        /** A break down of requests served over HTTPS. */
        ssl?: {
            /** The number of requests served over HTTPS. */
            encrypted?: number;
            /** The number of requests served over HTTP. */
            unencrypted?: number;
        };
        /** A breakdown of requests by their SSL protocol. */
        ssl_protocols?: {
            /** The number of requests served over TLS v1.0. */
            TLSv1?: number;
            /** The number of requests served over TLS v1.1. */
            "TLSv1.1"?: number;
            /** The number of requests served over TLS v1.2. */
            "TLSv1.2"?: number;
            /** The number of requests served over TLS v1.3. */
            "TLSv1.3"?: number;
            /** The number of requests served over HTTP. */
            none?: number;
        };
        /** Total number of requests served from the origin. */
        uncached?: number;
    }
    /** Breakdown of totals for requests. */
    export interface dFBpZBFx_requests_by_colo {
        /** Total number of requests served. */
        all?: number;
        /** Total number of cached requests served. */
        cached?: number;
        /** Key/value pairs where the key is a two-digit country code and the value is the number of requests served to that country. */
        country?: {};
        /** A variable list of key/value pairs where the key is a HTTP status code and the value is the number of requests with that code served. */
        http_status?: {};
        /** Total number of requests served from the origin. */
        uncached?: number;
    }
    /** When \`?sample=\` is provided, a sample of matching records is returned. If \`sample=0.1\` then 10% of records will be returned. Sampling is random: repeated calls will not only return different records, but likely will also vary slightly in number of returned records. When \`?count=\` is also specified, \`count\` is applied to the number of returned records, not the sampled records. So, with \`sample=0.05\` and \`count=7\`, when there is a total of 100 records available, approximately five will be returned. When there are 1000 records, seven will be returned. When there are 10,000 records, seven will be returned. */
    export type dFBpZBFx_sample = number;
    export type dFBpZBFx_since = string | number;
    /** Breakdown of totals for threats. */
    export interface dFBpZBFx_threats {
        /** The total number of identifiable threats received over the time frame. */
        all?: number;
        /** A list of key/value pairs where the key is a two-digit country code and the value is the number of malicious requests received from that country. */
        country?: {};
        /** The list of key/value pairs where the key is a threat category and the value is the number of requests. */
        type?: {};
    }
    /** Time deltas containing metadata about each bucket of time. The number of buckets (resolution) is determined by the amount of time between the since and until parameters. */
    export type dFBpZBFx_timeseries = {
        bandwidth?: Schemas.dFBpZBFx_bandwidth;
        pageviews?: Schemas.dFBpZBFx_pageviews;
        requests?: Schemas.dFBpZBFx_requests;
        since?: Schemas.dFBpZBFx_since;
        threats?: Schemas.dFBpZBFx_threats;
        uniques?: Schemas.dFBpZBFx_uniques;
        until?: Schemas.dFBpZBFx_until;
    }[];
    /** Time deltas containing metadata about each bucket of time. The number of buckets (resolution) is determined by the amount of time between the since and until parameters. */
    export type dFBpZBFx_timeseries_by_colo = {
        bandwidth?: Schemas.dFBpZBFx_bandwidth_by_colo;
        requests?: Schemas.dFBpZBFx_requests_by_colo;
        since?: Schemas.dFBpZBFx_since;
        threats?: Schemas.dFBpZBFx_threats;
        until?: Schemas.dFBpZBFx_until;
    }[];
    /** By default, timestamps in responses are returned as Unix nanosecond integers. The \`?timestamps=\` argument can be set to change the format in which response timestamps are returned. Possible values are: \`unix\`, \`unixnano\`, \`rfc3339\`. Note that \`unix\` and \`unixnano\` return timestamps as integers; \`rfc3339\` returns timestamps as strings. */
    export type dFBpZBFx_timestamps = "unix" | "unixnano" | "rfc3339";
    /** Breakdown of totals by data type. */
    export interface dFBpZBFx_totals {
        bandwidth?: Schemas.dFBpZBFx_bandwidth;
        pageviews?: Schemas.dFBpZBFx_pageviews;
        requests?: Schemas.dFBpZBFx_requests;
        since?: Schemas.dFBpZBFx_since;
        threats?: Schemas.dFBpZBFx_threats;
        uniques?: Schemas.dFBpZBFx_uniques;
        until?: Schemas.dFBpZBFx_until;
    }
    /** Breakdown of totals by data type. */
    export interface dFBpZBFx_totals_by_colo {
        bandwidth?: Schemas.dFBpZBFx_bandwidth_by_colo;
        requests?: Schemas.dFBpZBFx_requests_by_colo;
        since?: Schemas.dFBpZBFx_since;
        threats?: Schemas.dFBpZBFx_threats;
        until?: Schemas.dFBpZBFx_until;
    }
    export interface dFBpZBFx_uniques {
        /** Total number of unique IP addresses within the time range. */
        all?: number;
    }
    export type dFBpZBFx_until = string | number;
    export type digital$experience$monitoring_account_identifier = string;
    export interface digital$experience$monitoring_aggregate_stat {
        avgMs?: number | null;
        deltaPct?: number | null;
        timePeriod: Schemas.digital$experience$monitoring_aggregate_time_period;
    }
    export interface digital$experience$monitoring_aggregate_time_period {
        units: "hours" | "days" | "testRuns";
        value: number;
    }
    export interface digital$experience$monitoring_aggregate_time_slot {
        avgMs: number;
        timestamp: string;
    }
    export type digital$experience$monitoring_api$response$collection = Schemas.digital$experience$monitoring_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.digital$experience$monitoring_result_info;
    };
    export interface digital$experience$monitoring_api$response$common {
        errors: Schemas.digital$experience$monitoring_messages;
        messages: Schemas.digital$experience$monitoring_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface digital$experience$monitoring_api$response$common$failure {
        errors: Schemas.digital$experience$monitoring_messages;
        messages: Schemas.digital$experience$monitoring_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type digital$experience$monitoring_api$response$single = Schemas.digital$experience$monitoring_api$response$common & {
        result?: {} | string;
    };
    /** Cloudflare colo */
    export type digital$experience$monitoring_colo = string;
    /** array of colos. */
    export type digital$experience$monitoring_colos_response = {
        /** Airport code */
        airportCode: string;
        /** City */
        city: string;
        /** Country code */
        countryCode: string;
    }[];
    export interface digital$experience$monitoring_device {
        colo: Schemas.digital$experience$monitoring_colo;
        /** Device identifier (UUID v4) */
        deviceId: string;
        /** Device identifier (human readable) */
        deviceName?: string;
        personEmail?: Schemas.digital$experience$monitoring_personEmail;
        platform: Schemas.digital$experience$monitoring_platform;
        status: Schemas.digital$experience$monitoring_status;
        version: Schemas.digital$experience$monitoring_version;
    }
    /** Device-specific ID, given as UUID v4 */
    export type digital$experience$monitoring_device_id = string;
    export type digital$experience$monitoring_fleet_status_devices_response = Schemas.digital$experience$monitoring_api$response$collection & {
        result?: Schemas.digital$experience$monitoring_device[];
    };
    export type digital$experience$monitoring_fleet_status_live_response = Schemas.digital$experience$monitoring_api$response$single & {
        result?: {
            deviceStats?: {
                byColo?: Schemas.digital$experience$monitoring_live_stat[] | null;
                byMode?: Schemas.digital$experience$monitoring_live_stat[] | null;
                byPlatform?: Schemas.digital$experience$monitoring_live_stat[] | null;
                byStatus?: Schemas.digital$experience$monitoring_live_stat[] | null;
                byVersion?: Schemas.digital$experience$monitoring_live_stat[] | null;
                uniqueDevicesTotal?: Schemas.digital$experience$monitoring_uniqueDevicesTotal;
            };
        };
    };
    export interface digital$experience$monitoring_http_details_percentiles_response {
        dnsResponseTimeMs?: Schemas.digital$experience$monitoring_percentiles;
        resourceFetchTimeMs?: Schemas.digital$experience$monitoring_percentiles;
        serverResponseTimeMs?: Schemas.digital$experience$monitoring_percentiles;
    }
    export interface digital$experience$monitoring_http_details_response {
        /** The url of the HTTP synthetic application test */
        host?: string;
        httpStats?: {
            dnsResponseTimeMs: Schemas.digital$experience$monitoring_test_stat_over_time;
            httpStatusCode: {
                status200: number;
                status300: number;
                status400: number;
                status500: number;
                timestamp: string;
            }[];
            resourceFetchTimeMs: Schemas.digital$experience$monitoring_test_stat_over_time;
            serverResponseTimeMs: Schemas.digital$experience$monitoring_test_stat_over_time;
            /** Count of unique devices that have run this test in the given time period */
            uniqueDevicesTotal: number;
        } | null;
        httpStatsByColo?: {
            colo: string;
            dnsResponseTimeMs: Schemas.digital$experience$monitoring_test_stat_over_time;
            httpStatusCode: {
                status200: number;
                status300: number;
                status400: number;
                status500: number;
                timestamp: string;
            }[];
            resourceFetchTimeMs: Schemas.digital$experience$monitoring_test_stat_over_time;
            serverResponseTimeMs: Schemas.digital$experience$monitoring_test_stat_over_time;
            /** Count of unique devices that have run this test in the given time period */
            uniqueDevicesTotal: number;
        }[];
        /** The interval at which the HTTP synthetic application test is set to run. */
        interval?: string;
        kind?: "http";
        /** The HTTP method to use when running the test */
        method?: string;
        /** The name of the HTTP synthetic application test */
        name?: string;
    }
    export interface digital$experience$monitoring_live_stat {
        uniqueDevicesTotal?: Schemas.digital$experience$monitoring_uniqueDevicesTotal;
        value?: string;
    }
    export type digital$experience$monitoring_messages = {
        code: number;
        message: string;
    }[];
    /** The mode under which the WARP client is run */
    export type digital$experience$monitoring_mode = string;
    /** Page number of paginated results */
    export type digital$experience$monitoring_page = number;
    /** Number of items per page */
    export type digital$experience$monitoring_per_page = number;
    export interface digital$experience$monitoring_percentiles {
        /** p50 observed in the time period */
        p50?: number | null;
        /** p90 observed in the time period */
        p90?: number | null;
        /** p95 observed in the time period */
        p95?: number | null;
        /** p99 observed in the time period */
        p99?: number | null;
    }
    /** User contact email address */
    export type digital$experience$monitoring_personEmail = string;
    /** Operating system */
    export type digital$experience$monitoring_platform = string;
    export interface digital$experience$monitoring_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Number of minutes before current time */
    export type digital$experience$monitoring_since_minutes = number;
    /** Dimension to sort results by */
    export type digital$experience$monitoring_sort_by = "colo" | "device_id" | "mode" | "platform" | "status" | "timestamp" | "version";
    /** Network status */
    export type digital$experience$monitoring_status = string;
    export interface digital$experience$monitoring_test_stat_over_time {
        /** average observed in the time period */
        avg?: number | null;
        /** highest observed in the time period */
        max?: number | null;
        /** lowest observed in the time period */
        min?: number | null;
        slots: {
            timestamp: string;
            value: number;
        }[];
    }
    export interface digital$experience$monitoring_test_stat_pct_over_time {
        /** average observed in the time period */
        avg?: number | null;
        /** highest observed in the time period */
        max?: number | null;
        /** lowest  observed in the time period */
        min?: number | null;
        slots: {
            timestamp: string;
            value: number;
        }[];
    }
    export interface digital$experience$monitoring_tests_response {
        overviewMetrics: {
            /** percentage availability for all traceroutes results in response */
            avgTracerouteAvailabilityPct?: number | null;
            /** number of  tests. */
            testsTotal: number;
        };
        /** array of test results objects. */
        tests: {
            /** date the test was created. */
            created: string;
            /** the test description defined during configuration */
            description: string;
            /** if true, then the test will run on targeted devices. Else, the test will not run. */
            enabled: boolean;
            host: string;
            httpResults?: {
                resourceFetchTime: Schemas.digital$experience$monitoring_timing_aggregates;
            } | null;
            httpResultsByColo?: {
                /** Cloudflare colo */
                colo: string;
                resourceFetchTime: Schemas.digital$experience$monitoring_timing_aggregates;
            }[];
            id: Schemas.digital$experience$monitoring_uuid;
            /** The interval at which the synthetic application test is set to run. */
            interval: string;
            /** test type, http or traceroute */
            kind: "http" | "traceroute";
            /** for HTTP, the method to use when running the test */
            method?: string;
            /** name given to this test */
            name: string;
            tracerouteResults?: {
                roundTripTime: Schemas.digital$experience$monitoring_timing_aggregates;
            } | null;
            tracerouteResultsByColo?: {
                /** Cloudflare colo */
                colo: string;
                roundTripTime: Schemas.digital$experience$monitoring_timing_aggregates;
            }[];
            updated: string;
        }[];
    }
    /** Timestamp in ISO format */
    export type digital$experience$monitoring_timestamp = string;
    export interface digital$experience$monitoring_timing_aggregates {
        avgMs?: number | null;
        history: Schemas.digital$experience$monitoring_aggregate_stat[];
        overTime?: {
            timePeriod: Schemas.digital$experience$monitoring_aggregate_time_period;
            values: Schemas.digital$experience$monitoring_aggregate_time_slot[];
        } | null;
    }
    export interface digital$experience$monitoring_traceroute_details_percentiles_response {
        hopsCount?: Schemas.digital$experience$monitoring_percentiles;
        packetLossPct?: Schemas.digital$experience$monitoring_percentiles;
        roundTripTimeMs?: Schemas.digital$experience$monitoring_percentiles;
    }
    export interface digital$experience$monitoring_traceroute_details_response {
        /** The host of the Traceroute synthetic application test */
        host: string;
        /** The interval at which the Traceroute synthetic application test is set to run. */
        interval: string;
        kind: "traceroute";
        /** The name of the Traceroute synthetic application test */
        name: string;
        tracerouteStats?: {
            availabilityPct: Schemas.digital$experience$monitoring_test_stat_pct_over_time;
            hopsCount: Schemas.digital$experience$monitoring_test_stat_over_time;
            packetLossPct: Schemas.digital$experience$monitoring_test_stat_pct_over_time;
            roundTripTimeMs: Schemas.digital$experience$monitoring_test_stat_over_time;
            /** Count of unique devices that have run this test in the given time period */
            uniqueDevicesTotal: number;
        } | null;
        tracerouteStatsByColo?: {
            availabilityPct: Schemas.digital$experience$monitoring_test_stat_pct_over_time;
            colo: string;
            hopsCount: Schemas.digital$experience$monitoring_test_stat_over_time;
            packetLossPct: Schemas.digital$experience$monitoring_test_stat_pct_over_time;
            roundTripTimeMs: Schemas.digital$experience$monitoring_test_stat_over_time;
            /** Count of unique devices that have run this test in the given time period */
            uniqueDevicesTotal: number;
        }[];
    }
    export interface digital$experience$monitoring_traceroute_test_network_path_response {
        deviceName?: string;
        id: Schemas.digital$experience$monitoring_uuid;
        /** The interval at which the Traceroute synthetic application test is set to run. */
        interval?: string;
        kind?: "traceroute";
        name?: string;
        networkPath?: {
            /** Specifies the sampling applied, if any, to the slots response. When sampled, results shown represent the first test run to the start of each sampling interval. */
            sampling?: {
                unit: "hours";
                value: number;
            } | null;
            slots: {
                /** Round trip time in ms of the client to app mile */
                clientToAppRttMs: number | null;
                /** Round trip time in ms of the client to Cloudflare egress mile */
                clientToCfEgressRttMs: number | null;
                /** Round trip time in ms of the client to Cloudflare ingress mile */
                clientToCfIngressRttMs: number | null;
                /** Round trip time in ms of the client to ISP mile */
                clientToIspRttMs?: number | null;
                id: Schemas.digital$experience$monitoring_uuid;
                timestamp: string;
            }[];
        } | null;
        /** The host of the Traceroute synthetic application test */
        url?: string;
    }
    export interface digital$experience$monitoring_traceroute_test_result_network_path_response {
        /** name of the device associated with this network path response */
        deviceName?: string;
        /** an array of the hops taken by the device to reach the end destination */
        hops: {
            asn?: number | null;
            aso?: string | null;
            ipAddress?: string | null;
            location?: {
                city?: string | null;
                state?: string | null;
                zip?: string | null;
            } | null;
            mile?: ("client-to-app" | "client-to-cf-egress" | "client-to-cf-ingress" | "client-to-isp") | null;
            name?: string | null;
            packetLossPct?: number | null;
            rttMs?: number | null;
            ttl: number;
        }[];
        resultId: Schemas.digital$experience$monitoring_uuid;
        testId?: Schemas.digital$experience$monitoring_uuid;
        /** name of the tracroute test */
        testName?: string;
        /** date time of this traceroute test */
        time_start: string;
    }
    export interface digital$experience$monitoring_unique_devices_response {
        /** total number of unique devices */
        uniqueDevicesTotal: number;
    }
    /** Number of unique devices */
    export type digital$experience$monitoring_uniqueDevicesTotal = number;
    /** API Resource UUID tag. */
    export type digital$experience$monitoring_uuid = string;
    /** WARP client version */
    export type digital$experience$monitoring_version = string;
    export interface dlp_Dataset {
        created_at: Date;
        description?: string | null;
        id: string;
        name: string;
        num_cells: number;
        secret: boolean;
        status: Schemas.dlp_DatasetUploadStatus;
        updated_at: Date;
        uploads: Schemas.dlp_DatasetUpload[];
    }
    export type dlp_DatasetArray = Schemas.dlp_Dataset[];
    export type dlp_DatasetArrayResponse = Schemas.dlp_V4Response & {
        result?: Schemas.dlp_DatasetArray;
    };
    export interface dlp_DatasetCreation {
        dataset: Schemas.dlp_Dataset;
        max_cells: number;
        /**
         * The secret to use for Exact Data Match datasets. This is not present in
         * Custom Wordlists.
         */
        secret?: string;
        /** The version to use when uploading the dataset. */
        version: number;
    }
    export type dlp_DatasetCreationResponse = Schemas.dlp_V4Response & {
        result?: Schemas.dlp_DatasetCreation;
    };
    export interface dlp_DatasetNewVersion {
        max_cells: number;
        secret?: string;
        version: number;
    }
    export type dlp_DatasetNewVersionResponse = Schemas.dlp_V4Response & {
        result?: Schemas.dlp_DatasetNewVersion;
    };
    export type dlp_DatasetResponse = Schemas.dlp_V4Response & {
        result?: Schemas.dlp_Dataset;
    };
    export interface dlp_DatasetUpdate {
        description?: string | null;
        name?: string | null;
    }
    export interface dlp_DatasetUpload {
        num_cells: number;
        status: Schemas.dlp_DatasetUploadStatus;
        version: number;
    }
    export type dlp_DatasetUploadStatus = "empty" | "uploading" | "failed" | "complete";
    export interface dlp_NewDataset {
        description?: string | null;
        name: string;
        /**
         * Generate a secret dataset.
         *
         * If true, the response will include a secret to use with the EDM encoder.
         * If false, the response has no secret and the dataset is uploaded in plaintext.
         */
        secret?: boolean;
    }
    export interface dlp_V4Response {
        errors: Schemas.dlp_V4ResponseMessage[];
        messages: Schemas.dlp_V4ResponseMessage[];
        result_info?: Schemas.dlp_V4ResponsePagination;
        success: boolean;
    }
    export interface dlp_V4ResponseError {
        errors: Schemas.dlp_V4ResponseMessage[];
        messages: Schemas.dlp_V4ResponseMessage[];
        result?: {} | null;
        success: boolean;
    }
    export interface dlp_V4ResponseMessage {
        code: number;
        message: string;
    }
    export interface dlp_V4ResponsePagination {
        /** total number of pages */
        count: number;
        /** current page */
        page: number;
        /** number of items per page */
        per_page: number;
        /** total number of items */
        total_count: number;
    }
    /** Related DLP policies will trigger when the match count exceeds the number set. */
    export type dlp_allowed_match_count = number;
    export type dlp_api$response$collection = Schemas.dlp_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.dlp_result_info;
    };
    export interface dlp_api$response$common {
        errors: Schemas.dlp_messages;
        messages: Schemas.dlp_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface dlp_api$response$common$failure {
        errors: Schemas.dlp_messages;
        messages: Schemas.dlp_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type dlp_api$response$single = Schemas.dlp_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export type dlp_create_custom_profile_response = Schemas.dlp_api$response$collection & {
        result?: Schemas.dlp_custom_profile[];
    };
    export interface dlp_create_custom_profiles {
        profiles: Schemas.dlp_new_custom_profile[];
    }
    /** A custom entry that matches a profile */
    export interface dlp_custom_entry {
        created_at?: Schemas.dlp_timestamp;
        /** Whether the entry is enabled or not. */
        enabled?: boolean;
        id?: Schemas.dlp_entry_id;
        /** The name of the entry. */
        name?: string;
        pattern?: Schemas.dlp_pattern;
        /** ID of the parent profile */
        profile_id?: any;
        updated_at?: Schemas.dlp_timestamp;
    }
    export interface dlp_custom_profile {
        allowed_match_count?: Schemas.dlp_allowed_match_count;
        created_at?: Schemas.dlp_timestamp;
        /** The description of the profile. */
        description?: string;
        /** The entries for this profile. */
        entries?: Schemas.dlp_custom_entry[];
        id?: Schemas.dlp_profile_id;
        /** The name of the profile. */
        name?: string;
        /** The type of the profile. */
        type?: "custom";
        updated_at?: Schemas.dlp_timestamp;
    }
    export type dlp_custom_profile_response = Schemas.dlp_api$response$single & {
        result?: Schemas.dlp_custom_profile;
    };
    export type dlp_either_profile_response = Schemas.dlp_api$response$single & {
        result?: Schemas.dlp_predefined_profile | Schemas.dlp_custom_profile | Schemas.dlp_integration_profile;
    };
    export type dlp_entry_id = Schemas.dlp_uuid;
    export type dlp_get_settings_response = Schemas.dlp_api$response$single & {
        result?: {
            public_key: string | null;
        };
    };
    /** Identifier */
    export type dlp_identifier = string;
    /** An entry derived from an integration */
    export interface dlp_integration_entry {
        created_at?: Schemas.dlp_timestamp;
        /** Whether the entry is enabled or not. */
        enabled?: boolean;
        id?: Schemas.dlp_entry_id;
        /** The name of the entry. */
        name?: string;
        /** ID of the parent profile */
        profile_id?: any;
        updated_at?: Schemas.dlp_timestamp;
    }
    export interface dlp_integration_profile {
        created_at?: Schemas.dlp_timestamp;
        /** The description of the profile. */
        description?: string;
        /** The entries for this profile. */
        entries?: Schemas.dlp_integration_entry[];
        id?: Schemas.dlp_profile_id;
        /** The name of the profile. */
        name?: string;
        /** The type of the profile. */
        type?: "integration";
        updated_at?: Schemas.dlp_timestamp;
    }
    export type dlp_messages = {
        code: number;
        message: string;
    }[];
    /** A custom entry create payload */
    export interface dlp_new_custom_entry {
        /** Whether the entry is enabled or not. */
        enabled: boolean;
        /** The name of the entry. */
        name: string;
        pattern: Schemas.dlp_pattern;
    }
    export interface dlp_new_custom_profile {
        allowed_match_count?: Schemas.dlp_allowed_match_count;
        /** The description of the profile. */
        description?: string;
        /** The entries for this profile. */
        entries?: Schemas.dlp_new_custom_entry[];
        /** The name of the profile. */
        name?: string;
    }
    /** A pattern that matches an entry */
    export interface dlp_pattern {
        /** The regex pattern. */
        regex: string;
        /** Validation algorithm for the pattern. This algorithm will get run on potential matches, and if it returns false, the entry will not be matched. */
        validation?: "luhn";
    }
    /** A predefined entry that matches a profile */
    export interface dlp_predefined_entry {
        /** Whether the entry is enabled or not. */
        enabled?: boolean;
        id?: Schemas.dlp_entry_id;
        /** The name of the entry. */
        name?: string;
        /** ID of the parent profile */
        profile_id?: any;
    }
    export interface dlp_predefined_profile {
        allowed_match_count?: Schemas.dlp_allowed_match_count;
        /** The entries for this profile. */
        entries?: Schemas.dlp_predefined_entry[];
        id?: Schemas.dlp_profile_id;
        /** The name of the profile. */
        name?: string;
        /** The type of the profile. */
        type?: "predefined";
    }
    export type dlp_predefined_profile_response = Schemas.dlp_api$response$single & {
        result?: Schemas.dlp_predefined_profile;
    };
    export type dlp_profile_id = Schemas.dlp_uuid;
    export type dlp_profiles = Schemas.dlp_predefined_profile | Schemas.dlp_custom_profile | Schemas.dlp_integration_profile;
    export type dlp_response_collection = Schemas.dlp_api$response$collection & {
        result?: Schemas.dlp_profiles[];
    };
    export interface dlp_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Properties of an integration entry in a custom profile */
    export interface dlp_shared_entry_update_integration {
        /** Whether the entry is enabled or not. */
        enabled?: boolean;
        entry_id?: Schemas.dlp_entry_id;
    }
    /** Properties of a predefined entry in a custom profile */
    export interface dlp_shared_entry_update_predefined {
        /** Whether the entry is enabled or not. */
        enabled?: boolean;
        entry_id?: Schemas.dlp_entry_id;
    }
    export type dlp_timestamp = Date;
    export interface dlp_update_custom_profile {
        allowed_match_count?: Schemas.dlp_allowed_match_count;
        /** The description of the profile. */
        description?: string;
        /** The custom entries for this profile. Array elements with IDs are modifying the existing entry with that ID. Elements without ID will create new entries. Any entry not in the list will be deleted. */
        entries?: Schemas.dlp_custom_entry[];
        /** The name of the profile. */
        name?: string;
        /** Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles). */
        shared_entries?: (Schemas.dlp_shared_entry_update_predefined | Schemas.dlp_shared_entry_update_integration)[];
    }
    export interface dlp_update_predefined_profile {
        allowed_match_count?: Schemas.dlp_allowed_match_count;
        /** The entries for this profile. */
        entries?: {
            /** Whether the entry is enabled or not. */
            enabled?: boolean;
            id?: Schemas.dlp_entry_id;
        }[];
    }
    /** Payload log settings */
    export interface dlp_update_settings {
        /** The public key to use when encrypting extracted payloads, as a base64 string */
        public_key: string | null;
    }
    export type dlp_update_settings_response = Schemas.dlp_api$response$single & {
        result?: {
            public_key: string | null;
        };
    };
    /** UUID */
    export type dlp_uuid = string;
    /** A request to validate a pattern */
    export interface dlp_validate_pattern {
        /** The regex pattern. */
        regex: string;
    }
    export type dlp_validate_response = Schemas.dlp_api$response$single & {
        result?: {
            valid?: boolean;
        };
    };
    /** A single account custom nameserver. */
    export interface dns$custom$nameservers_CustomNS {
        /** A and AAAA records associated with the nameserver. */
        dns_records: {
            /** DNS record type. */
            type?: "A" | "AAAA";
            /** DNS record contents (an IPv4 or IPv6 address). */
            value?: string;
        }[];
        ns_name: Schemas.dns$custom$nameservers_ns_name;
        ns_set?: Schemas.dns$custom$nameservers_ns_set;
        /** Verification status of the nameserver. */
        status: "moved" | "pending" | "verified";
        zone_tag: Schemas.dns$custom$nameservers_schemas$identifier;
    }
    export interface dns$custom$nameservers_CustomNSInput {
        ns_name: Schemas.dns$custom$nameservers_ns_name;
        ns_set?: Schemas.dns$custom$nameservers_ns_set;
    }
    export type dns$custom$nameservers_acns_response_collection = Schemas.dns$custom$nameservers_api$response$collection & {
        result?: Schemas.dns$custom$nameservers_CustomNS[];
    };
    export type dns$custom$nameservers_acns_response_single = Schemas.dns$custom$nameservers_api$response$single & {
        result?: Schemas.dns$custom$nameservers_CustomNS;
    };
    export type dns$custom$nameservers_api$response$collection = Schemas.dns$custom$nameservers_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.dns$custom$nameservers_result_info;
    };
    export interface dns$custom$nameservers_api$response$common {
        errors: Schemas.dns$custom$nameservers_messages;
        messages: Schemas.dns$custom$nameservers_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface dns$custom$nameservers_api$response$common$failure {
        errors: Schemas.dns$custom$nameservers_messages;
        messages: Schemas.dns$custom$nameservers_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type dns$custom$nameservers_api$response$single = Schemas.dns$custom$nameservers_api$response$common & {
        result?: {} | string;
    };
    export type dns$custom$nameservers_availability_response = Schemas.dns$custom$nameservers_api$response$collection & {
        result?: string[];
    };
    export type dns$custom$nameservers_empty_response = Schemas.dns$custom$nameservers_api$response$collection & {
        result?: {}[];
    };
    export type dns$custom$nameservers_get_response = Schemas.dns$custom$nameservers_api$response$collection & Schemas.dns$custom$nameservers_zone_metadata;
    /** Account identifier tag. */
    export type dns$custom$nameservers_identifier = string;
    export type dns$custom$nameservers_messages = {
        code: number;
        message: string;
    }[];
    /** The FQDN of the name server. */
    export type dns$custom$nameservers_ns_name = string;
    /** The number of the set that this name server belongs to. */
    export type dns$custom$nameservers_ns_set = number;
    export interface dns$custom$nameservers_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type dns$custom$nameservers_schemas$empty_response = Schemas.dns$custom$nameservers_api$response$collection & {
        result?: {}[];
    };
    /** Identifier */
    export type dns$custom$nameservers_schemas$identifier = string;
    export interface dns$custom$nameservers_zone_metadata {
        /** Whether zone uses account-level custom nameservers. */
        enabled?: boolean;
        /** The number of the name server set to assign to the zone. */
        ns_set?: number;
    }
    export type dns$firewall_api$response$collection = Schemas.dns$firewall_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.dns$firewall_result_info;
    };
    export interface dns$firewall_api$response$common {
        errors: Schemas.dns$firewall_messages;
        messages: Schemas.dns$firewall_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface dns$firewall_api$response$common$failure {
        errors: Schemas.dns$firewall_messages;
        messages: Schemas.dns$firewall_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type dns$firewall_api$response$single = Schemas.dns$firewall_api$response$common & {
        result?: {} | string;
    };
    /** Attack mitigation settings. */
    export type dns$firewall_attack_mitigation = {
        /** When enabled, random-prefix attacks are automatically mitigated and the upstream DNS servers protected. */
        enabled?: boolean;
        /** Deprecated alias for "only_when_upstream_unhealthy". */
        only_when_origin_unhealthy?: any;
        /** Only mitigate attacks when upstream servers seem unhealthy. */
        only_when_upstream_unhealthy?: boolean;
    } | null;
    /** Deprecate the response to ANY requests. */
    export type dns$firewall_deprecate_any_requests = boolean;
    export interface dns$firewall_dns$firewall {
        attack_mitigation?: Schemas.dns$firewall_attack_mitigation;
        deprecate_any_requests: Schemas.dns$firewall_deprecate_any_requests;
        dns_firewall_ips: Schemas.dns$firewall_dns_firewall_ips;
        ecs_fallback: Schemas.dns$firewall_ecs_fallback;
        id: Schemas.dns$firewall_identifier;
        maximum_cache_ttl: Schemas.dns$firewall_maximum_cache_ttl;
        minimum_cache_ttl: Schemas.dns$firewall_minimum_cache_ttl;
        modified_on: Schemas.dns$firewall_modified_on;
        name: Schemas.dns$firewall_name;
        negative_cache_ttl?: Schemas.dns$firewall_negative_cache_ttl;
        /** Deprecated alias for "upstream_ips". */
        origin_ips?: any;
        ratelimit?: Schemas.dns$firewall_ratelimit;
        retries?: Schemas.dns$firewall_retries;
        upstream_ips: Schemas.dns$firewall_upstream_ips;
    }
    export type dns$firewall_dns_firewall_ips = (string | string)[];
    export type dns$firewall_dns_firewall_response_collection = Schemas.dns$firewall_api$response$collection & {
        result?: Schemas.dns$firewall_dns$firewall[];
    };
    export type dns$firewall_dns_firewall_single_response = Schemas.dns$firewall_api$response$single & {
        result?: Schemas.dns$firewall_dns$firewall;
    };
    /** Forward client IP (resolver) subnet if no EDNS Client Subnet is sent. */
    export type dns$firewall_ecs_fallback = boolean;
    /** Identifier */
    export type dns$firewall_identifier = string;
    /** Maximum DNS Cache TTL. */
    export type dns$firewall_maximum_cache_ttl = number;
    export type dns$firewall_messages = {
        code: number;
        message: string;
    }[];
    /** Minimum DNS Cache TTL. */
    export type dns$firewall_minimum_cache_ttl = number;
    /** Last modification of DNS Firewall cluster. */
    export type dns$firewall_modified_on = Date;
    /** DNS Firewall Cluster Name. */
    export type dns$firewall_name = string;
    /** Negative DNS Cache TTL. */
    export type dns$firewall_negative_cache_ttl = number | null;
    /** Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster). */
    export type dns$firewall_ratelimit = number | null;
    export interface dns$firewall_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt). */
    export type dns$firewall_retries = number;
    export type dns$firewall_schemas$dns$firewall = Schemas.dns$firewall_dns$firewall;
    export type dns$firewall_upstream_ips = (string | string)[];
    export type dns$records_AAAARecord = {
        /** A valid IPv6 address. */
        content?: string;
        name?: Schemas.dns$records_name;
        proxied?: Schemas.dns$records_proxied;
        /** Record type. */
        type?: "AAAA";
    } & Schemas.dns$records_base;
    export type dns$records_ARecord = {
        /** A valid IPv4 address. */
        content?: string;
        name?: Schemas.dns$records_name;
        proxied?: Schemas.dns$records_proxied;
        /** Record type. */
        type?: "A";
    } & Schemas.dns$records_base;
    export type dns$records_CAARecord = {
        /** Formatted CAA content. See 'data' to set CAA properties. */
        readonly content?: string;
        /** Components of a CAA record. */
        data?: {
            /** Flags for the CAA record. */
            flags?: number;
            /** Name of the property controlled by this record (e.g.: issue, issuewild, iodef). */
            tag?: string;
            /** Value of the record. This field's semantics depend on the chosen tag. */
            value?: string;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "CAA";
    } & Schemas.dns$records_base;
    export type dns$records_CERTRecord = {
        /** Formatted CERT content. See 'data' to set CERT properties. */
        readonly content?: string;
        /** Components of a CERT record. */
        data?: {
            /** Algorithm. */
            algorithm?: number;
            /** Certificate. */
            certificate?: string;
            /** Key Tag. */
            key_tag?: number;
            /** Type. */
            type?: number;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "CERT";
    } & Schemas.dns$records_base;
    export type dns$records_CNAMERecord = {
        /** A valid hostname. Must not match the record's name. */
        content?: any;
        name?: Schemas.dns$records_name;
        proxied?: Schemas.dns$records_proxied;
        /** Record type. */
        type?: "CNAME";
    } & Schemas.dns$records_base;
    export type dns$records_DNSKEYRecord = {
        /** Formatted DNSKEY content. See 'data' to set DNSKEY properties. */
        readonly content?: string;
        /** Components of a DNSKEY record. */
        data?: {
            /** Algorithm. */
            algorithm?: number;
            /** Flags. */
            flags?: number;
            /** Protocol. */
            protocol?: number;
            /** Public Key. */
            public_key?: string;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "DNSKEY";
    } & Schemas.dns$records_base;
    export type dns$records_DSRecord = {
        /** Formatted DS content. See 'data' to set DS properties. */
        readonly content?: string;
        /** Components of a DS record. */
        data?: {
            /** Algorithm. */
            algorithm?: number;
            /** Digest. */
            digest?: string;
            /** Digest Type. */
            digest_type?: number;
            /** Key Tag. */
            key_tag?: number;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "DS";
    } & Schemas.dns$records_base;
    export type dns$records_HTTPSRecord = {
        /** Formatted HTTPS content. See 'data' to set HTTPS properties. */
        readonly content?: string;
        /** Components of a HTTPS record. */
        data?: {
            /** priority. */
            priority?: number;
            /** target. */
            target?: string;
            /** value. */
            value?: string;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "HTTPS";
    } & Schemas.dns$records_base;
    export type dns$records_LOCRecord = {
        /** Formatted LOC content. See 'data' to set LOC properties. */
        readonly content?: string;
        /** Components of a LOC record. */
        data?: {
            /** Altitude of location in meters. */
            altitude?: number;
            /** Degrees of latitude. */
            lat_degrees?: number;
            /** Latitude direction. */
            lat_direction?: "N" | "S";
            /** Minutes of latitude. */
            lat_minutes?: number;
            /** Seconds of latitude. */
            lat_seconds?: number;
            /** Degrees of longitude. */
            long_degrees?: number;
            /** Longitude direction. */
            long_direction?: "E" | "W";
            /** Minutes of longitude. */
            long_minutes?: number;
            /** Seconds of longitude. */
            long_seconds?: number;
            /** Horizontal precision of location. */
            precision_horz?: number;
            /** Vertical precision of location. */
            precision_vert?: number;
            /** Size of location in meters. */
            size?: number;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "LOC";
    } & Schemas.dns$records_base;
    export type dns$records_MXRecord = {
        /** A valid mail server hostname. */
        content?: string;
        name?: Schemas.dns$records_name;
        priority?: Schemas.dns$records_priority;
        /** Record type. */
        type?: "MX";
    } & Schemas.dns$records_base;
    export type dns$records_NAPTRRecord = {
        /** Formatted NAPTR content. See 'data' to set NAPTR properties. */
        readonly content?: string;
        /** Components of a NAPTR record. */
        data?: {
            /** Flags. */
            flags?: string;
            /** Order. */
            order?: number;
            /** Preference. */
            preference?: number;
            /** Regex. */
            regex?: string;
            /** Replacement. */
            replacement?: string;
            /** Service. */
            service?: string;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "NAPTR";
    } & Schemas.dns$records_base;
    export type dns$records_NSRecord = {
        /** A valid name server host name. */
        content?: any;
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "NS";
    } & Schemas.dns$records_base;
    export type dns$records_PTRRecord = {
        /** Domain name pointing to the address. */
        content?: string;
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "PTR";
    } & Schemas.dns$records_base;
    export type dns$records_SMIMEARecord = {
        /** Formatted SMIMEA content. See 'data' to set SMIMEA properties. */
        readonly content?: string;
        /** Components of a SMIMEA record. */
        data?: {
            /** Certificate. */
            certificate?: string;
            /** Matching Type. */
            matching_type?: number;
            /** Selector. */
            selector?: number;
            /** Usage. */
            usage?: number;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "SMIMEA";
    } & Schemas.dns$records_base;
    export type dns$records_SRVRecord = {
        /** Priority, weight, port, and SRV target. See 'data' for setting the individual component values. */
        readonly content?: string;
        /** Components of a SRV record. */
        data?: {
            /** A valid hostname. Deprecated in favor of the regular 'name' outside the data map. This data map field represents the remainder of the full 'name' after the service and protocol. */
            name?: string;
            /** The port of the service. */
            port?: number;
            priority?: Schemas.dns$records_priority;
            /** A valid protocol, prefixed with an underscore. Deprecated in favor of the regular 'name' outside the data map. This data map field normally represents the second label of that 'name'. */
            proto?: string;
            /** A service type, prefixed with an underscore. Deprecated in favor of the regular 'name' outside the data map. This data map field normally represents the first label of that 'name'. */
            service?: string;
            /** A valid hostname. */
            target?: string;
            /** The record weight. */
            weight?: number;
        };
        /** DNS record name (or @ for the zone apex) in Punycode. For SRV records, the first label is normally a service and the second a protocol name, each starting with an underscore. */
        name?: string;
        /** Record type. */
        type?: "SRV";
    } & Schemas.dns$records_base;
    export type dns$records_SSHFPRecord = {
        /** Formatted SSHFP content. See 'data' to set SSHFP properties. */
        readonly content?: string;
        /** Components of a SSHFP record. */
        data?: {
            /** algorithm. */
            algorithm?: number;
            /** fingerprint. */
            fingerprint?: string;
            /** type. */
            type?: number;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "SSHFP";
    } & Schemas.dns$records_base;
    export type dns$records_SVCBRecord = {
        /** Formatted SVCB content. See 'data' to set SVCB properties. */
        readonly content?: string;
        /** Components of a SVCB record. */
        data?: {
            /** priority. */
            priority?: number;
            /** target. */
            target?: string;
            /** value. */
            value?: string;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "SVCB";
    } & Schemas.dns$records_base;
    export type dns$records_TLSARecord = {
        /** Formatted TLSA content. See 'data' to set TLSA properties. */
        readonly content?: string;
        /** Components of a TLSA record. */
        data?: {
            /** certificate. */
            certificate?: string;
            /** Matching Type. */
            matching_type?: number;
            /** Selector. */
            selector?: number;
            /** Usage. */
            usage?: number;
        };
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "TLSA";
    } & Schemas.dns$records_base;
    export type dns$records_TXTRecord = {
        /** Text content for the record. */
        content?: string;
        name?: Schemas.dns$records_name;
        /** Record type. */
        type?: "TXT";
    } & Schemas.dns$records_base;
    export type dns$records_URIRecord = {
        /** Formatted URI content. See 'data' to set URI properties. */
        readonly content?: string;
        /** Components of a URI record. */
        data?: {
            /** The record content. */
            content?: string;
            /** The record weight. */
            weight?: number;
        };
        name?: Schemas.dns$records_name;
        priority?: Schemas.dns$records_priority;
        /** Record type. */
        type?: "URI";
    } & Schemas.dns$records_base;
    export type dns$records_api$response$collection = Schemas.dns$records_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.dns$records_result_info;
    };
    export interface dns$records_api$response$common {
        errors: Schemas.dns$records_messages;
        messages: Schemas.dns$records_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface dns$records_api$response$common$failure {
        errors: Schemas.dns$records_messages;
        messages: Schemas.dns$records_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type dns$records_api$response$single = Schemas.dns$records_api$response$common & {
        result?: {} | string;
    };
    export interface dns$records_base {
        comment?: Schemas.dns$records_comment;
        /** When the record was created. */
        readonly created_on?: Date;
        id?: Schemas.dns$records_identifier;
        /** Whether this record can be modified/deleted (true means it's managed by Cloudflare). */
        readonly locked?: boolean;
        /** Extra Cloudflare-specific information about the record. */
        readonly meta?: {
            /** Will exist if Cloudflare automatically added this DNS record during initial setup. */
            auto_added?: boolean;
            /** Where the record originated from. */
            source?: string;
        };
        /** When the record was last modified. */
        readonly modified_on?: Date;
        /** Whether the record can be proxied by Cloudflare or not. */
        readonly proxiable?: boolean;
        tags?: Schemas.dns$records_tags;
        ttl?: Schemas.dns$records_ttl;
        zone_id?: Schemas.dns$records_identifier;
        /** The domain of the record. */
        readonly zone_name?: string;
    }
    /** Comments or notes about the DNS record. This field has no effect on DNS responses. */
    export type dns$records_comment = string;
    /** DNS record content. */
    export type dns$records_content = string;
    /** Direction to order DNS records in. */
    export type dns$records_direction = "asc" | "desc";
    export type dns$records_dns$record = Schemas.dns$records_ARecord | Schemas.dns$records_AAAARecord | Schemas.dns$records_CAARecord | Schemas.dns$records_CERTRecord | Schemas.dns$records_CNAMERecord | Schemas.dns$records_DNSKEYRecord | Schemas.dns$records_DSRecord | Schemas.dns$records_HTTPSRecord | Schemas.dns$records_LOCRecord | Schemas.dns$records_MXRecord | Schemas.dns$records_NAPTRRecord | Schemas.dns$records_NSRecord | Schemas.dns$records_PTRRecord | Schemas.dns$records_SMIMEARecord | Schemas.dns$records_SRVRecord | Schemas.dns$records_SSHFPRecord | Schemas.dns$records_SVCBRecord | Schemas.dns$records_TLSARecord | Schemas.dns$records_TXTRecord | Schemas.dns$records_URIRecord;
    export type dns$records_dns_response_collection = Schemas.dns$records_api$response$collection & {
        result?: Schemas.dns$records_dns$record[];
    };
    export type dns$records_dns_response_import_scan = Schemas.dns$records_api$response$single & {
        result?: {
            /** Number of DNS records added. */
            recs_added?: number;
            /** Total number of DNS records parsed. */
            total_records_parsed?: number;
        };
        timing?: {
            /** When the file parsing ended. */
            end_time?: Date;
            /** Processing time of the file in seconds. */
            process_time?: number;
            /** When the file parsing started. */
            start_time?: Date;
        };
    };
    export type dns$records_dns_response_single = Schemas.dns$records_api$response$single & {
        result?: Schemas.dns$records_dns$record;
    };
    /** Identifier */
    export type dns$records_identifier = string;
    /** Whether to match all search requirements or at least one (any). If set to \`all\`, acts like a logical AND between filters. If set to \`any\`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the \`tag-match\` parameter instead. */
    export type dns$records_match = "any" | "all";
    export type dns$records_messages = {
        code: number;
        message: string;
    }[];
    /** DNS record name (or @ for the zone apex) in Punycode. */
    export type dns$records_name = string;
    /** Field to order DNS records by. */
    export type dns$records_order = "type" | "name" | "content" | "ttl" | "proxied";
    /** Page number of paginated results. */
    export type dns$records_page = number;
    /** Number of DNS records per page. */
    export type dns$records_per_page = number;
    /** Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred. */
    export type dns$records_priority = number;
    /** Whether the record is receiving the performance and security benefits of Cloudflare. */
    export type dns$records_proxied = boolean;
    export interface dns$records_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the \`match\` setting. For automated searches, please use the other available parameters. */
    export type dns$records_search = string;
    /** Whether to match all tag search requirements or at least one (any). If set to \`all\`, acts like a logical AND between tag filters. If set to \`any\`, acts like a logical OR instead. Note that the regular \`match\` parameter is still used to combine the resulting condition with other filters that aren't related to tags. */
    export type dns$records_tag_match = "any" | "all";
    /** Custom tags for the DNS record. This field has no effect on DNS responses. */
    export type dns$records_tags = string[];
    export type dns$records_ttl = number | (1);
    /** Record type. */
    export type dns$records_type = "A" | "AAAA" | "CAA" | "CERT" | "CNAME" | "DNSKEY" | "DS" | "HTTPS" | "LOC" | "MX" | "NAPTR" | "NS" | "PTR" | "SMIMEA" | "SRV" | "SSHFP" | "SVCB" | "TLSA" | "TXT" | "URI";
    /** Algorithm key code. */
    export type dnssec_algorithm = string | null;
    export interface dnssec_api$response$common {
        errors: Schemas.dnssec_messages;
        messages: Schemas.dnssec_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface dnssec_api$response$common$failure {
        errors: Schemas.dnssec_messages;
        messages: Schemas.dnssec_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type dnssec_api$response$single = Schemas.dnssec_api$response$common & {
        result?: {} | string;
    };
    export type dnssec_delete_dnssec_response_single = Schemas.dnssec_api$response$single & {
        result?: string;
    };
    /** Digest hash. */
    export type dnssec_digest = string | null;
    /** Type of digest algorithm. */
    export type dnssec_digest_algorithm = string | null;
    /** Coded type for digest algorithm. */
    export type dnssec_digest_type = string | null;
    export interface dnssec_dnssec {
        algorithm?: Schemas.dnssec_algorithm;
        digest?: Schemas.dnssec_digest;
        digest_algorithm?: Schemas.dnssec_digest_algorithm;
        digest_type?: Schemas.dnssec_digest_type;
        dnssec_multi_signer?: Schemas.dnssec_dnssec_multi_signer;
        dnssec_presigned?: Schemas.dnssec_dnssec_presigned;
        ds?: Schemas.dnssec_ds;
        flags?: Schemas.dnssec_flags;
        key_tag?: Schemas.dnssec_key_tag;
        key_type?: Schemas.dnssec_key_type;
        modified_on?: Schemas.dnssec_modified_on;
        public_key?: Schemas.dnssec_public_key;
        status?: Schemas.dnssec_status;
    }
    /**
     * If true, multi-signer DNSSEC is enabled on the zone, allowing multiple
     * providers to serve a DNSSEC-signed zone at the same time.
     * This is required for DNSKEY records (except those automatically
     * generated by Cloudflare) to be added to the zone.
     *
     * See [Multi-signer DNSSEC](https://developers.cloudflare.com/dns/dnssec/multi-signer-dnssec/) for details.
     */
    export type dnssec_dnssec_multi_signer = boolean;
    /**
     * If true, allows Cloudflare to transfer in a DNSSEC-signed zone
     * including signatures from an external provider, without requiring
     * Cloudflare to sign any records on the fly.
     *
     * Note that this feature has some limitations.
     * See [Cloudflare as Secondary](https://developers.cloudflare.com/dns/zone-setups/zone-transfers/cloudflare-as-secondary/setup/#dnssec) for details.
     */
    export type dnssec_dnssec_presigned = boolean;
    export type dnssec_dnssec_response_single = Schemas.dnssec_api$response$single & {
        result?: Schemas.dnssec_dnssec;
    };
    /** Full DS record. */
    export type dnssec_ds = string | null;
    /** Flag for DNSSEC record. */
    export type dnssec_flags = number | null;
    /** Identifier */
    export type dnssec_identifier = string;
    /** Code for key tag. */
    export type dnssec_key_tag = number | null;
    /** Algorithm key type. */
    export type dnssec_key_type = string | null;
    export type dnssec_messages = {
        code: number;
        message: string;
    }[];
    /** When DNSSEC was last modified. */
    export type dnssec_modified_on = (Date) | null;
    /** Public key for DS record. */
    export type dnssec_public_key = string | null;
    /** Status of DNSSEC, based on user-desired state and presence of necessary records. */
    export type dnssec_status = "active" | "pending" | "disabled" | "pending-disabled" | "error";
    export type email_account_identifier = Schemas.email_identifier;
    export type email_addresses = Schemas.email_destination_address_properties;
    export type email_api$response$collection = Schemas.email_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.email_result_info;
    };
    export interface email_api$response$common {
        errors: Schemas.email_messages;
        messages: Schemas.email_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export type email_api$response$single = Schemas.email_api$response$common & {
        result?: {} | string;
    };
    export interface email_catch_all_rule {
        actions?: Schemas.email_rule_catchall$actions;
        enabled?: Schemas.email_rule_enabled;
        id?: Schemas.email_rule_identifier;
        matchers?: Schemas.email_rule_catchall$matchers;
        name?: Schemas.email_rule_name;
        tag?: Schemas.email_rule_tag;
    }
    export type email_catch_all_rule_response_single = Schemas.email_api$response$single & {
        result?: Schemas.email_catch_all_rule;
    };
    export interface email_create_destination_address_properties {
        email: Schemas.email_email;
    }
    export interface email_create_rule_properties {
        actions: Schemas.email_rule_actions;
        enabled?: Schemas.email_rule_enabled;
        matchers: Schemas.email_rule_matchers;
        name?: Schemas.email_rule_name;
        priority?: Schemas.email_rule_priority;
    }
    /** The date and time the destination address has been created. */
    export type email_created = Date;
    /** Destination address identifier. */
    export type email_destination_address_identifier = string;
    export interface email_destination_address_properties {
        created?: Schemas.email_created;
        email?: Schemas.email_email;
        id?: Schemas.email_destination_address_identifier;
        modified?: Schemas.email_modified;
        tag?: Schemas.email_destination_address_tag;
        verified?: Schemas.email_verified;
    }
    export type email_destination_address_response_single = Schemas.email_api$response$single & {
        result?: Schemas.email_addresses;
    };
    /** Destination address tag. (Deprecated, replaced by destination address identifier) */
    export type email_destination_address_tag = string;
    export type email_destination_addresses_response_collection = Schemas.email_api$response$collection & {
        result?: Schemas.email_addresses[];
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
        };
    };
    /** List of records needed to enable an Email Routing zone. */
    export interface email_dns_record {
        /** DNS record content. */
        content?: string;
        /** DNS record name (or @ for the zone apex). */
        name?: string;
        /** Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred. */
        priority?: number;
        /** Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'. */
        ttl?: number | (1);
        /** DNS record type. */
        readonly type?: "A" | "AAAA" | "CNAME" | "HTTPS" | "TXT" | "SRV" | "LOC" | "MX" | "NS" | "CERT" | "DNSKEY" | "DS" | "NAPTR" | "SMIMEA" | "SSHFP" | "SVCB" | "TLSA" | "URI";
    }
    export type email_dns_settings_response_collection = Schemas.email_api$response$collection & {
        result?: Schemas.email_dns_record[];
    };
    /** The contact email address of the user. */
    export type email_email = string;
    /** The date and time the settings have been created. */
    export type email_email_setting_created = Date;
    /** State of the zone settings for Email Routing. */
    export type email_email_setting_enabled = true | false;
    /** Email Routing settings identifier. */
    export type email_email_setting_identifier = string;
    /** The date and time the settings have been modified. */
    export type email_email_setting_modified = Date;
    /** Domain of your zone. */
    export type email_email_setting_name = string;
    /** Flag to check if the user skipped the configuration wizard. */
    export type email_email_setting_skip$wizard = true | false;
    /** Show the state of your account, and the type or configuration error. */
    export type email_email_setting_status = "ready" | "unconfigured" | "misconfigured" | "misconfigured/locked" | "unlocked";
    /** Email Routing settings tag. (Deprecated, replaced by Email Routing settings identifier) */
    export type email_email_setting_tag = string;
    export interface email_email_settings_properties {
        created?: Schemas.email_email_setting_created;
        enabled?: Schemas.email_email_setting_enabled;
        id?: Schemas.email_email_setting_identifier;
        modified?: Schemas.email_email_setting_modified;
        name?: Schemas.email_email_setting_name;
        skip_wizard?: Schemas.email_email_setting_skip$wizard;
        status?: Schemas.email_email_setting_status;
        tag?: Schemas.email_email_setting_tag;
    }
    export type email_email_settings_response_single = Schemas.email_api$response$single & {
        result?: Schemas.email_settings;
    };
    /** Identifier */
    export type email_identifier = string;
    export type email_messages = {
        code: number;
        message: string;
    }[];
    /** The date and time the destination address was last modified. */
    export type email_modified = Date;
    export interface email_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Actions pattern. */
    export interface email_rule_action {
        /** Type of supported action. */
        type: "drop" | "forward" | "worker";
        value: string[];
    }
    /** List actions patterns. */
    export type email_rule_actions = Schemas.email_rule_action[];
    /** Action for the catch-all routing rule. */
    export interface email_rule_catchall$action {
        /** Type of action for catch-all rule. */
        type: "drop" | "forward" | "worker";
        value?: string[];
    }
    /** List actions for the catch-all routing rule. */
    export type email_rule_catchall$actions = Schemas.email_rule_catchall$action[];
    /** Matcher for catch-all routing rule. */
    export interface email_rule_catchall$matcher {
        /** Type of matcher. Default is 'all'. */
        type: "all";
    }
    /** List of matchers for the catch-all routing rule. */
    export type email_rule_catchall$matchers = Schemas.email_rule_catchall$matcher[];
    /** Routing rule status. */
    export type email_rule_enabled = true | false;
    /** Routing rule identifier. */
    export type email_rule_identifier = string;
    /** Matching pattern to forward your actions. */
    export interface email_rule_matcher {
        /** Field for type matcher. */
        field: "to";
        /** Type of matcher. */
        type: "literal";
        /** Value for matcher. */
        value: string;
    }
    /** Matching patterns to forward to your actions. */
    export type email_rule_matchers = Schemas.email_rule_matcher[];
    /** Routing rule name. */
    export type email_rule_name = string;
    /** Priority of the routing rule. */
    export type email_rule_priority = number;
    export interface email_rule_properties {
        actions?: Schemas.email_rule_actions;
        enabled?: Schemas.email_rule_enabled;
        id?: Schemas.email_rule_identifier;
        matchers?: Schemas.email_rule_matchers;
        name?: Schemas.email_rule_name;
        priority?: Schemas.email_rule_priority;
        tag?: Schemas.email_rule_tag;
    }
    export type email_rule_response_single = Schemas.email_api$response$single & {
        result?: Schemas.email_rules;
    };
    /** Routing rule tag. (Deprecated, replaced by routing rule identifier) */
    export type email_rule_tag = string;
    export type email_rules = Schemas.email_rule_properties;
    export type email_rules_response_collection = Schemas.email_api$response$collection & {
        result?: Schemas.email_rules[];
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
        };
    };
    export type email_settings = Schemas.email_email_settings_properties;
    export interface email_update_catch_all_rule_properties {
        actions: Schemas.email_rule_catchall$actions;
        enabled?: Schemas.email_rule_enabled;
        matchers: Schemas.email_rule_catchall$matchers;
        name?: Schemas.email_rule_name;
    }
    export interface email_update_rule_properties {
        actions: Schemas.email_rule_actions;
        enabled?: Schemas.email_rule_enabled;
        matchers: Schemas.email_rule_matchers;
        name?: Schemas.email_rule_name;
        priority?: Schemas.email_rule_priority;
    }
    /** The date and time the destination address has been verified. Null means not verified yet. */
    export type email_verified = Date;
    export type email_zone_identifier = Schemas.email_identifier;
    export interface erIwb89A_api$response$common {
        errors: Schemas.erIwb89A_messages;
        messages: Schemas.erIwb89A_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface erIwb89A_api$response$common$failure {
        errors: Schemas.erIwb89A_messages;
        messages: Schemas.erIwb89A_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type erIwb89A_api$response$single = Schemas.erIwb89A_api$response$common & {
        result?: {} | string;
    };
    /** Array with one row per combination of dimension values. */
    export type erIwb89A_data = {
        /** Array of dimension values, representing the combination of dimension values corresponding to this row. */
        dimensions: string[];
    }[];
    /** A comma-separated list of dimensions to group results by. */
    export type erIwb89A_dimensions = string;
    /** Segmentation filter in 'attribute operator value' format. */
    export type erIwb89A_filters = string;
    /** Identifier */
    export type erIwb89A_identifier = string;
    /** Limit number of returned metrics. */
    export type erIwb89A_limit = number;
    export type erIwb89A_messages = {
        code: number;
        message: string;
    }[];
    /** A comma-separated list of metrics to query. */
    export type erIwb89A_metrics = string;
    export interface erIwb89A_query {
        /** Array of dimension names. */
        dimensions: string[];
        filters?: Schemas.erIwb89A_filters;
        limit: Schemas.erIwb89A_limit;
        /** Array of metric names. */
        metrics: string[];
        since: Schemas.erIwb89A_since;
        /** Array of dimensions to sort by, where each dimension may be prefixed by - (descending) or + (ascending). */
        sort?: string[];
        until: Schemas.erIwb89A_until;
    }
    export type erIwb89A_report = Schemas.erIwb89A_result & {
        data: {
            /** Array with one item per requested metric. Each item is a single value. */
            metrics: number[];
        }[];
    };
    export type erIwb89A_report_bytime = Schemas.erIwb89A_result & {
        data: {
            /** Array with one item per requested metric. Each item is an array of values, broken down by time interval. */
            metrics: {}[][];
        }[];
        query: {
            time_delta: Schemas.erIwb89A_time_delta;
        };
        /** Array of time intervals in the response data. Each interval is represented as an array containing two values: the start time, and the end time. */
        time_intervals: (Date)[][];
    };
    export interface erIwb89A_result {
        data: Schemas.erIwb89A_data;
        /** Number of seconds between current time and last processed event, in another words how many seconds of data could be missing. */
        data_lag: number;
        /** Maximum results for each metric (object mapping metric names to values). Currently always an empty object. */
        max: {};
        /** Minimum results for each metric (object mapping metric names to values). Currently always an empty object. */
        min: {};
        query: Schemas.erIwb89A_query;
        /** Total number of rows in the result. */
        rows: number;
        /** Total results for metrics across all data (object mapping metric names to values). */
        totals: {};
    }
    /** Start date and time of requesting data period in ISO 8601 format. */
    export type erIwb89A_since = Date;
    /** A comma-separated list of dimensions to sort by, where each dimension may be prefixed by - (descending) or + (ascending). */
    export type erIwb89A_sort = string;
    /** Unit of time to group data by. */
    export type erIwb89A_time_delta = "all" | "auto" | "year" | "quarter" | "month" | "week" | "day" | "hour" | "dekaminute" | "minute";
    /** End date and time of requesting data period in ISO 8601 format. */
    export type erIwb89A_until = Date;
    export interface grwMffPV_api$response$common {
        errors: Schemas.grwMffPV_messages;
        messages: Schemas.grwMffPV_messages;
        /** Whether the API call was successful */
        success: boolean;
    }
    export interface grwMffPV_api$response$common$failure {
        errors: Schemas.grwMffPV_messages;
        messages: Schemas.grwMffPV_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: boolean;
    }
    /**
     * If bot_fight_mode is set to \`true\`, Cloudflare issues computationally
     * expensive challenges in response to malicious bots (ENT only).
     */
    export type grwMffPV_bot_fight_mode = boolean;
    /**
     * If Turnstile is embedded on a Cloudflare site and the widget should grant challenge clearance,
     * this setting can determine the clearance level to be set
     */
    export type grwMffPV_clearance_level = "no_clearance" | "jschallenge" | "managed" | "interactive";
    /** When the widget was created. */
    export type grwMffPV_created_on = Date;
    export type grwMffPV_domains = string[];
    /** Identifier */
    export type grwMffPV_identifier = string;
    /**
     * If \`invalidate_immediately\` is set to \`false\`, the previous secret will
     * remain valid for two hours. Otherwise, the secret is immediately
     * invalidated, and requests using it will be rejected.
     */
    export type grwMffPV_invalidate_immediately = boolean;
    export type grwMffPV_messages = {
        code: number;
        message: string;
    }[];
    /** Widget Mode */
    export type grwMffPV_mode = "non-interactive" | "invisible" | "managed";
    /** When the widget was modified. */
    export type grwMffPV_modified_on = Date;
    /**
     * Human readable widget name. Not unique. Cloudflare suggests that you
     * set this to a meaningful string to make it easier to identify your
     * widget, and where it is used.
     */
    export type grwMffPV_name = string;
    /** Do not show any Cloudflare branding on the widget (ENT only). */
    export type grwMffPV_offlabel = boolean;
    /** Region where this widget can be used. */
    export type grwMffPV_region = "world";
    export interface grwMffPV_result_info {
        /** Total number of results for the requested service */
        count: number;
        /** Current page within paginated list of results */
        page: number;
        /** Number of results per page of results */
        per_page: number;
        /** Total results available without any search parameters */
        total_count: number;
    }
    /** Secret key for this widget. */
    export type grwMffPV_secret = string;
    /** Widget item identifier tag. */
    export type grwMffPV_sitekey = string;
    /** A Turnstile widget's detailed configuration */
    export interface grwMffPV_widget_detail {
        bot_fight_mode: Schemas.grwMffPV_bot_fight_mode;
        clearance_level: Schemas.grwMffPV_clearance_level;
        created_on: Schemas.grwMffPV_created_on;
        domains: Schemas.grwMffPV_domains;
        mode: Schemas.grwMffPV_mode;
        modified_on: Schemas.grwMffPV_modified_on;
        name: Schemas.grwMffPV_name;
        offlabel: Schemas.grwMffPV_offlabel;
        region: Schemas.grwMffPV_region;
        secret: Schemas.grwMffPV_secret;
        sitekey: Schemas.grwMffPV_sitekey;
    }
    /** A Turnstile Widgets configuration as it appears in listings */
    export interface grwMffPV_widget_list {
        bot_fight_mode: Schemas.grwMffPV_bot_fight_mode;
        clearance_level: Schemas.grwMffPV_clearance_level;
        created_on: Schemas.grwMffPV_created_on;
        domains: Schemas.grwMffPV_domains;
        mode: Schemas.grwMffPV_mode;
        modified_on: Schemas.grwMffPV_modified_on;
        name: Schemas.grwMffPV_name;
        offlabel: Schemas.grwMffPV_offlabel;
        region: Schemas.grwMffPV_region;
        sitekey: Schemas.grwMffPV_sitekey;
    }
    /** The hostname or IP address of the origin server to run health checks on. */
    export type healthchecks_address = string;
    export type healthchecks_api$response$collection = Schemas.healthchecks_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.healthchecks_result_info;
    };
    export interface healthchecks_api$response$common {
        errors: Schemas.healthchecks_messages;
        messages: Schemas.healthchecks_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface healthchecks_api$response$common$failure {
        errors: Schemas.healthchecks_messages;
        messages: Schemas.healthchecks_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type healthchecks_api$response$single = Schemas.healthchecks_api$response$common & {
        result?: {} | string;
    };
    /** A list of regions from which to run health checks. Null means Cloudflare will pick a default region. */
    export type healthchecks_check_regions = ("WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "IN" | "SEAS" | "NEAS" | "ALL_REGIONS")[] | null;
    /** The number of consecutive fails required from a health check before changing the health to unhealthy. */
    export type healthchecks_consecutive_fails = number;
    /** The number of consecutive successes required from a health check before changing the health to healthy. */
    export type healthchecks_consecutive_successes = number;
    /** A human-readable description of the health check. */
    export type healthchecks_description = string;
    /** The current failure reason if status is unhealthy. */
    export type healthchecks_failure_reason = string;
    export interface healthchecks_healthchecks {
        address?: Schemas.healthchecks_address;
        check_regions?: Schemas.healthchecks_check_regions;
        consecutive_fails?: Schemas.healthchecks_consecutive_fails;
        consecutive_successes?: Schemas.healthchecks_consecutive_successes;
        created_on?: Schemas.healthchecks_timestamp;
        description?: Schemas.healthchecks_description;
        failure_reason?: Schemas.healthchecks_failure_reason;
        http_config?: Schemas.healthchecks_http_config;
        id?: Schemas.healthchecks_identifier;
        interval?: Schemas.healthchecks_interval;
        modified_on?: Schemas.healthchecks_timestamp;
        name?: Schemas.healthchecks_name;
        retries?: Schemas.healthchecks_retries;
        status?: Schemas.healthchecks_status;
        suspended?: Schemas.healthchecks_suspended;
        tcp_config?: Schemas.healthchecks_tcp_config;
        timeout?: Schemas.healthchecks_timeout;
        type?: Schemas.healthchecks_type;
    }
    /** Parameters specific to an HTTP or HTTPS health check. */
    export type healthchecks_http_config = {
        /** Do not validate the certificate when the health check uses HTTPS. */
        allow_insecure?: boolean;
        /** A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. */
        expected_body?: string;
        /** The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check. */
        expected_codes?: string[] | null;
        /** Follow redirects if the origin returns a 3xx status code. */
        follow_redirects?: boolean;
        /** The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. */
        header?: {} | null;
        /** The HTTP method to use for the health check. */
        method?: "GET" | "HEAD";
        /** The endpoint path to health check against. */
        path?: string;
        /** Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS. */
        port?: number;
    } | null;
    export type healthchecks_id_response = Schemas.healthchecks_api$response$single & {
        result?: {
            id?: Schemas.healthchecks_identifier;
        };
    };
    /** Identifier */
    export type healthchecks_identifier = string;
    /** The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations. */
    export type healthchecks_interval = number;
    export type healthchecks_messages = {
        code: number;
        message: string;
    }[];
    /** A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed. */
    export type healthchecks_name = string;
    export interface healthchecks_query_healthcheck {
        address: Schemas.healthchecks_address;
        check_regions?: Schemas.healthchecks_check_regions;
        consecutive_fails?: Schemas.healthchecks_consecutive_fails;
        consecutive_successes?: Schemas.healthchecks_consecutive_successes;
        description?: Schemas.healthchecks_description;
        http_config?: Schemas.healthchecks_http_config;
        interval?: Schemas.healthchecks_interval;
        name: Schemas.healthchecks_name;
        retries?: Schemas.healthchecks_retries;
        suspended?: Schemas.healthchecks_suspended;
        tcp_config?: Schemas.healthchecks_tcp_config;
        timeout?: Schemas.healthchecks_timeout;
        type?: Schemas.healthchecks_type;
    }
    export type healthchecks_response_collection = Schemas.healthchecks_api$response$collection & {
        result?: Schemas.healthchecks_healthchecks[];
    };
    export interface healthchecks_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. */
    export type healthchecks_retries = number;
    export type healthchecks_single_response = Schemas.healthchecks_api$response$single & {
        result?: Schemas.healthchecks_healthchecks;
    };
    /** The current status of the origin server according to the health check. */
    export type healthchecks_status = "unknown" | "healthy" | "unhealthy" | "suspended";
    /** If suspended, no health checks are sent to the origin. */
    export type healthchecks_suspended = boolean;
    /** Parameters specific to TCP health check. */
    export type healthchecks_tcp_config = {
        /** The TCP connection method to use for the health check. */
        method?: "connection_established";
        /** Port number to connect to for the health check. Defaults to 80. */
        port?: number;
    } | null;
    /** The timeout (in seconds) before marking the health check as failed. */
    export type healthchecks_timeout = number;
    export type healthchecks_timestamp = Date;
    /** The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'. */
    export type healthchecks_type = string;
    export type hyperdrive_api$response$collection = Schemas.hyperdrive_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.hyperdrive_result_info;
    };
    export interface hyperdrive_api$response$common {
        errors: Schemas.hyperdrive_messages;
        messages: Schemas.hyperdrive_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface hyperdrive_api$response$common$failure {
        errors: Schemas.hyperdrive_messages;
        messages: Schemas.hyperdrive_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type hyperdrive_api$response$single = Schemas.hyperdrive_api$response$common & {
        result?: ({} | string) | null;
    };
    export interface hyperdrive_hyperdrive {
        caching?: Schemas.hyperdrive_hyperdrive$caching;
        name: Schemas.hyperdrive_hyperdrive$name;
        origin: Schemas.hyperdrive_hyperdrive$origin & {
            host: any;
            port: any;
        };
    }
    export interface hyperdrive_hyperdrive$caching {
        /** When set to true, disables the caching of SQL responses. (Default: false) */
        disabled?: boolean;
        /** When present, specifies max duration for which items should persist in the cache. (Default: 60) */
        max_age?: number;
        /** When present, indicates the number of seconds cache may serve the response after it becomes stale. (Default: 15) */
        stale_while_revalidate?: number;
    }
    export type hyperdrive_hyperdrive$name = string;
    export interface hyperdrive_hyperdrive$origin {
        /** The name of your origin database. */
        database?: string;
        /** The host (hostname or IP) of your origin database. */
        host?: string;
        /** The port (default: 5432 for Postgres) of your origin database. */
        port?: number;
        scheme?: Schemas.hyperdrive_hyperdrive$scheme;
        /** The user of your origin database. */
        user?: string;
    }
    /** Specifies the URL scheme used to connect to your origin database. */
    export type hyperdrive_hyperdrive$scheme = "postgres" | "postgresql";
    export type hyperdrive_hyperdrive$with$identifier = Schemas.hyperdrive_hyperdrive;
    export type hyperdrive_hyperdrive$with$password = Schemas.hyperdrive_hyperdrive;
    /** Identifier */
    export type hyperdrive_identifier = string;
    export type hyperdrive_messages = {
        code: number;
        message: string;
    }[];
    export interface hyperdrive_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Account identifier tag. */
    export type images_account_identifier = string;
    export type images_api$response$collection$v2 = Schemas.images_api$response$common & {
        result?: {
            continuation_token?: Schemas.images_images_list_continuation_token;
        };
    };
    export interface images_api$response$common {
        errors: Schemas.images_messages;
        messages: Schemas.images_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface images_api$response$common$failure {
        errors: Schemas.images_messages;
        messages: Schemas.images_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type images_api$response$single = Schemas.images_api$response$common & {
        result?: {} | string;
    };
    export type images_deleted_response = Schemas.images_api$response$single & {
        result?: {};
    };
    export interface images_image {
        filename?: Schemas.images_image_filename;
        id?: Schemas.images_image_identifier;
        meta?: Schemas.images_image_metadata;
        requireSignedURLs?: Schemas.images_image_requireSignedURLs;
        uploaded?: Schemas.images_image_uploaded;
        variants?: Schemas.images_image_variants;
    }
    export type images_image_basic_upload = Schemas.images_image_upload_via_file | Schemas.images_image_upload_via_url;
    export interface images_image_direct_upload_request_v2 {
        /** The date after which the upload will not be accepted. Minimum: Now + 2 minutes. Maximum: Now + 6 hours. */
        expiry?: Date;
        /** Optional Image Custom ID. Up to 1024 chars. Can include any number of subpaths, and utf8 characters. Cannot start nor end with a / (forward slash). Cannot be a UUID. */
        readonly id?: string;
        /** User modifiable key-value store. Can be used for keeping references to another system of record, for managing images. */
        metadata?: {};
        /** Indicates whether the image requires a signature token to be accessed. */
        requireSignedURLs?: boolean;
    }
    export type images_image_direct_upload_response_v2 = Schemas.images_api$response$single & {
        result?: {
            /** Image unique identifier. */
            readonly id?: string;
            /** The URL the unauthenticated upload can be performed to using a single HTTP POST (multipart/form-data) request. */
            uploadURL?: string;
        };
    };
    /** Image file name. */
    export type images_image_filename = string;
    /** URI to hero variant for an image. */
    export type images_image_hero_url = string;
    /** Image unique identifier. */
    export type images_image_identifier = string;
    /** Key name. */
    export type images_image_key_name = string;
    export type images_image_key_response_collection = Schemas.images_api$response$common & {
        result?: Schemas.images_image_keys_response;
    };
    /** Key value. */
    export type images_image_key_value = string;
    export interface images_image_keys {
        name?: Schemas.images_image_key_name;
        value?: Schemas.images_image_key_value;
    }
    export interface images_image_keys_response {
        keys?: Schemas.images_image_keys[];
    }
    /** User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes. */
    export interface images_image_metadata {
    }
    /** URI to original variant for an image. */
    export type images_image_original_url = string;
    export interface images_image_patch_request {
        /** User modifiable key-value store. Can be used for keeping references to another system of record for managing images. No change if not specified. */
        metadata?: {};
        /** Indicates whether the image can be accessed using only its UID. If set to \`true\`, a signed token needs to be generated with a signing key to view the image. Returns a new UID on a change. No change if not specified. */
        requireSignedURLs?: boolean;
    }
    /** Indicates whether the image can be a accessed only using it's UID. If set to true, a signed token needs to be generated with a signing key to view the image. */
    export type images_image_requireSignedURLs = boolean;
    export type images_image_response_blob = string | {};
    export type images_image_response_single = Schemas.images_api$response$single & {
        result?: Schemas.images_image;
    };
    /** URI to thumbnail variant for an image. */
    export type images_image_thumbnail_url = string;
    export interface images_image_upload_via_file {
        /** An image binary data. */
        file: any;
    }
    export interface images_image_upload_via_url {
        /** A URL to fetch an image from origin. */
        url: string;
    }
    /** When the media item was uploaded. */
    export type images_image_uploaded = Date;
    export interface images_image_variant_definition {
        id: Schemas.images_image_variant_identifier;
        neverRequireSignedURLs?: Schemas.images_image_variant_neverRequireSignedURLs;
        options: Schemas.images_image_variant_options;
    }
    /** The fit property describes how the width and height dimensions should be interpreted. */
    export type images_image_variant_fit = "scale-down" | "contain" | "cover" | "crop" | "pad";
    /** Maximum height in image pixels. */
    export type images_image_variant_height = number;
    export type images_image_variant_identifier = any;
    export type images_image_variant_list_response = Schemas.images_api$response$common & {
        result?: Schemas.images_image_variants_response;
    };
    /** Indicates whether the variant can access an image without a signature, regardless of image access control. */
    export type images_image_variant_neverRequireSignedURLs = boolean;
    /** Allows you to define image resizing sizes for different use cases. */
    export interface images_image_variant_options {
        fit: Schemas.images_image_variant_fit;
        height: Schemas.images_image_variant_height;
        metadata: Schemas.images_image_variant_schemas_metadata;
        width: Schemas.images_image_variant_width;
    }
    export interface images_image_variant_patch_request {
        neverRequireSignedURLs?: Schemas.images_image_variant_neverRequireSignedURLs;
        options: Schemas.images_image_variant_options;
    }
    export interface images_image_variant_public_request {
        hero?: {
            id: Schemas.images_image_variant_identifier;
            neverRequireSignedURLs?: Schemas.images_image_variant_neverRequireSignedURLs;
            options: Schemas.images_image_variant_options;
        };
    }
    export interface images_image_variant_response {
        variant?: Schemas.images_image_variant_definition;
    }
    /** What EXIF data should be preserved in the output image. */
    export type images_image_variant_schemas_metadata = "keep" | "copyright" | "none";
    export type images_image_variant_simple_response = Schemas.images_api$response$single & {
        result?: Schemas.images_image_variant_response;
    };
    /** Maximum width in image pixels. */
    export type images_image_variant_width = number;
    /** Object specifying available variants for an image. */
    export type images_image_variants = (Schemas.images_image_thumbnail_url | Schemas.images_image_hero_url | Schemas.images_image_original_url)[];
    export interface images_image_variants_response {
        variants?: Schemas.images_image_variant_public_request;
    }
    /** Continuation token to fetch next page. Passed as a query param when requesting List V2 api endpoint. */
    export type images_images_list_continuation_token = string | null;
    export type images_images_list_response = Schemas.images_api$response$common & {
        result?: {
            images?: Schemas.images_image[];
        };
    };
    export type images_images_list_response_v2 = Schemas.images_api$response$collection$v2 & {
        result?: {
            images?: Schemas.images_image[];
        };
    };
    export interface images_images_stats {
        count?: Schemas.images_images_stats_count;
    }
    /** Cloudflare Images allowed usage. */
    export type images_images_stats_allowed = number;
    export interface images_images_stats_count {
        allowed?: Schemas.images_images_stats_allowed;
        current?: Schemas.images_images_stats_current;
    }
    /** Cloudflare Images current usage. */
    export type images_images_stats_current = number;
    export type images_images_stats_response = Schemas.images_api$response$single & {
        result?: Schemas.images_images_stats;
    };
    export type images_messages = {
        code: number;
        message: string;
    }[];
    /** Additional information related to the host name. */
    export interface intel_additional_information {
        /** Suspected DGA malware family. */
        suspected_malware_family?: string;
    }
    export type intel_api$response$collection = Schemas.intel_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.intel_result_info;
    };
    export interface intel_api$response$common {
        errors: Schemas.intel_messages;
        messages: Schemas.intel_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface intel_api$response$common$failure {
        errors: Schemas.intel_messages;
        messages: Schemas.intel_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type intel_api$response$single = Schemas.intel_api$response$common & {
        result?: {} | string;
    };
    /** Application that the hostname belongs to. */
    export interface intel_application {
        id?: number;
        name?: string;
    }
    export type intel_asn = number;
    export type intel_asn_components$schemas$response = Schemas.intel_api$response$single & {
        result?: Schemas.intel_asn;
    };
    export type intel_asn_country = string;
    export type intel_asn_description = string;
    /** Infrastructure type of this ASN. */
    export type intel_asn_type = "hosting_provider" | "isp" | "organization";
    export type intel_categories_with_super_category_ids_example_empty = Schemas.intel_category_with_super_category_id[];
    export interface intel_category_with_super_category_id {
        id?: number;
        name?: string;
        super_category_id?: number;
    }
    export type intel_collection_response = Schemas.intel_api$response$collection & {
        result?: {
            additional_information?: Schemas.intel_additional_information;
            application?: Schemas.intel_application;
            content_categories?: Schemas.intel_content_categories;
            domain?: Schemas.intel_domain_name;
            inherited_content_categories?: Schemas.intel_inherited_content_categories;
            inherited_from?: Schemas.intel_inherited_from;
            inherited_risk_types?: Schemas.intel_inherited_risk_types;
            popularity_rank?: Schemas.intel_popularity_rank;
            risk_score?: Schemas.intel_risk_score;
            risk_types?: Schemas.intel_risk_types;
        }[];
    };
    export type intel_components$schemas$response = Schemas.intel_api$response$collection & {
        result?: Schemas.intel_ip$list[];
    };
    export type intel_components$schemas$single_response = Schemas.intel_api$response$single & {
        result?: Schemas.intel_passive$dns$by$ip;
    };
    /** Current content categories. */
    export type intel_content_categories = any;
    /** Total results returned based on your search parameters. */
    export type intel_count = number;
    export interface intel_domain {
        additional_information?: Schemas.intel_additional_information;
        application?: Schemas.intel_application;
        content_categories?: Schemas.intel_content_categories;
        domain?: Schemas.intel_domain_name;
        inherited_content_categories?: Schemas.intel_inherited_content_categories;
        inherited_from?: Schemas.intel_inherited_from;
        inherited_risk_types?: Schemas.intel_inherited_risk_types;
        popularity_rank?: Schemas.intel_popularity_rank;
        resolves_to_refs?: Schemas.intel_resolves_to_refs;
        risk_score?: Schemas.intel_risk_score;
        risk_types?: Schemas.intel_risk_types;
    }
    export interface intel_domain$history {
        categorizations?: {
            categories?: any;
            end?: string;
            start?: string;
        }[];
        domain?: Schemas.intel_domain_name;
    }
    export type intel_domain_name = string;
    /** Identifier */
    export type intel_identifier = string;
    export type intel_inherited_content_categories = Schemas.intel_categories_with_super_category_ids_example_empty;
    /** Domain from which \`inherited_content_categories\` and \`inherited_risk_types\` are inherited, if applicable. */
    export type intel_inherited_from = string;
    export type intel_inherited_risk_types = Schemas.intel_categories_with_super_category_ids_example_empty;
    export type intel_ip = Schemas.intel_ipv4 | Schemas.intel_ipv6;
    export interface intel_ip$list {
        description?: string;
        id?: number;
        name?: string;
    }
    export type intel_ipv4 = string;
    export type intel_ipv6 = string;
    export type intel_messages = {
        code: number;
        message: string;
    }[];
    export interface intel_miscategorization {
        /** Content category IDs to add. */
        content_adds?: any;
        /** Content category IDs to remove. */
        content_removes?: any;
        indicator_type?: "domain" | "ipv4" | "ipv6" | "url";
        /** Provide only if indicator_type is \`ipv4\` or \`ipv6\`. */
        ip?: any;
        /** Security category IDs to add. */
        security_adds?: any;
        /** Security category IDs to remove. */
        security_removes?: any;
        /** Provide only if indicator_type is \`domain\` or \`url\`. Example if indicator_type is \`domain\`: \`example.com\`. Example if indicator_type is \`url\`: \`https://example.com/news/\`. */
        url?: string;
    }
    /** Current page within paginated list of results. */
    export type intel_page = number;
    export interface intel_passive$dns$by$ip {
        /** Total results returned based on your search parameters. */
        count?: number;
        /** Current page within paginated list of results. */
        page?: number;
        /** Number of results per page of results. */
        per_page?: number;
        /** Reverse DNS look-ups observed during the time period. */
        reverse_records?: {
            /** First seen date of the DNS record during the time period. */
            first_seen?: string;
            /** Hostname that the IP was observed resolving to. */
            hostname?: any;
            /** Last seen date of the DNS record during the time period. */
            last_seen?: string;
        }[];
    }
    /** Number of results per page of results. */
    export type intel_per_page = number;
    export interface intel_phishing$url$info {
        /** List of categorizations applied to this submission. */
        categorizations?: {
            /** Name of the category applied. */
            category?: string;
            /** Result of human review for this categorization. */
            verification_status?: string;
        }[];
        /** List of model results for completed scans. */
        model_results?: {
            /** Name of the model. */
            model_name?: string;
            /** Score output by the model for this submission. */
            model_score?: number;
        }[];
        /** List of signatures that matched against site content found when crawling the URL. */
        rule_matches?: {
            /** For internal use. */
            banning?: boolean;
            /** For internal use. */
            blocking?: boolean;
            /** Description of the signature that matched. */
            description?: string;
            /** Name of the signature that matched. */
            name?: string;
        }[];
        /** Status of the most recent scan found. */
        scan_status?: {
            /** Timestamp of when the submission was processed. */
            last_processed?: string;
            /** For internal use. */
            scan_complete?: boolean;
            /** Status code that the crawler received when loading the submitted URL. */
            status_code?: number;
            /** ID of the most recent submission. */
            submission_id?: number;
        };
        /** For internal use. */
        screenshot_download_signature?: string;
        /** For internal use. */
        screenshot_path?: string;
        /** URL that was submitted. */
        url?: string;
    }
    export type intel_phishing$url$info_components$schemas$single_response = Schemas.intel_api$response$single & {
        result?: Schemas.intel_phishing$url$info;
    };
    export interface intel_phishing$url$submit {
        /** URLs that were excluded from scanning because their domain is in our no-scan list. */
        excluded_urls?: {
            /** URL that was excluded. */
            url?: string;
        }[];
        /** URLs that were skipped because the same URL is currently being scanned */
        skipped_urls?: {
            /** URL that was skipped. */
            url?: string;
            /** ID of the submission of that URL that is currently scanning. */
            url_id?: number;
        }[];
        /** URLs that were successfully submitted for scanning. */
        submitted_urls?: {
            /** URL that was submitted. */
            url?: string;
            /** ID assigned to this URL submission. Used to retrieve scanning results. */
            url_id?: number;
        }[];
    }
    export type intel_phishing$url$submit_components$schemas$single_response = Schemas.intel_api$response$single & {
        result?: Schemas.intel_phishing$url$submit;
    };
    /** Global Cloudflare 100k ranking for the last 30 days, if available for the hostname. The top ranked domain is 1, the lowest ranked domain is 100,000. */
    export type intel_popularity_rank = number;
    export interface intel_resolves_to_ref {
        id?: Schemas.intel_stix_identifier;
        /** IP address or domain name. */
        value?: string;
    }
    /** Specifies a list of references to one or more IP addresses or domain names that the domain name currently resolves to. */
    export type intel_resolves_to_refs = Schemas.intel_resolves_to_ref[];
    export type intel_response = Schemas.intel_api$response$collection & {
        result?: Schemas.intel_domain$history[];
    };
    export interface intel_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Hostname risk score, which is a value between 0 (lowest risk) to 1 (highest risk). */
    export type intel_risk_score = number;
    export type intel_risk_types = any;
    export interface intel_schemas$asn {
        asn?: Schemas.intel_asn;
        country?: Schemas.intel_asn_country;
        description?: Schemas.intel_asn_description;
        domain_count?: number;
        top_domains?: string[];
        type?: Schemas.intel_asn_type;
    }
    export interface intel_schemas$ip {
        /** Specifies a reference to the autonomous systems (AS) that the IP address belongs to. */
        belongs_to_ref?: {
            country?: string;
            description?: string;
            id?: any;
            /** Infrastructure type of this ASN. */
            type?: "hosting_provider" | "isp" | "organization";
            value?: string;
        };
        ip?: Schemas.intel_ip;
        risk_types?: any;
    }
    export type intel_schemas$response = Schemas.intel_api$response$collection & {
        result?: Schemas.intel_schemas$ip[];
    };
    export type intel_schemas$single_response = Schemas.intel_api$response$single & {
        result?: Schemas.intel_whois;
    };
    export type intel_single_response = Schemas.intel_api$response$single & {
        result?: Schemas.intel_domain;
    };
    export interface intel_start_end_params {
        /** Defaults to the current date. */
        end?: string;
        /** Defaults to 30 days before the end parameter value. */
        start?: string;
    }
    /** STIX 2.1 identifier: https://docs.oasis-open.org/cti/stix/v2.1/cs02/stix-v2.1-cs02.html#_64yvzeku5a5c */
    export type intel_stix_identifier = string;
    /** URL(s) to filter submissions results by */
    export type intel_url = string;
    /** Submission ID(s) to filter submission results by. */
    export type intel_url_id = number;
    export interface intel_url_id_param {
        url_id?: Schemas.intel_url_id;
    }
    export interface intel_url_param {
        url?: Schemas.intel_url;
    }
    export interface intel_whois {
        created_date?: string;
        domain?: Schemas.intel_domain_name;
        nameservers?: string[];
        registrant?: string;
        registrant_country?: string;
        registrant_email?: string;
        registrant_org?: string;
        registrar?: string;
        updated_date?: string;
    }
    export interface lSaKXx3s_api$response$common {
        errors: Schemas.lSaKXx3s_messages;
        messages: Schemas.lSaKXx3s_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface lSaKXx3s_api$response$common$failure {
        errors: Schemas.lSaKXx3s_messages;
        messages: Schemas.lSaKXx3s_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type lSaKXx3s_api$response$single = Schemas.lSaKXx3s_api$response$common & {
        result?: {} | string;
    };
    export interface lSaKXx3s_create_feed {
        description?: Schemas.lSaKXx3s_description;
        name?: Schemas.lSaKXx3s_name;
    }
    export type lSaKXx3s_create_feed_response = Schemas.lSaKXx3s_api$response$single & {
        result?: Schemas.lSaKXx3s_indicator_feed_item;
    };
    /** The description of the example test */
    export type lSaKXx3s_description = string;
    /** Indicator feed ID */
    export type lSaKXx3s_feed_id = number;
    /** The unique identifier for the indicator feed */
    export type lSaKXx3s_id = number;
    /** Identifier */
    export type lSaKXx3s_identifier = string;
    export interface lSaKXx3s_indicator_feed_item {
        /** The date and time when the data entry was created */
        created_on?: Date;
        description?: Schemas.lSaKXx3s_description;
        id?: Schemas.lSaKXx3s_id;
        /** The date and time when the data entry was last modified */
        modified_on?: Date;
        name?: Schemas.lSaKXx3s_name;
    }
    export interface lSaKXx3s_indicator_feed_metadata {
        /** The date and time when the data entry was created */
        created_on?: Date;
        description?: Schemas.lSaKXx3s_description;
        id?: Schemas.lSaKXx3s_id;
        /** Status of the latest snapshot uploaded */
        latest_upload_status?: "Mirroring" | "Unifying" | "Loading" | "Provisioning" | "Complete" | "Error";
        /** The date and time when the data entry was last modified */
        modified_on?: Date;
        name?: Schemas.lSaKXx3s_name;
    }
    export type lSaKXx3s_indicator_feed_metadata_response = Schemas.lSaKXx3s_api$response$single & {
        result?: Schemas.lSaKXx3s_indicator_feed_metadata;
    };
    export type lSaKXx3s_indicator_feed_response = Schemas.lSaKXx3s_api$response$common & {
        result?: Schemas.lSaKXx3s_indicator_feed_item[];
    };
    export type lSaKXx3s_indicator_feed_response_single = Schemas.lSaKXx3s_api$response$single & {
        result?: Schemas.lSaKXx3s_indicator_feed_item;
    };
    export type lSaKXx3s_messages = {
        code: number;
        message: string;
    }[];
    /** The name of the indicator feed */
    export type lSaKXx3s_name = string;
    export interface lSaKXx3s_permission_list_item {
        description?: Schemas.lSaKXx3s_description;
        id?: Schemas.lSaKXx3s_id;
        name?: Schemas.lSaKXx3s_name;
    }
    export type lSaKXx3s_permission_list_item_response = Schemas.lSaKXx3s_api$response$common & {
        result?: Schemas.lSaKXx3s_permission_list_item[];
    };
    export interface lSaKXx3s_permissions$request {
        /** The Cloudflare account tag of the account to change permissions on */
        account_tag?: string;
        /** The ID of the feed to add/remove permissions on */
        feed_id?: number;
    }
    export type lSaKXx3s_permissions_response = Schemas.lSaKXx3s_api$response$single & {
        result?: Schemas.lSaKXx3s_permissions_update;
    };
    export interface lSaKXx3s_permissions_update {
        /** Whether the update succeeded or not */
        success?: boolean;
    }
    export interface lSaKXx3s_update_feed {
        /** Feed id */
        file_id?: number;
        /** Name of the file unified in our system */
        filename?: string;
        /** Current status of upload, should be unified */
        status?: string;
    }
    export type lSaKXx3s_update_feed_response = Schemas.lSaKXx3s_api$response$single & {
        result?: Schemas.lSaKXx3s_update_feed;
    };
    /** The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin. */
    export type legacy$jhs_Host = string[];
    export type legacy$jhs_access$policy = Schemas.legacy$jhs_policy_with_permission_groups;
    export interface legacy$jhs_access$requests {
        action?: Schemas.legacy$jhs_access$requests_components$schemas$action;
        allowed?: Schemas.legacy$jhs_schemas$allowed;
        app_domain?: Schemas.legacy$jhs_app_domain;
        app_uid?: Schemas.legacy$jhs_app_uid;
        connection?: Schemas.legacy$jhs_schemas$connection;
        created_at?: Schemas.legacy$jhs_timestamp;
        ip_address?: Schemas.legacy$jhs_schemas$ip;
        ray_id?: Schemas.legacy$jhs_ray_id;
        user_email?: Schemas.legacy$jhs_schemas$email;
    }
    /** The event that occurred, such as a login attempt. */
    export type legacy$jhs_access$requests_components$schemas$action = string;
    export type legacy$jhs_access$requests_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_access$requests[];
    };
    /** Matches an Access group. */
    export interface legacy$jhs_access_group_rule {
        group: {
            /** The ID of a previously created Access group. */
            id: string;
        };
    }
    export type legacy$jhs_account$settings$response = Schemas.legacy$jhs_api$response$common & {
        result?: {
            readonly default_usage_model?: any;
            readonly green_compute?: any;
        };
    };
    export type legacy$jhs_account_identifier = any;
    export type legacy$jhs_account_subscription_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_subscription[];
    };
    export type legacy$jhs_account_subscription_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** The billing item action. */
    export type legacy$jhs_action = string;
    /** The default action performed by the rules in the WAF package. */
    export type legacy$jhs_action_mode = "simulate" | "block" | "challenge";
    /** The parameters configuring the rule action. */
    export interface legacy$jhs_action_parameters {
    }
    /** Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin. */
    export interface legacy$jhs_adaptive_routing {
        /** Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See \`session_affinity_attributes\` for control over when sessions are broken or reassigned. */
        failover_across_pools?: boolean;
    }
    /** Additional information related to the host name. */
    export interface legacy$jhs_additional_information {
        /** Suspected DGA malware family. */
        suspected_malware_family?: string;
    }
    /** The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual_network_id must also be set. */
    export type legacy$jhs_address = string;
    export interface legacy$jhs_address$maps {
        can_delete?: Schemas.legacy$jhs_can_delete;
        can_modify_ips?: Schemas.legacy$jhs_can_modify_ips;
        created_at?: Schemas.legacy$jhs_timestamp;
        default_sni?: Schemas.legacy$jhs_default_sni;
        description?: Schemas.legacy$jhs_address$maps_components$schemas$description;
        enabled?: Schemas.legacy$jhs_address$maps_components$schemas$enabled;
        id?: Schemas.legacy$jhs_common_components$schemas$identifier;
        modified_at?: Schemas.legacy$jhs_timestamp;
    }
    export interface legacy$jhs_address$maps$ip {
        created_at?: Schemas.legacy$jhs_created$on;
        ip?: Schemas.legacy$jhs_ip;
    }
    export interface legacy$jhs_address$maps$membership {
        can_delete?: Schemas.legacy$jhs_schemas$can_delete;
        created_at?: Schemas.legacy$jhs_created$on;
        identifier?: Schemas.legacy$jhs_common_components$schemas$identifier;
        kind?: Schemas.legacy$jhs_components$schemas$kind;
    }
    /** An optional description field which may be used to describe the types of IPs or zones on the map. */
    export type legacy$jhs_address$maps_components$schemas$description = string | null;
    /** Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled. */
    export type legacy$jhs_address$maps_components$schemas$enabled = boolean | null;
    export type legacy$jhs_address$maps_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_address$maps[];
    };
    export type legacy$jhs_address$maps_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_address$maps;
    };
    /** Optional address line for unit, floor, suite, etc. */
    export type legacy$jhs_address2 = string;
    export type legacy$jhs_advanced_certificate_pack_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {
            certificate_authority?: Schemas.legacy$jhs_certificate_authority;
            cloudflare_branding?: Schemas.legacy$jhs_cloudflare_branding;
            hosts?: Schemas.legacy$jhs_schemas$hosts;
            id?: Schemas.legacy$jhs_certificate$packs_components$schemas$identifier;
            status?: Schemas.legacy$jhs_certificate$packs_components$schemas$status;
            type?: Schemas.legacy$jhs_advanced_type;
            validation_method?: Schemas.legacy$jhs_validation_method;
            validity_days?: Schemas.legacy$jhs_validity_days;
        };
    };
    /** Type of certificate pack. */
    export type legacy$jhs_advanced_type = "advanced";
    /** Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled. */
    export type legacy$jhs_advertised = boolean | null;
    export type legacy$jhs_advertised_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            advertised?: Schemas.legacy$jhs_schemas$advertised;
            advertised_modified_at?: Schemas.legacy$jhs_modified_at_nullable;
        };
    };
    export interface legacy$jhs_alert$types {
        description?: Schemas.legacy$jhs_alert$types_components$schemas$description;
        display_name?: Schemas.legacy$jhs_display_name;
        filter_options?: Schemas.legacy$jhs_schemas$filter_options;
        type?: Schemas.legacy$jhs_alert$types_components$schemas$type;
    }
    /** Describes the alert type. */
    export type legacy$jhs_alert$types_components$schemas$description = string;
    export type legacy$jhs_alert$types_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: {};
    };
    /** Use this value when creating and updating a notification policy. */
    export type legacy$jhs_alert$types_components$schemas$type = string;
    /** Message body included in the notification sent. */
    export type legacy$jhs_alert_body = string;
    /** Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values. */
    export type legacy$jhs_alert_type = string;
    /** Allows all HTTP request headers. */
    export type legacy$jhs_allow_all_headers = boolean;
    /** Allows all HTTP request methods. */
    export type legacy$jhs_allow_all_methods = boolean;
    /** Allows all origins. */
    export type legacy$jhs_allow_all_origins = boolean;
    /** When set to \`true\`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests. */
    export type legacy$jhs_allow_credentials = boolean;
    /** Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors. */
    export type legacy$jhs_allow_insecure = boolean;
    /** Whether to allow the user to switch WARP between modes. */
    export type legacy$jhs_allow_mode_switch = boolean;
    /** Whether to receive update notifications when a new version of the client is available. */
    export type legacy$jhs_allow_updates = boolean;
    /** Allowed HTTP request headers. */
    export type legacy$jhs_allowed_headers = {}[];
    /** The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account. */
    export type legacy$jhs_allowed_idps = string[];
    /** Related DLP policies will trigger when the match count exceeds the number set. */
    export type legacy$jhs_allowed_match_count = number;
    /** Allowed HTTP request methods. */
    export type legacy$jhs_allowed_methods = ("GET" | "POST" | "HEAD" | "PUT" | "DELETE" | "CONNECT" | "OPTIONS" | "TRACE" | "PATCH")[];
    /** The available states for the rule group. */
    export type legacy$jhs_allowed_modes = Schemas.legacy$jhs_components$schemas$mode[];
    /** Defines the available modes for the current WAF rule. */
    export type legacy$jhs_allowed_modes_allow_traditional = Schemas.legacy$jhs_mode_allow_traditional[];
    /** Defines the available modes for the current WAF rule. Applies to anomaly detection WAF rules. */
    export type legacy$jhs_allowed_modes_anomaly = Schemas.legacy$jhs_mode_anomaly[];
    /** The list of possible actions of the WAF rule when it is triggered. */
    export type legacy$jhs_allowed_modes_deny_traditional = Schemas.legacy$jhs_mode_deny_traditional[];
    /** Allowed origins. */
    export type legacy$jhs_allowed_origins = {}[];
    /** Whether to allow devices to leave the organization. */
    export type legacy$jhs_allowed_to_leave = boolean;
    /** The amount associated with this billing item. */
    export type legacy$jhs_amount = number;
    export interface legacy$jhs_analytics {
        id?: number;
        origins?: {}[];
        pool?: {};
        timestamp?: Date;
    }
    export type legacy$jhs_analytics$aggregate_components$schemas$response_collection = Schemas.legacy$jhs_api$response$common & {
        result?: {}[];
    };
    export type legacy$jhs_analytics_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_analytics[];
    };
    /** A summary of the purpose/function of the WAF package. */
    export type legacy$jhs_anomaly_description = string;
    /** When a WAF package uses anomaly detection, each rule is given a score when triggered. If the total score of all triggered rules exceeds the sensitivity defined on the WAF package, the action defined on the package will be taken. */
    export type legacy$jhs_anomaly_detection_mode = string;
    /** The name of the WAF package. */
    export type legacy$jhs_anomaly_name = string;
    export type legacy$jhs_anomaly_package = Schemas.legacy$jhs_package_definition & {
        action_mode?: Schemas.legacy$jhs_action_mode;
        description?: Schemas.legacy$jhs_anomaly_description;
        detection_mode?: Schemas.legacy$jhs_anomaly_detection_mode;
        name?: Schemas.legacy$jhs_anomaly_name;
        sensitivity?: Schemas.legacy$jhs_sensitivity;
    };
    export type legacy$jhs_anomaly_rule = Schemas.legacy$jhs_rule_components$schemas$base$2 & {
        allowed_modes?: Schemas.legacy$jhs_allowed_modes_anomaly;
        mode?: Schemas.legacy$jhs_mode_anomaly;
    };
    export type legacy$jhs_api$response$collection = Schemas.legacy$jhs_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.legacy$jhs_result_info;
    };
    export interface legacy$jhs_api$response$common {
        errors: Schemas.legacy$jhs_messages;
        messages: Schemas.legacy$jhs_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface legacy$jhs_api$response$common$failure {
        errors: Schemas.legacy$jhs_messages;
        messages: Schemas.legacy$jhs_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type legacy$jhs_api$response$single = Schemas.legacy$jhs_api$response$common & {
        result?: ({} | string) | null;
    };
    export type legacy$jhs_api$response$single$id = Schemas.legacy$jhs_api$response$common & {
        result?: {
            id: Schemas.legacy$jhs_common_components$schemas$identifier;
        } | null;
    };
    export type legacy$jhs_api$shield = Schemas.legacy$jhs_operation;
    /** The URL of the Access application. */
    export type legacy$jhs_app_domain = string;
    /** Application identifier. */
    export type legacy$jhs_app_id = string;
    /** Comma-delimited list of Spectrum Application Id(s). If provided, the response will be limited to Spectrum Application Id(s) that match. */
    export type legacy$jhs_app_id_param = string;
    export type legacy$jhs_app_launcher_props = Schemas.legacy$jhs_feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    /** Displays the application in the App Launcher. */
    export type legacy$jhs_app_launcher_visible = boolean;
    /** The unique identifier for the Access application. */
    export type legacy$jhs_app_uid = any;
    /** Application that the hostname belongs to. */
    export interface legacy$jhs_application {
        id?: number;
        name?: string;
    }
    /** A group of email addresses that can approve a temporary authentication request. */
    export interface legacy$jhs_approval_group {
        /** The number of approvals needed to obtain access. */
        approvals_needed: number;
        /** A list of emails that can approve the access request. */
        email_addresses?: {}[];
        /** The UUID of an re-usable email list. */
        email_list_uuid?: string;
    }
    /** Administrators who can approve a temporary authentication request. */
    export type legacy$jhs_approval_groups = Schemas.legacy$jhs_approval_group[];
    /** Requires the user to request access from an administrator at the start of each session. */
    export type legacy$jhs_approval_required = boolean;
    /** Approval state of the prefix (P = pending, V = active). */
    export type legacy$jhs_approved = string;
    export type legacy$jhs_apps = (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_self_hosted_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_saas_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_ssh_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_vnc_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_app_launcher_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_warp_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_biso_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_bookmark_props);
    export type legacy$jhs_apps_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_uuid;
        };
    };
    /** The name of the application. */
    export type legacy$jhs_apps_components$schemas$name = string;
    export type legacy$jhs_apps_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_apps[];
    };
    export type legacy$jhs_apps_components$schemas$response_collection$2 = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_schemas$apps[];
    };
    export type legacy$jhs_apps_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_apps;
    };
    export type legacy$jhs_apps_components$schemas$single_response$2 = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_schemas$apps;
    };
    /** The application type. */
    export type legacy$jhs_apps_components$schemas$type = "self_hosted" | "saas" | "ssh" | "vnc" | "app_launcher" | "warp" | "biso" | "bookmark" | "dash_sso";
    /**
     * Enables Argo Smart Routing for this application.
     * Notes: Only available for TCP applications with traffic_type set to "direct".
     */
    export type legacy$jhs_argo_smart_routing = boolean;
    /** Autonomous System Number (ASN) the prefix will be advertised under. */
    export type legacy$jhs_asn = number | null;
    export interface legacy$jhs_asn_components$schemas$asn {
        asn?: Schemas.legacy$jhs_components$schemas$asn;
        country?: Schemas.legacy$jhs_asn_country;
        description?: Schemas.legacy$jhs_asn_description;
        domain_count?: number;
        top_domains?: string[];
        type?: Schemas.legacy$jhs_asn_type;
    }
    export type legacy$jhs_asn_components$schemas$response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_asn_components$schemas$asn;
    };
    export interface legacy$jhs_asn_configuration {
        /** The configuration target. You must set the target to \`asn\` when specifying an Autonomous System Number (ASN) in the rule. */
        target?: "asn";
        /** The AS number to match. */
        value?: string;
    }
    export type legacy$jhs_asn_country = string;
    export type legacy$jhs_asn_description = string;
    /** Infrastructure type of this ASN. */
    export type legacy$jhs_asn_type = "hosting_provider" | "isp" | "organization";
    /** The hostnames of the applications that will use this certificate. */
    export type legacy$jhs_associated_hostnames = string[];
    export type legacy$jhs_association_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_associationObject[];
    };
    export interface legacy$jhs_associationObject {
        service?: Schemas.legacy$jhs_service;
        status?: Schemas.legacy$jhs_mtls$management_components$schemas$status;
    }
    /** The Application Audience (AUD) tag. Identifies the application associated with the CA. */
    export type legacy$jhs_aud = string;
    /** The unique subdomain assigned to your Zero Trust organization. */
    export type legacy$jhs_auth_domain = string;
    /** The total number of auth-ids seen across this calculation. */
    export type legacy$jhs_auth_id_tokens = number;
    /** The amount of time in minutes to reconnect after having been disabled. */
    export type legacy$jhs_auto_connect = number;
    /** When set to \`true\`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps. */
    export type legacy$jhs_auto_redirect_to_identity = boolean;
    /**
     * Matches an Azure group.
     * Requires an Azure identity provider.
     */
    export interface legacy$jhs_azure_group_rule {
        azureAD: {
            /** The ID of your Azure identity provider. */
            connection_id: string;
            /** The ID of an Azure group. */
            id: string;
        };
    }
    /** Breakdown of totals for bandwidth in the form of bytes. */
    export interface legacy$jhs_bandwidth {
        /** The total number of bytes served within the time frame. */
        all?: number;
        /** The number of bytes that were cached (and served) by Cloudflare. */
        cached?: number;
        /** A variable list of key/value pairs where the key represents the type of content served, and the value is the number in bytes served. */
        content_type?: {};
        /** A variable list of key/value pairs where the key is a two-digit country code and the value is the number of bytes served to that country. */
        country?: {};
        /** A break down of bytes served over HTTPS. */
        ssl?: {
            /** The number of bytes served over HTTPS. */
            encrypted?: number;
            /** The number of bytes served over HTTP. */
            unencrypted?: number;
        };
        /** A breakdown of requests by their SSL protocol. */
        ssl_protocols?: {
            /** The number of requests served over TLS v1.0. */
            TLSv1?: number;
            /** The number of requests served over TLS v1.1. */
            "TLSv1.1"?: number;
            /** The number of requests served over TLS v1.2. */
            "TLSv1.2"?: number;
            /** The number of requests served over TLS v1.3. */
            "TLSv1.3"?: number;
            /** The number of requests served over HTTP. */
            none?: number;
        };
        /** The number of bytes that were fetched and served from the origin server. */
        uncached?: number;
    }
    /** Breakdown of totals for bandwidth in the form of bytes. */
    export interface legacy$jhs_bandwidth_by_colo {
        /** The total number of bytes served within the time frame. */
        all?: number;
        /** The number of bytes that were cached (and served) by Cloudflare. */
        cached?: number;
        /** The number of bytes that were fetched and served from the origin server. */
        uncached?: number;
    }
    export interface legacy$jhs_base {
        expires_on?: Schemas.legacy$jhs_schemas$expires_on;
        id?: Schemas.legacy$jhs_invite_components$schemas$identifier;
        invited_by?: Schemas.legacy$jhs_invited_by;
        invited_member_email?: Schemas.legacy$jhs_invited_member_email;
        /** ID of the user to add to the organization. */
        readonly invited_member_id: string | null;
        invited_on?: Schemas.legacy$jhs_invited_on;
        /** ID of the organization the user will be added to. */
        readonly organization_id: string;
        /** Organization name. */
        readonly organization_name?: string;
        /** Roles to be assigned to this user. */
        roles?: Schemas.legacy$jhs_schemas$role[];
    }
    export interface legacy$jhs_basic_app_response_props {
        aud?: Schemas.legacy$jhs_schemas$aud;
        created_at?: Schemas.legacy$jhs_timestamp;
        id?: Schemas.legacy$jhs_uuid;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    export interface legacy$jhs_billing$history {
        action: Schemas.legacy$jhs_action;
        amount: Schemas.legacy$jhs_amount;
        currency: Schemas.legacy$jhs_currency;
        description: Schemas.legacy$jhs_schemas$description;
        id: Schemas.legacy$jhs_billing$history_components$schemas$identifier;
        occurred_at: Schemas.legacy$jhs_occurred_at;
        type: Schemas.legacy$jhs_type;
        zone: Schemas.legacy$jhs_schemas$zone;
    }
    /** Billing item identifier tag. */
    export type legacy$jhs_billing$history_components$schemas$identifier = string;
    export type legacy$jhs_billing_history_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_billing$history[];
    };
    export type legacy$jhs_billing_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_biso_props = Schemas.legacy$jhs_feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    /** The response body to return. The value must conform to the configured content type. */
    export type legacy$jhs_body = string;
    export interface legacy$jhs_bookmark_props {
        app_launcher_visible?: any;
        /** The URL or domain of the bookmark. */
        domain?: any;
        logo_url?: Schemas.legacy$jhs_logo_url;
        name?: Schemas.legacy$jhs_apps_components$schemas$name;
        /** The application type. */
        type?: string;
    }
    export interface legacy$jhs_bookmarks {
        app_launcher_visible?: Schemas.legacy$jhs_schemas$app_launcher_visible;
        created_at?: Schemas.legacy$jhs_timestamp;
        domain?: Schemas.legacy$jhs_components$schemas$domain;
        /** The unique identifier for the Bookmark application. */
        id?: any;
        logo_url?: Schemas.legacy$jhs_logo_url;
        name?: Schemas.legacy$jhs_bookmarks_components$schemas$name;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    export type legacy$jhs_bookmarks_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_uuid;
        };
    };
    /** The name of the Bookmark application. */
    export type legacy$jhs_bookmarks_components$schemas$name = string;
    export type legacy$jhs_bookmarks_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_bookmarks[];
    };
    export type legacy$jhs_bookmarks_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_bookmarks;
    };
    /** Certificate Authority is manually reviewing the order. */
    export type legacy$jhs_brand_check = boolean;
    export type legacy$jhs_bulk$operation$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_schemas$operation;
    };
    /** A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. */
    export type legacy$jhs_bundle_method = "ubiquitous" | "optimal" | "force";
    /** Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs. */
    export type legacy$jhs_bypass = {
        name?: "url";
        /** The URL to bypass. */
        value?: string;
    }[];
    /** Indicates whether the certificate is a CA or leaf certificate. */
    export type legacy$jhs_ca = boolean;
    /** The ID of the CA. */
    export type legacy$jhs_ca_components$schemas$id = string;
    export type legacy$jhs_ca_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_ca_components$schemas$id;
        };
    };
    export type legacy$jhs_ca_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_schemas$ca[];
    };
    export type legacy$jhs_ca_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_cache_reserve = Schemas.legacy$jhs_schemas$base & {
        /** ID of the zone setting. */
        id?: "cache_reserve";
    };
    /** If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps. */
    export type legacy$jhs_can_delete = boolean;
    /** If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps. */
    export type legacy$jhs_can_modify_ips = boolean;
    /** Indicates if the domain can be registered as a new domain. */
    export type legacy$jhs_can_register = boolean;
    /** Turn on the captive portal after the specified amount of time. */
    export type legacy$jhs_captive_portal = number;
    /** The categories of the rule. */
    export type legacy$jhs_categories = Schemas.legacy$jhs_category[];
    /** A category of the rule. */
    export type legacy$jhs_category = string;
    /** Certificate Pack UUID. */
    export type legacy$jhs_cert_pack_uuid = string;
    /** The unique identifier for a certificate_pack. */
    export type legacy$jhs_certificate$packs_components$schemas$identifier = string;
    /** Status of certificate pack. */
    export type legacy$jhs_certificate$packs_components$schemas$status = "initializing" | "pending_validation" | "deleted" | "pending_issuance" | "pending_deployment" | "pending_deletion" | "pending_expiration" | "expired" | "active" | "initializing_timed_out" | "validation_timed_out" | "issuance_timed_out" | "deployment_timed_out" | "deletion_timed_out" | "pending_cleanup" | "staging_deployment" | "staging_active" | "deactivating" | "inactive" | "backup_issued" | "holding_deployment";
    export type legacy$jhs_certificate_analyze_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** Certificate Authority selected for the order.  Selecting Let's Encrypt will reduce customization of other fields: validation_method must be 'txt', validity_days must be 90, cloudflare_branding must be omitted, and hosts must contain only 2 entries, one for the zone name and one for the subdomain wildcard of the zone name (e.g. example.com, *.example.com). */
    export type legacy$jhs_certificate_authority = "digicert" | "google" | "lets_encrypt";
    export type legacy$jhs_certificate_pack_quota_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            advanced?: Schemas.legacy$jhs_quota;
        };
    };
    export type legacy$jhs_certificate_pack_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: {}[];
    };
    export type legacy$jhs_certificate_pack_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_certificate_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_custom$certificate[];
    };
    export type legacy$jhs_certificate_response_id_only = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_custom$certificate_components$schemas$identifier;
        };
    };
    export type legacy$jhs_certificate_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_certificate_response_single_id = Schemas.legacy$jhs_schemas$certificate_response_single & {
        result?: {
            id?: Schemas.legacy$jhs_certificates_components$schemas$identifier;
        };
    };
    export type legacy$jhs_certificate_response_single_post = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_certificateObjectPost;
    };
    /** Matches any valid client certificate. */
    export interface legacy$jhs_certificate_rule {
        certificate: {};
    }
    /** Current status of certificate. */
    export type legacy$jhs_certificate_status = "initializing" | "authorizing" | "active" | "expired" | "issuing" | "timing_out" | "pending_deployment";
    export interface legacy$jhs_certificateObject {
        certificate?: Schemas.legacy$jhs_zone$authenticated$origin$pull_components$schemas$certificate;
        expires_on?: Schemas.legacy$jhs_zone$authenticated$origin$pull_components$schemas$expires_on;
        id?: Schemas.legacy$jhs_zone$authenticated$origin$pull_components$schemas$identifier;
        issuer?: Schemas.legacy$jhs_issuer;
        signature?: Schemas.legacy$jhs_signature;
        status?: Schemas.legacy$jhs_zone$authenticated$origin$pull_components$schemas$status;
        uploaded_on?: Schemas.legacy$jhs_schemas$uploaded_on;
    }
    export interface legacy$jhs_certificateObjectPost {
        ca?: Schemas.legacy$jhs_ca;
        certificates?: Schemas.legacy$jhs_schemas$certificates;
        expires_on?: Schemas.legacy$jhs_mtls$management_components$schemas$expires_on;
        id?: Schemas.legacy$jhs_mtls$management_components$schemas$identifier;
        issuer?: Schemas.legacy$jhs_schemas$issuer;
        name?: Schemas.legacy$jhs_mtls$management_components$schemas$name;
        serial_number?: Schemas.legacy$jhs_schemas$serial_number;
        signature?: Schemas.legacy$jhs_signature;
        updated_at?: Schemas.legacy$jhs_schemas$updated_at;
        uploaded_on?: Schemas.legacy$jhs_mtls$management_components$schemas$uploaded_on;
    }
    export interface legacy$jhs_certificates {
        certificate?: Schemas.legacy$jhs_components$schemas$certificate;
        csr: Schemas.legacy$jhs_csr;
        expires_on?: Schemas.legacy$jhs_certificates_components$schemas$expires_on;
        hostnames: Schemas.legacy$jhs_hostnames;
        id?: Schemas.legacy$jhs_certificates_components$schemas$identifier;
        request_type: Schemas.legacy$jhs_request_type;
        requested_validity: Schemas.legacy$jhs_requested_validity;
    }
    /** When the certificate will expire. */
    export type legacy$jhs_certificates_components$schemas$expires_on = Date;
    export type legacy$jhs_certificates_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_uuid;
        };
    };
    /** The x509 serial number of the Origin CA certificate. */
    export type legacy$jhs_certificates_components$schemas$identifier = string;
    /** The name of the certificate. */
    export type legacy$jhs_certificates_components$schemas$name = string;
    export type legacy$jhs_certificates_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_components$schemas$certificates[];
    };
    export type legacy$jhs_certificates_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_components$schemas$certificates;
    };
    export type legacy$jhs_characteristics = {
        name: Schemas.legacy$jhs_characteristics_components$schemas$name;
        type: Schemas.legacy$jhs_schemas$type;
    }[];
    /** The name of the characteristic field, i.e., the header or cookie name. */
    export type legacy$jhs_characteristics_components$schemas$name = string;
    /** A list of regions from which to run health checks. Null means every Cloudflare data center. */
    export type legacy$jhs_check_regions = ("WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS")[] | null;
    /** IP Prefix in Classless Inter-Domain Routing format. */
    export type legacy$jhs_cidr = string;
    export interface legacy$jhs_cidr_configuration {
        /** The configuration target. You must set the target to \`ip_range\` when specifying an IP address range in the rule. */
        target?: "ip_range";
        /** The IP address range to match. You can only use prefix lengths \`/16\` and \`/24\` for IPv4 ranges, and prefix lengths \`/32\`, \`/48\`, and \`/64\` for IPv6 ranges. */
        value?: string;
    }
    /** List of IPv4/IPv6 CIDR addresses. */
    export type legacy$jhs_cidr_list = string[];
    /** City. */
    export type legacy$jhs_city = string;
    /** The Client ID for the service token. Access will check for this value in the \`CF-Access-Client-ID\` request header. */
    export type legacy$jhs_client_id = string;
    /** The Client Secret for the service token. Access will check for this value in the \`CF-Access-Client-Secret\` request header. */
    export type legacy$jhs_client_secret = string;
    /** Whether or not to add Cloudflare Branding for the order.  This will add sni.cloudflaressl.com as the Common Name if set true. */
    export type legacy$jhs_cloudflare_branding = boolean;
    export type legacy$jhs_collection_invite_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_invite[];
    };
    export type legacy$jhs_collection_response = Schemas.legacy$jhs_api$response$collection & {
        result?: (Schemas.legacy$jhs_api$shield & {
            features?: {};
        })[];
    };
    export interface legacy$jhs_colo {
        city?: Schemas.legacy$jhs_colo_city;
        name?: Schemas.legacy$jhs_colo_name;
    }
    /** Source colo city. */
    export type legacy$jhs_colo_city = string;
    /** Source colo name. */
    export type legacy$jhs_colo_name = string;
    export type legacy$jhs_colo_response = Schemas.legacy$jhs_api$response$single & {
        query?: Schemas.legacy$jhs_query_response;
        result?: Schemas.legacy$jhs_datacenters;
    };
    export interface legacy$jhs_colo_result {
        colo?: Schemas.legacy$jhs_colo;
        error?: Schemas.legacy$jhs_error;
        hops?: Schemas.legacy$jhs_hop_result[];
        target_summary?: Schemas.legacy$jhs_target_summary;
        traceroute_time_ms?: Schemas.legacy$jhs_traceroute_time_ms;
    }
    /** Identifier */
    export type legacy$jhs_common_components$schemas$identifier = string;
    export type legacy$jhs_common_components$schemas$ip = Schemas.legacy$jhs_ipv4 | Schemas.legacy$jhs_ipv6;
    export interface legacy$jhs_component$value {
        default?: Schemas.legacy$jhs_default;
        name?: Schemas.legacy$jhs_component$value_components$schemas$name;
        unit_price?: Schemas.legacy$jhs_unit_price;
    }
    /** The unique component. */
    export type legacy$jhs_component$value_components$schemas$name = "zones" | "page_rules" | "dedicated_certificates" | "dedicated_certificates_custom";
    /** A component value for a subscription. */
    export interface legacy$jhs_component_value {
        /** The default amount assigned. */
        default?: number;
        /** The name of the component value. */
        name?: string;
        /** The unit price for the component value. */
        price?: number;
        /** The amount of the component value assigned. */
        value?: number;
    }
    /** The list of add-ons subscribed to. */
    export type legacy$jhs_component_values = Schemas.legacy$jhs_component_value[];
    /** The action to apply to a matched request. The \`log\` action is only available on an Enterprise plan. */
    export type legacy$jhs_components$schemas$action = "block" | "challenge" | "js_challenge" | "managed_challenge" | "allow" | "log" | "bypass";
    export type legacy$jhs_components$schemas$asn = number;
    export interface legacy$jhs_components$schemas$base {
        /** When the Keyless SSL was created. */
        readonly created_on: Date;
        enabled: Schemas.legacy$jhs_enabled;
        host: Schemas.legacy$jhs_schemas$host;
        id: Schemas.legacy$jhs_keyless$certificate_components$schemas$identifier;
        /** When the Keyless SSL was last modified. */
        readonly modified_on: Date;
        name: Schemas.legacy$jhs_keyless$certificate_components$schemas$name;
        /** Available permissions for the Keyless SSL for the current user requesting the item. */
        readonly permissions: {}[];
        port: Schemas.legacy$jhs_port;
        status: Schemas.legacy$jhs_keyless$certificate_components$schemas$status;
    }
    /** The Origin CA certificate. Will be newline-encoded. */
    export type legacy$jhs_components$schemas$certificate = string;
    export type legacy$jhs_components$schemas$certificate_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_zone$authenticated$origin$pull[];
    };
    export type legacy$jhs_components$schemas$certificate_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_schemas$certificateObject;
    };
    export interface legacy$jhs_components$schemas$certificateObject {
        ca?: Schemas.legacy$jhs_ca;
        certificates?: Schemas.legacy$jhs_schemas$certificates;
        expires_on?: Schemas.legacy$jhs_mtls$management_components$schemas$expires_on;
        id?: Schemas.legacy$jhs_mtls$management_components$schemas$identifier;
        issuer?: Schemas.legacy$jhs_schemas$issuer;
        name?: Schemas.legacy$jhs_mtls$management_components$schemas$name;
        serial_number?: Schemas.legacy$jhs_schemas$serial_number;
        signature?: Schemas.legacy$jhs_signature;
        uploaded_on?: Schemas.legacy$jhs_mtls$management_components$schemas$uploaded_on;
    }
    export interface legacy$jhs_components$schemas$certificates {
        associated_hostnames?: Schemas.legacy$jhs_associated_hostnames;
        created_at?: Schemas.legacy$jhs_timestamp;
        expires_on?: Schemas.legacy$jhs_timestamp;
        fingerprint?: Schemas.legacy$jhs_fingerprint;
        /** The ID of the application that will use this certificate. */
        id?: any;
        name?: Schemas.legacy$jhs_certificates_components$schemas$name;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    /** The configuration object for the current rule. */
    export interface legacy$jhs_components$schemas$configuration {
        /** The configuration target for this rule. You must set the target to \`ua\` for User Agent Blocking rules. */
        target?: string;
        /** The exact user agent string to match. This value will be compared to the received \`User-Agent\` HTTP header value. */
        value?: string;
    }
    /** Shows time of creation. */
    export type legacy$jhs_components$schemas$created_at = Date;
    /** An informative summary of the rate limit. This value is sanitized and any tags will be removed. */
    export type legacy$jhs_components$schemas$description = string;
    /** The domain of the Bookmark application. */
    export type legacy$jhs_components$schemas$domain = string;
    export type legacy$jhs_components$schemas$empty_response = Schemas.legacy$jhs_api$response$common & {
        result?: {};
    };
    /** If enabled, Total TLS will order a hostname specific TLS certificate for any proxied A, AAAA, or CNAME record in your zone. */
    export type legacy$jhs_components$schemas$enabled = boolean;
    export type legacy$jhs_components$schemas$exclude = Schemas.legacy$jhs_split_tunnel[];
    /** When the certificate from the authority expires. */
    export type legacy$jhs_components$schemas$expires_on = Date;
    export interface legacy$jhs_components$schemas$filters {
    }
    /** Hostname of the Worker Domain. */
    export type legacy$jhs_components$schemas$hostname = string;
    export type legacy$jhs_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_load$balancer_components$schemas$identifier;
        };
    };
    /** Token identifier tag. */
    export type legacy$jhs_components$schemas$identifier = string;
    /** IPv4 or IPv6 address. */
    export type legacy$jhs_components$schemas$ip = string;
    /** The type of the membership. */
    export type legacy$jhs_components$schemas$kind = "zone" | "account";
    /** The wirefilter expression to match devices. */
    export type legacy$jhs_components$schemas$match = string;
    /** The state of the rules contained in the rule group. When \`on\`, the rules in the group are configurable/usable. */
    export type legacy$jhs_components$schemas$mode = "on" | "off";
    /** The timestamp of when the rule was last modified. */
    export type legacy$jhs_components$schemas$modified_on = Date;
    export interface legacy$jhs_components$schemas$monitor {
        allow_insecure?: Schemas.legacy$jhs_allow_insecure;
        consecutive_down?: Schemas.legacy$jhs_consecutive_down;
        consecutive_up?: Schemas.legacy$jhs_consecutive_up;
        created_on?: Schemas.legacy$jhs_timestamp;
        description?: Schemas.legacy$jhs_monitor_components$schemas$description;
        expected_body?: Schemas.legacy$jhs_expected_body;
        expected_codes?: Schemas.legacy$jhs_schemas$expected_codes;
        follow_redirects?: Schemas.legacy$jhs_follow_redirects;
        header?: Schemas.legacy$jhs_header;
        id?: Schemas.legacy$jhs_monitor_components$schemas$identifier;
        interval?: Schemas.legacy$jhs_interval;
        method?: Schemas.legacy$jhs_schemas$method;
        modified_on?: Schemas.legacy$jhs_timestamp;
        path?: Schemas.legacy$jhs_path;
        port?: Schemas.legacy$jhs_components$schemas$port;
        probe_zone?: Schemas.legacy$jhs_probe_zone;
        retries?: Schemas.legacy$jhs_retries;
        timeout?: Schemas.legacy$jhs_schemas$timeout;
        type?: Schemas.legacy$jhs_monitor_components$schemas$type;
    }
    /** Role Name. */
    export type legacy$jhs_components$schemas$name = string;
    /** A pattern that matches an entry */
    export interface legacy$jhs_components$schemas$pattern {
        /** The regex pattern. */
        regex: string;
        /** Validation algorithm for the pattern. This algorithm will get run on potential matches, and if it returns false, the entry will not be matched. */
        validation?: "luhn";
    }
    /** When true, indicates that the firewall rule is currently paused. */
    export type legacy$jhs_components$schemas$paused = boolean;
    export interface legacy$jhs_components$schemas$policies {
        alert_type?: Schemas.legacy$jhs_alert_type;
        created?: Schemas.legacy$jhs_timestamp;
        description?: Schemas.legacy$jhs_policies_components$schemas$description;
        enabled?: Schemas.legacy$jhs_policies_components$schemas$enabled;
        filters?: Schemas.legacy$jhs_components$schemas$filters;
        id?: Schemas.legacy$jhs_uuid;
        mechanisms?: Schemas.legacy$jhs_mechanisms;
        modified?: Schemas.legacy$jhs_timestamp;
        name?: Schemas.legacy$jhs_policies_components$schemas$name$2;
    }
    /** The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443). */
    export type legacy$jhs_components$schemas$port = number;
    /** The relative priority of the current URI-based WAF override when multiple overrides match a single URL. A lower number indicates higher priority. Higher priority overrides may overwrite values set by lower priority overrides. */
    export type legacy$jhs_components$schemas$priority = number;
    /** The reference of the rule (the rule ID by default). */
    export type legacy$jhs_components$schemas$ref = string;
    export type legacy$jhs_components$schemas$response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_ip$list[];
    };
    export type legacy$jhs_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: {}[];
    };
    export type legacy$jhs_components$schemas$result = Schemas.legacy$jhs_result & {
        data?: any;
        max?: any;
        min?: any;
        query?: Schemas.legacy$jhs_query;
        totals?: any;
    };
    export type legacy$jhs_components$schemas$rule = Schemas.legacy$jhs_anomaly_rule | Schemas.legacy$jhs_traditional_deny_rule | Schemas.legacy$jhs_traditional_allow_rule;
    /** BETA Field Not General Access: A list of rules for this load balancer to execute. */
    export type legacy$jhs_components$schemas$rules = {
        /** The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions. */
        condition?: string;
        /** Disable this specific rule. It will no longer be evaluated by this load balancer. */
        disabled?: boolean;
        /** A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed_response is supplied the rule will be marked as terminates. */
        fixed_response?: {
            /** The http 'Content-Type' header to include in the response. */
            content_type?: string;
            /** The http 'Location' header to include in the response. */
            location?: string;
            /** Text to include as the http body. */
            message_body?: string;
            /** The http status code to respond with. */
            status_code?: number;
        };
        /** Name of this rule. Only used for human readability. */
        name?: string;
        /** A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional. */
        overrides?: {
            adaptive_routing?: Schemas.legacy$jhs_adaptive_routing;
            country_pools?: Schemas.legacy$jhs_country_pools;
            default_pools?: Schemas.legacy$jhs_default_pools;
            fallback_pool?: Schemas.legacy$jhs_fallback_pool;
            location_strategy?: Schemas.legacy$jhs_location_strategy;
            pop_pools?: Schemas.legacy$jhs_pop_pools;
            random_steering?: Schemas.legacy$jhs_random_steering;
            region_pools?: Schemas.legacy$jhs_region_pools;
            session_affinity?: Schemas.legacy$jhs_session_affinity;
            session_affinity_attributes?: Schemas.legacy$jhs_session_affinity_attributes;
            session_affinity_ttl?: Schemas.legacy$jhs_session_affinity_ttl;
            steering_policy?: Schemas.legacy$jhs_steering_policy;
            ttl?: Schemas.legacy$jhs_ttl;
        };
        /** The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority. */
        priority?: number;
        /** If this rule's condition is true, this causes rule evaluation to stop after processing this rule. */
        terminates?: boolean;
    }[];
    /** The device serial number. */
    export type legacy$jhs_components$schemas$serial_number = string;
    export type legacy$jhs_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_monitor;
    };
    /** Last updated. */
    export type legacy$jhs_components$schemas$updated_at = Date;
    /** The time when the certificate was uploaded. */
    export type legacy$jhs_components$schemas$uploaded_on = Date;
    /** The policy ID. */
    export type legacy$jhs_components$schemas$uuid = string;
    export interface legacy$jhs_condition {
        "request.ip"?: Schemas.legacy$jhs_request$ip;
    }
    export type legacy$jhs_config_response = Schemas.legacy$jhs_workspace_one_config_response;
    export type legacy$jhs_config_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export interface legacy$jhs_configuration {
        auth_id_characteristics?: Schemas.legacy$jhs_characteristics;
    }
    export type legacy$jhs_configurations = Schemas.legacy$jhs_schemas$ip_configuration | Schemas.legacy$jhs_schemas$cidr_configuration;
    export interface legacy$jhs_connection {
        created_on?: Schemas.legacy$jhs_connection_components$schemas$created_on;
        enabled: Schemas.legacy$jhs_connection_components$schemas$enabled;
        id: Schemas.legacy$jhs_connection_components$schemas$identifier;
        modified_on?: Schemas.legacy$jhs_connection_components$schemas$modified_on;
        zone: Schemas.legacy$jhs_connection_components$schemas$zone;
    }
    export type legacy$jhs_connection_collection_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_connection[];
    };
    /** When the connection was created. */
    export type legacy$jhs_connection_components$schemas$created_on = Date;
    /** A value indicating whether the connection is enabled or not. */
    export type legacy$jhs_connection_components$schemas$enabled = boolean;
    /** Connection identifier tag. */
    export type legacy$jhs_connection_components$schemas$identifier = string;
    /** When the connection was last modified. */
    export type legacy$jhs_connection_components$schemas$modified_on = Date;
    export interface legacy$jhs_connection_components$schemas$zone {
        id?: Schemas.legacy$jhs_common_components$schemas$identifier;
        name?: Schemas.legacy$jhs_zone$properties$name;
    }
    export type legacy$jhs_connection_single_id_response = Schemas.legacy$jhs_connection_single_response & {
        result?: {
            id?: Schemas.legacy$jhs_connection_components$schemas$identifier;
        };
    };
    export type legacy$jhs_connection_single_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. */
    export type legacy$jhs_consecutive_down = number;
    /** To be marked healthy the monitored origin must pass this healthcheck N consecutive times. */
    export type legacy$jhs_consecutive_up = number;
    /** Contact Identifier. */
    export type legacy$jhs_contact_identifier = string;
    export interface legacy$jhs_contact_properties {
        address: Schemas.legacy$jhs_schemas$address;
        address2?: Schemas.legacy$jhs_address2;
        city: Schemas.legacy$jhs_city;
        country: Schemas.legacy$jhs_country;
        email?: Schemas.legacy$jhs_email;
        fax?: Schemas.legacy$jhs_fax;
        first_name: Schemas.legacy$jhs_first_name;
        id?: Schemas.legacy$jhs_contact_identifier;
        last_name: Schemas.legacy$jhs_last_name;
        organization: Schemas.legacy$jhs_schemas$organization;
        phone: Schemas.legacy$jhs_telephone;
        state: Schemas.legacy$jhs_contacts_components$schemas$state;
        zip: Schemas.legacy$jhs_zipcode;
    }
    export type legacy$jhs_contacts = Schemas.legacy$jhs_contact_properties;
    /** State. */
    export type legacy$jhs_contacts_components$schemas$state = string;
    /** Current content categories. */
    export type legacy$jhs_content_categories = any;
    /** Behavior of the content list. */
    export type legacy$jhs_content_list_action = "block";
    export interface legacy$jhs_content_list_details {
        action?: Schemas.legacy$jhs_content_list_action;
    }
    export type legacy$jhs_content_list_details_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_content_list_details;
    };
    /** Content list entries. */
    export type legacy$jhs_content_list_entries = Schemas.legacy$jhs_content_list_entry[];
    /** Content list entry to be blocked. */
    export interface legacy$jhs_content_list_entry {
        content?: Schemas.legacy$jhs_content_list_entry_content;
        created_on?: Schemas.legacy$jhs_timestamp;
        description?: Schemas.legacy$jhs_content_list_entry_description;
        id?: Schemas.legacy$jhs_common_components$schemas$identifier;
        modified_on?: Schemas.legacy$jhs_timestamp;
        type?: Schemas.legacy$jhs_content_list_entry_type;
    }
    export type legacy$jhs_content_list_entry_collection_response = Schemas.legacy$jhs_api$response$collection & {
        result?: {
            entries?: Schemas.legacy$jhs_content_list_entries;
        };
    };
    /** CID or content path of content to block. */
    export type legacy$jhs_content_list_entry_content = string;
    /** An optional description of the content list entry. */
    export type legacy$jhs_content_list_entry_description = string;
    export type legacy$jhs_content_list_entry_single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_content_list_entry;
    };
    /** Type of content list entry to block. */
    export type legacy$jhs_content_list_entry_type = "cid" | "content_path";
    /** The content type of the body. Must be one of the following: \`text/plain\`, \`text/xml\`, or \`application/json\`. */
    export type legacy$jhs_content_type = string;
    export interface legacy$jhs_cors_headers {
        allow_all_headers?: Schemas.legacy$jhs_allow_all_headers;
        allow_all_methods?: Schemas.legacy$jhs_allow_all_methods;
        allow_all_origins?: Schemas.legacy$jhs_allow_all_origins;
        allow_credentials?: Schemas.legacy$jhs_allow_credentials;
        allowed_headers?: Schemas.legacy$jhs_allowed_headers;
        allowed_methods?: Schemas.legacy$jhs_allowed_methods;
        allowed_origins?: Schemas.legacy$jhs_allowed_origins;
        max_age?: Schemas.legacy$jhs_max_age;
    }
    /** The country in which the user lives. */
    export type legacy$jhs_country = string | null;
    export interface legacy$jhs_country_configuration {
        /** The configuration target. You must set the target to \`country\` when specifying a country code in the rule. */
        target?: "country";
        /** The two-letter ISO-3166-1 alpha-2 code to match. For more information, refer to [IP Access rules: Parameters](https://developers.cloudflare.com/waf/tools/ip-access-rules/parameters/#country). */
        value?: string;
    }
    /** A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region_pool mapping if it exists else to default_pools. */
    export interface legacy$jhs_country_pools {
    }
    export type legacy$jhs_create_custom_profile_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_custom_profile[];
    };
    export type legacy$jhs_create_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            client_id?: Schemas.legacy$jhs_client_id;
            client_secret?: Schemas.legacy$jhs_client_secret;
            created_at?: Schemas.legacy$jhs_timestamp;
            /** The ID of the service token. */
            id?: any;
            name?: Schemas.legacy$jhs_service$tokens_components$schemas$name;
            updated_at?: Schemas.legacy$jhs_timestamp;
        };
    };
    /** When the Application was created. */
    export type legacy$jhs_created = Date;
    export type legacy$jhs_created$on = Date;
    /** This is the time the hostname was created. */
    export type legacy$jhs_created_at = Date;
    /** The timestamp of when the rule was created. */
    export type legacy$jhs_created_on = Date;
    export type legacy$jhs_cron$trigger$response$collection = Schemas.legacy$jhs_api$response$common & {
        result?: {
            schedules?: {
                readonly created_on?: any;
                readonly cron?: any;
                readonly modified_on?: any;
            }[];
        };
    };
    /** The Certificate Signing Request (CSR). Must be newline-encoded. */
    export type legacy$jhs_csr = string;
    /** The monetary unit in which pricing information is displayed. */
    export type legacy$jhs_currency = string;
    /** The end of the current period and also when the next billing is due. */
    export type legacy$jhs_current_period_end = Date;
    /** When the current billing period started. May match initial_period_start if this is the first period. */
    export type legacy$jhs_current_period_start = Date;
    /** Shows name of current registrar. */
    export type legacy$jhs_current_registrar = string;
    export interface legacy$jhs_custom$certificate {
        bundle_method: Schemas.legacy$jhs_bundle_method;
        expires_on: Schemas.legacy$jhs_components$schemas$expires_on;
        geo_restrictions?: Schemas.legacy$jhs_geo_restrictions;
        hosts: Schemas.legacy$jhs_hosts;
        id: Schemas.legacy$jhs_custom$certificate_components$schemas$identifier;
        issuer: Schemas.legacy$jhs_issuer;
        keyless_server?: Schemas.legacy$jhs_keyless$certificate;
        modified_on: Schemas.legacy$jhs_schemas$modified_on;
        policy?: Schemas.legacy$jhs_policy;
        priority: Schemas.legacy$jhs_priority;
        signature: Schemas.legacy$jhs_signature;
        status: Schemas.legacy$jhs_custom$certificate_components$schemas$status;
        uploaded_on: Schemas.legacy$jhs_uploaded_on;
        zone_id: Schemas.legacy$jhs_common_components$schemas$identifier;
    }
    /** Custom certificate identifier tag. */
    export type legacy$jhs_custom$certificate_components$schemas$identifier = string;
    /** Status of the zone's custom SSL. */
    export type legacy$jhs_custom$certificate_components$schemas$status = "active" | "expired" | "deleted" | "pending" | "initializing";
    export type legacy$jhs_custom$hostname = Schemas.legacy$jhs_customhostname;
    /** Custom hostname identifier tag. */
    export type legacy$jhs_custom$hostname_components$schemas$identifier = string;
    /** Status of the hostname's activation. */
    export type legacy$jhs_custom$hostname_components$schemas$status = "active" | "pending" | "active_redeploying" | "moved" | "pending_deletion" | "deleted" | "pending_blocked" | "pending_migration" | "pending_provisioned" | "test_pending" | "test_active" | "test_active_apex" | "test_blocked" | "test_failed" | "provisioned" | "blocked";
    /** The custom error message shown to a user when they are denied access to the application. */
    export type legacy$jhs_custom_deny_message = string;
    /** The custom URL a user is redirected to when they are denied access to the application. */
    export type legacy$jhs_custom_deny_url = string;
    /** A custom entry that matches a profile */
    export interface legacy$jhs_custom_entry {
        created_at?: Schemas.legacy$jhs_timestamp;
        /** Whether the entry is enabled or not. */
        enabled?: boolean;
        id?: Schemas.legacy$jhs_entry_id;
        /** The name of the entry. */
        name?: string;
        pattern?: Schemas.legacy$jhs_components$schemas$pattern;
        /** ID of the parent profile */
        profile_id?: any;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    export type legacy$jhs_custom_hostname_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_custom$hostname[];
    };
    export type legacy$jhs_custom_hostname_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_custom_metadata = {
        /** Unique metadata for this hostname. */
        key?: string;
    };
    /** a valid hostname thatâ€™s been added to your DNS zone as an A, AAAA, or CNAME record. */
    export type legacy$jhs_custom_origin_server = string;
    /** A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server. */
    export type legacy$jhs_custom_origin_sni = string;
    export type legacy$jhs_custom_pages_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: {}[];
    };
    export type legacy$jhs_custom_pages_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export interface legacy$jhs_custom_profile {
        allowed_match_count?: Schemas.legacy$jhs_allowed_match_count;
        created_at?: Schemas.legacy$jhs_timestamp;
        /** The description of the profile. */
        description?: string;
        /** The entries for this profile. */
        entries?: Schemas.legacy$jhs_custom_entry[];
        id?: Schemas.legacy$jhs_profile_id;
        /** The name of the profile. */
        name?: string;
        /** The type of the profile. */
        type?: "custom";
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    export type legacy$jhs_custom_profile_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_custom_profile;
    };
    export type legacy$jhs_custom_response = {
        body?: Schemas.legacy$jhs_body;
        content_type?: Schemas.legacy$jhs_content_type;
    };
    export interface legacy$jhs_customhostname {
        created_at?: Schemas.legacy$jhs_created_at;
        custom_metadata?: Schemas.legacy$jhs_custom_metadata;
        custom_origin_server?: Schemas.legacy$jhs_custom_origin_server;
        custom_origin_sni?: Schemas.legacy$jhs_custom_origin_sni;
        hostname?: Schemas.legacy$jhs_hostname;
        id?: Schemas.legacy$jhs_custom$hostname_components$schemas$identifier;
        ownership_verification?: Schemas.legacy$jhs_ownership_verification;
        ownership_verification_http?: Schemas.legacy$jhs_ownership_verification_http;
        ssl?: Schemas.legacy$jhs_ssl;
        status?: Schemas.legacy$jhs_custom$hostname_components$schemas$status;
        verification_errors?: Schemas.legacy$jhs_verification_errors;
    }
    /** Totals and timeseries data. */
    export interface legacy$jhs_dashboard {
        timeseries?: Schemas.legacy$jhs_timeseries;
        totals?: Schemas.legacy$jhs_totals;
    }
    export type legacy$jhs_dashboard_response = Schemas.legacy$jhs_api$response$single & {
        query?: Schemas.legacy$jhs_query_response;
        result?: Schemas.legacy$jhs_dashboard;
    };
    /** The number of data points used for the threshold suggestion calculation. */
    export type legacy$jhs_data_points = number;
    /**
     * Analytics data by datacenter
     *
     * A breakdown of all dashboard analytics data by co-locations. This is limited to Enterprise zones only.
     */
    export type legacy$jhs_datacenters = {
        /** The airport code identifer for the co-location. */
        colo_id?: string;
        timeseries?: Schemas.legacy$jhs_timeseries_by_colo;
        totals?: Schemas.legacy$jhs_totals_by_colo;
    }[];
    /** The number of days until the next key rotation. */
    export type legacy$jhs_days_until_next_rotation = number;
    /** The action Access will take if a user matches this policy. */
    export type legacy$jhs_decision = "allow" | "deny" | "non_identity" | "bypass";
    /** The default amount allocated. */
    export type legacy$jhs_default = number;
    export interface legacy$jhs_default_device_settings_policy {
        allow_mode_switch?: Schemas.legacy$jhs_allow_mode_switch;
        allow_updates?: Schemas.legacy$jhs_allow_updates;
        allowed_to_leave?: Schemas.legacy$jhs_allowed_to_leave;
        auto_connect?: Schemas.legacy$jhs_auto_connect;
        captive_portal?: Schemas.legacy$jhs_captive_portal;
        /** Whether the policy will be applied to matching devices. */
        default?: boolean;
        disable_auto_fallback?: Schemas.legacy$jhs_disable_auto_fallback;
        /** Whether the policy will be applied to matching devices. */
        enabled?: boolean;
        exclude?: Schemas.legacy$jhs_components$schemas$exclude;
        exclude_office_ips?: Schemas.legacy$jhs_exclude_office_ips;
        fallback_domains?: Schemas.legacy$jhs_fallback_domains;
        gateway_unique_id?: Schemas.legacy$jhs_gateway_unique_id;
        include?: Schemas.legacy$jhs_schemas$include;
        service_mode_v2?: Schemas.legacy$jhs_service_mode_v2;
        support_url?: Schemas.legacy$jhs_support_url;
        switch_locked?: Schemas.legacy$jhs_switch_locked;
    }
    export type legacy$jhs_default_device_settings_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_default_device_settings_policy;
    };
    /** The default action/mode of a rule. */
    export type legacy$jhs_default_mode = "disable" | "simulate" | "block" | "challenge";
    /** A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region. */
    export type legacy$jhs_default_pools = string[];
    export type legacy$jhs_default_response = Schemas.legacy$jhs_api$response$single;
    /** If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account. */
    export type legacy$jhs_default_sni = string | null;
    /** Account identifier for the account to which prefix is being delegated. */
    export type legacy$jhs_delegated_account_identifier = string;
    /** Delegation identifier tag. */
    export type legacy$jhs_delegation_identifier = string;
    export type legacy$jhs_delete_advanced_certificate_pack_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_certificate$packs_components$schemas$identifier;
        };
    };
    /** When true, indicates that Cloudflare should also delete the associated filter if there are no other firewall rules referencing the filter. */
    export type legacy$jhs_delete_filter_if_unused = boolean;
    /** When true, indicates that the firewall rule was deleted. */
    export type legacy$jhs_deleted = boolean;
    export interface legacy$jhs_deleted$filter {
        deleted: Schemas.legacy$jhs_deleted;
        id: Schemas.legacy$jhs_filters_components$schemas$id;
    }
    export type legacy$jhs_deleted_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_deployments$list$response = Schemas.legacy$jhs_api$response$common & {
        items?: {}[];
        latest?: {};
    };
    export type legacy$jhs_deployments$single$response = Schemas.legacy$jhs_api$response$common & {
        id?: string;
        metadata?: {};
        number?: number;
        resources?: {};
    };
    /** Description of role's permissions. */
    export type legacy$jhs_description = string;
    /** A string to search for in the description of existing rules. */
    export type legacy$jhs_description_search = string;
    /** The mode that defines how rules within the package are evaluated during the course of a request. When a package uses anomaly detection mode (\`anomaly\` value), each rule is given a score when triggered. If the total score of all triggered rules exceeds the sensitivity defined in the WAF package, the action configured in the package will be performed. Traditional detection mode (\`traditional\` value) will decide the action to take when it is triggered by the request. If multiple rules are triggered, the action providing the highest protection will be applied (for example, a 'block' action will win over a 'challenge' action). */
    export type legacy$jhs_detection_mode = "anomaly" | "traditional";
    export interface legacy$jhs_device$managed$networks {
        config?: Schemas.legacy$jhs_schemas$config_response;
        name?: Schemas.legacy$jhs_device$managed$networks_components$schemas$name;
        network_id?: Schemas.legacy$jhs_device$managed$networks_components$schemas$uuid;
        type?: Schemas.legacy$jhs_device$managed$networks_components$schemas$type;
    }
    /** The name of the Device Managed Network. Must be unique. */
    export type legacy$jhs_device$managed$networks_components$schemas$name = string;
    export type legacy$jhs_device$managed$networks_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_device$managed$networks[];
    };
    export type legacy$jhs_device$managed$networks_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_device$managed$networks;
    };
    /** The type of Device Managed Network. */
    export type legacy$jhs_device$managed$networks_components$schemas$type = "tls";
    /** API uuid tag. */
    export type legacy$jhs_device$managed$networks_components$schemas$uuid = string;
    export interface legacy$jhs_device$posture$integrations {
        config?: Schemas.legacy$jhs_config_response;
        id?: Schemas.legacy$jhs_device$posture$integrations_components$schemas$uuid;
        interval?: Schemas.legacy$jhs_schemas$interval;
        name?: Schemas.legacy$jhs_device$posture$integrations_components$schemas$name;
        type?: Schemas.legacy$jhs_device$posture$integrations_components$schemas$type;
    }
    export type legacy$jhs_device$posture$integrations_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: any | null;
    };
    /** The name of the Device Posture Integration. */
    export type legacy$jhs_device$posture$integrations_components$schemas$name = string;
    export type legacy$jhs_device$posture$integrations_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_device$posture$integrations[];
    };
    export type legacy$jhs_device$posture$integrations_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_device$posture$integrations;
    };
    /** The type of Device Posture Integration. */
    export type legacy$jhs_device$posture$integrations_components$schemas$type = "workspace_one" | "crowdstrike_s2s" | "uptycs" | "intune";
    /** API uuid tag. */
    export type legacy$jhs_device$posture$integrations_components$schemas$uuid = string;
    export interface legacy$jhs_device$posture$rules {
        description?: Schemas.legacy$jhs_device$posture$rules_components$schemas$description;
        expiration?: Schemas.legacy$jhs_schemas$expiration;
        id?: Schemas.legacy$jhs_device$posture$rules_components$schemas$uuid;
        input?: Schemas.legacy$jhs_input;
        match?: Schemas.legacy$jhs_schemas$match;
        name?: Schemas.legacy$jhs_device$posture$rules_components$schemas$name;
        schedule?: Schemas.legacy$jhs_schedule;
        type?: Schemas.legacy$jhs_device$posture$rules_components$schemas$type;
    }
    /** The description of the Device Posture Rule. */
    export type legacy$jhs_device$posture$rules_components$schemas$description = string;
    export type legacy$jhs_device$posture$rules_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_device$posture$rules_components$schemas$uuid;
        };
    };
    /** The name of the Device Posture Rule. */
    export type legacy$jhs_device$posture$rules_components$schemas$name = string;
    export type legacy$jhs_device$posture$rules_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_device$posture$rules[];
    };
    export type legacy$jhs_device$posture$rules_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_device$posture$rules;
    };
    /** The type of Device Posture Rule. */
    export type legacy$jhs_device$posture$rules_components$schemas$type = "file" | "application" | "serial_number" | "tanium" | "gateway" | "warp";
    /** API uuid tag. */
    export type legacy$jhs_device$posture$rules_components$schemas$uuid = string;
    export type legacy$jhs_device_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export interface legacy$jhs_device_settings_policy {
        allow_mode_switch?: Schemas.legacy$jhs_allow_mode_switch;
        allow_updates?: Schemas.legacy$jhs_allow_updates;
        allowed_to_leave?: Schemas.legacy$jhs_allowed_to_leave;
        auto_connect?: Schemas.legacy$jhs_auto_connect;
        captive_portal?: Schemas.legacy$jhs_captive_portal;
        default?: Schemas.legacy$jhs_schemas$default;
        description?: Schemas.legacy$jhs_devices_components$schemas$description;
        disable_auto_fallback?: Schemas.legacy$jhs_disable_auto_fallback;
        /** Whether the policy will be applied to matching devices. */
        enabled?: boolean;
        exclude?: Schemas.legacy$jhs_components$schemas$exclude;
        exclude_office_ips?: Schemas.legacy$jhs_exclude_office_ips;
        fallback_domains?: Schemas.legacy$jhs_fallback_domains;
        gateway_unique_id?: Schemas.legacy$jhs_gateway_unique_id;
        include?: Schemas.legacy$jhs_schemas$include;
        match?: Schemas.legacy$jhs_components$schemas$match;
        /** The name of the device settings policy. */
        name?: string;
        policy_id?: Schemas.legacy$jhs_uuid;
        precedence?: Schemas.legacy$jhs_schemas$precedence;
        service_mode_v2?: Schemas.legacy$jhs_service_mode_v2;
        support_url?: Schemas.legacy$jhs_support_url;
        switch_locked?: Schemas.legacy$jhs_switch_locked;
    }
    export type legacy$jhs_device_settings_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_device_settings_policy;
    };
    export type legacy$jhs_device_settings_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_device_settings_policy[];
    };
    export interface legacy$jhs_devices {
        created?: Schemas.legacy$jhs_schemas$created;
        deleted?: Schemas.legacy$jhs_schemas$deleted;
        device_type?: Schemas.legacy$jhs_platform;
        id?: Schemas.legacy$jhs_devices_components$schemas$uuid;
        ip?: Schemas.legacy$jhs_components$schemas$ip;
        key?: Schemas.legacy$jhs_schemas$key;
        last_seen?: Schemas.legacy$jhs_last_seen;
        mac_address?: Schemas.legacy$jhs_mac_address;
        manufacturer?: Schemas.legacy$jhs_manufacturer;
        model?: Schemas.legacy$jhs_model;
        name?: Schemas.legacy$jhs_devices_components$schemas$name;
        os_distro_name?: Schemas.legacy$jhs_os_distro_name;
        os_distro_revision?: Schemas.legacy$jhs_os_distro_revision;
        os_version?: Schemas.legacy$jhs_os_version;
        revoked_at?: Schemas.legacy$jhs_revoked_at;
        serial_number?: Schemas.legacy$jhs_components$schemas$serial_number;
        updated?: Schemas.legacy$jhs_updated;
        user?: Schemas.legacy$jhs_user;
        version?: Schemas.legacy$jhs_devices_components$schemas$version;
    }
    /** A description of the policy. */
    export type legacy$jhs_devices_components$schemas$description = string;
    /** The device name. */
    export type legacy$jhs_devices_components$schemas$name = string;
    /** Device ID. */
    export type legacy$jhs_devices_components$schemas$uuid = string;
    /** The WARP client version. */
    export type legacy$jhs_devices_components$schemas$version = string;
    export type legacy$jhs_devices_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_devices[];
    };
    /**
     * Can be used to break down the data by given attributes. Options are:
     *
     * Dimension                 | Name                            | Example
     * --------------------------|---------------------------------|--------------------------
     * event                     | Connection Event                | connect, progress, disconnect, originError, clientFiltered
     * appID                     | Application ID                  | 40d67c87c6cd4b889a4fd57805225e85
     * coloName                  | Colo Name                       | SFO
     * ipVersion                 | IP version used by the client   | 4, 6.
     */
    export type legacy$jhs_dimensions = ("event" | "appID" | "coloName" | "ipVersion")[];
    export type legacy$jhs_direct_upload_response_v2 = Schemas.legacy$jhs_api$response$single & {
        result?: {
            /** Image unique identifier. */
            readonly id?: string;
            /** The URL the unauthenticated upload can be performed to using a single HTTP POST (multipart/form-data) request. */
            uploadURL?: string;
        };
    };
    /** If the dns_server field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers, unless this policy option is set. */
    export type legacy$jhs_disable_auto_fallback = boolean;
    export interface legacy$jhs_disable_for_time {
        /** Override code that is valid for 1 hour. */
        "1"?: any;
        /** Override code that is valid for 3 hours. */
        "3"?: any;
        /** Override code that is valid for 6 hours. */
        "6"?: any;
        /** Override code that is valid for 12 hour2. */
        "12"?: any;
        /** Override code that is valid for 24 hour.2. */
        "24"?: any;
    }
    /** When true, indicates that the rate limit is currently disabled. */
    export type legacy$jhs_disabled = boolean;
    /** This field shows up only if the origin is disabled. This field is set with the time the origin was disabled. */
    export type legacy$jhs_disabled_at = Date;
    /** Alert type name. */
    export type legacy$jhs_display_name = string;
    /** The name and type of DNS record for the Spectrum application. */
    export interface legacy$jhs_dns {
        name?: Schemas.legacy$jhs_dns_name;
        type?: Schemas.legacy$jhs_dns_type;
    }
    /** The name of the DNS record associated with the application. */
    export type legacy$jhs_dns_name = string;
    /** The TTL of our resolution of your DNS record in seconds. */
    export type legacy$jhs_dns_ttl = number;
    /** The type of DNS record associated with the application. */
    export type legacy$jhs_dns_type = "CNAME" | "ADDRESS";
    export interface legacy$jhs_domain {
        environment?: Schemas.legacy$jhs_environment;
        hostname?: Schemas.legacy$jhs_components$schemas$hostname;
        id?: Schemas.legacy$jhs_domain_identifier;
        service?: Schemas.legacy$jhs_schemas$service;
        zone_id?: Schemas.legacy$jhs_zone_identifier;
        zone_name?: Schemas.legacy$jhs_zone_name;
    }
    export interface legacy$jhs_domain$history {
        categorizations?: {
            categories?: any;
            end?: string;
            start?: string;
        }[];
        domain?: Schemas.legacy$jhs_schemas$domain_name;
    }
    export type legacy$jhs_domain$response$collection = Schemas.legacy$jhs_api$response$common & {
        result?: Schemas.legacy$jhs_domain[];
    };
    export type legacy$jhs_domain$response$single = Schemas.legacy$jhs_api$response$common & {
        result?: Schemas.legacy$jhs_domain;
    };
    export interface legacy$jhs_domain_components$schemas$domain {
        additional_information?: Schemas.legacy$jhs_additional_information;
        application?: Schemas.legacy$jhs_application;
        content_categories?: Schemas.legacy$jhs_content_categories;
        domain?: Schemas.legacy$jhs_schemas$domain_name;
        popularity_rank?: Schemas.legacy$jhs_popularity_rank;
        resolves_to_refs?: Schemas.legacy$jhs_resolves_to_refs;
        risk_score?: Schemas.legacy$jhs_risk_score;
        risk_types?: Schemas.legacy$jhs_risk_types;
    }
    export type legacy$jhs_domain_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_domain_components$schemas$domain;
    };
    /** Identifer of the Worker Domain. */
    export type legacy$jhs_domain_identifier = any;
    export interface legacy$jhs_domain_properties {
        available?: Schemas.legacy$jhs_schemas$available;
        can_register?: Schemas.legacy$jhs_can_register;
        created_at?: Schemas.legacy$jhs_components$schemas$created_at;
        current_registrar?: Schemas.legacy$jhs_current_registrar;
        expires_at?: Schemas.legacy$jhs_expires_at;
        id?: Schemas.legacy$jhs_schemas$domain_identifier;
        locked?: Schemas.legacy$jhs_locked;
        registrant_contact?: Schemas.legacy$jhs_registrant_contact;
        registry_statuses?: Schemas.legacy$jhs_registry_statuses;
        supported_tld?: Schemas.legacy$jhs_supported_tld;
        transfer_in?: Schemas.legacy$jhs_transfer_in;
        updated_at?: Schemas.legacy$jhs_components$schemas$updated_at;
    }
    export type legacy$jhs_domain_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_domains[];
    };
    export type legacy$jhs_domain_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** Match an entire email domain. */
    export interface legacy$jhs_domain_rule {
        email_domain: {
            /** The email domain to match. */
            domain: string;
        };
    }
    export type legacy$jhs_domains = Schemas.legacy$jhs_domain_properties;
    /** The duration of the plan subscription. */
    export type legacy$jhs_duration = number;
    export type legacy$jhs_edge_ips = {
        /** The IP versions supported for inbound connections on Spectrum anycast IPs. */
        connectivity?: "all" | "ipv4" | "ipv6";
        /** The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names. */
        type?: "dynamic";
    } | {
        /** The array of customer owned IPs we broadcast via anycast for this hostname and application. */
        ips?: string[];
        /** The type of edge IP configuration specified. Statically allocated edge IPs use customer IPs in accordance with the ips array you specify. Only valid with ADDRESS DNS names. */
        type?: "static";
    };
    /** Allow or deny operations against the resources. */
    export type legacy$jhs_effect = "allow" | "deny";
    export interface legacy$jhs_egs$pagination {
        /** The page number of paginated results. */
        page?: number;
        /** The maximum number of results per page. You can only set the value to \`1\` or to a multiple of 5 such as \`5\`, \`10\`, \`15\`, or \`20\`. */
        per_page?: number;
    }
    export type legacy$jhs_either_profile_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_predefined_profile | Schemas.legacy$jhs_custom_profile;
    };
    export interface legacy$jhs_eligibility {
        eligible?: Schemas.legacy$jhs_eligible;
        ready?: Schemas.legacy$jhs_ready;
        type?: Schemas.legacy$jhs_eligibility_components$schemas$type;
    }
    export type legacy$jhs_eligibility_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: {};
    };
    /** Determines type of delivery mechanism. */
    export type legacy$jhs_eligibility_components$schemas$type = "email" | "pagerduty" | "webhook";
    /** Determines whether or not the account is eligible for the delivery mechanism. */
    export type legacy$jhs_eligible = boolean;
    /** The contact email address of the user. */
    export type legacy$jhs_email = string;
    /** Matches a specific email. */
    export interface legacy$jhs_email_rule {
        email: {
            /** The email of the user. */
            email: string;
        };
    }
    export type legacy$jhs_empty_response = {
        result?: true | false;
        success?: true | false;
    };
    /** Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks. */
    export type legacy$jhs_enable_binding_cookie = boolean;
    /** Whether or not the Keyless SSL is on or off. */
    export type legacy$jhs_enabled = boolean;
    export type legacy$jhs_enabled_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            enabled?: Schemas.legacy$jhs_zone$authenticated$origin$pull_components$schemas$enabled;
        };
    };
    /** The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/. */
    export type legacy$jhs_endpoint = string;
    export type legacy$jhs_entry_id = Schemas.legacy$jhs_uuid;
    /** Worker environment associated with the zone and hostname. */
    export type legacy$jhs_environment = string;
    /** Errors resulting from collecting traceroute from colo to target. */
    export type legacy$jhs_error = "" | "Could not gather traceroute data: Code 1" | "Could not gather traceroute data: Code 2" | "Could not gather traceroute data: Code 3" | "Could not gather traceroute data: Code 4";
    /** Matches everyone. */
    export interface legacy$jhs_everyone_rule {
        /** An empty object which matches on all users. */
        everyone: {};
    }
    /** Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules. */
    export type legacy$jhs_exclude = Schemas.legacy$jhs_rule_components$schemas$rule[];
    /** Whether to add Microsoft IPs to split tunnel exclusions. */
    export type legacy$jhs_exclude_office_ips = boolean;
    /** A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors. */
    export type legacy$jhs_expected_body = string;
    /** The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors. */
    export type legacy$jhs_expected_codes = string;
    /** Shows when domain name registration expires. */
    export type legacy$jhs_expires_at = Date;
    /** The expiration time on or after which the JWT MUST NOT be accepted for processing. */
    export type legacy$jhs_expires_on = Date;
    /** The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/). */
    export type legacy$jhs_expression = string;
    export type legacy$jhs_failed_login_response = Schemas.legacy$jhs_api$response$collection & {
        result?: {
            expiration?: number;
            metadata?: {};
        }[];
    };
    export interface legacy$jhs_fallback_domain {
        /** A description of the fallback domain, displayed in the client UI. */
        description?: string;
        /** A list of IP addresses to handle domain resolution. */
        dns_server?: {}[];
        /** The domain suffix to match when resolving locally. */
        suffix: string;
    }
    export type legacy$jhs_fallback_domain_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_fallback_domain[];
    };
    export type legacy$jhs_fallback_domains = Schemas.legacy$jhs_fallback_domain[];
    export type legacy$jhs_fallback_origin_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** The pool ID to use when all other pools are detected as unhealthy. */
    export type legacy$jhs_fallback_pool = any;
    /** Contact fax number. */
    export type legacy$jhs_fax = string;
    export interface legacy$jhs_feature_app_props {
        allowed_idps?: Schemas.legacy$jhs_allowed_idps;
        auto_redirect_to_identity?: Schemas.legacy$jhs_auto_redirect_to_identity;
        domain?: Schemas.legacy$jhs_schemas$domain;
        name?: Schemas.legacy$jhs_apps_components$schemas$name;
        session_duration?: Schemas.legacy$jhs_session_duration;
        type?: Schemas.legacy$jhs_apps_components$schemas$type;
    }
    export type legacy$jhs_features = Schemas.legacy$jhs_thresholds | Schemas.legacy$jhs_parameter_schemas;
    /** Image file name. */
    export type legacy$jhs_filename = string;
    export interface legacy$jhs_filter {
        description?: Schemas.legacy$jhs_filters_components$schemas$description;
        expression?: Schemas.legacy$jhs_expression;
        id?: Schemas.legacy$jhs_filters_components$schemas$id;
        paused?: Schemas.legacy$jhs_filters_components$schemas$paused;
        ref?: Schemas.legacy$jhs_schemas$ref;
    }
    export type legacy$jhs_filter$delete$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result?: (Schemas.legacy$jhs_filter & {})[];
    };
    export type legacy$jhs_filter$delete$response$single = Schemas.legacy$jhs_api$response$single & {
        result: Schemas.legacy$jhs_filter & {};
    };
    export type legacy$jhs_filter$response$collection = Schemas.legacy$jhs_api$response$common & {
        result?: Schemas.legacy$jhs_filters[];
    };
    export type legacy$jhs_filter$response$single = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_filters;
    };
    export interface legacy$jhs_filter$rule$base {
        action?: Schemas.legacy$jhs_components$schemas$action;
        description?: Schemas.legacy$jhs_firewall$rules_components$schemas$description;
        id?: Schemas.legacy$jhs_firewall$rules_components$schemas$id;
        paused?: Schemas.legacy$jhs_components$schemas$paused;
        priority?: Schemas.legacy$jhs_firewall$rules_components$schemas$priority;
        products?: Schemas.legacy$jhs_products;
        ref?: Schemas.legacy$jhs_ref;
    }
    export type legacy$jhs_filter$rule$response = Schemas.legacy$jhs_filter$rule$base & {
        filter?: Schemas.legacy$jhs_filter | Schemas.legacy$jhs_deleted$filter;
    };
    export type legacy$jhs_filter$rules$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result: (Schemas.legacy$jhs_filter$rule$response & {})[];
    };
    export type legacy$jhs_filter$rules$response$collection$delete = Schemas.legacy$jhs_api$response$collection & {
        result: (Schemas.legacy$jhs_filter$rule$response & {})[];
    };
    export type legacy$jhs_filter$rules$single$response = Schemas.legacy$jhs_api$response$single & {
        result: Schemas.legacy$jhs_filter$rule$response & {};
    };
    export type legacy$jhs_filter$rules$single$response$delete = Schemas.legacy$jhs_api$response$single & {
        result: Schemas.legacy$jhs_filter$rule$response & {};
    };
    /** Filter options for a particular resource type (pool or origin). Use null to reset. */
    export type legacy$jhs_filter_options = {
        /** If set true, disable notifications for this type of resource (pool or origin). */
        disable?: boolean;
        /** If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events). */
        healthy?: boolean | null;
    } | null;
    export interface legacy$jhs_filters {
        enabled: Schemas.legacy$jhs_filters_components$schemas$enabled;
        id: Schemas.legacy$jhs_common_components$schemas$identifier;
        pattern: Schemas.legacy$jhs_schemas$pattern;
    }
    /** An informative summary of the filter. */
    export type legacy$jhs_filters_components$schemas$description = string;
    /** Whether or not this filter will run a script */
    export type legacy$jhs_filters_components$schemas$enabled = boolean;
    /** The unique identifier of the filter. */
    export type legacy$jhs_filters_components$schemas$id = string;
    /** When true, indicates that the filter is currently paused. */
    export type legacy$jhs_filters_components$schemas$paused = boolean;
    /** The MD5 fingerprint of the certificate. */
    export type legacy$jhs_fingerprint = string;
    /** An informative summary of the firewall rule. */
    export type legacy$jhs_firewall$rules_components$schemas$description = string;
    /** The unique identifier of the firewall rule. */
    export type legacy$jhs_firewall$rules_components$schemas$id = string;
    /** The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority. */
    export type legacy$jhs_firewall$rules_components$schemas$priority = number;
    export interface legacy$jhs_firewalluablock {
        configuration?: Schemas.legacy$jhs_components$schemas$configuration;
        description?: Schemas.legacy$jhs_ua$rules_components$schemas$description;
        id?: Schemas.legacy$jhs_ua$rules_components$schemas$id;
        mode?: Schemas.legacy$jhs_ua$rules_components$schemas$mode;
        paused?: Schemas.legacy$jhs_schemas$paused;
    }
    export type legacy$jhs_firewalluablock_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_ua$rules[];
    };
    export type legacy$jhs_firewalluablock_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** User's first name */
    export type legacy$jhs_first_name = string | null;
    export type legacy$jhs_flag_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            flag?: boolean;
        };
    };
    /** Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors. */
    export type legacy$jhs_follow_redirects = boolean;
    /** How often the subscription is renewed automatically. */
    export type legacy$jhs_frequency = "weekly" | "monthly" | "quarterly" | "yearly";
    export type legacy$jhs_full_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_address$maps & {
            ips?: Schemas.legacy$jhs_ips;
            memberships?: Schemas.legacy$jhs_memberships;
        };
    };
    export type legacy$jhs_gateway_unique_id = string;
    /** Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance. */
    export interface legacy$jhs_geo_restrictions {
        label?: "us" | "eu" | "highest_security";
    }
    export type legacy$jhs_get_settings_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            public_key: string | null;
        };
    };
    /**
     * Matches a Github organization.
     * Requires a Github identity provider.
     */
    export interface legacy$jhs_github_organization_rule {
        "github-organization": {
            /** The ID of your Github identity provider. */
            connection_id: string;
            /** The name of the organization. */
            name: string;
        };
    }
    export interface legacy$jhs_group {
        description?: Schemas.legacy$jhs_group_components$schemas$description;
        id?: Schemas.legacy$jhs_group_components$schemas$identifier;
        modified_rules_count?: Schemas.legacy$jhs_modified_rules_count;
        name?: Schemas.legacy$jhs_group_components$schemas$name;
        package_id?: Schemas.legacy$jhs_package_components$schemas$identifier;
        rules_count?: Schemas.legacy$jhs_rules_count;
    }
    /** An informative summary of what the rule group does. */
    export type legacy$jhs_group_components$schemas$description = string | null;
    /** The unique identifier of the rule group. */
    export type legacy$jhs_group_components$schemas$identifier = string;
    /** The name of the rule group. */
    export type legacy$jhs_group_components$schemas$name = string;
    /** An object that allows you to enable or disable WAF rule groups for the current WAF override. Each key of this object must be the ID of a WAF rule group, and each value must be a valid WAF action (usually \`default\` or \`disable\`). When creating a new URI-based WAF override, you must provide a \`groups\` object or a \`rules\` object. */
    export interface legacy$jhs_groups {
    }
    export type legacy$jhs_groups_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_schemas$uuid;
        };
    };
    /** The name of the Access group. */
    export type legacy$jhs_groups_components$schemas$name = string;
    export type legacy$jhs_groups_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_schemas$groups[];
    };
    export type legacy$jhs_groups_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_schemas$groups;
    };
    /**
     * Matches a group in Google Workspace.
     * Requires a Google Workspace identity provider.
     */
    export interface legacy$jhs_gsuite_group_rule {
        gsuite: {
            /** The ID of your Google Workspace identity provider. */
            connection_id: string;
            /** The email of the Google Workspace group. */
            email: string;
        };
    }
    /** The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors. */
    export interface legacy$jhs_header {
    }
    /** The name of the response header to match. */
    export type legacy$jhs_header_name = string;
    /** The operator used when matching: \`eq\` means "equal" and \`ne\` means "not equal". */
    export type legacy$jhs_header_op = "eq" | "ne";
    /** The value of the response header, which must match exactly. */
    export type legacy$jhs_header_value = string;
    export type legacy$jhs_health_details = Schemas.legacy$jhs_api$response$single & {
        /** A list of regions from which to run health checks. Null means every Cloudflare data center. */
        result?: {};
    };
    /** URI to hero variant for an image. */
    export type legacy$jhs_hero_url = string;
    export interface legacy$jhs_history {
        alert_body?: Schemas.legacy$jhs_alert_body;
        alert_type?: Schemas.legacy$jhs_schemas$alert_type;
        description?: Schemas.legacy$jhs_history_components$schemas$description;
        id?: Schemas.legacy$jhs_uuid;
        mechanism?: Schemas.legacy$jhs_mechanism;
        mechanism_type?: Schemas.legacy$jhs_mechanism_type;
        name?: Schemas.legacy$jhs_history_components$schemas$name;
        sent?: Schemas.legacy$jhs_sent;
    }
    /** Description of the notification policy (if present). */
    export type legacy$jhs_history_components$schemas$description = string;
    /** Name of the policy. */
    export type legacy$jhs_history_components$schemas$name = string;
    export type legacy$jhs_history_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_history[];
        result_info?: {};
    };
    export interface legacy$jhs_hop_result {
        /** An array of node objects. */
        nodes?: Schemas.legacy$jhs_node_result[];
        packets_lost?: Schemas.legacy$jhs_packets_lost;
        packets_sent?: Schemas.legacy$jhs_packets_sent;
        packets_ttl?: Schemas.legacy$jhs_packets_ttl;
    }
    /** RFC3986-compliant host. */
    export type legacy$jhs_host = string;
    /** The custom hostname that will point to your hostname via CNAME. */
    export type legacy$jhs_hostname = string;
    export type legacy$jhs_hostname$authenticated$origin$pull = Schemas.legacy$jhs_hostname_certid_object;
    /** The hostname certificate. */
    export type legacy$jhs_hostname$authenticated$origin$pull_components$schemas$certificate = string;
    export type legacy$jhs_hostname$authenticated$origin$pull_components$schemas$certificate_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_hostname$authenticated$origin$pull[];
    };
    /** Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association. */
    export type legacy$jhs_hostname$authenticated$origin$pull_components$schemas$enabled = boolean | null;
    /** The date when the certificate expires. */
    export type legacy$jhs_hostname$authenticated$origin$pull_components$schemas$expires_on = Date;
    /** Certificate identifier tag. */
    export type legacy$jhs_hostname$authenticated$origin$pull_components$schemas$identifier = string;
    /** Status of the certificate or the association. */
    export type legacy$jhs_hostname$authenticated$origin$pull_components$schemas$status = "initializing" | "pending_deployment" | "pending_deletion" | "active" | "deleted" | "deployment_timed_out" | "deletion_timed_out";
    export type legacy$jhs_hostname_aop_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_hostname$authenticated$origin$pull[];
    };
    export type legacy$jhs_hostname_aop_single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_hostname_certid_object;
    };
    export interface legacy$jhs_hostname_certid_object {
        cert_id?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$identifier;
        cert_status?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$status;
        cert_updated_at?: Schemas.legacy$jhs_updated_at;
        cert_uploaded_on?: Schemas.legacy$jhs_components$schemas$uploaded_on;
        certificate?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$certificate;
        created_at?: Schemas.legacy$jhs_schemas$created_at;
        enabled?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$enabled;
        expires_on?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$expires_on;
        hostname?: Schemas.legacy$jhs_schemas$hostname;
        issuer?: Schemas.legacy$jhs_issuer;
        serial_number?: Schemas.legacy$jhs_serial_number;
        signature?: Schemas.legacy$jhs_signature;
        status?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$status;
        updated_at?: Schemas.legacy$jhs_updated_at;
    }
    /** Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate. */
    export type legacy$jhs_hostnames = {}[];
    export type legacy$jhs_hosts = string[];
    /** Enables the HttpOnly cookie attribute, which increases security against XSS attacks. */
    export type legacy$jhs_http_only_cookie_attribute = boolean;
    /** Identifier of a recommedation result. */
    export type legacy$jhs_id = string;
    export type legacy$jhs_id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_monitor_components$schemas$identifier;
        };
    };
    /** Policy identifier. */
    export type legacy$jhs_identifier = string;
    export interface legacy$jhs_identity$providers {
        config?: Schemas.legacy$jhs_schemas$config;
        id?: Schemas.legacy$jhs_uuid;
        name?: Schemas.legacy$jhs_identity$providers_components$schemas$name;
        type?: Schemas.legacy$jhs_identity$providers_components$schemas$type;
    }
    /** The name of the identity provider, shown to users on the login page. */
    export type legacy$jhs_identity$providers_components$schemas$name = string;
    export type legacy$jhs_identity$providers_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_identity$providers[];
    };
    export type legacy$jhs_identity$providers_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_identity$providers;
    };
    /** The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/). */
    export type legacy$jhs_identity$providers_components$schemas$type = string;
    export type legacy$jhs_image_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_images[];
    };
    export type legacy$jhs_image_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export interface legacy$jhs_images {
        filename?: Schemas.legacy$jhs_filename;
        id?: Schemas.legacy$jhs_images_components$schemas$identifier;
        metadata?: Schemas.legacy$jhs_metadata;
        requireSignedURLs?: Schemas.legacy$jhs_requireSignedURLs;
        uploaded?: Schemas.legacy$jhs_uploaded;
        variants?: Schemas.legacy$jhs_schemas$variants;
    }
    /** Image unique identifier. */
    export type legacy$jhs_images_components$schemas$identifier = string;
    /** Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. */
    export type legacy$jhs_include = Schemas.legacy$jhs_rule_components$schemas$rule[];
    /** The value to be checked against. */
    export interface legacy$jhs_input {
        id?: Schemas.legacy$jhs_device$posture$rules_components$schemas$uuid;
    }
    /** app install id. */
    export type legacy$jhs_install_id = string;
    /** The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. */
    export type legacy$jhs_interval = number;
    export type legacy$jhs_invite = Schemas.legacy$jhs_organization_invite;
    /** Invite identifier tag. */
    export type legacy$jhs_invite_components$schemas$identifier = string;
    /** The email address of the user who created the invite. */
    export type legacy$jhs_invited_by = string;
    /** Email address of the user to add to the organization. */
    export type legacy$jhs_invited_member_email = string;
    /** When the invite was sent. */
    export type legacy$jhs_invited_on = Date;
    /** An IPv4 or IPv6 address. */
    export type legacy$jhs_ip = string;
    export interface legacy$jhs_ip$list {
        description?: string;
        id?: number;
        name?: string;
    }
    export interface legacy$jhs_ip_components$schemas$ip {
        /** Specifies a reference to the autonomous systems (AS) that the IP address belongs to. */
        belongs_to_ref?: {
            country?: string;
            description?: string;
            id?: any;
            /** Infrastructure type of this ASN. */
            type?: "hosting_provider" | "isp" | "organization";
            value?: string;
        };
        ip?: Schemas.legacy$jhs_common_components$schemas$ip;
        risk_types?: any;
    }
    export interface legacy$jhs_ip_configuration {
        /** The configuration target. You must set the target to \`ip\` when specifying an IP address in the rule. */
        target?: "ip";
        /** The IP address to match. This address will be compared to the IP address of incoming requests. */
        value?: string;
    }
    /**
     * Enables IP Access Rules for this application.
     * Notes: Only available for TCP applications.
     */
    export type legacy$jhs_ip_firewall = boolean;
    /** Matches an IP address from a list. */
    export interface legacy$jhs_ip_list_rule {
        ip_list: {
            /** The ID of a previously created IP list. */
            id: string;
        };
    }
    /** A single IP address range to search for in existing rules. */
    export type legacy$jhs_ip_range_search = string;
    /** Matches an IP address block. */
    export interface legacy$jhs_ip_rule {
        ip: {
            /** An IPv4 or IPv6 CIDR block. */
            ip: string;
        };
    }
    /** A single IP address to search for in existing rules. */
    export type legacy$jhs_ip_search = string;
    export interface legacy$jhs_ipam$delegations {
        cidr?: Schemas.legacy$jhs_cidr;
        created_at?: Schemas.legacy$jhs_timestamp;
        delegated_account_id?: Schemas.legacy$jhs_delegated_account_identifier;
        id?: Schemas.legacy$jhs_delegation_identifier;
        modified_at?: Schemas.legacy$jhs_timestamp;
        parent_prefix_id?: Schemas.legacy$jhs_common_components$schemas$identifier;
    }
    export type legacy$jhs_ipam$delegations_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_delegation_identifier;
        };
    };
    export type legacy$jhs_ipam$delegations_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_ipam$delegations[];
    };
    export type legacy$jhs_ipam$delegations_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_ipam$delegations;
    };
    export interface legacy$jhs_ipam$prefixes {
        account_id?: Schemas.legacy$jhs_common_components$schemas$identifier;
        advertised?: Schemas.legacy$jhs_advertised;
        advertised_modified_at?: Schemas.legacy$jhs_modified_at_nullable;
        approved?: Schemas.legacy$jhs_approved;
        asn?: Schemas.legacy$jhs_asn;
        cidr?: Schemas.legacy$jhs_cidr;
        created_at?: Schemas.legacy$jhs_timestamp;
        description?: Schemas.legacy$jhs_ipam$prefixes_components$schemas$description;
        id?: Schemas.legacy$jhs_common_components$schemas$identifier;
        loa_document_id?: Schemas.legacy$jhs_loa_document_identifier;
        modified_at?: Schemas.legacy$jhs_timestamp;
        on_demand_enabled?: Schemas.legacy$jhs_on_demand_enabled;
        on_demand_locked?: Schemas.legacy$jhs_on_demand_locked;
    }
    /** Description of the prefix. */
    export type legacy$jhs_ipam$prefixes_components$schemas$description = string;
    export type legacy$jhs_ipam$prefixes_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_ipam$prefixes[];
    };
    export type legacy$jhs_ipam$prefixes_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_ipam$prefixes;
    };
    /** The set of IPs on the Address Map. */
    export type legacy$jhs_ips = Schemas.legacy$jhs_address$maps$ip[];
    export type legacy$jhs_ipv4 = string;
    export type legacy$jhs_ipv6 = string;
    export interface legacy$jhs_ipv6_configuration {
        /** The configuration target. You must set the target to \`ip6\` when specifying an IPv6 address in the rule. */
        target?: "ip6";
        /** The IPv6 address to match. */
        value?: string;
    }
    /** If \`true\`, this virtual network is the default for the account. */
    export type legacy$jhs_is_default_network = boolean;
    /** Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled. */
    export type legacy$jhs_is_ui_read_only = boolean;
    /** The time on which the token was created. */
    export type legacy$jhs_issued_on = Date;
    /** The certificate authority that issued the certificate. */
    export type legacy$jhs_issuer = string;
    export type legacy$jhs_item = {
        ip: any;
    } | {
        redirect: any;
    } | {
        hostname: any;
    };
    export type legacy$jhs_item$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_item;
    };
    /** An informative summary of the list item. */
    export type legacy$jhs_item_comment = string;
    /** Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-). */
    export type legacy$jhs_item_hostname = string;
    /** The unique ID of the item in the List. */
    export type legacy$jhs_item_id = string;
    /** An IPv4 address, an IPv4 CIDR, or an IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64. */
    export type legacy$jhs_item_ip = string;
    /** The definition of the redirect. */
    export interface legacy$jhs_item_redirect {
        include_subdomains?: boolean;
        preserve_path_suffix?: boolean;
        preserve_query_string?: boolean;
        source_url: string;
        status_code?: 301 | 302 | 307 | 308;
        subpath_matching?: boolean;
        target_url: string;
    }
    export type legacy$jhs_items = Schemas.legacy$jhs_item[];
    export type legacy$jhs_items$list$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_items;
        result_info?: {
            cursors?: {
                after?: string;
                before?: string;
            };
        };
    };
    export interface legacy$jhs_key_config {
        days_until_next_rotation?: Schemas.legacy$jhs_days_until_next_rotation;
        key_rotation_interval_days?: Schemas.legacy$jhs_key_rotation_interval_days;
        last_key_rotation_at?: Schemas.legacy$jhs_last_key_rotation_at;
    }
    export type legacy$jhs_key_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_keys_response;
    };
    /** The number of days between key rotations. */
    export type legacy$jhs_key_rotation_interval_days = number;
    export type legacy$jhs_keyless$certificate = Schemas.legacy$jhs_components$schemas$base;
    /** Keyless certificate identifier tag. */
    export type legacy$jhs_keyless$certificate_components$schemas$identifier = string;
    /** The keyless SSL name. */
    export type legacy$jhs_keyless$certificate_components$schemas$name = string;
    /** Status of the Keyless SSL. */
    export type legacy$jhs_keyless$certificate_components$schemas$status = "active" | "deleted";
    export type legacy$jhs_keyless_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_keyless$certificate[];
    };
    export type legacy$jhs_keyless_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_keyless_response_single_id = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_keyless$certificate_components$schemas$identifier;
        };
    };
    export interface legacy$jhs_keys {
        name?: Schemas.legacy$jhs_keys_components$schemas$name;
        value?: Schemas.legacy$jhs_keys_components$schemas$value;
    }
    /** Key name. */
    export type legacy$jhs_keys_components$schemas$name = string;
    export type legacy$jhs_keys_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & Schemas.legacy$jhs_key_config;
    /** Key value. */
    export type legacy$jhs_keys_components$schemas$value = string;
    export interface legacy$jhs_keys_response {
        keys?: Schemas.legacy$jhs_keys[];
    }
    /** The type of the list. Each type supports specific list items (IP addresses, hostnames or redirects). */
    export type legacy$jhs_kind = "ip" | "redirect" | "hostname";
    /** Field appears if there is an additional annotation printed when the probe returns. Field also appears when running a GRE+ICMP traceroute to denote which traceroute a node comes from. */
    export type legacy$jhs_labels = string[];
    /** Timestamp of the last time an attempt to dispatch a notification to this webhook failed. */
    export type legacy$jhs_last_failure = Date;
    /** The timestamp of the previous key rotation. */
    export type legacy$jhs_last_key_rotation_at = Date;
    /** User's last name */
    export type legacy$jhs_last_name = string | null;
    /** When the device last connected to Cloudflare services. */
    export type legacy$jhs_last_seen = Date;
    /** Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook. */
    export type legacy$jhs_last_success = Date;
    /** The timestamp of when the ruleset was last modified. */
    export type legacy$jhs_last_updated = string;
    /** The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set. */
    export type legacy$jhs_latitude = number;
    export interface legacy$jhs_list {
        created_on?: Schemas.legacy$jhs_schemas$created_on;
        description?: Schemas.legacy$jhs_lists_components$schemas$description;
        id?: Schemas.legacy$jhs_list_id;
        kind?: Schemas.legacy$jhs_kind;
        modified_on?: Schemas.legacy$jhs_lists_components$schemas$modified_on;
        name?: Schemas.legacy$jhs_lists_components$schemas$name;
        num_items?: Schemas.legacy$jhs_num_items;
        num_referencing_filters?: Schemas.legacy$jhs_num_referencing_filters;
    }
    export type legacy$jhs_list$delete$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result?: {
            id?: Schemas.legacy$jhs_item_id;
        };
    };
    export type legacy$jhs_list$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_list;
    };
    /** The unique ID of the list. */
    export type legacy$jhs_list_id = string;
    export type legacy$jhs_lists$async$response = Schemas.legacy$jhs_api$response$collection & {
        result?: {
            operation_id?: Schemas.legacy$jhs_operation_id;
        };
    };
    export type legacy$jhs_lists$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result?: (Schemas.legacy$jhs_list & {})[];
    };
    /** An informative summary of the list. */
    export type legacy$jhs_lists_components$schemas$description = string;
    /** The RFC 3339 timestamp of when the list was last modified. */
    export type legacy$jhs_lists_components$schemas$modified_on = string;
    /** An informative name for the list. Use this name in filter and rule expressions. */
    export type legacy$jhs_lists_components$schemas$name = string;
    /** Identifier for the uploaded LOA document. */
    export type legacy$jhs_loa_document_identifier = string | null;
    export type legacy$jhs_loa_upload_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            /** Name of LOA document. */
            filename?: string;
        };
    };
    export interface legacy$jhs_load$balancer {
        adaptive_routing?: Schemas.legacy$jhs_adaptive_routing;
        country_pools?: Schemas.legacy$jhs_country_pools;
        created_on?: Schemas.legacy$jhs_timestamp;
        default_pools?: Schemas.legacy$jhs_default_pools;
        description?: Schemas.legacy$jhs_load$balancer_components$schemas$description;
        enabled?: Schemas.legacy$jhs_load$balancer_components$schemas$enabled;
        fallback_pool?: Schemas.legacy$jhs_fallback_pool;
        id?: Schemas.legacy$jhs_load$balancer_components$schemas$identifier;
        location_strategy?: Schemas.legacy$jhs_location_strategy;
        modified_on?: Schemas.legacy$jhs_timestamp;
        name?: Schemas.legacy$jhs_load$balancer_components$schemas$name;
        pop_pools?: Schemas.legacy$jhs_pop_pools;
        proxied?: Schemas.legacy$jhs_proxied;
        random_steering?: Schemas.legacy$jhs_random_steering;
        region_pools?: Schemas.legacy$jhs_region_pools;
        rules?: Schemas.legacy$jhs_components$schemas$rules;
        session_affinity?: Schemas.legacy$jhs_session_affinity;
        session_affinity_attributes?: Schemas.legacy$jhs_session_affinity_attributes;
        session_affinity_ttl?: Schemas.legacy$jhs_session_affinity_ttl;
        steering_policy?: Schemas.legacy$jhs_steering_policy;
        ttl?: Schemas.legacy$jhs_ttl;
    }
    /** Object description. */
    export type legacy$jhs_load$balancer_components$schemas$description = string;
    /** Whether to enable (the default) this load balancer. */
    export type legacy$jhs_load$balancer_components$schemas$enabled = boolean;
    export type legacy$jhs_load$balancer_components$schemas$identifier = any;
    /** The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used. */
    export type legacy$jhs_load$balancer_components$schemas$name = string;
    export type legacy$jhs_load$balancer_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_load$balancer[];
    };
    export type legacy$jhs_load$balancer_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_load$balancer;
    };
    /** Configures load shedding policies and percentages for the pool. */
    export interface legacy$jhs_load_shedding {
        /** The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity. */
        default_percent?: number;
        /** The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs. */
        default_policy?: "random" | "hash";
        /** The percent of existing sessions to shed from the pool, according to the session policy. */
        session_percent?: number;
        /** Only the hash policy is supported for existing sessions (to avoid exponential decay). */
        session_policy?: "hash";
    }
    /** Controls location-based steering for non-proxied requests. See \`steering_policy\` to learn how steering is affected. */
    export interface legacy$jhs_location_strategy {
        /**
         * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
         * - \`"pop"\`: Use the Cloudflare PoP location.
         * - \`"resolver_ip"\`: Use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, use the Cloudflare PoP location.
         */
        mode?: "pop" | "resolver_ip";
        /**
         * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
         * - \`"always"\`: Always prefer ECS.
         * - \`"never"\`: Never prefer ECS.
         * - \`"proximity"\`: Prefer ECS only when \`steering_policy="proximity"\`.
         * - \`"geo"\`: Prefer ECS only when \`steering_policy="geo"\`.
         */
        prefer_ecs?: "always" | "never" | "proximity" | "geo";
    }
    /** An informative summary of the rule. */
    export type legacy$jhs_lockdowns_components$schemas$description = string;
    /** The unique identifier of the Zone Lockdown rule. */
    export type legacy$jhs_lockdowns_components$schemas$id = string;
    /** The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority. */
    export type legacy$jhs_lockdowns_components$schemas$priority = number;
    /** Shows whether a registrar lock is in place for a domain. */
    export type legacy$jhs_locked = boolean;
    /** An object configuring the rule's logging behavior. */
    export interface legacy$jhs_logging {
        /** Whether to generate a log when the rule matches. */
        enabled?: boolean;
    }
    export interface legacy$jhs_login_design {
        /** The background color on your login page. */
        background_color?: string;
        /** The text at the bottom of your login page. */
        footer_text?: string;
        /** The text at the top of your login page. */
        header_text?: string;
        /** The URL of the logo on your login page. */
        logo_path?: string;
        /** The text color on your login page. */
        text_color?: string;
    }
    /** The image URL for the logo shown in the App Launcher dashboard. */
    export type legacy$jhs_logo_url = string;
    /** The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set. */
    export type legacy$jhs_longitude = number;
    /** The device mac address. */
    export type legacy$jhs_mac_address = string;
    /** The device manufacturer name. */
    export type legacy$jhs_manufacturer = string;
    export type legacy$jhs_match = {
        headers?: {
            name?: Schemas.legacy$jhs_header_name;
            op?: Schemas.legacy$jhs_header_op;
            value?: Schemas.legacy$jhs_header_value;
        }[];
        request?: {
            methods?: Schemas.legacy$jhs_methods;
            schemes?: Schemas.legacy$jhs_schemes;
            url?: Schemas.legacy$jhs_schemas$url;
        };
        response?: {
            origin_traffic?: Schemas.legacy$jhs_origin_traffic;
        };
    };
    export interface legacy$jhs_match_item {
        platform?: Schemas.legacy$jhs_platform;
    }
    /** The maximum number of seconds the results of a preflight request can be cached. */
    export type legacy$jhs_max_age = number;
    /** Maximum RTT in ms. */
    export type legacy$jhs_max_rtt_ms = number;
    /** Mean RTT in ms. */
    export type legacy$jhs_mean_rtt_ms = number;
    /** The mechanism to which the notification has been dispatched. */
    export type legacy$jhs_mechanism = string;
    /** The type of mechanism to which the notification has been dispatched. This can be email/pagerduty/webhook based on the mechanism configured. */
    export type legacy$jhs_mechanism_type = "email" | "pagerduty" | "webhook";
    /** List of IDs that will be used when dispatching a notification. IDs for email type will be the email address. */
    export interface legacy$jhs_mechanisms {
    }
    /** Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership. */
    export type legacy$jhs_memberships = Schemas.legacy$jhs_address$maps$membership[];
    export type legacy$jhs_messages = {
        code: number;
        message: string;
    }[];
    /** User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes. */
    export interface legacy$jhs_metadata {
    }
    /** The HTTP method used to access the endpoint. */
    export type legacy$jhs_method = "GET" | "POST" | "HEAD" | "OPTIONS" | "PUT" | "DELETE" | "CONNECT" | "PATCH" | "TRACE";
    /** The HTTP methods to match. You can specify a subset (for example, \`['POST','PUT']\`) or all methods (\`['_ALL_']\`). This field is optional when creating a rate limit. */
    export type legacy$jhs_methods = ("GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "_ALL_")[];
    /** Minimum RTT in ms. */
    export type legacy$jhs_min_rtt_ms = number;
    /** The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool. */
    export type legacy$jhs_minimum_origins = number;
    /** The action to perform. */
    export type legacy$jhs_mode = "simulate" | "ban" | "challenge" | "js_challenge" | "managed_challenge";
    /** When set to \`on\`, the current rule will be used when evaluating the request. Applies to traditional (allow) WAF rules. */
    export type legacy$jhs_mode_allow_traditional = "on" | "off";
    /** When set to \`on\`, the current WAF rule will be used when evaluating the request. Applies to anomaly detection WAF rules. */
    export type legacy$jhs_mode_anomaly = "on" | "off";
    /** The action that the current WAF rule will perform when triggered. Applies to traditional (deny) WAF rules. */
    export type legacy$jhs_mode_deny_traditional = "default" | "disable" | "simulate" | "block" | "challenge";
    /** The device model name. */
    export type legacy$jhs_model = string;
    /** When the Application was last modified. */
    export type legacy$jhs_modified = Date;
    /** Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled. */
    export type legacy$jhs_modified_at_nullable = (Date) | null;
    /** Last time the token was modified. */
    export type legacy$jhs_modified_on = Date;
    /** The number of rules within the group that have been modified from their default configuration. */
    export type legacy$jhs_modified_rules_count = number;
    export interface legacy$jhs_monitor {
        allow_insecure?: Schemas.legacy$jhs_allow_insecure;
        created_on?: Schemas.legacy$jhs_timestamp;
        description?: Schemas.legacy$jhs_monitor_components$schemas$description;
        expected_body?: Schemas.legacy$jhs_expected_body;
        expected_codes?: Schemas.legacy$jhs_expected_codes;
        follow_redirects?: Schemas.legacy$jhs_follow_redirects;
        header?: Schemas.legacy$jhs_header;
        id?: Schemas.legacy$jhs_monitor_components$schemas$identifier;
        interval?: Schemas.legacy$jhs_interval;
        method?: Schemas.legacy$jhs_schemas$method;
        modified_on?: Schemas.legacy$jhs_timestamp;
        path?: Schemas.legacy$jhs_path;
        port?: Schemas.legacy$jhs_schemas$port;
        retries?: Schemas.legacy$jhs_retries;
        timeout?: Schemas.legacy$jhs_schemas$timeout;
        type?: Schemas.legacy$jhs_monitor_components$schemas$type;
    }
    /** Object description. */
    export type legacy$jhs_monitor_components$schemas$description = string;
    export type legacy$jhs_monitor_components$schemas$identifier = any;
    export type legacy$jhs_monitor_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_monitor[];
    };
    export type legacy$jhs_monitor_components$schemas$response_collection$2 = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_components$schemas$monitor[];
    };
    export type legacy$jhs_monitor_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_components$schemas$monitor;
    };
    /** The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'. */
    export type legacy$jhs_monitor_components$schemas$type = "http" | "https" | "tcp" | "udp_icmp" | "icmp_ping" | "smtp";
    export type legacy$jhs_mtls$management_components$schemas$certificate_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_components$schemas$certificateObject[];
    } & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
            total_pages?: any;
        };
    };
    export type legacy$jhs_mtls$management_components$schemas$certificate_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_components$schemas$certificateObject;
    };
    /** When the certificate expires. */
    export type legacy$jhs_mtls$management_components$schemas$expires_on = Date;
    /** Certificate identifier tag. */
    export type legacy$jhs_mtls$management_components$schemas$identifier = string;
    /** Optional unique name for the certificate. Only used for human readability. */
    export type legacy$jhs_mtls$management_components$schemas$name = string;
    /** Certificate deployment status for the given service. */
    export type legacy$jhs_mtls$management_components$schemas$status = string;
    /** This is the time the certificate was uploaded. */
    export type legacy$jhs_mtls$management_components$schemas$uploaded_on = Date;
    /** Token name. */
    export type legacy$jhs_name = string;
    export interface legacy$jhs_node_result {
        asn?: Schemas.legacy$jhs_schemas$asn;
        ip?: Schemas.legacy$jhs_traceroute_components$schemas$ip;
        labels?: Schemas.legacy$jhs_labels;
        max_rtt_ms?: Schemas.legacy$jhs_max_rtt_ms;
        mean_rtt_ms?: Schemas.legacy$jhs_mean_rtt_ms;
        min_rtt_ms?: Schemas.legacy$jhs_min_rtt_ms;
        name?: Schemas.legacy$jhs_traceroute_components$schemas$name;
        packet_count?: Schemas.legacy$jhs_packet_count;
        std_dev_rtt_ms?: Schemas.legacy$jhs_std_dev_rtt_ms;
    }
    /** The time before which the token MUST NOT be accepted for processing. */
    export type legacy$jhs_not_before = Date;
    /** An informative summary of the rule, typically used as a reminder or explanation. */
    export type legacy$jhs_notes = string;
    /** The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list. */
    export type legacy$jhs_notification_email = string;
    /** Filter pool and origin health notifications by resource type or health status. Use null to reset. */
    export type legacy$jhs_notification_filter = {
        origin?: Schemas.legacy$jhs_filter_options;
        pool?: Schemas.legacy$jhs_filter_options;
    } | null;
    /** The number of items in the list. */
    export type legacy$jhs_num_items = number;
    /** The number of [filters](#filters) referencing the list. */
    export type legacy$jhs_num_referencing_filters = number;
    /** When the billing item was created. */
    export type legacy$jhs_occurred_at = Date;
    /**
     * Matches an Okta group.
     * Requires an Okta identity provider.
     */
    export interface legacy$jhs_okta_group_rule {
        okta: {
            /** The ID of your Okta identity provider. */
            connection_id: string;
            /** The email of the Okta group. */
            email: string;
        };
    }
    /** Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled. */
    export type legacy$jhs_on_demand_enabled = boolean;
    /** Whether advertisement status of the prefix is locked, meaning it cannot be changed. */
    export type legacy$jhs_on_demand_locked = boolean;
    /** A OpenAPI 3.0.0 compliant schema. */
    export interface legacy$jhs_openapi {
    }
    /** A OpenAPI 3.0.0 compliant schema. */
    export interface legacy$jhs_openapiwiththresholds {
    }
    export interface legacy$jhs_operation {
        endpoint: Schemas.legacy$jhs_endpoint;
        features?: Schemas.legacy$jhs_features;
        host: Schemas.legacy$jhs_host;
        last_updated: Schemas.legacy$jhs_timestamp;
        method: Schemas.legacy$jhs_method;
        operation_id: Schemas.legacy$jhs_uuid;
    }
    /** The unique operation ID of the asynchronous action. */
    export type legacy$jhs_operation_id = string;
    export type legacy$jhs_organization_invite = Schemas.legacy$jhs_base & {
        /** Current status of two-factor enforcement on the organization. */
        organization_is_enforcing_twofactor?: boolean;
        /** Current status of the invitation. */
        status?: "pending" | "accepted" | "rejected" | "canceled" | "left" | "expired";
    };
    export interface legacy$jhs_organizations {
        auth_domain?: Schemas.legacy$jhs_auth_domain;
        created_at?: Schemas.legacy$jhs_timestamp;
        is_ui_read_only?: Schemas.legacy$jhs_is_ui_read_only;
        login_design?: Schemas.legacy$jhs_login_design;
        name?: Schemas.legacy$jhs_organizations_components$schemas$name;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    /** The name of your Zero Trust organization. */
    export type legacy$jhs_organizations_components$schemas$name = string;
    export type legacy$jhs_organizations_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_organizations;
    };
    /** Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool. */
    export type legacy$jhs_origin_components$schemas$enabled = boolean;
    /** A human-identifiable name for the origin. */
    export type legacy$jhs_origin_components$schemas$name = string;
    /** The name and type of DNS record for the Spectrum application. */
    export interface legacy$jhs_origin_dns {
        name?: Schemas.legacy$jhs_origin_dns_name;
        ttl?: Schemas.legacy$jhs_dns_ttl;
        type?: Schemas.legacy$jhs_origin_dns_type;
    }
    /** The name of the DNS record associated with the origin. */
    export type legacy$jhs_origin_dns_name = string;
    /** The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records. */
    export type legacy$jhs_origin_dns_type = "" | "A" | "AAAA" | "SRV";
    export type legacy$jhs_origin_port = number | string;
    /** Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity. */
    export interface legacy$jhs_origin_steering {
        /** The type of origin steering policy to use, either "random" or "hash" (based on CF-Connecting-IP). */
        policy?: "random" | "hash";
    }
    /**
     * When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
     * Notes: This field is deprecated. Instead, use response headers and set "origin_traffic" to "false" to avoid legacy behaviour interacting with the "response_headers" property.
     */
    export type legacy$jhs_origin_traffic = boolean;
    /** URI to original variant for an image. */
    export type legacy$jhs_original_url = string;
    /** The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. */
    export type legacy$jhs_origins = Schemas.legacy$jhs_schemas$origin[];
    /** The Linux distro name. */
    export type legacy$jhs_os_distro_name = string;
    /** The Linux distro revision. */
    export type legacy$jhs_os_distro_revision = string;
    /** The operating system version. */
    export type legacy$jhs_os_version = string;
    export interface legacy$jhs_override {
        description?: Schemas.legacy$jhs_overrides_components$schemas$description;
        groups?: Schemas.legacy$jhs_groups;
        id?: Schemas.legacy$jhs_overrides_components$schemas$id;
        paused?: Schemas.legacy$jhs_paused;
        priority?: Schemas.legacy$jhs_components$schemas$priority;
        rewrite_action?: Schemas.legacy$jhs_rewrite_action;
        rules?: Schemas.legacy$jhs_rules;
        urls?: Schemas.legacy$jhs_urls;
    }
    export type legacy$jhs_override_codes_response = Schemas.legacy$jhs_api$response$collection & {
        result?: {
            disable_for_time?: Schemas.legacy$jhs_disable_for_time;
        };
    };
    export type legacy$jhs_override_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result: (Schemas.legacy$jhs_override & {})[];
    };
    export type legacy$jhs_override_response_single = Schemas.legacy$jhs_api$response$single & {
        result: Schemas.legacy$jhs_override;
    };
    /** An informative summary of the current URI-based WAF override. */
    export type legacy$jhs_overrides_components$schemas$description = string | null;
    /** The unique identifier of the WAF override. */
    export type legacy$jhs_overrides_components$schemas$id = string;
    export type legacy$jhs_ownership_verification = {
        /** DNS Name for record. */
        name?: string;
        /** DNS Record type. */
        type?: "txt";
        /** Content for the record. */
        value?: string;
    };
    export type legacy$jhs_ownership_verification_http = {
        /** Token to be served. */
        http_body?: string;
        /** The HTTP URL that will be checked during custom hostname verification and where the customer should host the token. */
        http_url?: string;
    };
    /** The p50 quantile of requests (in period_seconds). */
    export type legacy$jhs_p50 = number;
    /** The p90 quantile of requests (in period_seconds). */
    export type legacy$jhs_p90 = number;
    /** The p99 quantile of requests (in period_seconds). */
    export type legacy$jhs_p99 = number;
    export type legacy$jhs_package = Schemas.legacy$jhs_package_definition | Schemas.legacy$jhs_anomaly_package;
    /** A summary of the purpose/function of the WAF package. */
    export type legacy$jhs_package_components$schemas$description = string;
    /** The unique identifier of a WAF package. */
    export type legacy$jhs_package_components$schemas$identifier = string;
    /** The name of the WAF package. */
    export type legacy$jhs_package_components$schemas$name = string;
    /** When set to \`active\`, indicates that the WAF package will be applied to the zone. */
    export type legacy$jhs_package_components$schemas$status = "active";
    export interface legacy$jhs_package_definition {
        description: Schemas.legacy$jhs_package_components$schemas$description;
        detection_mode: Schemas.legacy$jhs_detection_mode;
        id: Schemas.legacy$jhs_package_components$schemas$identifier;
        name: Schemas.legacy$jhs_package_components$schemas$name;
        status?: Schemas.legacy$jhs_package_components$schemas$status;
        zone_id: Schemas.legacy$jhs_common_components$schemas$identifier;
    }
    export type legacy$jhs_package_response_collection = Schemas.legacy$jhs_api$response$collection | {
        result?: Schemas.legacy$jhs_package[];
    };
    export type legacy$jhs_package_response_single = Schemas.legacy$jhs_api$response$single | {
        result?: {};
    };
    /** Number of packets with a response from this node. */
    export type legacy$jhs_packet_count = number;
    /** Number of packets where no response was received. */
    export type legacy$jhs_packets_lost = number;
    /** Number of packets sent with specified TTL. */
    export type legacy$jhs_packets_sent = number;
    /** The time to live (TTL). */
    export type legacy$jhs_packets_ttl = number;
    export interface legacy$jhs_pagerduty {
        id?: Schemas.legacy$jhs_uuid;
        name?: Schemas.legacy$jhs_pagerduty_components$schemas$name;
    }
    /** The name of the pagerduty service. */
    export type legacy$jhs_pagerduty_components$schemas$name = string;
    export type legacy$jhs_pagerduty_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_pagerduty[];
    };
    /** Breakdown of totals for pageviews. */
    export interface legacy$jhs_pageviews {
        /** The total number of pageviews served within the time range. */
        all?: number;
        /** A variable list of key/value pairs representing the search engine and number of hits. */
        search_engine?: {};
    }
    export interface legacy$jhs_parameter_schemas {
        parameter_schemas: {
            last_updated?: Schemas.legacy$jhs_timestamp;
            parameter_schemas?: Schemas.legacy$jhs_parameter_schemas_definition;
        };
    }
    /** An operation schema object containing a response. */
    export interface legacy$jhs_parameter_schemas_definition {
        /** An array containing the learned parameter schemas. */
        readonly parameters?: {}[];
        /** An empty response object. This field is required to yield a valid operation schema. */
        readonly responses?: {};
    }
    export interface legacy$jhs_passive$dns$by$ip {
        /** Total results returned based on your search parameters. */
        count?: number;
        /** Current page within paginated list of results. */
        page?: number;
        /** Number of results per page of results. */
        per_page?: number;
        /** Reverse DNS look-ups observed during the time period. */
        reverse_records?: {
            /** First seen date of the DNS record during the time period. */
            first_seen?: string;
            /** Hostname that the IP was observed resolving to. */
            hostname?: any;
            /** Last seen date of the DNS record during the time period. */
            last_seen?: string;
        }[];
    }
    export type legacy$jhs_passive$dns$by$ip_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_passive$dns$by$ip;
    };
    /** The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors. */
    export type legacy$jhs_path = string;
    /** Route pattern */
    export type legacy$jhs_pattern = string;
    /** When true, indicates that the WAF package is currently paused. */
    export type legacy$jhs_paused = boolean;
    /** The maximum number of bytes to capture. This field only applies to \`full\` packet captures. */
    export type legacy$jhs_pcaps_byte_limit = number;
    export type legacy$jhs_pcaps_collection_response = Schemas.legacy$jhs_api$response$collection & {
        result?: (Schemas.legacy$jhs_pcaps_response_simple | Schemas.legacy$jhs_pcaps_response_full)[];
    };
    /** The name of the data center used for the packet capture. This can be a specific colo (ord02) or a multi-colo name (ORD). This field only applies to \`full\` packet captures. */
    export type legacy$jhs_pcaps_colo_name = string;
    /** The full URI for the bucket. This field only applies to \`full\` packet captures. */
    export type legacy$jhs_pcaps_destination_conf = string;
    /** An error message that describes why the packet capture failed. This field only applies to \`full\` packet captures. */
    export type legacy$jhs_pcaps_error_message = string;
    /** The packet capture filter. When this field is empty, all packets are captured. */
    export interface legacy$jhs_pcaps_filter_v1 {
        /** The destination IP address of the packet. */
        destination_address?: string;
        /** The destination port of the packet. */
        destination_port?: number;
        /** The protocol number of the packet. */
        protocol?: number;
        /** The source IP address of the packet. */
        source_address?: string;
        /** The source port of the packet. */
        source_port?: number;
    }
    /** The ID for the packet capture. */
    export type legacy$jhs_pcaps_id = string;
    /** The ownership challenge filename stored in the bucket. */
    export type legacy$jhs_pcaps_ownership_challenge = string;
    export type legacy$jhs_pcaps_ownership_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_pcaps_ownership_response[] | null;
    };
    export interface legacy$jhs_pcaps_ownership_response {
        destination_conf: Schemas.legacy$jhs_pcaps_destination_conf;
        filename: Schemas.legacy$jhs_pcaps_ownership_challenge;
        /** The bucket ID associated with the packet captures API. */
        id: string;
        /** The status of the ownership challenge. Can be pending, success or failed. */
        status: "pending" | "success" | "failed";
        /** The RFC 3339 timestamp when the bucket was added to packet captures API. */
        submitted: string;
        /** The RFC 3339 timestamp when the bucket was validated. */
        validated?: string;
    }
    export type legacy$jhs_pcaps_ownership_single_response = Schemas.legacy$jhs_api$response$common & {
        result?: Schemas.legacy$jhs_pcaps_ownership_response;
    };
    export interface legacy$jhs_pcaps_response_full {
        byte_limit?: Schemas.legacy$jhs_pcaps_byte_limit;
        colo_name?: Schemas.legacy$jhs_pcaps_colo_name;
        destination_conf?: Schemas.legacy$jhs_pcaps_destination_conf;
        error_message?: Schemas.legacy$jhs_pcaps_error_message;
        filter_v1?: Schemas.legacy$jhs_pcaps_filter_v1;
        id?: Schemas.legacy$jhs_pcaps_id;
        status?: Schemas.legacy$jhs_pcaps_status;
        submitted?: Schemas.legacy$jhs_pcaps_submitted;
        system?: Schemas.legacy$jhs_pcaps_system;
        time_limit?: Schemas.legacy$jhs_pcaps_time_limit;
        type?: Schemas.legacy$jhs_pcaps_type;
    }
    export interface legacy$jhs_pcaps_response_simple {
        filter_v1?: Schemas.legacy$jhs_pcaps_filter_v1;
        id?: Schemas.legacy$jhs_pcaps_id;
        status?: Schemas.legacy$jhs_pcaps_status;
        submitted?: Schemas.legacy$jhs_pcaps_submitted;
        system?: Schemas.legacy$jhs_pcaps_system;
        time_limit?: Schemas.legacy$jhs_pcaps_time_limit;
        type?: Schemas.legacy$jhs_pcaps_type;
    }
    export type legacy$jhs_pcaps_single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_pcaps_response_simple | Schemas.legacy$jhs_pcaps_response_full;
    };
    /** The status of the packet capture request. */
    export type legacy$jhs_pcaps_status = "unknown" | "success" | "pending" | "running" | "conversion_pending" | "conversion_running" | "complete" | "failed";
    /** The RFC 3339 timestamp when the packet capture was created. */
    export type legacy$jhs_pcaps_submitted = string;
    /** The system used to collect packet captures. */
    export type legacy$jhs_pcaps_system = "magic-transit";
    /** The packet capture duration in seconds. */
    export type legacy$jhs_pcaps_time_limit = number;
    /** The type of packet capture. \`Simple\` captures sampled packets, and \`full\` captures entire payloads and non-sampled packets. */
    export type legacy$jhs_pcaps_type = "simple" | "full";
    /** The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action. */
    export type legacy$jhs_period = number;
    /** The period over which this threshold is suggested. */
    export type legacy$jhs_period_seconds = number;
    /** A named group of permissions that map to a group of operations against resources. */
    export interface legacy$jhs_permission_group {
        /** Identifier of the group. */
        readonly id: string;
        /** Name of the group. */
        readonly name?: string;
    }
    /** A set of permission groups that are specified to the policy. */
    export type legacy$jhs_permission_groups = Schemas.legacy$jhs_permission_group[];
    /** The phase of the ruleset. */
    export type legacy$jhs_phase = string;
    export interface legacy$jhs_phishing$url$info {
        /** List of categorizations applied to this submission. */
        categorizations?: {
            /** Name of the category applied. */
            category?: string;
            /** Result of human review for this categorization. */
            verification_status?: string;
        }[];
        /** List of model results for completed scans. */
        model_results?: {
            /** Name of the model. */
            model_name?: string;
            /** Score output by the model for this submission. */
            model_score?: number;
        }[];
        /** List of signatures that matched against site content found when crawling the URL. */
        rule_matches?: {
            /** For internal use. */
            banning?: boolean;
            /** For internal use. */
            blocking?: boolean;
            /** Description of the signature that matched. */
            description?: string;
            /** Name of the signature that matched. */
            name?: string;
        }[];
        /** Status of the most recent scan found. */
        scan_status?: {
            /** Timestamp of when the submission was processed. */
            last_processed?: string;
            /** For internal use. */
            scan_complete?: boolean;
            /** Status code that the crawler received when loading the submitted URL. */
            status_code?: number;
            /** ID of the most recent submission. */
            submission_id?: number;
        };
        /** For internal use. */
        screenshot_download_signature?: string;
        /** For internal use. */
        screenshot_path?: string;
        /** URL that was submitted. */
        url?: string;
    }
    export type legacy$jhs_phishing$url$info_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_phishing$url$info;
    };
    export interface legacy$jhs_phishing$url$submit {
        /** URLs that were excluded from scanning because their domain is in our no-scan list. */
        excluded_urls?: {
            /** URL that was excluded. */
            url?: string;
        }[];
        /** URLs that were skipped because the same URL is currently being scanned */
        skipped_urls?: {
            /** URL that was skipped. */
            url?: string;
            /** ID of the submission of that URL that is currently scanning. */
            url_id?: number;
        }[];
        /** URLs that were successfully submitted for scanning. */
        submitted_urls?: {
            /** URL that was submitted. */
            url?: string;
            /** ID assigned to this URL submission. Used to retrieve scanning results. */
            url_id?: number;
        }[];
    }
    export type legacy$jhs_phishing$url$submit_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_phishing$url$submit;
    };
    export type legacy$jhs_plan_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_schemas$rate$plan[];
    };
    export type legacy$jhs_platform = "windows" | "mac" | "linux" | "android" | "ios";
    /** List of access policies assigned to the token. */
    export type legacy$jhs_policies = Schemas.legacy$jhs_access$policy[];
    /** Optional description for the Notification policy. */
    export type legacy$jhs_policies_components$schemas$description = string;
    /** Whether or not the Notification policy is enabled. */
    export type legacy$jhs_policies_components$schemas$enabled = boolean;
    export type legacy$jhs_policies_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_components$schemas$uuid;
        };
    };
    export type legacy$jhs_policies_components$schemas$id_response$2 = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_uuid;
        };
    };
    /** The name of the Access policy. */
    export type legacy$jhs_policies_components$schemas$name = string;
    /** Name of the policy. */
    export type legacy$jhs_policies_components$schemas$name$2 = string;
    export type legacy$jhs_policies_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_schemas$policies[];
    };
    export type legacy$jhs_policies_components$schemas$response_collection$2 = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_components$schemas$policies[];
    };
    export type legacy$jhs_policies_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_schemas$policies;
    };
    export type legacy$jhs_policies_components$schemas$single_response$2 = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_components$schemas$policies;
    };
    /** Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected. */
    export type legacy$jhs_policy = string;
    export type legacy$jhs_policy_check_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            app_state?: {
                app_uid?: Schemas.legacy$jhs_uuid;
                aud?: string;
                hostname?: string;
                name?: string;
                policies?: {}[];
                status?: string;
            };
            user_identity?: {
                account_id?: string;
                device_sessions?: {};
                email?: string;
                geo?: {
                    country?: string;
                };
                iat?: number;
                id?: string;
                is_gateway?: boolean;
                is_warp?: boolean;
                name?: string;
                user_uuid?: Schemas.legacy$jhs_uuid;
                version?: number;
            };
        };
    };
    export interface legacy$jhs_policy_with_permission_groups {
        effect: Schemas.legacy$jhs_effect;
        id: Schemas.legacy$jhs_identifier;
        permission_groups: Schemas.legacy$jhs_permission_groups;
        resources: Schemas.legacy$jhs_resources;
    }
    export interface legacy$jhs_pool {
        check_regions?: Schemas.legacy$jhs_check_regions;
        created_on?: Schemas.legacy$jhs_timestamp;
        description?: Schemas.legacy$jhs_pool_components$schemas$description;
        disabled_at?: Schemas.legacy$jhs_schemas$disabled_at;
        enabled?: Schemas.legacy$jhs_pool_components$schemas$enabled;
        id?: Schemas.legacy$jhs_pool_components$schemas$identifier;
        latitude?: Schemas.legacy$jhs_latitude;
        load_shedding?: Schemas.legacy$jhs_load_shedding;
        longitude?: Schemas.legacy$jhs_longitude;
        minimum_origins?: Schemas.legacy$jhs_minimum_origins;
        modified_on?: Schemas.legacy$jhs_timestamp;
        monitor?: Schemas.legacy$jhs_schemas$monitor;
        name?: Schemas.legacy$jhs_pool_components$schemas$name;
        notification_email?: Schemas.legacy$jhs_notification_email;
        notification_filter?: Schemas.legacy$jhs_notification_filter;
        origin_steering?: Schemas.legacy$jhs_origin_steering;
        origins?: Schemas.legacy$jhs_origins;
    }
    /** A human-readable description of the pool. */
    export type legacy$jhs_pool_components$schemas$description = string;
    /** Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any). */
    export type legacy$jhs_pool_components$schemas$enabled = boolean;
    export type legacy$jhs_pool_components$schemas$identifier = any;
    /** A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed. */
    export type legacy$jhs_pool_components$schemas$name = string;
    export type legacy$jhs_pool_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_pool[];
    };
    export type legacy$jhs_pool_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_pool;
    };
    /** (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country_pool, then region_pool mapping if it exists else to default_pools. */
    export interface legacy$jhs_pop_pools {
    }
    /** Global Cloudflare 100k ranking for the last 30 days, if available for the hostname. The top ranked domain is 1, the lowest ranked domain is 100,000. */
    export type legacy$jhs_popularity_rank = number;
    /** The keyless SSL port used to commmunicate between Cloudflare and the client's Keyless SSL server. */
    export type legacy$jhs_port = number;
    /** The order of execution for this policy. Must be unique for each policy. */
    export type legacy$jhs_precedence = number;
    /** A predefined entry that matches a profile */
    export interface legacy$jhs_predefined_entry {
        /** Whether the entry is enabled or not. */
        enabled?: boolean;
        id?: Schemas.legacy$jhs_entry_id;
        /** The name of the entry. */
        name?: string;
        /** ID of the parent profile */
        profile_id?: any;
    }
    export interface legacy$jhs_predefined_profile {
        allowed_match_count?: Schemas.legacy$jhs_allowed_match_count;
        /** The entries for this profile. */
        entries?: Schemas.legacy$jhs_predefined_entry[];
        id?: Schemas.legacy$jhs_profile_id;
        /** The name of the profile. */
        name?: string;
        /** The type of the profile. */
        type?: "predefined";
    }
    export type legacy$jhs_predefined_profile_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_predefined_profile;
    };
    export type legacy$jhs_preview_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            pools?: {};
            preview_id?: Schemas.legacy$jhs_monitor_components$schemas$identifier;
        };
    };
    /** The price of the subscription that will be billed, in US dollars. */
    export type legacy$jhs_price = number;
    /** The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates. */
    export type legacy$jhs_priority = number;
    /** The zone's private key. */
    export type legacy$jhs_private_key = string;
    /** Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors. */
    export type legacy$jhs_probe_zone = string;
    export type legacy$jhs_products = ("zoneLockdown" | "uaBlock" | "bic" | "hot" | "securityLevel" | "rateLimit" | "waf")[];
    export type legacy$jhs_profile_id = Schemas.legacy$jhs_uuid;
    export type legacy$jhs_profiles = Schemas.legacy$jhs_predefined_profile | Schemas.legacy$jhs_custom_profile;
    export type legacy$jhs_profiles_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_profiles[];
    };
    /** The port configuration at Cloudflareâ€™s edge. May specify a single port, for example \`"tcp/1000"\`, or a range of ports, for example \`"tcp/1000-2000"\`. */
    export type legacy$jhs_protocol = string;
    /** Whether the hostname should be gray clouded (false) or orange clouded (true). */
    export type legacy$jhs_proxied = boolean;
    /** Enables Proxy Protocol to the origin. Refer to [Enable Proxy protocol](https://developers.cloudflare.com/spectrum/getting-started/proxy-protocol/) for implementation details on PROXY Protocol V1, PROXY Protocol V2, and Simple Proxy Protocol. */
    export type legacy$jhs_proxy_protocol = "off" | "v1" | "v2" | "simple";
    /** The public key to add to your SSH server configuration. */
    export type legacy$jhs_public_key = string;
    /** A custom message that will appear on the purpose justification screen. */
    export type legacy$jhs_purpose_justification_prompt = string;
    /** Require users to enter a justification when they log in to the application. */
    export type legacy$jhs_purpose_justification_required = boolean;
    /** For specifying result metrics. */
    export interface legacy$jhs_query {
        /** Can be used to break down the data by given attributes. */
        dimensions?: string[];
        /**
         * Used to filter rows by one or more dimensions. Filters can be combined using OR and AND boolean logic. AND takes precedence over OR in all the expressions. The OR operator is defined using a comma (,) or OR keyword surrounded by whitespace. The AND operator is defined using a semicolon (;) or AND keyword surrounded by whitespace. Note that the semicolon is a reserved character in URLs (rfc1738) and needs to be percent-encoded as %3B. Comparison options are:
         *
         * Operator                  | Name                            | URL Encoded
         * --------------------------|---------------------------------|--------------------------
         * ==                        | Equals                          | %3D%3D
         * !=                        | Does not equals                 | !%3D
         * >                        | Greater Than                    | %3E
         * <                         | Less Than                       | %3C
         * >=                       | Greater than or equal to        | %3E%3D
         * <=                        | Less than or equal to           | %3C%3D     .
         */
        filters?: string;
        /** Limit number of returned metrics. */
        limit?: number;
        /** One or more metrics to compute. */
        metrics?: string[];
        /** Start of time interval to query, defaults to 6 hours before request received. */
        since?: Date;
        /** Array of dimensions or metrics to sort by, each dimension/metric may be prefixed by - (descending) or + (ascending). */
        sort?: {}[];
        /** End of time interval to query, defaults to current time. */
        until?: Date;
    }
    /** The exact parameters/timestamps the analytics service used to return data. */
    export interface legacy$jhs_query_response {
        since?: Schemas.legacy$jhs_since;
        /** The amount of time (in minutes) that each data point in the timeseries represents. The granularity of the time-series returned (e.g. each bucket in the time series representing 1-minute vs 1-day) is calculated by the API based on the time-range provided to the API. */
        time_delta?: number;
        until?: Schemas.legacy$jhs_until;
    }
    export interface legacy$jhs_quota {
        /** Quantity Allocated. */
        allocated?: number;
        /** Quantity Used. */
        used?: number;
    }
    export type legacy$jhs_r2$single$bucket$operation$response = Schemas.legacy$jhs_api$response$common & {
        result?: {};
    };
    /** Configures pool weights for random steering. When steering_policy is 'random', a random pool is selected with probability proportional to these pool weights. */
    export interface legacy$jhs_random_steering {
        /** The default weight for pools in the load balancer that are not specified in the pool_weights map. */
        default_weight?: number;
        /** A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer. */
        pool_weights?: {};
    }
    export type legacy$jhs_rate$limits = Schemas.legacy$jhs_ratelimit;
    /** The unique identifier of the rate limit. */
    export type legacy$jhs_rate$limits_components$schemas$id = string;
    export interface legacy$jhs_rate$plan {
        components?: Schemas.legacy$jhs_schemas$component_values;
        currency?: Schemas.legacy$jhs_currency;
        duration?: Schemas.legacy$jhs_duration;
        frequency?: Schemas.legacy$jhs_schemas$frequency;
        id?: Schemas.legacy$jhs_rate$plan_components$schemas$identifier;
        name?: Schemas.legacy$jhs_rate$plan_components$schemas$name;
    }
    /** Plan identifier tag. */
    export type legacy$jhs_rate$plan_components$schemas$identifier = string;
    /** The plan name. */
    export type legacy$jhs_rate$plan_components$schemas$name = string;
    /** The rate plan applied to the subscription. */
    export interface legacy$jhs_rate_plan {
        /** The currency applied to the rate plan subscription. */
        currency?: string;
        /** Whether this rate plan is managed externally from Cloudflare. */
        externally_managed?: boolean;
        /** The ID of the rate plan. */
        id?: any;
        /** Whether a rate plan is enterprise-based (or newly adopted term contract). */
        is_contract?: boolean;
        /** The full name of the rate plan. */
        public_name?: string;
        /** The scope that this rate plan applies to. */
        scope?: string;
        /** The list of sets this rate plan applies to. */
        sets?: string[];
    }
    export interface legacy$jhs_ratelimit {
        action?: Schemas.legacy$jhs_schemas$action;
        bypass?: Schemas.legacy$jhs_bypass;
        description?: Schemas.legacy$jhs_components$schemas$description;
        disabled?: Schemas.legacy$jhs_disabled;
        id?: Schemas.legacy$jhs_rate$limits_components$schemas$id;
        match?: Schemas.legacy$jhs_match;
        period?: Schemas.legacy$jhs_period;
        threshold?: Schemas.legacy$jhs_threshold;
    }
    export type legacy$jhs_ratelimit_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_rate$limits[];
    };
    export type legacy$jhs_ratelimit_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** The unique identifier for the request to Cloudflare. */
    export type legacy$jhs_ray_id = string;
    /** Beta flag. Users can create a policy with a mechanism that is not ready, but we cannot guarantee successful delivery of notifications. */
    export type legacy$jhs_ready = boolean;
    /** A short reference tag. Allows you to select related firewall rules. */
    export type legacy$jhs_ref = string;
    export type legacy$jhs_references_response = Schemas.legacy$jhs_api$response$collection & {
        /** List of resources that reference a given monitor. */
        result?: {
            reference_type?: "*" | "referral" | "referrer";
            resource_id?: string;
            resource_name?: string;
            resource_type?: string;
        }[];
    };
    export type legacy$jhs_region_components$schemas$response_collection = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_region_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        /** A list of countries and subdivisions mapped to a region. */
        result?: {};
    };
    /** A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools. */
    export interface legacy$jhs_region_pools {
    }
    export type legacy$jhs_registrant_contact = Schemas.legacy$jhs_contacts;
    /** A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en). */
    export type legacy$jhs_registry_statuses = string;
    /** Client IP restrictions. */
    export interface legacy$jhs_request$ip {
        in?: Schemas.legacy$jhs_cidr_list;
        not_in?: Schemas.legacy$jhs_cidr_list;
    }
    /** Signature type desired on certificate ("origin-rsa" (rsa), "origin-ecc" (ecdsa), or "keyless-certificate" (for Keyless SSL servers). */
    export type legacy$jhs_request_type = "origin-rsa" | "origin-ecc" | "keyless-certificate";
    /** The number of days for which the certificate should be valid. */
    export type legacy$jhs_requested_validity = 7 | 30 | 90 | 365 | 730 | 1095 | 5475;
    /** The estimated number of requests covered by these calculations. */
    export type legacy$jhs_requests = number;
    /** Breakdown of totals for requests. */
    export interface legacy$jhs_requests_by_colo {
        /** Total number of requests served. */
        all?: number;
        /** Total number of cached requests served. */
        cached?: number;
        /** Key/value pairs where the key is a two-digit country code and the value is the number of requests served to that country. */
        country?: {};
        /** A variable list of key/value pairs where the key is a HTTP status code and the value is the number of requests with that code served. */
        http_status?: {};
        /** Total number of requests served from the origin. */
        uncached?: number;
    }
    /** Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. */
    export type legacy$jhs_require = Schemas.legacy$jhs_rule_components$schemas$rule[];
    /** Indicates whether the image can be a accessed only using it's UID. If set to true, a signed token needs to be generated with a signing key to view the image. */
    export type legacy$jhs_requireSignedURLs = boolean;
    export interface legacy$jhs_resolves_to_ref {
        id?: Schemas.legacy$jhs_stix_identifier;
        /** IP address or domain name. */
        value?: string;
    }
    /** Specifies a list of references to one or more IP addresses or domain names that the domain name currently resolves to. */
    export type legacy$jhs_resolves_to_refs = Schemas.legacy$jhs_resolves_to_ref[];
    /** A list of resource names that the policy applies to. */
    export interface legacy$jhs_resources {
    }
    export type legacy$jhs_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_domain$history[];
    };
    export type legacy$jhs_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: {}[];
    };
    export type legacy$jhs_response_create = Schemas.legacy$jhs_api$response$single & {
        result?: {} & {
            value?: Schemas.legacy$jhs_value;
        };
    };
    export type legacy$jhs_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_response_single_origin_dns = Schemas.legacy$jhs_api$response$single & {
        result?: {
            argo_smart_routing?: Schemas.legacy$jhs_argo_smart_routing;
            created_on?: Schemas.legacy$jhs_created;
            dns?: Schemas.legacy$jhs_dns;
            edge_ips?: Schemas.legacy$jhs_edge_ips;
            id?: Schemas.legacy$jhs_app_id;
            ip_firewall?: Schemas.legacy$jhs_ip_firewall;
            modified_on?: Schemas.legacy$jhs_modified;
            origin_dns?: Schemas.legacy$jhs_origin_dns;
            origin_port?: Schemas.legacy$jhs_origin_port;
            protocol?: Schemas.legacy$jhs_protocol;
            proxy_protocol?: Schemas.legacy$jhs_proxy_protocol;
            tls?: Schemas.legacy$jhs_tls;
            traffic_type?: Schemas.legacy$jhs_traffic_type;
        };
    };
    export type legacy$jhs_response_single_segment = Schemas.legacy$jhs_api$response$single & {
        result?: {
            expires_on?: Schemas.legacy$jhs_expires_on;
            id: Schemas.legacy$jhs_components$schemas$identifier;
            not_before?: Schemas.legacy$jhs_not_before;
            status: Schemas.legacy$jhs_status;
        };
    };
    export type legacy$jhs_response_single_value = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_value;
    };
    /** Metrics on Workers KV requests. */
    export interface legacy$jhs_result {
        data: {
            /** List of metrics returned by the query. */
            metrics: {}[];
        }[] | null;
        /** Number of seconds between current time and last processed event, i.e. how many seconds of data could be missing. */
        data_lag: number;
        /** Maximum results for each metric. */
        max: any;
        /** Minimum results for each metric. */
        min: any;
        query: Schemas.legacy$jhs_query;
        /** Total number of rows in the result. */
        rows: number;
        /** Total results for metrics across all data. */
        totals: any;
    }
    export interface legacy$jhs_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. */
    export type legacy$jhs_retries = number;
    /** When the device was revoked. */
    export type legacy$jhs_revoked_at = Date;
    /** Specifies that, when a WAF rule matches, its configured action will be replaced by the action configured in this object. */
    export interface legacy$jhs_rewrite_action {
        block?: Schemas.legacy$jhs_waf_rewrite_action;
        challenge?: any;
        default?: any;
        disable?: Schemas.legacy$jhs_waf_rewrite_action;
        simulate?: any;
    }
    /** Hostname risk score, which is a value between 0 (lowest risk) to 1 (highest risk). */
    export type legacy$jhs_risk_score = number;
    export type legacy$jhs_risk_types = any;
    /** Role identifier tag. */
    export type legacy$jhs_role_components$schemas$identifier = string;
    export type legacy$jhs_route$response$collection = Schemas.legacy$jhs_api$response$common & {
        result?: Schemas.legacy$jhs_routes[];
    };
    export type legacy$jhs_route$response$single = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_routes;
    };
    export type legacy$jhs_route_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export interface legacy$jhs_routes {
        id: Schemas.legacy$jhs_common_components$schemas$identifier;
        pattern: Schemas.legacy$jhs_pattern;
        script: Schemas.legacy$jhs_schemas$script_name;
    }
    export interface legacy$jhs_rule {
        /** The available actions that a rule can apply to a matched request. */
        readonly allowed_modes: Schemas.legacy$jhs_schemas$mode[];
        configuration: Schemas.legacy$jhs_schemas$configuration;
        /** The timestamp of when the rule was created. */
        readonly created_on?: Date;
        id: Schemas.legacy$jhs_rule_components$schemas$identifier;
        mode: Schemas.legacy$jhs_schemas$mode;
        /** The timestamp of when the rule was last modified. */
        readonly modified_on?: Date;
        notes?: Schemas.legacy$jhs_notes;
    }
    export type legacy$jhs_rule_collection_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_rule[];
    };
    export interface legacy$jhs_rule_components$schemas$base {
        description?: Schemas.legacy$jhs_rule_components$schemas$description;
        /** The rule group to which the current WAF rule belongs. */
        readonly group?: {
            id?: Schemas.legacy$jhs_group_components$schemas$identifier;
            name?: Schemas.legacy$jhs_group_components$schemas$name;
        };
        id?: Schemas.legacy$jhs_rule_components$schemas$identifier$2;
        package_id?: Schemas.legacy$jhs_package_components$schemas$identifier;
        priority?: Schemas.legacy$jhs_schemas$priority;
    }
    export type legacy$jhs_rule_components$schemas$base$2 = Schemas.legacy$jhs_rule_components$schemas$base;
    /** The public description of the WAF rule. */
    export type legacy$jhs_rule_components$schemas$description = string;
    /** The unique identifier of the IP Access rule. */
    export type legacy$jhs_rule_components$schemas$identifier = string;
    /** The unique identifier of the WAF rule. */
    export type legacy$jhs_rule_components$schemas$identifier$2 = string;
    export type legacy$jhs_rule_components$schemas$rule = Schemas.legacy$jhs_email_rule | Schemas.legacy$jhs_domain_rule | Schemas.legacy$jhs_everyone_rule | Schemas.legacy$jhs_ip_rule | Schemas.legacy$jhs_ip_list_rule | Schemas.legacy$jhs_certificate_rule | Schemas.legacy$jhs_access_group_rule | Schemas.legacy$jhs_azure_group_rule | Schemas.legacy$jhs_github_organization_rule | Schemas.legacy$jhs_gsuite_group_rule | Schemas.legacy$jhs_okta_group_rule | Schemas.legacy$jhs_saml_group_rule;
    export type legacy$jhs_rule_group_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_schemas$group[];
    };
    export type legacy$jhs_rule_group_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_rule_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_components$schemas$rule[];
    };
    export type legacy$jhs_rule_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_rule_single_id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_rule_components$schemas$identifier;
        };
    };
    export type legacy$jhs_rule_single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_rule;
    };
    /** An object that allows you to override the action of specific WAF rules. Each key of this object must be the ID of a WAF rule, and each value must be a valid WAF action. Unless you are disabling a rule, ensure that you also enable the rule group that this WAF rule belongs to. When creating a new URI-based WAF override, you must provide a \`groups\` object or a \`rules\` object. */
    export interface legacy$jhs_rules {
    }
    /** The action to perform when the rule matches. */
    export type legacy$jhs_rules_components$schemas$action = string;
    /** An informative description of the rule. */
    export type legacy$jhs_rules_components$schemas$description = string;
    /** Whether the rule should be executed. */
    export type legacy$jhs_rules_components$schemas$enabled = boolean;
    /** The unique ID of the rule. */
    export type legacy$jhs_rules_components$schemas$id = string;
    /** A rule object. */
    export interface legacy$jhs_rules_components$schemas$rule {
        action?: Schemas.legacy$jhs_rules_components$schemas$action;
        action_parameters?: Schemas.legacy$jhs_action_parameters;
        categories?: Schemas.legacy$jhs_categories;
        description?: Schemas.legacy$jhs_rules_components$schemas$description;
        enabled?: Schemas.legacy$jhs_rules_components$schemas$enabled;
        expression?: Schemas.legacy$jhs_schemas$expression;
        id?: Schemas.legacy$jhs_rules_components$schemas$id;
        last_updated?: Schemas.legacy$jhs_schemas$last_updated;
        logging?: Schemas.legacy$jhs_logging;
        ref?: Schemas.legacy$jhs_components$schemas$ref;
        version?: Schemas.legacy$jhs_schemas$version;
    }
    /** The number of rules in the current rule group. */
    export type legacy$jhs_rules_count = number;
    /** A ruleset object. */
    export interface legacy$jhs_ruleset {
        description?: Schemas.legacy$jhs_rulesets_components$schemas$description;
        id?: Schemas.legacy$jhs_rulesets_components$schemas$id;
        kind?: Schemas.legacy$jhs_schemas$kind;
        last_updated?: Schemas.legacy$jhs_last_updated;
        name?: Schemas.legacy$jhs_rulesets_components$schemas$name;
        phase?: Schemas.legacy$jhs_phase;
        rules?: Schemas.legacy$jhs_schemas$rules;
        version?: Schemas.legacy$jhs_version;
    }
    export type legacy$jhs_ruleset_response = Schemas.legacy$jhs_api$response$common & {
        result?: Schemas.legacy$jhs_ruleset;
    };
    /** A ruleset object. */
    export interface legacy$jhs_ruleset_without_rules {
        description?: Schemas.legacy$jhs_rulesets_components$schemas$description;
        id?: Schemas.legacy$jhs_rulesets_components$schemas$id;
        kind?: Schemas.legacy$jhs_schemas$kind;
        last_updated?: Schemas.legacy$jhs_last_updated;
        name?: Schemas.legacy$jhs_rulesets_components$schemas$name;
        phase?: Schemas.legacy$jhs_phase;
        version?: Schemas.legacy$jhs_version;
    }
    /** An informative description of the ruleset. */
    export type legacy$jhs_rulesets_components$schemas$description = string;
    /** The unique ID of the ruleset. */
    export type legacy$jhs_rulesets_components$schemas$id = string;
    /** The human-readable name of the ruleset. */
    export type legacy$jhs_rulesets_components$schemas$name = string;
    export type legacy$jhs_rulesets_response = Schemas.legacy$jhs_api$response$common & {
        /** A list of rulesets. The returned information will not include the rules in each ruleset. */
        result?: Schemas.legacy$jhs_ruleset_without_rules[];
    };
    export interface legacy$jhs_saas_app {
        /** The service provider's endpoint that is responsible for receiving and parsing a SAML assertion. */
        consumer_service_url?: string;
        created_at?: Schemas.legacy$jhs_timestamp;
        custom_attributes?: {
            /** The name of the attribute. */
            name?: string;
            /** A globally unique name for an identity or service provider. */
            name_format?: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified" | "urn:oasis:names:tc:SAML:2.0:attrname-format:basic" | "urn:oasis:names:tc:SAML:2.0:attrname-format:uri";
            source?: {
                /** The name of the IdP attribute. */
                name?: string;
            };
        };
        /** The unique identifier for your SaaS application. */
        idp_entity_id?: string;
        /** The format of the name identifier sent to the SaaS application. */
        name_id_format?: "id" | "email";
        /** The Access public certificate that will be used to verify your identity. */
        public_key?: string;
        /** A globally unique name for an identity or service provider. */
        sp_entity_id?: string;
        /** The endpoint where your SaaS application will send login requests. */
        sso_endpoint?: string;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    export interface legacy$jhs_saas_props {
        allowed_idps?: Schemas.legacy$jhs_allowed_idps;
        app_launcher_visible?: Schemas.legacy$jhs_app_launcher_visible;
        auto_redirect_to_identity?: Schemas.legacy$jhs_auto_redirect_to_identity;
        logo_url?: Schemas.legacy$jhs_logo_url;
        name?: Schemas.legacy$jhs_apps_components$schemas$name;
        saas_app?: Schemas.legacy$jhs_saas_app;
        /** The application type. */
        type?: string;
    }
    /** Sets the SameSite cookie setting, which provides increased security against CSRF attacks. */
    export type legacy$jhs_same_site_cookie_attribute = string;
    /**
     * Matches a SAML group.
     * Requires a SAML identity provider.
     */
    export interface legacy$jhs_saml_group_rule {
        saml: {
            /** The name of the SAML attribute. */
            attribute_name: string;
            /** The SAML attribute value to look for. */
            attribute_value: string;
        };
    }
    /** Polling frequency for the WARP client posture check. Default: \`5m\` (poll every five minutes). Minimum: \`1m\`. */
    export type legacy$jhs_schedule = string;
    export type legacy$jhs_schema_response_discovery = Schemas.legacy$jhs_default_response & {
        result?: {
            schemas?: Schemas.legacy$jhs_openapi[];
            timestamp?: string;
        };
    };
    export type legacy$jhs_schema_response_with_thresholds = Schemas.legacy$jhs_default_response & {
        result?: {
            schemas?: Schemas.legacy$jhs_openapiwiththresholds[];
            timestamp?: string;
        };
    };
    export type legacy$jhs_schemas$action = {
        mode?: Schemas.legacy$jhs_mode;
        response?: Schemas.legacy$jhs_custom_response;
        timeout?: Schemas.legacy$jhs_timeout;
    };
    /** Address. */
    export type legacy$jhs_schemas$address = string;
    /** Enablement of prefix advertisement to the Internet. */
    export type legacy$jhs_schemas$advertised = boolean;
    /** Type of notification that has been dispatched. */
    export type legacy$jhs_schemas$alert_type = string;
    /** The result of the authentication event. */
    export type legacy$jhs_schemas$allowed = boolean;
    /** Displays the application in the App Launcher. */
    export type legacy$jhs_schemas$app_launcher_visible = boolean;
    export type legacy$jhs_schemas$apps = (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_self_hosted_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_saas_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_ssh_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_vnc_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_app_launcher_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_warp_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_biso_props) | (Schemas.legacy$jhs_basic_app_response_props & Schemas.legacy$jhs_schemas$bookmark_props);
    /** AS number associated with the node object. */
    export type legacy$jhs_schemas$asn = string;
    /** Audience tag. */
    export type legacy$jhs_schemas$aud = string;
    /** Shows if a domain is available for transferring into Cloudflare Registrar. */
    export type legacy$jhs_schemas$available = boolean;
    export interface legacy$jhs_schemas$base {
        /** Identifier of the zone setting. */
        id: string;
        /** last time this setting was modified. */
        readonly modified_on: Date;
    }
    export interface legacy$jhs_schemas$bookmark_props {
        app_launcher_visible?: any;
        /** The URL or domain of the bookmark. */
        domain?: any;
        logo_url?: Schemas.legacy$jhs_logo_url;
        name?: Schemas.legacy$jhs_apps_components$schemas$name;
        /** The application type. */
        type?: string;
    }
    export interface legacy$jhs_schemas$ca {
        aud?: Schemas.legacy$jhs_aud;
        id?: Schemas.legacy$jhs_ca_components$schemas$id;
        public_key?: Schemas.legacy$jhs_public_key;
    }
    /** Controls whether the membership can be deleted via the API or not. */
    export type legacy$jhs_schemas$can_delete = boolean;
    /** The Certificate Authority that Total TLS certificates will be issued through. */
    export type legacy$jhs_schemas$certificate_authority = "google" | "lets_encrypt";
    export type legacy$jhs_schemas$certificate_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_certificates[];
    };
    export type legacy$jhs_schemas$certificate_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export interface legacy$jhs_schemas$certificateObject {
        certificate?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$certificate;
        expires_on?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$expires_on;
        id?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$identifier;
        issuer?: Schemas.legacy$jhs_issuer;
        serial_number?: Schemas.legacy$jhs_serial_number;
        signature?: Schemas.legacy$jhs_signature;
        status?: Schemas.legacy$jhs_hostname$authenticated$origin$pull_components$schemas$status;
        uploaded_on?: Schemas.legacy$jhs_components$schemas$uploaded_on;
    }
    /** The uploaded root CA certificate. */
    export type legacy$jhs_schemas$certificates = string;
    export interface legacy$jhs_schemas$cidr_configuration {
        /** The configuration target. You must set the target to \`ip_range\` when specifying an IP address range in the Zone Lockdown rule. */
        target?: "ip_range";
        /** The IP address range to match. You can only use prefix lengths \`/16\` and \`/24\`. */
        value?: string;
    }
    export type legacy$jhs_schemas$collection_invite_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_schemas$invite[];
    };
    export type legacy$jhs_schemas$collection_response = Schemas.legacy$jhs_api$response$collection & {
        result?: {
            additional_information?: Schemas.legacy$jhs_additional_information;
            application?: Schemas.legacy$jhs_application;
            content_categories?: Schemas.legacy$jhs_content_categories;
            domain?: Schemas.legacy$jhs_schemas$domain_name;
            popularity_rank?: Schemas.legacy$jhs_popularity_rank;
            risk_score?: Schemas.legacy$jhs_risk_score;
            risk_types?: Schemas.legacy$jhs_risk_types;
        }[];
    };
    /** Optional remark describing the virtual network. */
    export type legacy$jhs_schemas$comment = string;
    /** Array of available components values for the plan. */
    export type legacy$jhs_schemas$component_values = Schemas.legacy$jhs_component$value[];
    /** The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/). */
    export interface legacy$jhs_schemas$config {
    }
    export type legacy$jhs_schemas$config_response = Schemas.legacy$jhs_tls_config_response;
    export type legacy$jhs_schemas$configuration = Schemas.legacy$jhs_ip_configuration | Schemas.legacy$jhs_ipv6_configuration | Schemas.legacy$jhs_cidr_configuration | Schemas.legacy$jhs_asn_configuration | Schemas.legacy$jhs_country_configuration;
    /** The IdP used to authenticate. */
    export type legacy$jhs_schemas$connection = string;
    /** When the device was created. */
    export type legacy$jhs_schemas$created = Date;
    /** The time when the certificate was created. */
    export type legacy$jhs_schemas$created_at = Date;
    /** The RFC 3339 timestamp of when the list was created. */
    export type legacy$jhs_schemas$created_on = string;
    /** Whether the policy is the default policy for an account. */
    export type legacy$jhs_schemas$default = boolean;
    /** True if the device was deleted. */
    export type legacy$jhs_schemas$deleted = boolean;
    /** The billing item description. */
    export type legacy$jhs_schemas$description = string;
    /** A string to search for in the description of existing rules. */
    export type legacy$jhs_schemas$description_search = string;
    /** This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at. */
    export type legacy$jhs_schemas$disabled_at = Date;
    /** The domain and path that Access will secure. */
    export type legacy$jhs_schemas$domain = string;
    /** Domain identifier. */
    export type legacy$jhs_schemas$domain_identifier = string;
    export type legacy$jhs_schemas$domain_name = string;
    /** The email address of the authenticating user. */
    export type legacy$jhs_schemas$email = string;
    export type legacy$jhs_schemas$empty_response = {
        result?: any | null;
        success?: true | false;
    };
    /**
     * Disabling Universal SSL removes any currently active Universal SSL certificates for your zone from the edge and prevents any future Universal SSL certificates from being ordered. If there are no advanced certificates or custom certificates uploaded for the domain, visitors will be unable to access the domain over HTTPS.
     *
     * By disabling Universal SSL, you understand that the following Cloudflare settings and preferences will result in visitors being unable to visit your domain unless you have uploaded a custom certificate or purchased an advanced certificate.
     *
     * * HSTS
     * * Always Use HTTPS
     * * Opportunistic Encryption
     * * Onion Routing
     * * Any Page Rules redirecting traffic to HTTPS
     *
     * Similarly, any HTTP redirect to HTTPS at the origin while the Cloudflare proxy is enabled will result in users being unable to visit your site without a valid certificate at Cloudflare's edge.
     *
     * If you do not have a valid custom or advanced certificate at Cloudflare's edge and are unsure if any of the above Cloudflare settings are enabled, or if any HTTP redirects exist at your origin, we advise leaving Universal SSL enabled for your domain.
     */
    export type legacy$jhs_schemas$enabled = boolean;
    /** Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. */
    export type legacy$jhs_schemas$exclude = Schemas.legacy$jhs_rule_components$schemas$rule[];
    /** The expected HTTP response codes or code ranges of the health check, comma-separated. This parameter is only valid for HTTP and HTTPS monitors. */
    export type legacy$jhs_schemas$expected_codes = string;
    /** Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client. */
    export type legacy$jhs_schemas$expiration = string;
    /** When the invite is no longer active. */
    export type legacy$jhs_schemas$expires_on = Date;
    /** The expression defining which traffic will match the rule. */
    export type legacy$jhs_schemas$expression = string;
    export type legacy$jhs_schemas$filter$response$collection = Schemas.legacy$jhs_api$response$collection & {
        result?: (Schemas.legacy$jhs_filter & {})[];
    };
    export type legacy$jhs_schemas$filter$response$single = Schemas.legacy$jhs_api$response$single & {
        result: (Schemas.legacy$jhs_filter & {}) | (any | null);
    };
    /** Format of additional configuration options (filters) for the alert type. Data type of filters during policy creation: Array of strings. */
    export type legacy$jhs_schemas$filter_options = {}[];
    export interface legacy$jhs_schemas$filters {
        /** The target to search in existing rules. */
        "configuration.target"?: "ip" | "ip_range" | "asn" | "country";
        /**
         * The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided \`configuration.target\`.
         * Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
         */
        "configuration.value"?: string;
        /** When set to \`all\`, all the search requirements must match. When set to \`any\`, only one of the search requirements has to match. */
        match?: "any" | "all";
        mode?: Schemas.legacy$jhs_schemas$mode;
        /**
         * The string to search for in the notes of existing IP Access rules.
         * Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
         */
        notes?: string;
    }
    /** The frequency at which you will be billed for this plan. */
    export type legacy$jhs_schemas$frequency = "weekly" | "monthly" | "quarterly" | "yearly";
    export type legacy$jhs_schemas$group = Schemas.legacy$jhs_group & {
        allowed_modes?: Schemas.legacy$jhs_allowed_modes;
        mode?: Schemas.legacy$jhs_components$schemas$mode;
    };
    export interface legacy$jhs_schemas$groups {
        created_at?: Schemas.legacy$jhs_timestamp;
        exclude?: Schemas.legacy$jhs_exclude;
        id?: Schemas.legacy$jhs_schemas$uuid;
        include?: Schemas.legacy$jhs_include;
        name?: Schemas.legacy$jhs_groups_components$schemas$name;
        require?: Schemas.legacy$jhs_require;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    /** The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'. */
    export interface legacy$jhs_schemas$header {
        Host?: Schemas.legacy$jhs_Host;
    }
    /** The keyless SSL name. */
    export type legacy$jhs_schemas$host = string;
    /** The hostname on the origin for which the client certificate uploaded will be used. */
    export type legacy$jhs_schemas$hostname = string;
    /** Comma separated list of valid host names for the certificate packs. Must contain the zone apex, may not contain more than 50 hosts, and may not be empty. */
    export type legacy$jhs_schemas$hosts = string[];
    export type legacy$jhs_schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_pool_components$schemas$identifier;
        };
    };
    export type legacy$jhs_schemas$identifier = any;
    export type legacy$jhs_schemas$include = Schemas.legacy$jhs_split_tunnel_include[];
    /** The interval between each posture check with the third party API. Use "m" for minutes (e.g. "5m") and "h" for hours (e.g. "12h"). */
    export type legacy$jhs_schemas$interval = string;
    export type legacy$jhs_schemas$invite = Schemas.legacy$jhs_user_invite;
    /** The IP address of the authenticating user. */
    export type legacy$jhs_schemas$ip = string;
    export interface legacy$jhs_schemas$ip_configuration {
        /** The configuration target. You must set the target to \`ip\` when specifying an IP address in the Zone Lockdown rule. */
        target?: "ip";
        /** The IP address to match. This address will be compared to the IP address of incoming requests. */
        value?: string;
    }
    /** The certificate authority that issued the certificate. */
    export type legacy$jhs_schemas$issuer = string;
    /** The device's public key. */
    export type legacy$jhs_schemas$key = string;
    /** The kind of the ruleset. */
    export type legacy$jhs_schemas$kind = "custom" | "root" | "zone";
    /** The timestamp of when the rule was last modified. */
    export type legacy$jhs_schemas$last_updated = string;
    /** The conditions that the client must match to run the rule. */
    export type legacy$jhs_schemas$match = Schemas.legacy$jhs_match_item[];
    /** The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks. */
    export type legacy$jhs_schemas$method = string;
    /** The action to apply to a matched request. */
    export type legacy$jhs_schemas$mode = "block" | "challenge" | "whitelist" | "js_challenge" | "managed_challenge";
    /** When the certificate was last modified. */
    export type legacy$jhs_schemas$modified_on = Date;
    /** The ID of the Monitor to use for checking the health of origins within this pool. */
    export type legacy$jhs_schemas$monitor = any;
    export interface legacy$jhs_schemas$operation {
        /** The RFC 3339 timestamp of when the operation was completed. */
        readonly completed?: string;
        /** A message describing the error when the status is \`failed\`. */
        readonly error?: string;
        id: Schemas.legacy$jhs_operation_id;
        /** The current status of the asynchronous operation. */
        readonly status: "pending" | "running" | "completed" | "failed";
    }
    /** Name of organization. */
    export type legacy$jhs_schemas$organization = string;
    export interface legacy$jhs_schemas$origin {
        address?: Schemas.legacy$jhs_address;
        disabled_at?: Schemas.legacy$jhs_disabled_at;
        enabled?: Schemas.legacy$jhs_origin_components$schemas$enabled;
        header?: Schemas.legacy$jhs_schemas$header;
        name?: Schemas.legacy$jhs_origin_components$schemas$name;
        virtual_network_id?: Schemas.legacy$jhs_virtual_network_id;
        weight?: Schemas.legacy$jhs_weight;
    }
    /** Filter pattern */
    export type legacy$jhs_schemas$pattern = string;
    /** When true, indicates that the rule is currently paused. */
    export type legacy$jhs_schemas$paused = boolean;
    /** Access permissions for this User. */
    export type legacy$jhs_schemas$permissions = string[];
    export interface legacy$jhs_schemas$policies {
        approval_groups?: Schemas.legacy$jhs_approval_groups;
        approval_required?: Schemas.legacy$jhs_approval_required;
        created_at?: Schemas.legacy$jhs_timestamp;
        decision?: Schemas.legacy$jhs_decision;
        exclude?: Schemas.legacy$jhs_schemas$exclude;
        id?: Schemas.legacy$jhs_components$schemas$uuid;
        include?: Schemas.legacy$jhs_include;
        name?: Schemas.legacy$jhs_policies_components$schemas$name;
        precedence?: Schemas.legacy$jhs_precedence;
        purpose_justification_prompt?: Schemas.legacy$jhs_purpose_justification_prompt;
        purpose_justification_required?: Schemas.legacy$jhs_purpose_justification_required;
        require?: Schemas.legacy$jhs_schemas$require;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    /** Port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443). */
    export type legacy$jhs_schemas$port = number;
    /** The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field. */
    export type legacy$jhs_schemas$precedence = number;
    /** The order in which the individual WAF rule is executed within its rule group. */
    export type legacy$jhs_schemas$priority = string;
    /** The hostname certificate's private key. */
    export type legacy$jhs_schemas$private_key = string;
    export type legacy$jhs_schemas$rate$plan = Schemas.legacy$jhs_rate$plan;
    /** A short reference tag. Allows you to select related filters. */
    export type legacy$jhs_schemas$ref = string;
    export type legacy$jhs_schemas$references_response = Schemas.legacy$jhs_api$response$collection & {
        /** List of resources that reference a given pool. */
        result?: {
            reference_type?: "*" | "referral" | "referrer";
            resource_id?: string;
            resource_name?: string;
            resource_type?: string;
        }[];
    };
    /** Breakdown of totals for requests. */
    export interface legacy$jhs_schemas$requests {
        /** Total number of requests served. */
        all?: number;
        /** Total number of cached requests served. */
        cached?: number;
        /** A variable list of key/value pairs where the key represents the type of content served, and the value is the number of requests. */
        content_type?: {};
        /** A variable list of key/value pairs where the key is a two-digit country code and the value is the number of requests served to that country. */
        country?: {};
        /** Key/value pairs where the key is a HTTP status code and the value is the number of requests served with that code. */
        http_status?: {};
        /** A break down of requests served over HTTPS. */
        ssl?: {
            /** The number of requests served over HTTPS. */
            encrypted?: number;
            /** The number of requests served over HTTP. */
            unencrypted?: number;
        };
        /** A breakdown of requests by their SSL protocol. */
        ssl_protocols?: {
            /** The number of requests served over TLS v1.0. */
            TLSv1?: number;
            /** The number of requests served over TLS v1.1. */
            "TLSv1.1"?: number;
            /** The number of requests served over TLS v1.2. */
            "TLSv1.2"?: number;
            /** The number of requests served over TLS v1.3. */
            "TLSv1.3"?: number;
            /** The number of requests served over HTTP. */
            none?: number;
        };
        /** Total number of requests served from the origin. */
        uncached?: number;
    }
    /** Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. */
    export type legacy$jhs_schemas$require = Schemas.legacy$jhs_rule_components$schemas$rule[];
    export type legacy$jhs_schemas$response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_ip_components$schemas$ip[];
    };
    export type legacy$jhs_schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: {}[];
    };
    export type legacy$jhs_schemas$response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_schemas$result = Schemas.legacy$jhs_result & {
        data?: any;
        max?: any;
        min?: any;
        query?: Schemas.legacy$jhs_query;
        totals?: any;
    };
    export interface legacy$jhs_schemas$role {
        description: Schemas.legacy$jhs_description;
        id: Schemas.legacy$jhs_role_components$schemas$identifier;
        name: Schemas.legacy$jhs_components$schemas$name;
        permissions: Schemas.legacy$jhs_schemas$permissions;
    }
    export type legacy$jhs_schemas$rule = Schemas.legacy$jhs_rule & {
        /** All zones owned by the user will have the rule applied. */
        readonly scope?: {
            email?: Schemas.legacy$jhs_email;
            id?: Schemas.legacy$jhs_common_components$schemas$identifier;
            /** The scope of the rule. */
            readonly type?: "user" | "organization";
        };
    };
    /** The list of rules in the ruleset. */
    export type legacy$jhs_schemas$rules = Schemas.legacy$jhs_rules_components$schemas$rule[];
    /** Name of the script to apply when the route is matched. The route is skipped when this is blank/missing. */
    export type legacy$jhs_schemas$script_name = string;
    /** The certificate serial number. */
    export type legacy$jhs_schemas$serial_number = string;
    /** Worker service associated with the zone and hostname. */
    export type legacy$jhs_schemas$service = string;
    /** Certificate's signature algorithm. */
    export type legacy$jhs_schemas$signature = "ECDSAWithSHA256" | "SHA1WithRSA" | "SHA256WithRSA";
    export type legacy$jhs_schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_api$shield;
    };
    /** The timeout (in seconds) before marking the health check as failed. */
    export type legacy$jhs_schemas$timeout = number;
    export type legacy$jhs_schemas$token = Schemas.legacy$jhs_token;
    /** The type of characteristic. */
    export type legacy$jhs_schemas$type = "header" | "cookie";
    /** End of time interval to query, defaults to current time. Timestamp must be in RFC3339 format and uses UTC unless otherwise specified. */
    export type legacy$jhs_schemas$until = Date;
    /** This is the time the certificate was updated. */
    export type legacy$jhs_schemas$updated_at = Date;
    /** This is the time the certificate was uploaded. */
    export type legacy$jhs_schemas$uploaded_on = Date;
    /** The URL pattern to match, composed of a host and a path such as \`example.org/path*\`. Normalization is applied before the pattern is matched. \`*\` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to \`*\` to match all traffic to your zone. */
    export type legacy$jhs_schemas$url = string;
    /** The URLs to include in the rule definition. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns. */
    export type legacy$jhs_schemas$urls = string[];
    /** The unique identifier for the Access group. */
    export type legacy$jhs_schemas$uuid = any;
    /** Validation method in use for a certificate pack order. */
    export type legacy$jhs_schemas$validation_method = "http" | "cname" | "txt";
    /** The validity period in days for the certificates ordered via Total TLS. */
    export type legacy$jhs_schemas$validity_days = 90;
    /** Object specifying available variants for an image. */
    export type legacy$jhs_schemas$variants = (Schemas.legacy$jhs_thumbnail_url | Schemas.legacy$jhs_hero_url | Schemas.legacy$jhs_original_url)[];
    /** The version of the rule. */
    export type legacy$jhs_schemas$version = string;
    export interface legacy$jhs_schemas$zone {
        readonly name?: any;
    }
    /** The HTTP schemes to match. You can specify one scheme (\`['HTTPS']\`), both schemes (\`['HTTP','HTTPS']\`), or all schemes (\`['_ALL_']\`). This field is optional. */
    export type legacy$jhs_schemes = string[];
    export type legacy$jhs_script$response$collection = Schemas.legacy$jhs_api$response$common & {
        result?: {
            readonly created_on?: any;
            readonly etag?: any;
            readonly id?: any;
            readonly modified_on?: any;
            readonly usage_model?: any;
        }[];
    };
    export type legacy$jhs_script$response$single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** Optional secret that will be passed in the \`cf-webhook-auth\` header when dispatching a webhook notification. Secrets are not returned in any API response body. */
    export type legacy$jhs_secret = string;
    export interface legacy$jhs_self_hosted_props {
        allowed_idps?: Schemas.legacy$jhs_allowed_idps;
        app_launcher_visible?: Schemas.legacy$jhs_app_launcher_visible;
        auto_redirect_to_identity?: Schemas.legacy$jhs_auto_redirect_to_identity;
        cors_headers?: Schemas.legacy$jhs_cors_headers;
        custom_deny_message?: Schemas.legacy$jhs_custom_deny_message;
        custom_deny_url?: Schemas.legacy$jhs_custom_deny_url;
        domain?: Schemas.legacy$jhs_schemas$domain;
        enable_binding_cookie?: Schemas.legacy$jhs_enable_binding_cookie;
        http_only_cookie_attribute?: Schemas.legacy$jhs_http_only_cookie_attribute;
        logo_url?: Schemas.legacy$jhs_logo_url;
        name?: Schemas.legacy$jhs_apps_components$schemas$name;
        same_site_cookie_attribute?: Schemas.legacy$jhs_same_site_cookie_attribute;
        service_auth_401_redirect?: Schemas.legacy$jhs_service_auth_401_redirect;
        session_duration?: Schemas.legacy$jhs_session_duration;
        skip_interstitial?: Schemas.legacy$jhs_skip_interstitial;
        /** The application type. */
        type?: string;
    }
    /** The sensitivity of the WAF package. */
    export type legacy$jhs_sensitivity = "high" | "medium" | "low" | "off";
    /** Timestamp of when the notification was dispatched in ISO 8601 format. */
    export type legacy$jhs_sent = Date;
    /** The serial number on the uploaded certificate. */
    export type legacy$jhs_serial_number = string;
    /** The service using the certificate. */
    export type legacy$jhs_service = string;
    export interface legacy$jhs_service$tokens {
        client_id?: Schemas.legacy$jhs_client_id;
        created_at?: Schemas.legacy$jhs_timestamp;
        /** The ID of the service token. */
        id?: any;
        name?: Schemas.legacy$jhs_service$tokens_components$schemas$name;
        updated_at?: Schemas.legacy$jhs_timestamp;
    }
    /** The name of the service token. */
    export type legacy$jhs_service$tokens_components$schemas$name = string;
    export type legacy$jhs_service$tokens_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_service$tokens[];
    };
    export type legacy$jhs_service$tokens_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_service$tokens;
    };
    /** Returns a 401 status code when the request is blocked by a Service Auth policy. */
    export type legacy$jhs_service_auth_401_redirect = boolean;
    export interface legacy$jhs_service_mode_v2 {
        /** The mode to run the WARP client under. */
        mode?: string;
        /** The port number when used with proxy mode. */
        port?: number;
    }
    /** The session_affinity specifies the type of session affinity the load balancer should use unless specified as "none" or ""(default). The supported types are "cookie" and "ip_cookie". "cookie" - On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. "ip_cookie" behaves the same as "cookie" except the initial origin selection is stable and based on the clientâ€™s ip address. */
    export type legacy$jhs_session_affinity = "none" | "cookie" | "ip_cookie" | "\\"\\"";
    /** Configures cookie attributes for session affinity cookie. */
    export interface legacy$jhs_session_affinity_attributes {
        /** Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. */
        drain_duration?: number;
        /** Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never". */
        samesite?: "Auto" | "Lax" | "None" | "Strict";
        /** Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled. */
        secure?: "Auto" | "Always" | "Never";
        /** Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value "none" means no failover takes place for sessions pinned to the origin (default). Value "temporary" means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value "sticky" means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. */
        zero_downtime_failover?: "none" | "temporary" | "sticky";
    }
    /** Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of 23 hours will be used unless session_affinity_ttl is explicitly set. The accepted range of values is between [1800, 604800]. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. */
    export type legacy$jhs_session_affinity_ttl = number;
    /** The amount of time that tokens issued for this application will be valid. Must be in the format \`300ms\` or \`2h45m\`. Valid time units are: ns, us (or Âµs), ms, s, m, h. */
    export type legacy$jhs_session_duration = string;
    /** The type of hash used for the certificate. */
    export type legacy$jhs_signature = string;
    export type legacy$jhs_since = string | number;
    export type legacy$jhs_single_invite_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_single_member_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_single_membership_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_single_organization_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_configuration;
    };
    export type legacy$jhs_single_role_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export type legacy$jhs_single_user_response = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** Enables automatic authentication through cloudflared. */
    export type legacy$jhs_skip_interstitial = boolean;
    /** The sort order for the result set; sort fields must be included in \`metrics\` or \`dimensions\`. */
    export type legacy$jhs_sort = {}[];
    export interface legacy$jhs_split_tunnel {
        /** The address in CIDR format to exclude from the tunnel. If address is present, host must not be present. */
        address: string;
        /** A description of the split tunnel item, displayed in the client UI. */
        description: string;
        /** The domain name to exclude from the tunnel. If host is present, address must not be present. */
        host?: string;
    }
    export interface legacy$jhs_split_tunnel_include {
        /** The address in CIDR format to include in the tunnel. If address is present, host must not be present. */
        address: string;
        /** A description of the split tunnel item, displayed in the client UI. */
        description: string;
        /** The domain name to include in the tunnel. If host is present, address must not be present. */
        host?: string;
    }
    export type legacy$jhs_split_tunnel_include_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_split_tunnel_include[];
    };
    export type legacy$jhs_split_tunnel_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_split_tunnel[];
    };
    export type legacy$jhs_ssh_props = Schemas.legacy$jhs_self_hosted_props & {
        /** The application type. */
        type?: string;
    };
    export type legacy$jhs_ssl = {
        /** A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. */
        bundle_method?: "ubiquitous" | "optimal" | "force";
        /** The Certificate Authority that has issued this certificate. */
        certificate_authority?: "digicert" | "google" | "lets_encrypt";
        /** If a custom uploaded certificate is used. */
        custom_certificate?: string;
        /** The identifier for the Custom CSR that was used. */
        custom_csr_id?: string;
        /** The key for a custom uploaded certificate. */
        custom_key?: string;
        /** The time the custom certificate expires on. */
        expires_on?: Date;
        /** A list of Hostnames on a custom uploaded certificate. */
        hosts?: {}[];
        /** Custom hostname SSL identifier tag. */
        id?: string;
        /** The issuer on a custom uploaded certificate. */
        issuer?: string;
        /** Domain control validation (DCV) method used for this hostname. */
        method?: "http" | "txt" | "email";
        /** The serial number on a custom uploaded certificate. */
        serial_number?: string;
        settings?: Schemas.legacy$jhs_sslsettings;
        /** The signature on a custom uploaded certificate. */
        signature?: string;
        /** Status of the hostname's SSL certificates. */
        readonly status?: "initializing" | "pending_validation" | "deleted" | "pending_issuance" | "pending_deployment" | "pending_deletion" | "pending_expiration" | "expired" | "active" | "initializing_timed_out" | "validation_timed_out" | "issuance_timed_out" | "deployment_timed_out" | "deletion_timed_out" | "pending_cleanup" | "staging_deployment" | "staging_active" | "deactivating" | "inactive" | "backup_issued" | "holding_deployment";
        /** Level of validation to be used for this hostname. Domain validation (dv) must be used. */
        readonly type?: "dv";
        /** The time the custom certificate was uploaded. */
        uploaded_on?: Date;
        /** Domain validation errors that have been received by the certificate authority (CA). */
        validation_errors?: {
            /** A domain validation error. */
            message?: string;
        }[];
        validation_records?: Schemas.legacy$jhs_validation_record[];
        /** Indicates whether the certificate covers a wildcard. */
        wildcard?: boolean;
    };
    export type legacy$jhs_ssl$recommender_components$schemas$value = "flexible" | "full" | "strict";
    export type legacy$jhs_ssl_universal_settings_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_universal;
    };
    export type legacy$jhs_ssl_validation_method_response_collection = Schemas.legacy$jhs_api$response$single & {
        result?: {
            status?: Schemas.legacy$jhs_validation_method_components$schemas$status;
            validation_method?: Schemas.legacy$jhs_validation_method_definition;
        };
    };
    export type legacy$jhs_ssl_verification_response_collection = {
        result?: Schemas.legacy$jhs_verification[];
    };
    /** SSL specific settings. */
    export interface legacy$jhs_sslsettings {
        /** An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format. */
        ciphers?: string[];
        /** Whether or not Early Hints is enabled. */
        early_hints?: "on" | "off";
        /** Whether or not HTTP2 is enabled. */
        http2?: "on" | "off";
        /** The minimum TLS version supported. */
        min_tls_version?: "1.0" | "1.1" | "1.2" | "1.3";
        /** Whether or not TLS 1.3 is enabled. */
        tls_1_3?: "on" | "off";
    }
    /** The state that the subscription is in. */
    export type legacy$jhs_state = "Trial" | "Provisioned" | "Paid" | "AwaitingPayment" | "Cancelled" | "Failed" | "Expired";
    /** Status of the token. */
    export type legacy$jhs_status = "active" | "disabled" | "expired";
    /** Standard deviation of the RTTs in ms. */
    export type legacy$jhs_std_dev_rtt_ms = number;
    /**
     * Steering Policy for this load balancer.
     * - \`"off"\`: Use \`default_pools\`.
     * - \`"geo"\`: Use \`region_pools\`/\`country_pools\`/\`pop_pools\`. For non-proxied requests, the country for \`country_pools\` is determined by \`location_strategy\`.
     * - \`"random"\`: Select a pool randomly.
     * - \`"dynamic_latency"\`: Use round trip time to select the closest pool in default_pools (requires pool health checks).
     * - \`"proximity"\`: Use the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by \`location_strategy\` for non-proxied requests.
     * - \`""\`: Will map to \`"geo"\` if you use \`region_pools\`/\`country_pools\`/\`pop_pools\` otherwise \`"off"\`.
     */
    export type legacy$jhs_steering_policy = "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "\\"\\"";
    /** STIX 2.1 identifier: https://docs.oasis-open.org/cti/stix/v2.1/cs02/stix-v2.1-cs02.html#_64yvzeku5a5c */
    export type legacy$jhs_stix_identifier = string;
    export type legacy$jhs_subdomain$response = Schemas.legacy$jhs_api$response$common & {
        result?: {
            readonly name?: any;
        };
    };
    export type legacy$jhs_subscription = Schemas.legacy$jhs_subscription$v2;
    export interface legacy$jhs_subscription$v2 {
        app?: {
            install_id?: Schemas.legacy$jhs_install_id;
        };
        component_values?: Schemas.legacy$jhs_component_values;
        currency?: Schemas.legacy$jhs_currency;
        current_period_end?: Schemas.legacy$jhs_current_period_end;
        current_period_start?: Schemas.legacy$jhs_current_period_start;
        frequency?: Schemas.legacy$jhs_frequency;
        id?: Schemas.legacy$jhs_subscription$v2_components$schemas$identifier;
        price?: Schemas.legacy$jhs_price;
        rate_plan?: Schemas.legacy$jhs_rate_plan;
        state?: Schemas.legacy$jhs_state;
        zone?: Schemas.legacy$jhs_zone;
    }
    /** Subscription identifier tag. */
    export type legacy$jhs_subscription$v2_components$schemas$identifier = string;
    /** The suggested threshold in requests done by the same auth_id or period_seconds. */
    export type legacy$jhs_suggested_threshold = number;
    /** The URL to launch when the Send Feedback button is clicked. */
    export type legacy$jhs_support_url = string;
    /** Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs. */
    export type legacy$jhs_supported_tld = boolean;
    /** Whether to allow the user to turn off the WARP switch and disconnect the client. */
    export type legacy$jhs_switch_locked = boolean;
    export type legacy$jhs_tail$response = Schemas.legacy$jhs_api$response$common & {
        result?: {
            readonly expires_at?: any;
            readonly id?: any;
            readonly url?: any;
        };
    };
    /** The target hostname, IPv6, or IPv6 address. */
    export type legacy$jhs_target = string;
    export interface legacy$jhs_target_result {
        colos?: Schemas.legacy$jhs_colo_result[];
        target?: Schemas.legacy$jhs_target;
    }
    /** Aggregated statistics from all hops about the target. */
    export interface legacy$jhs_target_summary {
    }
    /** User's telephone number */
    export type legacy$jhs_telephone = string | null;
    /** Breakdown of totals for threats. */
    export interface legacy$jhs_threats {
        /** The total number of identifiable threats received over the time frame. */
        all?: number;
        /** A list of key/value pairs where the key is a two-digit country code and the value is the number of malicious requests received from that country. */
        country?: {};
        /** The list of key/value pairs where the key is a threat category and the value is the number of requests. */
        type?: {};
    }
    /** The threshold that will trigger the configured mitigation action. Configure this value along with the \`period\` property to establish a threshold per period. */
    export type legacy$jhs_threshold = number;
    export interface legacy$jhs_thresholds {
        thresholds?: {
            auth_id_tokens?: Schemas.legacy$jhs_auth_id_tokens;
            data_points?: Schemas.legacy$jhs_data_points;
            last_updated?: Schemas.legacy$jhs_timestamp;
            p50?: Schemas.legacy$jhs_p50;
            p90?: Schemas.legacy$jhs_p90;
            p99?: Schemas.legacy$jhs_p99;
            period_seconds?: Schemas.legacy$jhs_period_seconds;
            requests?: Schemas.legacy$jhs_requests;
            suggested_threshold?: Schemas.legacy$jhs_suggested_threshold;
        };
    }
    /** URI to thumbnail variant for an image. */
    export type legacy$jhs_thumbnail_url = string;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed_challenge", or "js_challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    export type legacy$jhs_timeout = number;
    /** Time deltas containing metadata about each bucket of time. The number of buckets (resolution) is determined by the amount of time between the since and until parameters. */
    export type legacy$jhs_timeseries = {
        bandwidth?: Schemas.legacy$jhs_bandwidth;
        pageviews?: Schemas.legacy$jhs_pageviews;
        requests?: Schemas.legacy$jhs_schemas$requests;
        since?: Schemas.legacy$jhs_since;
        threats?: Schemas.legacy$jhs_threats;
        uniques?: Schemas.legacy$jhs_uniques;
        until?: Schemas.legacy$jhs_until;
    }[];
    /** Time deltas containing metadata about each bucket of time. The number of buckets (resolution) is determined by the amount of time between the since and until parameters. */
    export type legacy$jhs_timeseries_by_colo = {
        bandwidth?: Schemas.legacy$jhs_bandwidth_by_colo;
        requests?: Schemas.legacy$jhs_requests_by_colo;
        since?: Schemas.legacy$jhs_since;
        threats?: Schemas.legacy$jhs_threats;
        until?: Schemas.legacy$jhs_until;
    }[];
    export type legacy$jhs_timestamp = Date;
    /** The type of TLS termination associated with the application. */
    export type legacy$jhs_tls = "off" | "flexible" | "full" | "strict";
    /** The Managed Network TLS Config Response. */
    export interface legacy$jhs_tls_config_response {
        /** The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate. */
        sha256?: string;
        /** A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host. */
        tls_sockaddr: string;
    }
    export interface legacy$jhs_token {
        condition?: Schemas.legacy$jhs_condition;
        expires_on?: Schemas.legacy$jhs_expires_on;
        id: Schemas.legacy$jhs_components$schemas$identifier;
        issued_on?: Schemas.legacy$jhs_issued_on;
        modified_on?: Schemas.legacy$jhs_modified_on;
        name: Schemas.legacy$jhs_name;
        not_before?: Schemas.legacy$jhs_not_before;
        policies: Schemas.legacy$jhs_policies;
        status: Schemas.legacy$jhs_status;
    }
    export type legacy$jhs_total_tls_settings_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            certificate_authority?: Schemas.legacy$jhs_schemas$certificate_authority;
            enabled?: Schemas.legacy$jhs_components$schemas$enabled;
            validity_days?: Schemas.legacy$jhs_schemas$validity_days;
        };
    };
    /** Breakdown of totals by data type. */
    export interface legacy$jhs_totals {
        bandwidth?: Schemas.legacy$jhs_bandwidth;
        pageviews?: Schemas.legacy$jhs_pageviews;
        requests?: Schemas.legacy$jhs_schemas$requests;
        since?: Schemas.legacy$jhs_since;
        threats?: Schemas.legacy$jhs_threats;
        uniques?: Schemas.legacy$jhs_uniques;
        until?: Schemas.legacy$jhs_until;
    }
    /** Breakdown of totals by data type. */
    export interface legacy$jhs_totals_by_colo {
        bandwidth?: Schemas.legacy$jhs_bandwidth_by_colo;
        requests?: Schemas.legacy$jhs_requests_by_colo;
        since?: Schemas.legacy$jhs_since;
        threats?: Schemas.legacy$jhs_threats;
        until?: Schemas.legacy$jhs_until;
    }
    /** IP address of the node. */
    export type legacy$jhs_traceroute_components$schemas$ip = string;
    /** Host name of the address, this may be the same as the IP address. */
    export type legacy$jhs_traceroute_components$schemas$name = string;
    export type legacy$jhs_traceroute_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_target_result[];
    };
    /** Total time of traceroute in ms. */
    export type legacy$jhs_traceroute_time_ms = number;
    export type legacy$jhs_traditional_allow_rule = Schemas.legacy$jhs_rule_components$schemas$base$2 & {
        allowed_modes?: Schemas.legacy$jhs_allowed_modes_allow_traditional;
        mode?: Schemas.legacy$jhs_mode_allow_traditional;
    };
    export type legacy$jhs_traditional_deny_rule = Schemas.legacy$jhs_rule_components$schemas$base$2 & {
        allowed_modes?: Schemas.legacy$jhs_allowed_modes_deny_traditional;
        default_mode?: Schemas.legacy$jhs_default_mode;
        mode?: Schemas.legacy$jhs_mode_deny_traditional;
    };
    /** Determines how data travels from the edge to your origin. When set to "direct", Spectrum will send traffic directly to your origin, and the application's type is derived from the \`protocol\`. When set to "http" or "https", Spectrum will apply Cloudflare's HTTP/HTTPS features as it sends traffic to your origin, and the application type matches this property exactly. */
    export type legacy$jhs_traffic_type = "direct" | "http" | "https";
    /** Statuses for domain transfers into Cloudflare Registrar. */
    export interface legacy$jhs_transfer_in {
        /** Form of authorization has been accepted by the registrant. */
        accept_foa?: any;
        /** Shows transfer status with the registry. */
        approve_transfer?: any;
        /** Indicates if cancellation is still possible. */
        can_cancel_transfer?: boolean;
        /** Privacy guards are disabled at the foreign registrar. */
        disable_privacy?: any;
        /** Auth code has been entered and verified. */
        enter_auth_code?: any;
        /** Domain is unlocked at the foreign registrar. */
        unlock_domain?: any;
    }
    /** Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers. */
    export type legacy$jhs_ttl = number;
    /** The billing item type. */
    export type legacy$jhs_type = string;
    export type legacy$jhs_ua$rules = Schemas.legacy$jhs_firewalluablock;
    /** An informative summary of the rule. */
    export type legacy$jhs_ua$rules_components$schemas$description = string;
    /** The unique identifier of the User Agent Blocking rule. */
    export type legacy$jhs_ua$rules_components$schemas$id = string;
    /** The action to apply to a matched request. */
    export type legacy$jhs_ua$rules_components$schemas$mode = "block" | "challenge" | "js_challenge" | "managed_challenge";
    export interface legacy$jhs_uniques {
        /** Total number of unique IP addresses within the time range. */
        all?: number;
    }
    /** The unit price of the addon. */
    export type legacy$jhs_unit_price = number;
    export interface legacy$jhs_universal {
        enabled?: Schemas.legacy$jhs_schemas$enabled;
    }
    export type legacy$jhs_until = string | number;
    export type legacy$jhs_update_settings_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            public_key: string | null;
        };
    };
    /** When the device was updated. */
    export type legacy$jhs_updated = Date;
    /** The time when the certificate was updated. */
    export type legacy$jhs_updated_at = Date;
    /** When the media item was uploaded. */
    export type legacy$jhs_uploaded = Date;
    /** When the certificate was uploaded to Cloudflare. */
    export type legacy$jhs_uploaded_on = Date;
    /** A single URI to search for in the list of URLs of existing rules. */
    export type legacy$jhs_uri_search = string;
    /** The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns. */
    export type legacy$jhs_urls = string[];
    export type legacy$jhs_usage$model$response = Schemas.legacy$jhs_api$response$common & {
        result?: {
            readonly usage_model?: any;
        };
    };
    export interface legacy$jhs_user {
        email?: Schemas.legacy$jhs_email;
        id?: Schemas.legacy$jhs_uuid;
        /** The enrolled device user's name. */
        name?: string;
    }
    export type legacy$jhs_user_invite = Schemas.legacy$jhs_base & {
        /** Current status of the invitation. */
        status?: "pending" | "accepted" | "rejected" | "expired";
    };
    export type legacy$jhs_user_subscription_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_subscription[];
    };
    export type legacy$jhs_user_subscription_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** UUID */
    export type legacy$jhs_uuid = string;
    export type legacy$jhs_validate_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            valid?: boolean;
        };
    };
    /** Validation Method selected for the order. */
    export type legacy$jhs_validation_method = "txt" | "http" | "email";
    /** Result status. */
    export type legacy$jhs_validation_method_components$schemas$status = string;
    /** Desired validation method. */
    export type legacy$jhs_validation_method_definition = "http" | "cname" | "txt" | "email";
    /** Certificate's required validation record. */
    export interface legacy$jhs_validation_record {
        /** The set of email addresses that the certificate authority (CA) will use to complete domain validation. */
        emails?: {}[];
        /** The content that the certificate authority (CA) will expect to find at the http_url during the domain validation. */
        http_body?: string;
        /** The url that will be checked during domain validation. */
        http_url?: string;
        /** The hostname that the certificate authority (CA) will check for a TXT record during domain validation . */
        txt_name?: string;
        /** The TXT record that the certificate authority (CA) will check during domain validation. */
        txt_value?: string;
    }
    /** Validity Days selected for the order. */
    export type legacy$jhs_validity_days = 14 | 30 | 90 | 365;
    /** The token value. */
    export type legacy$jhs_value = string;
    export type legacy$jhs_variant_list_response = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_variants_response;
    };
    export interface legacy$jhs_variant_public_request {
        hero?: {};
    }
    export interface legacy$jhs_variant_response {
        variant?: {};
    }
    export type legacy$jhs_variant_simple_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_variant_response;
    };
    export type legacy$jhs_variants = Schemas.legacy$jhs_schemas$base & {
        /** ID of the zone setting. */
        id?: "variants";
    };
    export interface legacy$jhs_variants_response {
        variants?: Schemas.legacy$jhs_variant_public_request;
    }
    export interface legacy$jhs_verification {
        brand_check?: Schemas.legacy$jhs_brand_check;
        cert_pack_uuid?: Schemas.legacy$jhs_cert_pack_uuid;
        certificate_status: Schemas.legacy$jhs_certificate_status;
        signature?: Schemas.legacy$jhs_schemas$signature;
        validation_method?: Schemas.legacy$jhs_schemas$validation_method;
        verification_info?: Schemas.legacy$jhs_verification_info;
        verification_status?: Schemas.legacy$jhs_verification_status;
        verification_type?: Schemas.legacy$jhs_verification_type;
    }
    /** These are errors that were encountered while trying to activate a hostname. */
    export type legacy$jhs_verification_errors = {}[];
    /** Certificate's required verification information. */
    export interface legacy$jhs_verification_info {
        /** Name of CNAME record. */
        record_name?: string;
        /** Target of CNAME record. */
        record_target?: string;
    }
    /** Status of the required verification information, omitted if verification status is unknown. */
    export type legacy$jhs_verification_status = boolean;
    /** Method of verification. */
    export type legacy$jhs_verification_type = "cname" | "meta tag";
    /** The version of the ruleset. */
    export type legacy$jhs_version = string;
    export interface legacy$jhs_virtual$network {
        comment: Schemas.legacy$jhs_schemas$comment;
        /** Timestamp of when the virtual network was created. */
        created_at: any;
        /** Timestamp of when the virtual network was deleted. If \`null\`, the virtual network has not been deleted. */
        deleted_at?: any;
        id: Schemas.legacy$jhs_vnet_id;
        is_default_network: Schemas.legacy$jhs_is_default_network;
        name: Schemas.legacy$jhs_vnet_name;
    }
    /** The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account. */
    export type legacy$jhs_virtual_network_id = string;
    export type legacy$jhs_vnc_props = Schemas.legacy$jhs_self_hosted_props & {
        /** The application type. */
        type?: string;
    };
    /** UUID of the virtual network. */
    export type legacy$jhs_vnet_id = string;
    /** A user-friendly name for the virtual network. */
    export type legacy$jhs_vnet_name = string;
    export type legacy$jhs_vnet_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_virtual$network[];
    };
    export type legacy$jhs_vnet_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** The WAF rule action to apply. */
    export type legacy$jhs_waf_action = "challenge" | "block" | "simulate" | "disable" | "default";
    /** The WAF rule action to apply. */
    export type legacy$jhs_waf_rewrite_action = "challenge" | "block" | "simulate" | "disable" | "default";
    export type legacy$jhs_warp_props = Schemas.legacy$jhs_feature_app_props & {
        readonly domain?: any;
        readonly name?: any;
        /** The application type. */
        type?: string;
    };
    export interface legacy$jhs_webhooks {
        created_at?: Schemas.legacy$jhs_webhooks_components$schemas$created_at;
        id?: Schemas.legacy$jhs_uuid;
        last_failure?: Schemas.legacy$jhs_last_failure;
        last_success?: Schemas.legacy$jhs_last_success;
        name?: Schemas.legacy$jhs_webhooks_components$schemas$name;
        secret?: Schemas.legacy$jhs_secret;
        type?: Schemas.legacy$jhs_webhooks_components$schemas$type;
        url?: Schemas.legacy$jhs_webhooks_components$schemas$url;
    }
    /** Timestamp of when the webhook destination was created. */
    export type legacy$jhs_webhooks_components$schemas$created_at = Date;
    export type legacy$jhs_webhooks_components$schemas$id_response = Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_uuid;
        };
    };
    /** The name of the webhook destination. This will be included in the request body when you receive a webhook notification. */
    export type legacy$jhs_webhooks_components$schemas$name = string;
    export type legacy$jhs_webhooks_components$schemas$response_collection = Schemas.legacy$jhs_api$response$collection & {
        result?: Schemas.legacy$jhs_webhooks[];
    };
    export type legacy$jhs_webhooks_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_webhooks;
    };
    /** Type of webhook endpoint. */
    export type legacy$jhs_webhooks_components$schemas$type = "slack" | "generic" | "gchat";
    /** The POST endpoint to call when dispatching a notification. */
    export type legacy$jhs_webhooks_components$schemas$url = string;
    /** The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool. */
    export type legacy$jhs_weight = number;
    export interface legacy$jhs_whois {
        created_date?: string;
        domain?: Schemas.legacy$jhs_schemas$domain_name;
        nameservers?: string[];
        registrant?: string;
        registrant_country?: string;
        registrant_email?: string;
        registrant_org?: string;
        registrar?: string;
        updated_date?: string;
    }
    export type legacy$jhs_whois_components$schemas$single_response = Schemas.legacy$jhs_api$response$single & {
        result?: Schemas.legacy$jhs_whois;
    };
    /** The Workspace One Config Response. */
    export interface legacy$jhs_workspace_one_config_response {
        /** The Workspace One API URL provided in the Workspace One Admin Dashboard. */
        api_url: string;
        /** The Workspace One Authorization URL depending on your region. */
        auth_url: string;
        /** The Workspace One client ID provided in the Workspace One Admin Dashboard. */
        client_id: string;
    }
    /** The zipcode or postal code where the user lives. */
    export type legacy$jhs_zipcode = string | null;
    /** A simple zone object. May have null properties if not a zone subscription. */
    export interface legacy$jhs_zone {
        id?: Schemas.legacy$jhs_common_components$schemas$identifier;
        name?: Schemas.legacy$jhs_zone$properties$name;
    }
    export type legacy$jhs_zone$authenticated$origin$pull = Schemas.legacy$jhs_certificateObject;
    /** The zone's leaf certificate. */
    export type legacy$jhs_zone$authenticated$origin$pull_components$schemas$certificate = string;
    /** Indicates whether zone-level authenticated origin pulls is enabled. */
    export type legacy$jhs_zone$authenticated$origin$pull_components$schemas$enabled = boolean;
    /** When the certificate from the authority expires. */
    export type legacy$jhs_zone$authenticated$origin$pull_components$schemas$expires_on = Date;
    /** Certificate identifier tag. */
    export type legacy$jhs_zone$authenticated$origin$pull_components$schemas$identifier = string;
    /** Status of the certificate activation. */
    export type legacy$jhs_zone$authenticated$origin$pull_components$schemas$status = "initializing" | "pending_deployment" | "pending_deletion" | "active" | "deleted" | "deployment_timed_out" | "deletion_timed_out";
    /** The domain name */
    export type legacy$jhs_zone$properties$name = string;
    export type legacy$jhs_zone_cache_settings_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    /** Identifier of the zone. */
    export type legacy$jhs_zone_identifier = any;
    /** Name of the zone. */
    export type legacy$jhs_zone_name = string;
    export type legacy$jhs_zone_subscription_response_single = Schemas.legacy$jhs_api$response$single & {
        result?: {};
    };
    export interface legacy$jhs_zonelockdown {
        configurations: Schemas.legacy$jhs_configurations;
        created_on: Schemas.legacy$jhs_created_on;
        description: Schemas.legacy$jhs_lockdowns_components$schemas$description;
        id: Schemas.legacy$jhs_lockdowns_components$schemas$id;
        modified_on: Schemas.legacy$jhs_components$schemas$modified_on;
        paused: Schemas.legacy$jhs_schemas$paused;
        urls: Schemas.legacy$jhs_schemas$urls;
    }
    export type legacy$jhs_zonelockdown_response_collection = Schemas.legacy$jhs_api$response$collection & {
        result: Schemas.legacy$jhs_zonelockdown[];
    };
    export type legacy$jhs_zonelockdown_response_single = Schemas.legacy$jhs_api$response$single & {
        result: Schemas.legacy$jhs_zonelockdown;
    };
    export type lists_api$response$collection = Schemas.lists_api$response$common & {
        result?: {}[] | null;
    };
    export interface lists_api$response$common {
        errors: Schemas.lists_messages;
        messages: Schemas.lists_messages;
        result: {} | {}[];
        /** Whether the API call was successful */
        success: true;
    }
    export interface lists_api$response$common$failure {
        errors: Schemas.lists_messages;
        messages: Schemas.lists_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type lists_bulk$operation$response$collection = Schemas.lists_api$response$collection & {
        result?: Schemas.lists_operation;
    };
    /** The RFC 3339 timestamp of when the list was created. */
    export type lists_created_on = string;
    /** An informative summary of the list. */
    export type lists_description = string;
    /** Identifier */
    export type lists_identifier = string;
    export type lists_item = Schemas.lists_item_ip | Schemas.lists_item_redirect | Schemas.lists_item_hostname | Schemas.lists_item_asn;
    export type lists_item$response$collection = Schemas.lists_api$response$collection & {
        result?: Schemas.lists_item;
    };
    /** A non-negative 32 bit integer */
    export type lists_item_asn = number;
    /** An informative summary of the list item. */
    export type lists_item_comment = string;
    /** Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-). */
    export interface lists_item_hostname {
        url_hostname: string;
    }
    /** The unique ID of the item in the List. */
    export type lists_item_id = string;
    /** An IPv4 address, an IPv4 CIDR, or an IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64. */
    export type lists_item_ip = string;
    /** The definition of the redirect. */
    export interface lists_item_redirect {
        include_subdomains?: boolean;
        preserve_path_suffix?: boolean;
        preserve_query_string?: boolean;
        source_url: string;
        status_code?: 301 | 302 | 307 | 308;
        subpath_matching?: boolean;
        target_url: string;
    }
    export type lists_items = Schemas.lists_item[];
    export type lists_items$list$response$collection = Schemas.lists_api$response$collection & {
        result?: Schemas.lists_items;
        result_info?: {
            cursors?: {
                after?: string;
                before?: string;
            };
        };
    };
    export type lists_items$update$request$collection = ({
        asn?: Schemas.lists_item_asn;
        comment?: Schemas.lists_item_comment;
        hostname?: Schemas.lists_item_hostname;
        ip?: Schemas.lists_item_ip;
        redirect?: Schemas.lists_item_redirect;
    })[];
    /** The type of the list. Each type supports specific list items (IP addresses, ASNs, hostnames or redirects). */
    export type lists_kind = "ip" | "redirect" | "hostname" | "asn";
    export interface lists_list {
        created_on?: Schemas.lists_created_on;
        description?: Schemas.lists_description;
        id?: Schemas.lists_list_id;
        kind?: Schemas.lists_kind;
        modified_on?: Schemas.lists_modified_on;
        name?: Schemas.lists_name;
        num_items?: Schemas.lists_num_items;
        num_referencing_filters?: Schemas.lists_num_referencing_filters;
    }
    export type lists_list$delete$response$collection = Schemas.lists_api$response$collection & {
        result?: {
            id?: Schemas.lists_item_id;
        };
    };
    export type lists_list$response$collection = Schemas.lists_api$response$collection & {
        result?: Schemas.lists_list;
    };
    /** The unique ID of the list. */
    export type lists_list_id = string;
    export type lists_lists$async$response = Schemas.lists_api$response$collection & {
        result?: {
            operation_id?: Schemas.lists_operation_id;
        };
    };
    export type lists_lists$response$collection = Schemas.lists_api$response$collection & {
        result?: (Schemas.lists_list & {})[];
    };
    export type lists_messages = {
        code: number;
        message: string;
    }[];
    /** The RFC 3339 timestamp of when the list was last modified. */
    export type lists_modified_on = string;
    /** An informative name for the list. Use this name in filter and rule expressions. */
    export type lists_name = string;
    /** The number of items in the list. */
    export type lists_num_items = number;
    /** The number of [filters](/operations/filters-list-filters) referencing the list. */
    export type lists_num_referencing_filters = number;
    export interface lists_operation {
        /** The RFC 3339 timestamp of when the operation was completed. */
        readonly completed?: string;
        /** A message describing the error when the status is \`failed\`. */
        readonly error?: string;
        id: Schemas.lists_operation_id;
        /** The current status of the asynchronous operation. */
        readonly status: "pending" | "running" | "completed" | "failed";
    }
    /** The unique operation ID of the asynchronous action. */
    export type lists_operation_id = string;
    /** The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin. */
    export type load$balancing_Host = string[];
    /** Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin. */
    export interface load$balancing_adaptive_routing {
        /** Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See \`session_affinity_attributes\` for control over when sessions are broken or reassigned. */
        failover_across_pools?: boolean;
    }
    /** The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual_network_id must also be set. */
    export type load$balancing_address = string;
    /** Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors. */
    export type load$balancing_allow_insecure = boolean;
    export interface load$balancing_analytics {
        id?: number;
        origins?: {}[];
        pool?: {};
        timestamp?: Date;
    }
    export type load$balancing_api$response$collection = Schemas.load$balancing_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.load$balancing_result_info;
    };
    export interface load$balancing_api$response$common {
        errors: Schemas.load$balancing_messages;
        messages: Schemas.load$balancing_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface load$balancing_api$response$common$failure {
        errors: Schemas.load$balancing_messages;
        messages: Schemas.load$balancing_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type load$balancing_api$response$single = Schemas.load$balancing_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    /** A list of regions from which to run health checks. Null means every Cloudflare data center. */
    export type load$balancing_check_regions = ("WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS" | "ALL_REGIONS")[] | null;
    /** Object description. */
    export type load$balancing_components$schemas$description = string;
    /** Whether to enable (the default) this load balancer. */
    export type load$balancing_components$schemas$enabled = boolean;
    export type load$balancing_components$schemas$id_response = Schemas.load$balancing_api$response$single & {
        result?: {
            id?: Schemas.load$balancing_load$balancer_components$schemas$identifier;
        };
    };
    /** Identifier */
    export type load$balancing_components$schemas$identifier = string;
    /** The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used. */
    export type load$balancing_components$schemas$name = string;
    export type load$balancing_components$schemas$response_collection = Schemas.load$balancing_api$response$collection & {
        result?: Schemas.load$balancing_analytics[];
    };
    export type load$balancing_components$schemas$single_response = Schemas.load$balancing_api$response$single & {
        /** A list of countries and subdivisions mapped to a region. */
        result?: {};
    };
    /** To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. */
    export type load$balancing_consecutive_down = number;
    /** To be marked healthy the monitored origin must pass this healthcheck N consecutive times. */
    export type load$balancing_consecutive_up = number;
    /** A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region_pool mapping if it exists else to default_pools. */
    export interface load$balancing_country_pools {
    }
    /** A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region. */
    export type load$balancing_default_pools = string[];
    /** Object description. */
    export type load$balancing_description = string;
    /** This field shows up only if the origin is disabled. This field is set with the time the origin was disabled. */
    export type load$balancing_disabled_at = Date;
    /** Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any). */
    export type load$balancing_enabled = boolean;
    /** A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors. */
    export type load$balancing_expected_body = string;
    /** The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors. */
    export type load$balancing_expected_codes = string;
    /** The pool ID to use when all other pools are detected as unhealthy. */
    export type load$balancing_fallback_pool = any;
    /** Filter options for a particular resource type (pool or origin). Use null to reset. */
    export type load$balancing_filter_options = {
        /** If set true, disable notifications for this type of resource (pool or origin). */
        disable?: boolean;
        /** If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events). */
        healthy?: boolean | null;
    } | null;
    /** Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors. */
    export type load$balancing_follow_redirects = boolean;
    /** The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors. */
    export interface load$balancing_header {
    }
    export type load$balancing_health_details = Schemas.load$balancing_api$response$single & {
        /** A list of regions from which to run health checks. Null means every Cloudflare data center. */
        result?: {};
    };
    export type load$balancing_id_response = Schemas.load$balancing_api$response$single & {
        result?: {
            id?: Schemas.load$balancing_identifier;
        };
    };
    export type load$balancing_identifier = string;
    /** The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. */
    export type load$balancing_interval = number;
    /** The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set. */
    export type load$balancing_latitude = number;
    export interface load$balancing_load$balancer {
        adaptive_routing?: Schemas.load$balancing_adaptive_routing;
        country_pools?: Schemas.load$balancing_country_pools;
        created_on?: Schemas.load$balancing_timestamp;
        default_pools?: Schemas.load$balancing_default_pools;
        description?: Schemas.load$balancing_components$schemas$description;
        enabled?: Schemas.load$balancing_components$schemas$enabled;
        fallback_pool?: Schemas.load$balancing_fallback_pool;
        id?: Schemas.load$balancing_load$balancer_components$schemas$identifier;
        location_strategy?: Schemas.load$balancing_location_strategy;
        modified_on?: Schemas.load$balancing_timestamp;
        name?: Schemas.load$balancing_components$schemas$name;
        pop_pools?: Schemas.load$balancing_pop_pools;
        proxied?: Schemas.load$balancing_proxied;
        random_steering?: Schemas.load$balancing_random_steering;
        region_pools?: Schemas.load$balancing_region_pools;
        rules?: Schemas.load$balancing_rules;
        session_affinity?: Schemas.load$balancing_session_affinity;
        session_affinity_attributes?: Schemas.load$balancing_session_affinity_attributes;
        session_affinity_ttl?: Schemas.load$balancing_session_affinity_ttl;
        steering_policy?: Schemas.load$balancing_steering_policy;
        ttl?: Schemas.load$balancing_ttl;
    }
    export type load$balancing_load$balancer_components$schemas$identifier = string;
    export type load$balancing_load$balancer_components$schemas$response_collection = Schemas.load$balancing_api$response$collection & {
        result?: Schemas.load$balancing_load$balancer[];
    };
    export type load$balancing_load$balancer_components$schemas$single_response = Schemas.load$balancing_api$response$single & {
        result?: Schemas.load$balancing_load$balancer;
    };
    /** Configures load shedding policies and percentages for the pool. */
    export interface load$balancing_load_shedding {
        /** The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity. */
        default_percent?: number;
        /** The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs. */
        default_policy?: "random" | "hash";
        /** The percent of existing sessions to shed from the pool, according to the session policy. */
        session_percent?: number;
        /** Only the hash policy is supported for existing sessions (to avoid exponential decay). */
        session_policy?: "hash";
    }
    /** Controls location-based steering for non-proxied requests. See \`steering_policy\` to learn how steering is affected. */
    export interface load$balancing_location_strategy {
        /**
         * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
         * - \`"pop"\`: Use the Cloudflare PoP location.
         * - \`"resolver_ip"\`: Use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, use the Cloudflare PoP location.
         */
        mode?: "pop" | "resolver_ip";
        /**
         * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
         * - \`"always"\`: Always prefer ECS.
         * - \`"never"\`: Never prefer ECS.
         * - \`"proximity"\`: Prefer ECS only when \`steering_policy="proximity"\`.
         * - \`"geo"\`: Prefer ECS only when \`steering_policy="geo"\`.
         */
        prefer_ecs?: "always" | "never" | "proximity" | "geo";
    }
    /** The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set. */
    export type load$balancing_longitude = number;
    export type load$balancing_messages = {
        code: number;
        message: string;
    }[];
    /** The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks. */
    export type load$balancing_method = string;
    /** The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool. */
    export type load$balancing_minimum_origins = number;
    export type load$balancing_monitor = Schemas.load$balancing_monitor$editable & {
        created_on?: Schemas.load$balancing_timestamp;
        id?: Schemas.load$balancing_identifier;
        modified_on?: Schemas.load$balancing_timestamp;
    };
    export interface load$balancing_monitor$editable {
        allow_insecure?: Schemas.load$balancing_allow_insecure;
        consecutive_down?: Schemas.load$balancing_consecutive_down;
        consecutive_up?: Schemas.load$balancing_consecutive_up;
        description?: Schemas.load$balancing_description;
        expected_body?: Schemas.load$balancing_expected_body;
        expected_codes?: Schemas.load$balancing_expected_codes;
        follow_redirects?: Schemas.load$balancing_follow_redirects;
        header?: Schemas.load$balancing_header;
        interval?: Schemas.load$balancing_interval;
        method?: Schemas.load$balancing_method;
        path?: Schemas.load$balancing_path;
        port?: Schemas.load$balancing_port;
        probe_zone?: Schemas.load$balancing_probe_zone;
        retries?: Schemas.load$balancing_retries;
        timeout?: Schemas.load$balancing_timeout;
        type?: Schemas.load$balancing_type;
    }
    export type load$balancing_monitor$response$collection = Schemas.load$balancing_api$response$collection & {
        result?: Schemas.load$balancing_monitor[];
    };
    export type load$balancing_monitor$response$single = Schemas.load$balancing_api$response$single & {
        result?: Schemas.load$balancing_monitor;
    };
    /** The ID of the Monitor to use for checking the health of origins within this pool. */
    export type load$balancing_monitor_id = any;
    /** A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed. */
    export type load$balancing_name = string;
    /** This field is now deprecated. It has been moved to Cloudflare's Centralized Notification service https://developers.cloudflare.com/fundamentals/notifications/. The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list. */
    export type load$balancing_notification_email = string;
    /** Filter pool and origin health notifications by resource type or health status. Use null to reset. */
    export type load$balancing_notification_filter = {
        origin?: Schemas.load$balancing_filter_options;
        pool?: Schemas.load$balancing_filter_options;
    } | null;
    export interface load$balancing_origin {
        address?: Schemas.load$balancing_address;
        disabled_at?: Schemas.load$balancing_disabled_at;
        enabled?: Schemas.load$balancing_schemas$enabled;
        header?: Schemas.load$balancing_schemas$header;
        name?: Schemas.load$balancing_schemas$name;
        virtual_network_id?: Schemas.load$balancing_virtual_network_id;
        weight?: Schemas.load$balancing_weight;
    }
    /** The origin ipv4/ipv6 address or domain name mapped to it's health data. */
    export interface load$balancing_origin_health_data {
        failure_reason?: string;
        healthy?: boolean;
        response_code?: number;
        rtt?: string;
    }
    /** If true, filter events where the origin status is healthy. If false, filter events where the origin status is unhealthy. */
    export type load$balancing_origin_healthy = boolean;
    /** Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity. */
    export interface load$balancing_origin_steering {
        /**
         * The type of origin steering policy to use.
         * - \`"random"\`: Select an origin randomly.
         * - \`"hash"\`: Select an origin by computing a hash over the CF-Connecting-IP address.
         * - \`"least_outstanding_requests"\`: Select an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others.
         * - \`"least_connections"\`: Select an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections.
         */
        policy?: "random" | "hash" | "least_outstanding_requests" | "least_connections";
    }
    /** The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. */
    export type load$balancing_origins = Schemas.load$balancing_origin[];
    /** The email address to send health status notifications to. This field is now deprecated in favor of Cloudflare Notifications for Load Balancing, so only resetting this field with an empty string \`""\` is accepted. */
    export type load$balancing_patch_pools_notification_email = "\\"\\"";
    /** The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors. */
    export type load$balancing_path = string;
    export interface load$balancing_pool {
        check_regions?: Schemas.load$balancing_check_regions;
        created_on?: Schemas.load$balancing_timestamp;
        description?: Schemas.load$balancing_schemas$description;
        disabled_at?: Schemas.load$balancing_schemas$disabled_at;
        enabled?: Schemas.load$balancing_enabled;
        id?: Schemas.load$balancing_schemas$identifier;
        latitude?: Schemas.load$balancing_latitude;
        load_shedding?: Schemas.load$balancing_load_shedding;
        longitude?: Schemas.load$balancing_longitude;
        minimum_origins?: Schemas.load$balancing_minimum_origins;
        modified_on?: Schemas.load$balancing_timestamp;
        monitor?: Schemas.load$balancing_monitor_id;
        name?: Schemas.load$balancing_name;
        notification_email?: Schemas.load$balancing_notification_email;
        notification_filter?: Schemas.load$balancing_notification_filter;
        origin_steering?: Schemas.load$balancing_origin_steering;
        origins?: Schemas.load$balancing_origins;
    }
    /** The name for the pool to filter. */
    export type load$balancing_pool_name = string;
    /** (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country_pool, then region_pool mapping if it exists else to default_pools. */
    export interface load$balancing_pop_pools {
    }
    /** The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443). */
    export type load$balancing_port = number;
    export type load$balancing_preview_id = any;
    export type load$balancing_preview_response = Schemas.load$balancing_api$response$single & {
        result?: {
            /** Monitored pool IDs mapped to their respective names. */
            pools?: {};
            preview_id?: Schemas.load$balancing_identifier;
        };
    };
    /** Resulting health data from a preview operation. */
    export interface load$balancing_preview_result {
    }
    export type load$balancing_preview_result_response = Schemas.load$balancing_api$response$single & {
        result?: Schemas.load$balancing_preview_result;
    };
    /** Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors. */
    export type load$balancing_probe_zone = string;
    /** Whether the hostname should be gray clouded (false) or orange clouded (true). */
    export type load$balancing_proxied = boolean;
    /**
     * Configures pool weights.
     * - \`steering_policy="random"\`: A random pool is selected with probability proportional to pool weights.
     * - \`steering_policy="least_outstanding_requests"\`: Use pool weights to scale each pool's outstanding requests.
     * - \`steering_policy="least_connections"\`: Use pool weights to scale each pool's open connections.
     */
    export interface load$balancing_random_steering {
        /** The default weight for pools in the load balancer that are not specified in the pool_weights map. */
        default_weight?: number;
        /** A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer. */
        pool_weights?: {};
    }
    export type load$balancing_references_response = Schemas.load$balancing_api$response$collection & {
        /** List of resources that reference a given monitor. */
        result?: {
            reference_type?: "*" | "referral" | "referrer";
            resource_id?: string;
            resource_name?: string;
            resource_type?: string;
        }[];
    };
    /** A list of Cloudflare regions. WNAM: Western North America, ENAM: Eastern North America, WEU: Western Europe, EEU: Eastern Europe, NSAM: Northern South America, SSAM: Southern South America, OC: Oceania, ME: Middle East, NAF: North Africa, SAF: South Africa, SAS: Southern Asia, SEAS: South East Asia, NEAS: North East Asia). */
    export type load$balancing_region_code = "WNAM" | "ENAM" | "WEU" | "EEU" | "NSAM" | "SSAM" | "OC" | "ME" | "NAF" | "SAF" | "SAS" | "SEAS" | "NEAS";
    export type load$balancing_region_components$schemas$response_collection = Schemas.load$balancing_api$response$single & {
        result?: {};
    };
    /** A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools. */
    export interface load$balancing_region_pools {
    }
    /** A reference to a load balancer resource. */
    export interface load$balancing_resource_reference {
        /** When listed as a reference, the type (direction) of the reference. */
        reference_type?: "referral" | "referrer";
        /** A list of references to (referrer) or from (referral) this resource. */
        references?: {}[];
        resource_id?: any;
        /** The human-identifiable name of the resource. */
        resource_name?: string;
        /** The type of the resource. */
        resource_type?: "load_balancer" | "monitor" | "pool";
    }
    export interface load$balancing_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. */
    export type load$balancing_retries = number;
    /** BETA Field Not General Access: A list of rules for this load balancer to execute. */
    export type load$balancing_rules = {
        /** The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions. */
        condition?: string;
        /** Disable this specific rule. It will no longer be evaluated by this load balancer. */
        disabled?: boolean;
        /** A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed_response is supplied the rule will be marked as terminates. */
        fixed_response?: {
            /** The http 'Content-Type' header to include in the response. */
            content_type?: string;
            /** The http 'Location' header to include in the response. */
            location?: string;
            /** Text to include as the http body. */
            message_body?: string;
            /** The http status code to respond with. */
            status_code?: number;
        };
        /** Name of this rule. Only used for human readability. */
        name?: string;
        /** A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional. */
        overrides?: {
            adaptive_routing?: Schemas.load$balancing_adaptive_routing;
            country_pools?: Schemas.load$balancing_country_pools;
            default_pools?: Schemas.load$balancing_default_pools;
            fallback_pool?: Schemas.load$balancing_fallback_pool;
            location_strategy?: Schemas.load$balancing_location_strategy;
            pop_pools?: Schemas.load$balancing_pop_pools;
            random_steering?: Schemas.load$balancing_random_steering;
            region_pools?: Schemas.load$balancing_region_pools;
            session_affinity?: Schemas.load$balancing_session_affinity;
            session_affinity_attributes?: Schemas.load$balancing_session_affinity_attributes;
            session_affinity_ttl?: Schemas.load$balancing_session_affinity_ttl;
            steering_policy?: Schemas.load$balancing_steering_policy;
            ttl?: Schemas.load$balancing_ttl;
        };
        /** The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority. */
        priority?: number;
        /** If this rule's condition is true, this causes rule evaluation to stop after processing this rule. */
        terminates?: boolean;
    }[];
    /** A human-readable description of the pool. */
    export type load$balancing_schemas$description = string;
    /** This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at. */
    export type load$balancing_schemas$disabled_at = Date;
    /** Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool. */
    export type load$balancing_schemas$enabled = boolean;
    /** The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'. */
    export interface load$balancing_schemas$header {
        Host?: Schemas.load$balancing_Host;
    }
    export type load$balancing_schemas$id_response = Schemas.load$balancing_api$response$single & {
        result?: {
            id?: Schemas.load$balancing_schemas$identifier;
        };
    };
    export type load$balancing_schemas$identifier = string;
    /** A human-identifiable name for the origin. */
    export type load$balancing_schemas$name = string;
    export type load$balancing_schemas$preview_id = any;
    export type load$balancing_schemas$references_response = Schemas.load$balancing_api$response$collection & {
        /** List of resources that reference a given pool. */
        result?: {
            reference_type?: "*" | "referral" | "referrer";
            resource_id?: string;
            resource_name?: string;
            resource_type?: string;
        }[];
    };
    export type load$balancing_schemas$response_collection = Schemas.load$balancing_api$response$collection & {
        result?: Schemas.load$balancing_pool[];
    };
    export type load$balancing_schemas$single_response = Schemas.load$balancing_api$response$single & {
        result?: Schemas.load$balancing_pool;
    };
    export interface load$balancing_search {
        /** A list of resources matching the search query. */
        resources?: Schemas.load$balancing_resource_reference[];
    }
    export interface load$balancing_search_params {
        /** Search query term. */
        query?: string;
        /** The type of references to include ("*" for all). */
        references?: "" | "*" | "referral" | "referrer";
    }
    export interface load$balancing_search_result {
        result?: Schemas.load$balancing_search;
    }
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as \`"none"\` or "" (default). The supported types are:
     * - \`"cookie"\`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used.
     * - \`"ip_cookie"\`: Behaves the same as \`"cookie"\` except the initial origin selection is stable and based on the client's ip address.
     * - \`"header"\`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see \`session_affinity_attributes.headers\`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of \`session_affinity_ttl\` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See \`headers\` in \`session_affinity_attributes\` for additional required configuration.
     */
    export type load$balancing_session_affinity = "none" | "cookie" | "ip_cookie" | "header" | "\\"\\"";
    /** Configures attributes for session affinity. */
    export interface load$balancing_session_affinity_attributes {
        /** Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. */
        drain_duration?: number;
        /** Configures the names of HTTP headers to base session affinity on when header \`session_affinity\` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: \`"cookie:<cookie-name-1>,<cookie-name-2>"\` (example) where everything after the colon is a comma-separated list of cookie names. Providing only \`"cookie"\` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans. */
        headers?: string[];
        /**
         * When header \`session_affinity\` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
         * - \`"true"\`: Load balancing requests must contain *all* of the HTTP headers specified by the \`headers\` session affinity attribute, otherwise sessions aren't created.
         * - \`"false"\`: Load balancing requests must contain *at least one* of the HTTP headers specified by the \`headers\` session affinity attribute, otherwise sessions aren't created.
         */
        require_all_headers?: boolean;
        /** Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never". */
        samesite?: "Auto" | "Lax" | "None" | "Strict";
        /** Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled. */
        secure?: "Auto" | "Always" | "Never";
        /**
         * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
         * - \`"none"\`: No failover takes place for sessions pinned to the origin (default).
         * - \`"temporary"\`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping.
         * - \`"sticky"\`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
         */
        zero_downtime_failover?: "none" | "temporary" | "sticky";
    }
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per \`session_affinity\` policy are:
     * - \`"cookie"\` / \`"ip_cookie"\`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800].
     * - \`"header"\`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
     */
    export type load$balancing_session_affinity_ttl = number;
    /**
     * Steering Policy for this load balancer.
     * - \`"off"\`: Use \`default_pools\`.
     * - \`"geo"\`: Use \`region_pools\`/\`country_pools\`/\`pop_pools\`. For non-proxied requests, the country for \`country_pools\` is determined by \`location_strategy\`.
     * - \`"random"\`: Select a pool randomly.
     * - \`"dynamic_latency"\`: Use round trip time to select the closest pool in default_pools (requires pool health checks).
     * - \`"proximity"\`: Use the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by \`location_strategy\` for non-proxied requests.
     * - \`"least_outstanding_requests"\`: Select a pool by taking into consideration \`random_steering\` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others.
     * - \`"least_connections"\`: Select a pool by taking into consideration \`random_steering\` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections.
     * - \`""\`: Will map to \`"geo"\` if you use \`region_pools\`/\`country_pools\`/\`pop_pools\` otherwise \`"off"\`.
     */
    export type load$balancing_steering_policy = "off" | "geo" | "random" | "dynamic_latency" | "proximity" | "least_outstanding_requests" | "least_connections" | "\\"\\"";
    /** Two-letter subdivision code followed in ISO 3166-2. */
    export type load$balancing_subdivision_code_a2 = string;
    /** The timeout (in seconds) before marking the health check as failed. */
    export type load$balancing_timeout = number;
    export type load$balancing_timestamp = Date;
    /** Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers. */
    export type load$balancing_ttl = number;
    /** The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'. */
    export type load$balancing_type = "http" | "https" | "tcp" | "udp_icmp" | "icmp_ping" | "smtp";
    /** End date and time of requesting data period in the ISO8601 format. */
    export type load$balancing_until = Date;
    /** The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account. */
    export type load$balancing_virtual_network_id = string;
    /**
     * The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
     * - \`origin_steering.policy="least_outstanding_requests"\`: Use weight to scale the origin's outstanding requests.
     * - \`origin_steering.policy="least_connections"\`: Use weight to scale the origin's open connections.
     */
    export type load$balancing_weight = number;
    export type logcontrol_account_identifier = Schemas.logcontrol_identifier;
    export interface logcontrol_api$response$common {
        errors: Schemas.logcontrol_messages;
        messages: Schemas.logcontrol_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface logcontrol_api$response$common$failure {
        errors: Schemas.logcontrol_messages;
        messages: Schemas.logcontrol_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type logcontrol_api$response$single = Schemas.logcontrol_api$response$common & {
        result?: {} | string;
    };
    export type logcontrol_cmb_config = {
        regions?: Schemas.logcontrol_regions;
    } | null;
    export type logcontrol_cmb_config_response_single = Schemas.logcontrol_api$response$single & {
        result?: Schemas.logcontrol_cmb_config;
    };
    /** Identifier */
    export type logcontrol_identifier = string;
    export type logcontrol_messages = {
        code: number;
        message: string;
    }[];
    /** Comma-separated list of regions. */
    export type logcontrol_regions = string;
    export interface logpush_api$response$common {
        errors: Schemas.logpush_messages;
        messages: Schemas.logpush_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface logpush_api$response$common$failure {
        errors: Schemas.logpush_messages;
        messages: Schemas.logpush_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type logpush_api$response$single = Schemas.logpush_api$response$common & {
        result?: {} | string;
    };
    /** Name of the dataset. */
    export type logpush_dataset = string | null;
    /** Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. */
    export type logpush_destination_conf = string;
    export type logpush_destination_exists_response = Schemas.logpush_api$response$common & {
        result?: {
            exists?: boolean;
        } | null;
    };
    /** Flag that indicates if the job is enabled. */
    export type logpush_enabled = boolean;
    /** If not null, the job is currently failing. Failures are usually repetitive (example: no permissions to write to destination bucket). Only the last failure is recorded. On successful execution of a job the error_message and last_error are set to null. */
    export type logpush_error_message = (Date) | null;
    /** Comma-separated list of fields. */
    export type logpush_fields = string;
    /** Filters to drill down into specific events. */
    export type logpush_filter = string;
    /** The frequency at which Cloudflare sends batches of logs to your destination. Setting frequency to high sends your logs in larger quantities of smaller files. Setting frequency to low sends logs in smaller quantities of larger files. */
    export type logpush_frequency = ("high" | "low") | null;
    export type logpush_get_ownership_response = Schemas.logpush_api$response$common & {
        result?: {
            filename?: string;
            message?: string;
            valid?: boolean;
        } | null;
    };
    /** Unique id of the job. */
    export type logpush_id = number;
    /** Identifier */
    export type logpush_identifier = string;
    export type logpush_instant_logs_job = {
        destination_conf?: Schemas.logpush_schemas$destination_conf;
        fields?: Schemas.logpush_fields;
        filter?: Schemas.logpush_filter;
        sample?: Schemas.logpush_sample;
        session_id?: Schemas.logpush_session_id;
    } | null;
    export type logpush_instant_logs_job_response_collection = Schemas.logpush_api$response$common & {
        result?: Schemas.logpush_instant_logs_job[];
    };
    export type logpush_instant_logs_job_response_single = Schemas.logpush_api$response$single & {
        result?: Schemas.logpush_instant_logs_job;
    };
    /** Records the last time for which logs have been successfully pushed. If the last successful push was for logs range 2018-07-23T10:00:00Z to 2018-07-23T10:01:00Z then the value of this field will be 2018-07-23T10:01:00Z. If the job has never run or has just been enabled and hasn't run yet then the field will be empty. */
    export type logpush_last_complete = (Date) | null;
    /** Records the last time the job failed. If not null, the job is currently failing. If null, the job has either never failed or has run successfully at least once since last failure. See also the error_message field. */
    export type logpush_last_error = (Date) | null;
    /** This field is deprecated. Use \`output_options\` instead. Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately. */
    export type logpush_logpull_options = string | null;
    export type logpush_logpush_field_response_collection = Schemas.logpush_api$response$common & {
        result?: {};
    };
    export type logpush_logpush_job = {
        dataset?: Schemas.logpush_dataset;
        destination_conf?: Schemas.logpush_destination_conf;
        enabled?: Schemas.logpush_enabled;
        error_message?: Schemas.logpush_error_message;
        frequency?: Schemas.logpush_frequency;
        id?: Schemas.logpush_id;
        last_complete?: Schemas.logpush_last_complete;
        last_error?: Schemas.logpush_last_error;
        logpull_options?: Schemas.logpush_logpull_options;
        name?: Schemas.logpush_name;
        output_options?: Schemas.logpush_output_options;
    } | null;
    export type logpush_logpush_job_response_collection = Schemas.logpush_api$response$common & {
        result?: Schemas.logpush_logpush_job[];
    };
    export type logpush_logpush_job_response_single = Schemas.logpush_api$response$single & {
        result?: Schemas.logpush_logpush_job;
    };
    export type logpush_messages = {
        code: number;
        message: string;
    }[];
    /** Optional human readable job name. Not unique. Cloudflare suggests that you set this to a meaningful string, like the domain name, to make it easier to identify your job. */
    export type logpush_name = string | null;
    /** The structured replacement for \`logpull_options\`. When including this field, the \`logpull_option\` field will be ignored. */
    export type logpush_output_options = {
        /** If set to true, will cause all occurrences of \`\${\` in the generated files to be replaced with \`x{\`. */
        "CVE-2021-4428"?: boolean | null;
        /** String to be prepended before each batch. */
        batch_prefix?: string | null;
        /** String to be appended after each batch. */
        batch_suffix?: string | null;
        /** String to join fields. This field be ignored when \`record_template\` is set. */
        field_delimiter?: string | null;
        /** List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in. */
        field_names?: string[];
        /** Specifies the output type, such as \`ndjson\` or \`csv\`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types. */
        output_type?: "ndjson" | "csv";
        /** String to be inserted in-between the records as separator. */
        record_delimiter?: string | null;
        /** String to be prepended before each record. */
        record_prefix?: string | null;
        /** String to be appended after each record. */
        record_suffix?: string | null;
        /** String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in \`field_names\` as well, otherwise they will end up as null. Format as a Go \`text/template\` without any standard functions, like conditionals, loops, sub-templates, etc. */
        record_template?: string | null;
        /** Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current \`sample_interval\` of the data. */
        sample_rate?: number | null;
        /** String to specify the format for timestamps, such as \`unixnano\`, \`unix\`, or \`rfc3339\`. */
        timestamp_format?: "unixnano" | "unix" | "rfc3339";
    } | null;
    /** Ownership challenge token to prove destination ownership. */
    export type logpush_ownership_challenge = string;
    /** The sample parameter is the sample rate of the records set by the client: "sample": 1 is 100% of records "sample": 10 is 10% and so on. */
    export type logpush_sample = number;
    /** Unique WebSocket address that will receive messages from Cloudflareâ€™s edge. */
    export type logpush_schemas$destination_conf = string;
    /** Unique session id of the job. */
    export type logpush_session_id = string;
    export type logpush_validate_ownership_response = Schemas.logpush_api$response$common & {
        result?: {
            valid?: boolean;
        } | null;
    };
    export type logpush_validate_response = Schemas.logpush_api$response$common & {
        result?: {
            message?: string;
            valid?: boolean;
        } | null;
    };
    /** When \`true\`, the tunnel can use a null-cipher (\`ENCR_NULL\`) in the ESP tunnel (Phase 2). */
    export type magic_allow_null_cipher = boolean;
    export interface magic_api$response$common {
        errors: Schemas.magic_messages;
        messages: Schemas.magic_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface magic_api$response$common$failure {
        errors: Schemas.magic_messages;
        messages: Schemas.magic_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type magic_api$response$single = Schemas.magic_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    /** The IP address assigned to the Cloudflare side of the GRE tunnel. */
    export type magic_cloudflare_gre_endpoint = string;
    /** The IP address assigned to the Cloudflare side of the IPsec tunnel. */
    export type magic_cloudflare_ipsec_endpoint = string;
    /** Scope colo name. */
    export type magic_colo_name = string;
    /** List of colo names for the ECMP scope. */
    export type magic_colo_names = Schemas.magic_colo_name[];
    /** Scope colo region. */
    export type magic_colo_region = string;
    /** List of colo regions for the ECMP scope. */
    export type magic_colo_regions = Schemas.magic_colo_region[];
    /** An optional description forthe IPsec tunnel. */
    export type magic_components$schemas$description = string;
    export type magic_components$schemas$modified_tunnels_collection_response = Schemas.magic_api$response$single & {
        result?: {
            modified?: boolean;
            modified_interconnects?: Schemas.magic_interconnect[];
        };
    };
    /** The name of the interconnect. The name cannot share a name with other tunnels. */
    export type magic_components$schemas$name = string;
    export type magic_components$schemas$tunnel_modified_response = Schemas.magic_api$response$single & {
        result?: {
            modified?: boolean;
            modified_interconnect?: {};
        };
    };
    export type magic_components$schemas$tunnel_single_response = Schemas.magic_api$response$single & {
        result?: {
            interconnect?: {};
        };
    };
    export interface magic_components$schemas$tunnel_update_request {
        description?: Schemas.magic_interconnect_components$schemas$description;
        gre?: Schemas.magic_gre;
        health_check?: Schemas.magic_schemas$health_check;
        interface_address?: Schemas.magic_interface_address;
        mtu?: Schemas.magic_schemas$mtu;
    }
    export type magic_components$schemas$tunnels_collection_response = Schemas.magic_api$response$single & {
        result?: {
            interconnects?: Schemas.magic_interconnect[];
        };
    };
    /** When the route was created. */
    export type magic_created_on = Date;
    /** The IP address assigned to the customer side of the GRE tunnel. */
    export type magic_customer_gre_endpoint = string;
    /** The IP address assigned to the customer side of the IPsec tunnel. */
    export type magic_customer_ipsec_endpoint = string;
    /** An optional human provided description of the static route. */
    export type magic_description = string;
    /** The configuration specific to GRE interconnects. */
    export interface magic_gre {
        /** The IP address assigned to the Cloudflare side of the GRE tunnel created as part of the Interconnect. */
        cloudflare_endpoint?: string;
    }
    export interface magic_gre$tunnel {
        cloudflare_gre_endpoint: Schemas.magic_cloudflare_gre_endpoint;
        created_on?: Schemas.magic_schemas$created_on;
        customer_gre_endpoint: Schemas.magic_customer_gre_endpoint;
        description?: Schemas.magic_schemas$description;
        health_check?: Schemas.magic_health_check;
        id?: Schemas.magic_schemas$identifier;
        interface_address: Schemas.magic_interface_address;
        modified_on?: Schemas.magic_schemas$modified_on;
        mtu?: Schemas.magic_mtu;
        name: Schemas.magic_name;
        ttl?: Schemas.magic_ttl;
    }
    export interface magic_health_check {
        /** The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel. */
        direction?: "unidirectional" | "bidirectional";
        /** Determines whether to run healthchecks for a tunnel. */
        enabled?: boolean;
        /** How frequent the health check is run. The default value is \`mid\`. */
        rate?: "low" | "mid" | "high";
        /** The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to \`customer_gre_endpoint address\`. */
        target?: string;
        /** The type of healthcheck to run, reply or request. The default value is \`reply\`. */
        type?: "reply" | "request";
    }
    /** Identifier */
    export type magic_identifier = string;
    export interface magic_interconnect {
        colo_name?: Schemas.magic_components$schemas$name;
        created_on?: Schemas.magic_schemas$created_on;
        description?: Schemas.magic_interconnect_components$schemas$description;
        gre?: Schemas.magic_gre;
        health_check?: Schemas.magic_schemas$health_check;
        id?: Schemas.magic_schemas$identifier;
        interface_address?: Schemas.magic_interface_address;
        modified_on?: Schemas.magic_schemas$modified_on;
        mtu?: Schemas.magic_schemas$mtu;
        name?: Schemas.magic_components$schemas$name;
    }
    /** An optional description of the interconnect. */
    export type magic_interconnect_components$schemas$description = string;
    /** A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0â€“10.255.255.255, 172.16.0.0â€“172.31.255.255, 192.168.0.0â€“192.168.255.255. */
    export type magic_interface_address = string;
    export interface magic_ipsec$tunnel {
        allow_null_cipher?: Schemas.magic_allow_null_cipher;
        cloudflare_endpoint: Schemas.magic_cloudflare_ipsec_endpoint;
        created_on?: Schemas.magic_schemas$created_on;
        customer_endpoint?: Schemas.magic_customer_ipsec_endpoint;
        description?: Schemas.magic_components$schemas$description;
        id?: Schemas.magic_schemas$identifier;
        interface_address: Schemas.magic_interface_address;
        modified_on?: Schemas.magic_schemas$modified_on;
        name: Schemas.magic_schemas$name;
        psk_metadata?: Schemas.magic_psk_metadata;
        replay_protection?: Schemas.magic_replay_protection;
        tunnel_health_check?: Schemas.magic_tunnel_health_check;
    }
    export type magic_messages = {
        code: number;
        message: string;
    }[];
    /** When the route was last modified. */
    export type magic_modified_on = Date;
    export type magic_modified_tunnels_collection_response = Schemas.magic_api$response$single & {
        result?: {
            modified?: boolean;
            modified_gre_tunnels?: Schemas.magic_gre$tunnel[];
        };
    };
    /** Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576. */
    export type magic_mtu = number;
    export type magic_multiple_route_delete_response = Schemas.magic_api$response$single & {
        result?: {
            deleted?: boolean;
            deleted_routes?: {};
        };
    };
    export type magic_multiple_route_modified_response = Schemas.magic_api$response$single & {
        result?: {
            modified?: boolean;
            modified_routes?: Schemas.magic_route[];
        };
    };
    /** The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel. */
    export type magic_name = string;
    /** The next-hop IP Address for the static route. */
    export type magic_nexthop = string;
    /** IP Prefix in Classless Inter-Domain Routing format. */
    export type magic_prefix = string;
    /** Priority of the static route. */
    export type magic_priority = number;
    /** A randomly generated or provided string for use in the IPsec tunnel. */
    export type magic_psk = string;
    export type magic_psk_generation_response = Schemas.magic_api$response$single & {
        result?: {
            ipsec_tunnel_id?: Schemas.magic_identifier;
            psk?: Schemas.magic_psk;
            psk_metadata?: Schemas.magic_psk_metadata;
        };
    };
    /** The PSK metadata that includes when the PSK was generated. */
    export interface magic_psk_metadata {
        last_generated_on?: Schemas.magic_schemas$modified_on;
    }
    /** If \`true\`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction. */
    export type magic_replay_protection = boolean;
    export interface magic_route {
        created_on?: Schemas.magic_created_on;
        description?: Schemas.magic_description;
        id?: Schemas.magic_identifier;
        modified_on?: Schemas.magic_modified_on;
        nexthop: Schemas.magic_nexthop;
        prefix: Schemas.magic_prefix;
        priority: Schemas.magic_priority;
        scope?: Schemas.magic_scope;
        weight?: Schemas.magic_weight;
    }
    export interface magic_route_add_single_request {
        description?: Schemas.magic_description;
        nexthop: Schemas.magic_nexthop;
        prefix: Schemas.magic_prefix;
        priority: Schemas.magic_priority;
        scope?: Schemas.magic_scope;
        weight?: Schemas.magic_weight;
    }
    export type magic_route_delete_id = {
        id: Schemas.magic_identifier;
    };
    export interface magic_route_delete_many_request {
        routes: Schemas.magic_route_delete_id[];
    }
    export type magic_route_deleted_response = Schemas.magic_api$response$single & {
        result?: {
            deleted?: boolean;
            deleted_route?: {};
        };
    };
    export type magic_route_modified_response = Schemas.magic_api$response$single & {
        result?: {
            modified?: boolean;
            modified_route?: {};
        };
    };
    export type magic_route_single_response = Schemas.magic_api$response$single & {
        result?: {
            route?: {};
        };
    };
    export interface magic_route_update_many_request {
        routes: Schemas.magic_route_update_single_request[];
    }
    export type magic_route_update_request = Schemas.magic_route_add_single_request;
    export type magic_route_update_single_request = {
        id: Schemas.magic_identifier;
    } & Schemas.magic_route_add_single_request;
    export type magic_routes_collection_response = Schemas.magic_api$response$single & {
        result?: {
            routes?: Schemas.magic_route[];
        };
    };
    /** The date and time the tunnel was created. */
    export type magic_schemas$created_on = Date;
    /** An optional description of the GRE tunnel. */
    export type magic_schemas$description = string;
    export interface magic_schemas$health_check {
        /** Determines whether to run healthchecks for a tunnel. */
        enabled?: boolean;
        /** How frequent the health check is run. The default value is \`mid\`. */
        rate?: "low" | "mid" | "high";
        /** The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to \`customer_gre_endpoint address\`. */
        target?: string;
        /** The type of healthcheck to run, reply or request. The default value is \`reply\`. */
        type?: "reply" | "request";
    }
    /** Tunnel identifier tag. */
    export type magic_schemas$identifier = string;
    /** The date and time the tunnel was last modified. */
    export type magic_schemas$modified_on = Date;
    export type magic_schemas$modified_tunnels_collection_response = Schemas.magic_api$response$single & {
        result?: {
            modified?: boolean;
            modified_ipsec_tunnels?: Schemas.magic_ipsec$tunnel[];
        };
    };
    /** The Maximum Transmission Unit (MTU) in bytes for the interconnect. The minimum value is 576. */
    export type magic_schemas$mtu = number;
    /** The name of the IPsec tunnel. The name cannot share a name with other tunnels. */
    export type magic_schemas$name = string;
    export type magic_schemas$tunnel_add_request = Schemas.magic_schemas$tunnel_add_single_request;
    export interface magic_schemas$tunnel_add_single_request {
        cloudflare_endpoint: Schemas.magic_cloudflare_ipsec_endpoint;
        customer_endpoint?: Schemas.magic_customer_ipsec_endpoint;
        description?: Schemas.magic_components$schemas$description;
        interface_address: Schemas.magic_interface_address;
        name: Schemas.magic_schemas$name;
        psk?: Schemas.magic_psk;
        replay_protection?: Schemas.magic_replay_protection;
    }
    export type magic_schemas$tunnel_deleted_response = Schemas.magic_api$response$single & {
        result?: {
            deleted?: boolean;
            deleted_ipsec_tunnel?: {};
        };
    };
    export type magic_schemas$tunnel_modified_response = Schemas.magic_api$response$single & {
        result?: {
            modified?: boolean;
            modified_ipsec_tunnel?: {};
        };
    };
    export type magic_schemas$tunnel_single_response = Schemas.magic_api$response$single & {
        result?: {
            ipsec_tunnel?: {};
        };
    };
    export type magic_schemas$tunnel_update_request = Schemas.magic_schemas$tunnel_add_single_request;
    export type magic_schemas$tunnels_collection_response = Schemas.magic_api$response$single & {
        result?: {
            ipsec_tunnels?: Schemas.magic_ipsec$tunnel[];
        };
    };
    /** Used only for ECMP routes. */
    export interface magic_scope {
        colo_names?: Schemas.magic_colo_names;
        colo_regions?: Schemas.magic_colo_regions;
    }
    /** Time To Live (TTL) in number of hops of the GRE tunnel. */
    export type magic_ttl = number;
    export interface magic_tunnel_add_single_request {
        cloudflare_gre_endpoint: Schemas.magic_cloudflare_gre_endpoint;
        customer_gre_endpoint: Schemas.magic_customer_gre_endpoint;
        description?: Schemas.magic_schemas$description;
        health_check?: Schemas.magic_health_check;
        interface_address: Schemas.magic_interface_address;
        mtu?: Schemas.magic_mtu;
        name: Schemas.magic_name;
        ttl?: Schemas.magic_ttl;
    }
    export type magic_tunnel_deleted_response = Schemas.magic_api$response$single & {
        result?: {
            deleted?: boolean;
            deleted_gre_tunnel?: {};
        };
    };
    export interface magic_tunnel_health_check {
        /** Determines whether to run healthchecks for a tunnel. */
        enabled?: boolean;
        /** How frequent the health check is run. The default value is \`mid\`. */
        rate?: "low" | "mid" | "high";
        /** The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to \`customer_gre_endpoint address\`. */
        target?: string;
        /** The type of healthcheck to run, reply or request. The default value is \`reply\`. */
        type?: "reply" | "request";
    }
    export type magic_tunnel_modified_response = Schemas.magic_api$response$single & {
        result?: {
            modified?: boolean;
            modified_gre_tunnel?: {};
        };
    };
    export type magic_tunnel_single_response = Schemas.magic_api$response$single & {
        result?: {
            gre_tunnel?: {};
        };
    };
    export type magic_tunnel_update_request = Schemas.magic_tunnel_add_single_request;
    export type magic_tunnels_collection_response = Schemas.magic_api$response$single & {
        result?: {
            gre_tunnels?: Schemas.magic_gre$tunnel[];
        };
    };
    /** Optional weight of the ECMP scope - if provided. */
    export type magic_weight = number;
    export type mrUXABdt_access$policy = Schemas.mrUXABdt_policy_with_permission_groups;
    export interface mrUXABdt_account {
        /** Timestamp for the creation of the account */
        readonly created_on?: Date;
        id: Schemas.mrUXABdt_common_components$schemas$identifier;
        /** Account name */
        name: string;
        /** Account settings */
        settings?: {
            /**
             * Specifies the default nameservers to be used for new zones added to this account.
             *
             * - \`cloudflare.standard\` for Cloudflare-branded nameservers
             * - \`custom.account\` for account custom nameservers
             * - \`custom.tenant\` for tenant custom nameservers
             *
             * See [Custom Nameservers](https://developers.cloudflare.com/dns/additional-options/custom-nameservers/)
             * for more information.
             */
            default_nameservers?: "cloudflare.standard" | "custom.account" | "custom.tenant";
            /**
             * Indicates whether membership in this account requires that
             * Two-Factor Authentication is enabled
             */
            enforce_twofactor?: boolean;
            /**
             * Indicates whether new zones should use the account-level custom
             * nameservers by default
             */
            use_account_custom_ns_by_default?: boolean;
        };
    }
    export type mrUXABdt_account_identifier = any;
    export type mrUXABdt_api$response$collection = Schemas.mrUXABdt_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.mrUXABdt_result_info;
    };
    export interface mrUXABdt_api$response$common {
        errors: Schemas.mrUXABdt_messages;
        messages: Schemas.mrUXABdt_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface mrUXABdt_api$response$common$failure {
        errors: Schemas.mrUXABdt_messages;
        messages: Schemas.mrUXABdt_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type mrUXABdt_api$response$single = Schemas.mrUXABdt_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export type mrUXABdt_api$response$single$id = Schemas.mrUXABdt_api$response$common & {
        result?: {
            id: Schemas.mrUXABdt_common_components$schemas$identifier;
        } | null;
    };
    /** Enterprise only. Indicates whether or not API access is enabled specifically for this user on a given account. */
    export type mrUXABdt_api_access_enabled = boolean | null;
    export interface mrUXABdt_base {
        expires_on?: Schemas.mrUXABdt_schemas$expires_on;
        id?: Schemas.mrUXABdt_invite_components$schemas$identifier;
        invited_by?: Schemas.mrUXABdt_invited_by;
        invited_member_email?: Schemas.mrUXABdt_invited_member_email;
        /** ID of the user to add to the organization. */
        readonly invited_member_id: string | null;
        invited_on?: Schemas.mrUXABdt_invited_on;
        /** ID of the organization the user will be added to. */
        readonly organization_id: string;
        /** Organization name. */
        readonly organization_name?: string;
        /** Roles to be assigned to this user. */
        roles?: Schemas.mrUXABdt_schemas$role[];
    }
    /** List of IPv4/IPv6 CIDR addresses. */
    export type mrUXABdt_cidr_list = string[];
    /** The unique activation code for the account membership. */
    export type mrUXABdt_code = string;
    export type mrUXABdt_collection_invite_response = Schemas.mrUXABdt_api$response$collection & {
        result?: Schemas.mrUXABdt_invite[];
    };
    export type mrUXABdt_collection_member_response = Schemas.mrUXABdt_api$response$collection & {
        result?: Schemas.mrUXABdt_components$schemas$member[];
    };
    export type mrUXABdt_collection_membership_response = Schemas.mrUXABdt_api$response$collection & {
        result?: Schemas.mrUXABdt_membership[];
    };
    export type mrUXABdt_collection_organization_response = Schemas.mrUXABdt_api$response$collection & {
        result?: Schemas.mrUXABdt_organization[];
    };
    export type mrUXABdt_collection_role_response = Schemas.mrUXABdt_api$response$collection & {
        result?: Schemas.mrUXABdt_schemas$role[];
    };
    /** Identifier */
    export type mrUXABdt_common_components$schemas$identifier = string;
    export type mrUXABdt_components$schemas$account = Schemas.mrUXABdt_account;
    /** Token identifier tag. */
    export type mrUXABdt_components$schemas$identifier = string;
    export interface mrUXABdt_components$schemas$member {
        email: Schemas.mrUXABdt_email;
        id: Schemas.mrUXABdt_common_components$schemas$identifier;
        name: Schemas.mrUXABdt_member_components$schemas$name;
        /** Roles assigned to this Member. */
        roles: Schemas.mrUXABdt_schemas$role[];
        /** A member's status in the organization. */
        status: "accepted" | "invited";
    }
    /** Role Name. */
    export type mrUXABdt_components$schemas$name = string;
    /** Whether the user is a member of the organization or has an inivitation pending. */
    export type mrUXABdt_components$schemas$status = "member" | "invited";
    export interface mrUXABdt_condition {
        "request.ip"?: Schemas.mrUXABdt_request$ip;
    }
    /** The country in which the user lives. */
    export type mrUXABdt_country = string | null;
    export interface mrUXABdt_create {
        email: Schemas.mrUXABdt_email;
        /** Array of roles associated with this member. */
        roles: Schemas.mrUXABdt_role_components$schemas$identifier[];
        status?: "accepted" | "pending";
    }
    export interface mrUXABdt_create_payload {
        condition?: Schemas.mrUXABdt_condition;
        expires_on?: Schemas.mrUXABdt_expires_on;
        name: Schemas.mrUXABdt_name;
        not_before?: Schemas.mrUXABdt_not_before;
        policies: Schemas.mrUXABdt_policies;
    }
    /** Description of role's permissions. */
    export type mrUXABdt_description = string;
    /** Allow or deny operations against the resources. */
    export type mrUXABdt_effect = "allow" | "deny";
    /** The contact email address of the user. */
    export type mrUXABdt_email = string;
    /** The expiration time on or after which the JWT MUST NOT be accepted for processing. */
    export type mrUXABdt_expires_on = Date;
    /** User's first name */
    export type mrUXABdt_first_name = string | null;
    export interface mrUXABdt_grants {
        read?: boolean;
        write?: boolean;
    }
    /** Policy identifier. */
    export type mrUXABdt_identifier = string;
    export type mrUXABdt_invite = Schemas.mrUXABdt_organization_invite;
    /** Invite identifier tag. */
    export type mrUXABdt_invite_components$schemas$identifier = string;
    /** The email address of the user who created the invite. */
    export type mrUXABdt_invited_by = string;
    /** Email address of the user to add to the organization. */
    export type mrUXABdt_invited_member_email = string;
    /** When the invite was sent. */
    export type mrUXABdt_invited_on = Date;
    /** The time on which the token was created. */
    export type mrUXABdt_issued_on = Date;
    /** User's last name */
    export type mrUXABdt_last_name = string | null;
    export interface mrUXABdt_member {
        id: Schemas.mrUXABdt_membership_components$schemas$identifier;
        /** Roles assigned to this member. */
        roles: Schemas.mrUXABdt_role[];
        readonly status: any;
        readonly user: {
            email: Schemas.mrUXABdt_email;
            first_name?: Schemas.mrUXABdt_first_name;
            id?: Schemas.mrUXABdt_common_components$schemas$identifier;
            last_name?: Schemas.mrUXABdt_last_name;
            two_factor_authentication_enabled?: Schemas.mrUXABdt_two_factor_authentication_enabled;
        };
    }
    /** Member Name. */
    export type mrUXABdt_member_components$schemas$name = string | null;
    export type mrUXABdt_member_with_code = Schemas.mrUXABdt_member & {
        code?: Schemas.mrUXABdt_code;
    };
    export interface mrUXABdt_membership {
        account?: Schemas.mrUXABdt_schemas$account;
        api_access_enabled?: Schemas.mrUXABdt_api_access_enabled;
        code?: Schemas.mrUXABdt_code;
        id?: Schemas.mrUXABdt_membership_components$schemas$identifier;
        /** All access permissions for the user at the account. */
        readonly permissions?: Schemas.mrUXABdt_permissions;
        roles?: Schemas.mrUXABdt_roles;
        status?: Schemas.mrUXABdt_schemas$status;
    }
    /** Membership identifier tag. */
    export type mrUXABdt_membership_components$schemas$identifier = string;
    export type mrUXABdt_messages = {
        code: number;
        message: string;
    }[];
    /** Last time the token was modified. */
    export type mrUXABdt_modified_on = Date;
    /** Token name. */
    export type mrUXABdt_name = string;
    /** The time before which the token MUST NOT be accepted for processing. */
    export type mrUXABdt_not_before = Date;
    export interface mrUXABdt_organization {
        id?: Schemas.mrUXABdt_common_components$schemas$identifier;
        name?: Schemas.mrUXABdt_schemas$name;
        permissions?: Schemas.mrUXABdt_schemas$permissions;
        /** List of roles that a user has within an organization. */
        readonly roles?: string[];
        status?: Schemas.mrUXABdt_components$schemas$status;
    }
    /** Organization identifier tag. */
    export type mrUXABdt_organization_components$schemas$identifier = string;
    export type mrUXABdt_organization_invite = Schemas.mrUXABdt_base & {
        /** Current status of two-factor enforcement on the organization. */
        organization_is_enforcing_twofactor?: boolean;
        /** Current status of the invitation. */
        status?: "pending" | "accepted" | "rejected" | "canceled" | "left" | "expired";
    };
    /** A named group of permissions that map to a group of operations against resources. */
    export interface mrUXABdt_permission_group {
        /** Identifier of the group. */
        readonly id: string;
        /** Name of the group. */
        readonly name?: string;
    }
    /** A set of permission groups that are specified to the policy. */
    export type mrUXABdt_permission_groups = Schemas.mrUXABdt_permission_group[];
    export interface mrUXABdt_permissions {
        analytics?: Schemas.mrUXABdt_grants;
        billing?: Schemas.mrUXABdt_grants;
        cache_purge?: Schemas.mrUXABdt_grants;
        dns?: Schemas.mrUXABdt_grants;
        dns_records?: Schemas.mrUXABdt_grants;
        lb?: Schemas.mrUXABdt_grants;
        logs?: Schemas.mrUXABdt_grants;
        organization?: Schemas.mrUXABdt_grants;
        ssl?: Schemas.mrUXABdt_grants;
        waf?: Schemas.mrUXABdt_grants;
        zone_settings?: Schemas.mrUXABdt_grants;
        zones?: Schemas.mrUXABdt_grants;
    }
    /** List of access policies assigned to the token. */
    export type mrUXABdt_policies = Schemas.mrUXABdt_access$policy[];
    export interface mrUXABdt_policy_with_permission_groups {
        effect: Schemas.mrUXABdt_effect;
        id: Schemas.mrUXABdt_identifier;
        permission_groups: Schemas.mrUXABdt_permission_groups;
        resources: Schemas.mrUXABdt_resources;
    }
    /** Account name */
    export type mrUXABdt_properties$name = string;
    /** Client IP restrictions. */
    export interface mrUXABdt_request$ip {
        in?: Schemas.mrUXABdt_cidr_list;
        not_in?: Schemas.mrUXABdt_cidr_list;
    }
    /** A list of resource names that the policy applies to. */
    export interface mrUXABdt_resources {
    }
    export type mrUXABdt_response_collection = Schemas.mrUXABdt_api$response$collection & {
        result?: {}[];
    };
    export type mrUXABdt_response_create = Schemas.mrUXABdt_api$response$single & {
        result?: {} & {
            value?: Schemas.mrUXABdt_value;
        };
    };
    export type mrUXABdt_response_single = Schemas.mrUXABdt_api$response$single & {
        result?: {};
    };
    export type mrUXABdt_response_single_segment = Schemas.mrUXABdt_api$response$single & {
        result?: {
            expires_on?: Schemas.mrUXABdt_expires_on;
            id: Schemas.mrUXABdt_components$schemas$identifier;
            not_before?: Schemas.mrUXABdt_not_before;
            status: Schemas.mrUXABdt_status;
        };
    };
    export type mrUXABdt_response_single_value = Schemas.mrUXABdt_api$response$single & {
        result?: Schemas.mrUXABdt_value;
    };
    export interface mrUXABdt_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export interface mrUXABdt_role {
        /** Description of role's permissions. */
        readonly description: string;
        id: Schemas.mrUXABdt_role_components$schemas$identifier;
        /** Role name. */
        readonly name: string;
        permissions: Schemas.mrUXABdt_permissions & any;
    }
    /** Role identifier tag. */
    export type mrUXABdt_role_components$schemas$identifier = string;
    /** List of role names for the user at the account. */
    export type mrUXABdt_roles = string[];
    export type mrUXABdt_schemas$account = Schemas.mrUXABdt_account;
    export type mrUXABdt_schemas$collection_invite_response = Schemas.mrUXABdt_api$response$collection & {
        result?: Schemas.mrUXABdt_schemas$invite[];
    };
    /** When the invite is no longer active. */
    export type mrUXABdt_schemas$expires_on = Date;
    export type mrUXABdt_schemas$identifier = any;
    export type mrUXABdt_schemas$invite = Schemas.mrUXABdt_user_invite;
    export type mrUXABdt_schemas$member = Schemas.mrUXABdt_member;
    /** Organization name. */
    export type mrUXABdt_schemas$name = string;
    /** Access permissions for this User. */
    export type mrUXABdt_schemas$permissions = string[];
    export type mrUXABdt_schemas$response_collection = Schemas.mrUXABdt_api$response$collection & {
        result?: {}[];
    };
    export interface mrUXABdt_schemas$role {
        description: Schemas.mrUXABdt_description;
        id: Schemas.mrUXABdt_role_components$schemas$identifier;
        name: Schemas.mrUXABdt_components$schemas$name;
        permissions: Schemas.mrUXABdt_schemas$permissions;
    }
    /** Status of this membership. */
    export type mrUXABdt_schemas$status = "accepted" | "pending" | "rejected";
    export type mrUXABdt_schemas$token = Schemas.mrUXABdt_token;
    export type mrUXABdt_single_invite_response = Schemas.mrUXABdt_api$response$single & {
        result?: {};
    };
    export type mrUXABdt_single_member_response = Schemas.mrUXABdt_api$response$single & {
        result?: Schemas.mrUXABdt_member;
    };
    export type mrUXABdt_single_member_response_with_code = Schemas.mrUXABdt_api$response$single & {
        result?: Schemas.mrUXABdt_member_with_code;
    };
    export type mrUXABdt_single_membership_response = Schemas.mrUXABdt_api$response$single & {
        result?: {};
    };
    export type mrUXABdt_single_organization_response = Schemas.mrUXABdt_api$response$single & {
        result?: {};
    };
    export type mrUXABdt_single_role_response = Schemas.mrUXABdt_api$response$single & {
        result?: {};
    };
    export type mrUXABdt_single_user_response = Schemas.mrUXABdt_api$response$single & {
        result?: {};
    };
    /** Status of the token. */
    export type mrUXABdt_status = "active" | "disabled" | "expired";
    /** User's telephone number */
    export type mrUXABdt_telephone = string | null;
    export interface mrUXABdt_token {
        condition?: Schemas.mrUXABdt_condition;
        expires_on?: Schemas.mrUXABdt_expires_on;
        id: Schemas.mrUXABdt_components$schemas$identifier;
        issued_on?: Schemas.mrUXABdt_issued_on;
        modified_on?: Schemas.mrUXABdt_modified_on;
        name: Schemas.mrUXABdt_name;
        not_before?: Schemas.mrUXABdt_not_before;
        policies: Schemas.mrUXABdt_policies;
        status: Schemas.mrUXABdt_status;
    }
    /** Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication. */
    export type mrUXABdt_two_factor_authentication_enabled = boolean;
    export type mrUXABdt_user_invite = Schemas.mrUXABdt_base & {
        /** Current status of the invitation. */
        status?: "pending" | "accepted" | "rejected" | "expired";
    };
    /** The token value. */
    export type mrUXABdt_value = string;
    /** The zipcode or postal code where the user lives. */
    export type mrUXABdt_zipcode = string | null;
    export type observatory_api$response$collection = Schemas.observatory_api$response$common;
    export interface observatory_api$response$common {
        errors: Schemas.observatory_messages;
        messages: Schemas.observatory_messages;
        /** Whether the API call was successful. */
        success: boolean;
    }
    export interface observatory_api$response$common$failure {
        errors: Schemas.observatory_messages;
        messages: Schemas.observatory_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type observatory_api$response$single = Schemas.observatory_api$response$common;
    export interface observatory_availabilities {
        quota?: {
            /** Cloudflare plan. */
            plan?: string;
            /** The number of tests available per plan. */
            quotasPerPlan?: {};
            /** The number of remaining schedules available. */
            remainingSchedules?: number;
            /** The number of remaining tests available. */
            remainingTests?: number;
            /** The number of schedules available per plan. */
            scheduleQuotasPerPlan?: {};
        };
        regions?: Schemas.observatory_labeled_region[];
        regionsPerPlan?: {};
    }
    export type observatory_availabilities$response = Schemas.observatory_api$response$single & {
        result?: Schemas.observatory_availabilities;
    };
    export type observatory_count$response = Schemas.observatory_api$response$single & {
        result?: {
            /** Number of items affected. */
            count?: number;
        };
    };
    export type observatory_create$schedule$response = Schemas.observatory_api$response$single & {
        result?: {
            schedule?: Schemas.observatory_schedule;
            test?: Schemas.observatory_page_test;
        };
    };
    /** The type of device. */
    export type observatory_device_type = "DESKTOP" | "MOBILE";
    /** Identifier */
    export type observatory_identifier = string;
    /** A test region with a label. */
    export interface observatory_labeled_region {
        label?: string;
        value?: Schemas.observatory_region;
    }
    /** The error code of the Lighthouse result. */
    export type observatory_lighthouse_error_code = "NOT_REACHABLE" | "DNS_FAILURE" | "NOT_HTML" | "LIGHTHOUSE_TIMEOUT" | "UNKNOWN";
    /** The Lighthouse report. */
    export interface observatory_lighthouse_report {
        /** Cumulative Layout Shift. */
        cls?: number;
        deviceType?: Schemas.observatory_device_type;
        error?: {
            code?: Schemas.observatory_lighthouse_error_code;
            /** Detailed error message. */
            detail?: string;
            /** The final URL displayed to the user. */
            finalDisplayedUrl?: string;
        };
        /** First Contentful Paint. */
        fcp?: number;
        /** The URL to the full Lighthouse JSON report. */
        jsonReportUrl?: string;
        /** Largest Contentful Paint. */
        lcp?: number;
        /** The Lighthouse performance score. */
        performanceScore?: number;
        /** Speed Index. */
        si?: number;
        state?: Schemas.observatory_lighthouse_state;
        /** Total Blocking Time. */
        tbt?: number;
        /** Time To First Byte. */
        ttfb?: number;
        /** Time To Interactive. */
        tti?: number;
    }
    /** The state of the Lighthouse report. */
    export type observatory_lighthouse_state = "RUNNING" | "COMPLETE" | "FAILED";
    export type observatory_messages = {
        code: number;
        message: string;
    }[];
    export type observatory_page$test$response$collection = Schemas.observatory_api$response$collection & {
        result?: Schemas.observatory_page_test[];
    } & {
        result_info?: Schemas.observatory_result_info;
    };
    export type observatory_page$test$response$single = Schemas.observatory_api$response$single & {
        result?: Schemas.observatory_page_test;
    };
    export interface observatory_page_test {
        date?: Schemas.observatory_timestamp;
        desktopReport?: Schemas.observatory_lighthouse_report;
        id?: Schemas.observatory_uuid;
        mobileReport?: Schemas.observatory_lighthouse_report;
        region?: Schemas.observatory_labeled_region;
        scheduleFrequency?: Schemas.observatory_schedule_frequency;
        url?: Schemas.observatory_url;
    }
    export type observatory_pages$response$collection = Schemas.observatory_api$response$collection & {
        result?: {
            region?: Schemas.observatory_labeled_region;
            scheduleFrequency?: Schemas.observatory_schedule_frequency;
            tests?: Schemas.observatory_page_test[];
            url?: Schemas.observatory_url;
        }[];
    };
    /** A test region. */
    export type observatory_region = "asia-east1" | "asia-northeast1" | "asia-northeast2" | "asia-south1" | "asia-southeast1" | "australia-southeast1" | "europe-north1" | "europe-southwest1" | "europe-west1" | "europe-west2" | "europe-west3" | "europe-west4" | "europe-west8" | "europe-west9" | "me-west1" | "southamerica-east1" | "us-central1" | "us-east1" | "us-east4" | "us-south1" | "us-west1";
    export interface observatory_result_info {
        count?: number;
        page?: number;
        per_page?: number;
        total_count?: number;
    }
    /** The test schedule. */
    export interface observatory_schedule {
        frequency?: Schemas.observatory_schedule_frequency;
        region?: Schemas.observatory_region;
        url?: Schemas.observatory_url;
    }
    export type observatory_schedule$response$single = Schemas.observatory_api$response$single & {
        result?: Schemas.observatory_schedule;
    };
    /** The frequency of the test. */
    export type observatory_schedule_frequency = "DAILY" | "WEEKLY";
    export type observatory_timestamp = Date;
    export interface observatory_trend {
        /** Cumulative Layout Shift trend. */
        cls?: (number | null)[];
        /** First Contentful Paint trend. */
        fcp?: (number | null)[];
        /** Largest Contentful Paint trend. */
        lcp?: (number | null)[];
        /** The Lighthouse score trend. */
        performanceScore?: (number | null)[];
        /** Speed Index trend. */
        si?: (number | null)[];
        /** Total Blocking Time trend. */
        tbt?: (number | null)[];
        /** Time To First Byte trend. */
        ttfb?: (number | null)[];
        /** Time To Interactive trend. */
        tti?: (number | null)[];
    }
    export type observatory_trend$response = Schemas.observatory_api$response$single & {
        result?: Schemas.observatory_trend;
    };
    /** A URL. */
    export type observatory_url = string;
    /** UUID */
    export type observatory_uuid = string;
    export type page$shield_api$response$collection = Schemas.page$shield_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.page$shield_result_info;
    };
    export interface page$shield_api$response$common {
        errors: Schemas.page$shield_messages;
        messages: Schemas.page$shield_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface page$shield_api$response$common$failure {
        errors: Schemas.page$shield_messages;
        messages: Schemas.page$shield_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type page$shield_api$response$single = Schemas.page$shield_api$response$common & {
        result?: {} | {}[] | string;
    };
    export interface page$shield_connection {
        added_at?: any;
        domain_reported_malicious?: any;
        first_page_url?: any;
        first_seen_at?: any;
        host?: any;
        id?: any;
        last_seen_at?: any;
        page_urls?: any;
        url?: any;
        url_contains_cdn_cgi_path?: any;
    }
    /** When true, indicates that Page Shield is enabled. */
    export type page$shield_enabled = boolean;
    /** The timestamp of when the script was last fetched. */
    export type page$shield_fetched_at = string | null;
    export type page$shield_get$zone$connection$response = Schemas.page$shield_connection;
    export type page$shield_get$zone$policy$response = Schemas.page$shield_pageshield$policy;
    export type page$shield_get$zone$script$response = Schemas.page$shield_script & {
        versions?: Schemas.page$shield_version[] | null;
    };
    export interface page$shield_get$zone$settings$response {
        enabled?: Schemas.page$shield_enabled;
        updated_at?: Schemas.page$shield_updated_at;
        use_cloudflare_reporting_endpoint?: Schemas.page$shield_use_cloudflare_reporting_endpoint;
        use_connection_url_path?: Schemas.page$shield_use_connection_url_path;
    }
    /** The computed hash of the analyzed script. */
    export type page$shield_hash = string | null;
    /** Identifier */
    export type page$shield_identifier = string;
    /** The integrity score of the JavaScript content. */
    export type page$shield_js_integrity_score = number | null;
    export type page$shield_list$zone$connections$response = Schemas.page$shield_api$response$collection & {
        result?: Schemas.page$shield_connection[];
        result_info?: Schemas.page$shield_result_info;
    };
    export type page$shield_list$zone$policies$response = Schemas.page$shield_api$response$collection & {
        result?: Schemas.page$shield_pageshield$policy[];
    };
    export type page$shield_list$zone$scripts$response = Schemas.page$shield_api$response$collection & {
        result?: Schemas.page$shield_script[];
        result_info?: Schemas.page$shield_result_info;
    };
    export type page$shield_messages = {
        code: number;
        message: string;
    }[];
    export interface page$shield_pageshield$policy {
        action?: Schemas.page$shield_pageshield$policy$action;
        description?: Schemas.page$shield_pageshield$policy$description;
        enabled?: Schemas.page$shield_pageshield$policy$enabled;
        expression?: Schemas.page$shield_pageshield$policy$expression;
        id?: Schemas.page$shield_pageshield$policy$id;
        value?: Schemas.page$shield_pageshield$policy$value;
    }
    /** The action to take if the expression matches */
    export type page$shield_pageshield$policy$action = "allow" | "log";
    /** A description for the policy */
    export type page$shield_pageshield$policy$description = string;
    /** Whether the policy is enabled */
    export type page$shield_pageshield$policy$enabled = boolean;
    /** The expression which must match for the policy to be applied, using the Cloudflare Firewall rule expression syntax */
    export type page$shield_pageshield$policy$expression = string;
    /** The ID of the policy */
    export type page$shield_pageshield$policy$id = string;
    /** The policy which will be applied */
    export type page$shield_pageshield$policy$value = string;
    /** The ID of the policy. */
    export type page$shield_policy_id = string;
    /** The ID of the resource. */
    export type page$shield_resource_id = string;
    export interface page$shield_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export interface page$shield_script {
        added_at?: any;
        domain_reported_malicious?: any;
        fetched_at?: any;
        first_page_url?: any;
        first_seen_at?: any;
        hash?: any;
        host?: any;
        id?: any;
        js_integrity_score?: any;
        last_seen_at?: any;
        page_urls?: any;
        url?: any;
        url_contains_cdn_cgi_path?: any;
    }
    export interface page$shield_update$zone$settings$response {
        enabled?: Schemas.page$shield_enabled;
        updated_at?: Schemas.page$shield_updated_at;
        use_cloudflare_reporting_endpoint?: Schemas.page$shield_use_cloudflare_reporting_endpoint;
        use_connection_url_path?: Schemas.page$shield_use_connection_url_path;
    }
    /** The timestamp of when Page Shield was last updated. */
    export type page$shield_updated_at = string;
    /** When true, CSP reports will be sent to https://csp-reporting.cloudflare.com/cdn-cgi/script_monitor/report */
    export type page$shield_use_cloudflare_reporting_endpoint = boolean;
    /** When true, the paths associated with connections URLs will also be analyzed. */
    export type page$shield_use_connection_url_path = boolean;
    /** The version of the analyzed script. */
    export interface page$shield_version {
        fetched_at?: Schemas.page$shield_fetched_at;
        hash?: Schemas.page$shield_hash;
        js_integrity_score?: Schemas.page$shield_js_integrity_score;
    }
    export type page$shield_zone_settings_response_single = Schemas.page$shield_api$response$single & {
        result?: {};
    };
    export interface pages_api$response$common {
        errors: Schemas.pages_messages;
        messages: Schemas.pages_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface pages_api$response$common$failure {
        errors: Schemas.pages_messages;
        messages: Schemas.pages_messages;
        result: {} | null;
        /** Whether the API call was successful. */
        success: false;
    }
    export type pages_api$response$single = Schemas.pages_api$response$common & {
        result?: {} | null;
    };
    /** Configs for the project build process. */
    export interface pages_build_config {
        /** Enable build caching for the project. */
        build_caching?: boolean | null;
        /** Command used to build project. */
        build_command?: string | null;
        /** Output directory of the build. */
        destination_dir?: string | null;
        /** Directory to run the command. */
        root_dir?: string | null;
        /** The classifying tag for analytics. */
        web_analytics_tag?: string | null;
        /** The auth token for analytics. */
        web_analytics_token?: string | null;
    }
    export type pages_deployment$list$response = Schemas.pages_api$response$common & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
        };
    } & {
        result?: Schemas.pages_deployments[];
    };
    export type pages_deployment$new$deployment = Schemas.pages_api$response$common & {
        result?: Schemas.pages_deployments;
    };
    export type pages_deployment$response$details = Schemas.pages_api$response$common & {
        result?: Schemas.pages_deployments;
    };
    export type pages_deployment$response$logs = Schemas.pages_api$response$common & {
        result?: {};
    };
    export type pages_deployment$response$stage$logs = Schemas.pages_api$response$common & {
        result?: {};
    };
    /** Configs for deployments in a project. */
    export interface pages_deployment_configs {
        /** Configs for preview deploys. */
        preview?: Schemas.pages_deployment_configs_values;
        /** Configs for production deploys. */
        production?: Schemas.pages_deployment_configs_values;
    }
    export interface pages_deployment_configs_values {
        /** Constellation bindings used for Pages Functions. */
        ai_bindings?: {
            /** AI binding. */
            AI_BINDING?: {
                project_id?: {};
            };
        } | null;
        /** Analytics Engine bindings used for Pages Functions. */
        analytics_engine_datasets?: {
            /** Analytics Engine binding. */
            ANALYTICS_ENGINE_BINDING?: {
                /** Name of the dataset. */
                dataset?: string;
            };
        } | null;
        /** Compatibility date used for Pages Functions. */
        compatibility_date?: string;
        /** Compatibility flags used for Pages Functions. */
        compatibility_flags?: {}[];
        /** D1 databases used for Pages Functions. */
        d1_databases?: {
            /** D1 binding. */
            D1_BINDING?: {
                /** UUID of the D1 database. */
                id?: string;
            };
        } | null;
        /** Durabble Object namespaces used for Pages Functions. */
        durable_object_namespaces?: {
            /** Durabble Object binding. */
            DO_BINDING?: {
                /** ID of the Durabble Object namespace. */
                namespace_id?: string;
            };
        } | null;
        /** Environment variables for build configs. */
        env_vars?: {
            /** Environment variable. */
            ENVIRONMENT_VARIABLE?: {
                /** The type of environment variable (plain text or secret) */
                type?: "plain_text" | "secret_text";
                /** Environment variable value. */
                value?: string;
            };
        } | null;
        /** KV namespaces used for Pages Functions. */
        kv_namespaces?: {
            /** KV binding. */
            KV_BINDING?: {
                /** ID of the KV namespace. */
                namespace_id?: string;
            };
        };
        /** Placement setting used for Pages Functions. */
        placement?: {
            /** Placement mode. */
            mode?: string;
        } | null;
        /** Queue Producer bindings used for Pages Functions. */
        queue_producers?: {
            /** Queue Producer binding. */
            QUEUE_PRODUCER_BINDING?: {
                /** Name of the Queue. */
                name?: string;
            };
        } | null;
        /** R2 buckets used for Pages Functions. */
        r2_buckets?: {
            /** R2 binding. */
            R2_BINDING?: {
                /** Name of the R2 bucket. */
                name?: string;
            };
        } | null;
        /** Services used for Pages Functions. */
        service_bindings?: {
            /** Service binding. */
            SERVICE_BINDING?: {
                /** The Service environment. */
                environment?: string;
                /** The Service name. */
                service?: string;
            };
        } | null;
    }
    /** Deployment stage name. */
    export type pages_deployment_stage_name = string;
    export interface pages_deployments {
        /** A list of alias URLs pointing to this deployment. */
        readonly aliases?: {}[] | null;
        readonly build_config?: any;
        /** When the deployment was created. */
        readonly created_on?: Date;
        /** Info about what caused the deployment. */
        readonly deployment_trigger?: {
            /** Additional info about the trigger. */
            metadata?: {
                /** Where the trigger happened. */
                readonly branch?: string;
                /** Hash of the deployment trigger commit. */
                readonly commit_hash?: string;
                /** Message of the deployment trigger commit. */
                readonly commit_message?: string;
            };
            /** What caused the deployment. */
            readonly type?: string;
        };
        /** A dict of env variables to build this deploy. */
        readonly env_vars?: {};
        /** Type of deploy. */
        readonly environment?: string;
        /** Id of the deployment. */
        readonly id?: string;
        /** If the deployment has been skipped. */
        readonly is_skipped?: boolean;
        readonly latest_stage?: any;
        /** When the deployment was last modified. */
        readonly modified_on?: Date;
        /** Id of the project. */
        readonly project_id?: string;
        /** Name of the project. */
        readonly project_name?: string;
        /** Short Id (8 character) of the deployment. */
        readonly short_id?: string;
        readonly source?: any;
        /** List of past stages. */
        readonly stages?: Schemas.pages_stage[];
        /** The live URL to view this deployment. */
        readonly url?: string;
    }
    export type pages_domain$response$collection = Schemas.pages_api$response$common & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
        };
    } & {
        result?: {}[];
    };
    export type pages_domain$response$single = Schemas.pages_api$response$single & {
        result?: {};
    };
    /** Name of the domain. */
    export type pages_domain_name = string;
    export type pages_domains$post = any;
    /** Identifier */
    export type pages_identifier = string;
    export type pages_messages = {
        code: number;
        message: string;
    }[];
    export type pages_new$project$response = Schemas.pages_api$response$common & {
        result?: {};
    };
    export type pages_project$patch = any;
    export type pages_project$response = Schemas.pages_api$response$common & {
        result?: Schemas.pages_projects;
    };
    /** Name of the project. */
    export type pages_project_name = string;
    export interface pages_projects {
        build_config?: Schemas.pages_build_config;
        canonical_deployment?: Schemas.pages_deployments;
        /** When the project was created. */
        readonly created_on?: Date;
        deployment_configs?: Schemas.pages_deployment_configs;
        /** A list of associated custom domains for the project. */
        readonly domains?: {}[];
        /** Id of the project. */
        readonly id?: string;
        latest_deployment?: Schemas.pages_deployments;
        /** Name of the project. */
        name?: string;
        /** Production branch of the project. Used to identify production deployments. */
        production_branch?: string;
        readonly source?: any;
        /** The Cloudflare subdomain associated with the project. */
        readonly subdomain?: string;
    }
    export type pages_projects$response = Schemas.pages_api$response$common & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
        };
    } & {
        result?: Schemas.pages_deployments[];
    };
    /** The status of the deployment. */
    export interface pages_stage {
        /** When the stage ended. */
        readonly ended_on?: Date;
        /** The current build stage. */
        name?: string;
        /** When the stage started. */
        readonly started_on?: Date;
        /** State of the current stage. */
        readonly status?: string;
    }
    /** Account ID */
    export type r2_account_identifier = string;
    /** A single R2 bucket */
    export interface r2_bucket {
        /** Creation timestamp */
        creation_date?: string;
        location?: Schemas.r2_bucket_location;
        name?: Schemas.r2_bucket_name;
    }
    /** Location of the bucket */
    export type r2_bucket_location = "apac" | "eeur" | "enam" | "weur" | "wnam";
    /** Name of the bucket */
    export type r2_bucket_name = string;
    export interface r2_enable_sippy_aws {
        /** R2 bucket to copy objects to */
        destination?: {
            /**
             * ID of a Cloudflare API token.
             * This is the value labelled "Access Key ID" when creating an API
             * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
             *
             * Sippy will use this token when writing objects to R2, so it is
             * best to scope this token to the bucket you're enabling Sippy for.
             */
            accessKeyId?: string;
            provider?: "r2";
            /**
             * Value of a Cloudflare API token.
             * This is the value labelled "Secret Access Key" when creating an API
             * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
             *
             * Sippy will use this token when writing objects to R2, so it is
             * best to scope this token to the bucket you're enabling Sippy for.
             */
            secretAccessKey?: string;
        };
        /** AWS S3 bucket to copy objects from */
        source?: {
            /** Access Key ID of an IAM credential (ideally scoped to a single S3 bucket) */
            accessKeyId?: string;
            /** Name of the AWS S3 bucket */
            bucket?: string;
            provider?: "aws";
            /** Name of the AWS availability zone */
            region?: string;
            /** Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket) */
            secretAccessKey?: string;
        };
    }
    export interface r2_enable_sippy_gcs {
        /** R2 bucket to copy objects to */
        destination?: {
            /**
             * ID of a Cloudflare API token.
             * This is the value labelled "Access Key ID" when creating an API
             * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
             *
             * Sippy will use this token when writing objects to R2, so it is
             * best to scope this token to the bucket you're enabling Sippy for.
             */
            accessKeyId?: string;
            provider?: "r2";
            /**
             * Value of a Cloudflare API token.
             * This is the value labelled "Secret Access Key" when creating an API
             * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
             *
             * Sippy will use this token when writing objects to R2, so it is
             * best to scope this token to the bucket you're enabling Sippy for.
             */
            secretAccessKey?: string;
        };
        /** GCS bucket to copy objects from */
        source?: {
            /** Name of the GCS bucket */
            bucket?: string;
            /** Client email of an IAM credential (ideally scoped to a single GCS bucket) */
            clientEmail?: string;
            /** Private Key of an IAM credential (ideally scoped to a single GCS bucket) */
            privateKey?: string;
            provider?: "gcs";
        };
    }
    export type r2_errors = {
        code: number;
        message: string;
    }[];
    export type r2_messages = string[];
    export interface r2_result_info {
        /** A continuation token that should be used to fetch the next page of results */
        cursor?: string;
        /** Maximum number of results on this page */
        per_page?: number;
    }
    export interface r2_sippy {
        /** Details about the configured destination bucket */
        destination?: {
            /**
             * ID of the Cloudflare API token used when writing objects to this
             * bucket
             */
            accessKeyId?: string;
            account?: string;
            /** Name of the bucket on the provider */
            bucket?: string;
            provider?: "r2";
        };
        /** State of Sippy for this bucket */
        enabled?: boolean;
        /** Details about the configured source bucket */
        source?: {
            /** Name of the bucket on the provider */
            bucket?: string;
            provider?: "aws" | "gcs";
            /** Region where the bucket resides (AWS only) */
            region?: string | null;
        };
    }
    export interface r2_v4_response {
        errors: Schemas.r2_errors;
        messages: Schemas.r2_messages;
        result: {};
        /** Whether the API call was successful */
        success: true;
    }
    export interface r2_v4_response_failure {
        errors: Schemas.r2_errors;
        messages: Schemas.r2_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type r2_v4_response_list = Schemas.r2_v4_response & {
        result_info?: Schemas.r2_result_info;
    };
    /** Address. */
    export type registrar$api_address = string;
    /** Optional address line for unit, floor, suite, etc. */
    export type registrar$api_address2 = string;
    export type registrar$api_api$response$collection = Schemas.registrar$api_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.registrar$api_result_info;
    };
    export interface registrar$api_api$response$common {
        errors: Schemas.registrar$api_messages;
        messages: Schemas.registrar$api_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface registrar$api_api$response$common$failure {
        errors: Schemas.registrar$api_messages;
        messages: Schemas.registrar$api_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type registrar$api_api$response$single = Schemas.registrar$api_api$response$common & {
        result?: {} | null;
    };
    /** Auto-renew controls whether subscription is automatically renewed upon domain expiration. */
    export type registrar$api_auto_renew = boolean;
    /** Shows if a domain is available for transferring into Cloudflare Registrar. */
    export type registrar$api_available = boolean;
    /** Indicates if the domain can be registered as a new domain. */
    export type registrar$api_can_register = boolean;
    /** City. */
    export type registrar$api_city = string;
    /** Contact Identifier. */
    export type registrar$api_contact_identifier = string;
    export interface registrar$api_contact_properties {
        address: Schemas.registrar$api_address;
        address2?: Schemas.registrar$api_address2;
        city: Schemas.registrar$api_city;
        country: Schemas.registrar$api_country;
        email?: Schemas.registrar$api_email;
        fax?: Schemas.registrar$api_fax;
        first_name: Schemas.registrar$api_first_name;
        id?: Schemas.registrar$api_contact_identifier;
        last_name: Schemas.registrar$api_last_name;
        organization: Schemas.registrar$api_organization;
        phone: Schemas.registrar$api_telephone;
        state: Schemas.registrar$api_state;
        zip: Schemas.registrar$api_zipcode;
    }
    export type registrar$api_contacts = Schemas.registrar$api_contact_properties;
    /** The country in which the user lives. */
    export type registrar$api_country = string | null;
    /** Shows time of creation. */
    export type registrar$api_created_at = Date;
    /** Shows name of current registrar. */
    export type registrar$api_current_registrar = string;
    /** Domain identifier. */
    export type registrar$api_domain_identifier = string;
    /** Domain name. */
    export type registrar$api_domain_name = string;
    export interface registrar$api_domain_properties {
        available?: Schemas.registrar$api_available;
        can_register?: Schemas.registrar$api_can_register;
        created_at?: Schemas.registrar$api_created_at;
        current_registrar?: Schemas.registrar$api_current_registrar;
        expires_at?: Schemas.registrar$api_expires_at;
        id?: Schemas.registrar$api_domain_identifier;
        locked?: Schemas.registrar$api_locked;
        registrant_contact?: Schemas.registrar$api_registrant_contact;
        registry_statuses?: Schemas.registrar$api_registry_statuses;
        supported_tld?: Schemas.registrar$api_supported_tld;
        transfer_in?: Schemas.registrar$api_transfer_in;
        updated_at?: Schemas.registrar$api_updated_at;
    }
    export type registrar$api_domain_response_collection = Schemas.registrar$api_api$response$collection & {
        result?: Schemas.registrar$api_domains[];
    };
    export type registrar$api_domain_response_single = Schemas.registrar$api_api$response$single & {
        result?: {};
    };
    export interface registrar$api_domain_update_properties {
        auto_renew?: Schemas.registrar$api_auto_renew;
        locked?: Schemas.registrar$api_locked;
        privacy?: Schemas.registrar$api_privacy;
    }
    export type registrar$api_domains = Schemas.registrar$api_domain_properties;
    /** The contact email address of the user. */
    export type registrar$api_email = string;
    /** Shows when domain name registration expires. */
    export type registrar$api_expires_at = Date;
    /** Contact fax number. */
    export type registrar$api_fax = string;
    /** User's first name */
    export type registrar$api_first_name = string | null;
    /** Identifier */
    export type registrar$api_identifier = string;
    /** User's last name */
    export type registrar$api_last_name = string | null;
    /** Shows whether a registrar lock is in place for a domain. */
    export type registrar$api_locked = boolean;
    export type registrar$api_messages = {
        code: number;
        message: string;
    }[];
    /** Name of organization. */
    export type registrar$api_organization = string;
    /** Privacy option controls redacting WHOIS information. */
    export type registrar$api_privacy = boolean;
    export type registrar$api_registrant_contact = Schemas.registrar$api_contacts;
    /** A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en). */
    export type registrar$api_registry_statuses = string;
    export interface registrar$api_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** State. */
    export type registrar$api_state = string;
    /** Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs. */
    export type registrar$api_supported_tld = boolean;
    /** User's telephone number */
    export type registrar$api_telephone = string | null;
    /** Statuses for domain transfers into Cloudflare Registrar. */
    export interface registrar$api_transfer_in {
        /** Form of authorization has been accepted by the registrant. */
        accept_foa?: any;
        /** Shows transfer status with the registry. */
        approve_transfer?: any;
        /** Indicates if cancellation is still possible. */
        can_cancel_transfer?: boolean;
        /** Privacy guards are disabled at the foreign registrar. */
        disable_privacy?: any;
        /** Auth code has been entered and verified. */
        enter_auth_code?: any;
        /** Domain is unlocked at the foreign registrar. */
        unlock_domain?: any;
    }
    /** Last updated. */
    export type registrar$api_updated_at = Date;
    /** The zipcode or postal code where the user lives. */
    export type registrar$api_zipcode = string | null;
    /**
     * ID
     *
     * The unique ID of the account.
     */
    export type rulesets_AccountId = string;
    export type rulesets_BlockRule = Schemas.rulesets_Rule & {
        action?: "block";
        action_parameters?: {
            /** The response to show when the block is applied. */
            response?: {
                /** The content to return. */
                content: string;
                /** The type of the content to return. */
                content_type: string;
                /** The status code to return. */
                status_code: number;
            };
        };
        description?: any;
    };
    export type rulesets_CreateOrUpdateRuleRequest = Schemas.rulesets_RuleRequest & {
        position?: (Schemas.rulesets_RulePosition & {
            /** The ID of another rule to place the rule before. An empty value causes the rule to be placed at the top. */
            before?: string;
        }) | (Schemas.rulesets_RulePosition & {
            /** The ID of another rule to place the rule after. An empty value causes the rule to be placed at the bottom. */
            after?: string;
        }) | (Schemas.rulesets_RulePosition & {
            /** An index at which to place the rule, where index 1 is the first rule. */
            index?: number;
        });
    };
    export type rulesets_CreateRulesetRequest = Schemas.rulesets_Ruleset & {
        rules: Schemas.rulesets_RulesRequest;
    };
    /**
     * Errors
     *
     * A list of error messages.
     */
    export type rulesets_Errors = Schemas.rulesets_Message[];
    export type rulesets_ExecuteRule = Schemas.rulesets_Rule & {
        action?: "execute";
        action_parameters?: {
            id: Schemas.rulesets_RulesetId & any;
            /** The configuration to use for matched data logging. */
            matched_data?: {
                /** The public key to encrypt matched data logs with. */
                public_key: string;
            };
            /** A set of overrides to apply to the target ruleset. */
            overrides?: {
                action?: Schemas.rulesets_RuleAction & any;
                /** A list of category-level overrides. This option has the second-highest precedence after rule-level overrides. */
                categories?: {
                    action?: Schemas.rulesets_RuleAction & any;
                    category: Schemas.rulesets_RuleCategory & any;
                    enabled?: Schemas.rulesets_RuleEnabled & any;
                    sensitivity_level?: Schemas.rulesets_ExecuteSensitivityLevel & any;
                }[];
                enabled?: Schemas.rulesets_RuleEnabled & any;
                /** A list of rule-level overrides. This option has the highest precedence. */
                rules?: {
                    action?: Schemas.rulesets_RuleAction & any;
                    enabled?: Schemas.rulesets_RuleEnabled & any;
                    id: Schemas.rulesets_RuleId & any;
                    /** The score threshold to use for the rule. */
                    score_threshold?: number;
                    sensitivity_level?: Schemas.rulesets_ExecuteSensitivityLevel & any;
                }[];
                sensitivity_level?: Schemas.rulesets_ExecuteSensitivityLevel & any;
            };
        };
        description?: any;
    };
    /** Sensitivity level */
    export type rulesets_ExecuteSensitivityLevel = "default" | "medium" | "low" | "eoff";
    /** A failure response object. */
    export interface rulesets_FailureResponse {
        errors: Schemas.rulesets_Errors;
        messages: Schemas.rulesets_Messages;
        /**
         * Result
         *
         * A result.
         */
        result: string;
        /**
         * Success
         *
         * Whether the API call was successful.
         */
        success: false;
    }
    export type rulesets_LogRule = Schemas.rulesets_Rule & {
        action?: "log";
        action_parameters?: string;
        description?: any;
    };
    /** A message. */
    export interface rulesets_Message {
        /**
         * Code
         *
         * A unique code for this message.
         */
        code?: number;
        /**
         * Description
         *
         * A text description of this message.
         */
        message: string;
        /**
         * Source
         *
         * The source of this message.
         */
        source?: {
            /** A JSON pointer to the field that is the source of the message. */
            pointer: string;
        };
    }
    /**
     * Messages
     *
     * A list of warning messages.
     */
    export type rulesets_Messages = Schemas.rulesets_Message[];
    /** A response object. */
    export interface rulesets_Response {
        errors: Schemas.rulesets_Errors & string;
        messages: Schemas.rulesets_Messages;
        /**
         * Result
         *
         * A result.
         */
        result: any;
        /**
         * Success
         *
         * Whether the API call was successful.
         */
        success: true;
    }
    export interface rulesets_Rule {
        action?: Schemas.rulesets_RuleAction;
        /**
         * Action parameters
         *
         * The parameters configuring the rule's action.
         */
        action_parameters?: {};
        /**
         * Categories
         *
         * The categories of the rule.
         */
        readonly categories?: Schemas.rulesets_RuleCategory[];
        /**
         * Description
         *
         * An informative description of the rule.
         */
        description?: string;
        enabled?: Schemas.rulesets_RuleEnabled & any;
        /**
         * Expression
         *
         * The expression defining which traffic will match the rule.
         */
        expression?: string;
        id?: Schemas.rulesets_RuleId;
        /**
         * Last updated
         *
         * The timestamp of when the rule was last modified.
         */
        readonly last_updated: Date;
        /**
         * Logging
         *
         * An object configuring the rule's logging behavior.
         */
        logging?: {
            /** Whether to generate a log when the rule matches. */
            enabled: boolean;
        };
        /**
         * Ref
         *
         * The reference of the rule (the rule ID by default).
         */
        ref?: string;
        /**
         * Version
         *
         * The version of the rule.
         */
        readonly version: string;
    }
    /**
     * Action
     *
     * The action to perform when the rule matches.
     */
    export type rulesets_RuleAction = string;
    /**
     * Category
     *
     * A category of the rule.
     */
    export type rulesets_RuleCategory = string;
    /**
     * Enabled
     *
     * Whether the rule should be executed.
     */
    export type rulesets_RuleEnabled = boolean;
    /**
     * ID
     *
     * The unique ID of the rule.
     */
    export type rulesets_RuleId = string;
    /** An object configuring where the rule will be placed. */
    export interface rulesets_RulePosition {
    }
    export type rulesets_RuleRequest = Schemas.rulesets_BlockRule | Schemas.rulesets_ExecuteRule | Schemas.rulesets_LogRule | Schemas.rulesets_SkipRule;
    export type rulesets_RuleResponse = Schemas.rulesets_RuleRequest & {
        id: any;
        expression: any;
        action: any;
        ref: any;
        enabled: any;
    };
    /**
     * Rules
     *
     * The list of rules in the ruleset.
     */
    export type rulesets_RulesRequest = Schemas.rulesets_RuleRequest[];
    /**
     * Rules
     *
     * The list of rules in the ruleset.
     */
    export type rulesets_RulesResponse = Schemas.rulesets_RuleResponse[];
    /** A ruleset object. */
    export interface rulesets_Ruleset {
        /**
         * Description
         *
         * An informative description of the ruleset.
         */
        description?: string;
        id: Schemas.rulesets_RulesetId & any;
        kind?: Schemas.rulesets_RulesetKind;
        /**
         * Last updated
         *
         * The timestamp of when the ruleset was last modified.
         */
        readonly last_updated: Date;
        /**
         * Name
         *
         * The human-readable name of the ruleset.
         */
        name?: string;
        phase?: Schemas.rulesets_RulesetPhase;
        version: Schemas.rulesets_RulesetVersion;
    }
    /**
     * ID
     *
     * The unique ID of the ruleset.
     */
    export type rulesets_RulesetId = string;
    /**
     * Kind
     *
     * The kind of the ruleset.
     */
    export type rulesets_RulesetKind = "managed" | "custom" | "root" | "zone";
    /**
     * Phase
     *
     * The phase of the ruleset.
     */
    export type rulesets_RulesetPhase = "ddos_l4" | "ddos_l7" | "http_config_settings" | "http_custom_errors" | "http_log_custom_fields" | "http_ratelimit" | "http_request_cache_settings" | "http_request_dynamic_redirect" | "http_request_firewall_custom" | "http_request_firewall_managed" | "http_request_late_transform" | "http_request_origin" | "http_request_redirect" | "http_request_sanitize" | "http_request_sbfm" | "http_request_select_configuration" | "http_request_transform" | "http_response_compression" | "http_response_firewall_managed" | "http_response_headers_transform" | "magic_transit" | "magic_transit_ids_managed" | "magic_transit_managed";
    export type rulesets_RulesetResponse = Schemas.rulesets_Ruleset & {
        rules: Schemas.rulesets_RulesResponse;
    };
    /**
     * Version
     *
     * The version of the ruleset.
     */
    export type rulesets_RulesetVersion = string;
    /**
     * Rulesets
     *
     * A list of rulesets. The returned information will not include the rules in each ruleset.
     */
    export type rulesets_RulesetsResponse = (Schemas.rulesets_Ruleset & {
        name: any;
        kind: any;
        phase: any;
    })[];
    export type rulesets_SkipRule = Schemas.rulesets_Rule & {
        action?: "skip";
        action_parameters?: {
            /** A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options. */
            phases?: (Schemas.rulesets_RulesetPhase & any)[];
            /** A list of legacy security products to skip the execution of. */
            products?: ("bic" | "hot" | "rateLimit" | "securityLevel" | "uaBlock" | "waf" | "zoneLockdown")[];
            /** A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option. */
            rules?: {};
            /** A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options. */
            ruleset?: "current";
            /** A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options. */
            rulesets?: (Schemas.rulesets_RulesetId & any)[];
        };
        description?: any;
    };
    export type rulesets_UpdateRulesetRequest = Schemas.rulesets_Ruleset & {
        rules: Schemas.rulesets_RulesRequest;
    };
    /**
     * ID
     *
     * The unique ID of the zone.
     */
    export type rulesets_ZoneId = string;
    export type rulesets_api$response$collection = Schemas.rulesets_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.rulesets_result_info;
    };
    export interface rulesets_api$response$common {
        errors: Schemas.rulesets_messages;
        messages: Schemas.rulesets_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface rulesets_api$response$common$failure {
        errors: Schemas.rulesets_messages;
        messages: Schemas.rulesets_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type rulesets_api$response$single = Schemas.rulesets_api$response$common & {
        result?: {} | string;
    };
    /** When true, the Managed Transform is available in the current Cloudflare plan. */
    export type rulesets_available = boolean;
    export type rulesets_custom_pages_response_collection = Schemas.rulesets_api$response$collection & {
        result?: {}[];
    };
    export type rulesets_custom_pages_response_single = Schemas.rulesets_api$response$single & {
        result?: {};
    };
    /** When true, the Managed Transform is enabled. */
    export type rulesets_enabled = boolean;
    /** Human-readable identifier of the Managed Transform. */
    export type rulesets_id = string;
    /** Identifier */
    export type rulesets_identifier = string;
    export type rulesets_messages = {
        code: number;
        message: string;
    }[];
    export type rulesets_request_list = Schemas.rulesets_request_model[];
    export interface rulesets_request_model {
        enabled?: Schemas.rulesets_enabled;
        id?: Schemas.rulesets_id;
    }
    export type rulesets_response_list = Schemas.rulesets_response_model[];
    export interface rulesets_response_model {
        available?: Schemas.rulesets_available;
        enabled?: Schemas.rulesets_enabled;
        id?: Schemas.rulesets_id;
    }
    export interface rulesets_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export interface rulesets_schemas$request_model {
        scope?: Schemas.rulesets_scope;
        type?: Schemas.rulesets_type;
    }
    export interface rulesets_schemas$response_model {
        scope?: Schemas.rulesets_scope;
        type?: Schemas.rulesets_type;
    }
    /** The scope of the URL normalization. */
    export type rulesets_scope = string;
    /** The type of URL normalization performed by Cloudflare. */
    export type rulesets_type = string;
    export interface sMrrXoZ2_api$response$common {
        errors: Schemas.sMrrXoZ2_messages;
        messages: Schemas.sMrrXoZ2_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface sMrrXoZ2_empty_object_response {
    }
    export type sMrrXoZ2_get_sinkholes_response = Schemas.sMrrXoZ2_api$response$common & {
        result?: Schemas.sMrrXoZ2_sinkhole_item[];
    };
    /** The unique identifier for the sinkhole */
    export type sMrrXoZ2_id = number;
    /** Identifier */
    export type sMrrXoZ2_identifier = string;
    export type sMrrXoZ2_messages = {
        code: number;
        message: string;
    }[];
    /** The name of the sinkhole */
    export type sMrrXoZ2_name = string;
    export interface sMrrXoZ2_sinkhole_item {
        /** The account tag that owns this sinkhole */
        account_tag?: string;
        /** The date and time when the sinkhole was created */
        created_on?: Date;
        id?: Schemas.sMrrXoZ2_id;
        /** The date and time when the sinkhole was last modified */
        modified_on?: Date;
        name?: Schemas.sMrrXoZ2_name;
        /** The name of the R2 bucket to store results */
        r2_bucket?: string;
        /** The id of the R2 instance */
        r2_id?: string;
    }
    export type security$center_accountId = Schemas.security$center_identifier;
    export interface security$center_api$response$common {
        errors: Schemas.security$center_messages;
        messages: Schemas.security$center_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export type security$center_dismissed = boolean;
    /** Identifier */
    export type security$center_identifier = string;
    export interface security$center_issue {
        dismissed?: boolean;
        id?: string;
        issue_class?: Schemas.security$center_issueClass;
        issue_type?: Schemas.security$center_issueType;
        payload?: {};
        resolve_link?: string;
        resolve_text?: string;
        severity?: "Low" | "Moderate" | "Critical";
        since?: Date;
        subject?: string;
        timestamp?: Date;
    }
    export type security$center_issueClass = string;
    export type security$center_issueType = "compliance_violation" | "email_security" | "exposed_infrastructure" | "insecure_configuration" | "weak_authentication";
    export type security$center_messages = {
        code: number;
        message: string;
    }[];
    export type security$center_valueCountsResponse = Schemas.security$center_api$response$common & {
        result?: {
            count?: number;
            value?: string;
        }[];
    };
    export interface speed_api$response$common {
        errors: Schemas.speed_messages;
        messages: Schemas.speed_messages;
        /** Whether the API call was successful */
        success: boolean;
    }
    export interface speed_api$response$common$failure {
        errors: Schemas.speed_messages;
        messages: Schemas.speed_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: boolean;
    }
    export type speed_api$response$single$id = Schemas.speed_api$response$common & {
        result?: {
            id: Schemas.speed_identifier;
        } | null;
    };
    export interface speed_base {
        /** Whether or not this setting can be modified for this zone (based on your Cloudflare plan level). */
        readonly editable?: true | false;
        /** Identifier of the zone setting. */
        id: string;
        /** last time this setting was modified. */
        readonly modified_on?: Date;
        /** Current value of the zone setting. */
        value: any;
    }
    export type speed_cloudflare_fonts = Schemas.speed_base & {
        /** ID of the zone setting. */
        id?: "fonts";
        value?: Schemas.speed_cloudflare_fonts_value;
    };
    /** Whether the feature is enabled or disabled. */
    export type speed_cloudflare_fonts_value = "on" | "off";
    /** Identifier */
    export type speed_identifier = string;
    export type speed_messages = {
        code: number;
        message: string;
    }[];
    /** Defines rules for fine-grained control over content than signed URL tokens alone. Access rules primarily make tokens conditionally valid based on user information. Access Rules are specified on token payloads as the \`accessRules\` property containing an array of Rule objects. */
    export interface stream_accessRules {
        /** The action to take when a request matches a rule. If the action is \`block\`, the signed token blocks views for viewers matching the rule. */
        action?: "allow" | "block";
        /** An array of 2-letter country codes in ISO 3166-1 Alpha-2 format used to match requests. */
        country?: string[];
        /** An array of IPv4 or IPV6 addresses or CIDRs used to match requests. */
        ip?: string[];
        /** Lists available rule types to match for requests. An \`any\` type matches all requests and can be used as a wildcard to apply default actions after other rules. */
        type?: "any" | "ip.src" | "ip.geoip.country";
    }
    /** The account identifier tag. */
    export type stream_account_identifier = string;
    export type stream_addAudioTrackResponse = Schemas.stream_api$response$common & {
        result?: Schemas.stream_additionalAudio;
    };
    export interface stream_additionalAudio {
        default?: Schemas.stream_audio_default;
        label?: Schemas.stream_audio_label;
        status?: Schemas.stream_audio_state;
        uid?: Schemas.stream_identifier;
    }
    /** Lists the origins allowed to display the video. Enter allowed origin domains in an array and use \`*\` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin. */
    export type stream_allowedOrigins = string[];
    export interface stream_api$response$common {
        errors: Schemas.stream_messages;
        messages: Schemas.stream_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface stream_api$response$common$failure {
        errors: Schemas.stream_messages;
        messages: Schemas.stream_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type stream_api$response$single = Schemas.stream_api$response$common & {
        result?: {} | string;
    };
    /** Lists videos in ascending order of creation. */
    export type stream_asc = boolean;
    /** Denotes whether the audio track will be played by default in a player. */
    export type stream_audio_default = boolean;
    /** The unique identifier for an additional audio track. */
    export type stream_audio_identifier = string;
    /** A string to uniquely identify the track amongst other audio track labels for the specified video. */
    export type stream_audio_label = string;
    /** Specifies the processing status of the video. */
    export type stream_audio_state = "queued" | "ready" | "error";
    export interface stream_caption_basic_upload {
        /** The WebVTT file containing the caption or subtitle content. */
        file: string;
    }
    export interface stream_captions {
        label?: Schemas.stream_label;
        language?: Schemas.stream_language;
    }
    export type stream_clipResponseSingle = Schemas.stream_api$response$common & {
        result?: Schemas.stream_clipping;
    };
    /** The unique video identifier (UID). */
    export type stream_clipped_from_video_uid = string;
    export interface stream_clipping {
        allowedOrigins?: Schemas.stream_allowedOrigins;
        clippedFromVideoUID?: Schemas.stream_clipped_from_video_uid;
        created?: Schemas.stream_clipping_created;
        creator?: Schemas.stream_creator;
        endTimeSeconds?: Schemas.stream_end_time_seconds;
        maxDurationSeconds?: Schemas.stream_maxDurationSeconds;
        meta?: Schemas.stream_media_metadata;
        modified?: Schemas.stream_live_input_modified;
        playback?: Schemas.stream_playback;
        preview?: Schemas.stream_preview;
        requireSignedURLs?: Schemas.stream_requireSignedURLs;
        startTimeSeconds?: Schemas.stream_start_time_seconds;
        status?: Schemas.stream_media_state;
        thumbnailTimestampPct?: Schemas.stream_thumbnailTimestampPct;
        watermark?: Schemas.stream_watermarkAtUpload;
    }
    /** The date and time the clip was created. */
    export type stream_clipping_created = Date;
    export interface stream_copyAudioTrack {
        label: Schemas.stream_audio_label;
        /** An audio track URL. The server must be publicly routable and support \`HTTP HEAD\` requests and \`HTTP GET\` range requests. The server should respond to \`HTTP HEAD\` requests with a \`content-range\` header that includes the size of the file. */
        url?: string;
    }
    export interface stream_create_input_request {
        defaultCreator?: Schemas.stream_live_input_default_creator;
        deleteRecordingAfterDays?: Schemas.stream_live_input_recording_deletion;
        meta?: Schemas.stream_live_input_metadata;
        recording?: Schemas.stream_live_input_recording_settings;
    }
    export interface stream_create_output_request {
        enabled?: Schemas.stream_output_enabled;
        streamKey: Schemas.stream_output_streamKey;
        url: Schemas.stream_output_url;
    }
    /** The date and time the media item was created. */
    export type stream_created = Date;
    /** A user-defined identifier for the media creator. */
    export type stream_creator = string;
    export type stream_deleted_response = Schemas.stream_api$response$single & {
        result?: string;
    };
    export interface stream_direct_upload_request {
        allowedOrigins?: Schemas.stream_allowedOrigins;
        creator?: Schemas.stream_creator;
        /** The date and time after upload when videos will not be accepted. */
        expiry?: Date;
        maxDurationSeconds: Schemas.stream_maxDurationSeconds;
        meta?: Schemas.stream_media_metadata;
        requireSignedURLs?: Schemas.stream_requireSignedURLs;
        scheduledDeletion?: Schemas.stream_scheduledDeletion;
        thumbnailTimestampPct?: Schemas.stream_thumbnailTimestampPct;
        watermark?: Schemas.stream_watermark_at_upload;
    }
    export type stream_direct_upload_response = Schemas.stream_api$response$single & {
        result?: {
            scheduledDeletion?: Schemas.stream_scheduledDeletion;
            uid?: Schemas.stream_identifier;
            /** The URL an unauthenticated upload can use for a single \`HTTP POST multipart/form-data\` request. */
            uploadURL?: string;
            watermark?: Schemas.stream_watermarks;
        };
    };
    /** The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null. */
    export type stream_downloadedFrom = string;
    export type stream_downloads_response = Schemas.stream_api$response$single & {
        result?: {};
    };
    /** The duration of the video in seconds. A value of \`-1\` means the duration is unknown. The duration becomes available after the upload and before the video is ready. */
    export type stream_duration = number;
    export interface stream_editAudioTrack {
        default?: Schemas.stream_audio_default;
        label?: Schemas.stream_audio_label;
    }
    /** Lists videos created before the specified date. */
    export type stream_end = Date;
    /** Specifies the end time for the video clip in seconds. */
    export type stream_end_time_seconds = number;
    /** Specifies why the video failed to encode. This field is empty if the video is not in an \`error\` state. Preferred for programmatic use. */
    export type stream_errorReasonCode = string;
    /** Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an \`error\` state. */
    export type stream_errorReasonText = string;
    /** The height of the image in pixels. */
    export type stream_height = number;
    /** A Cloudflare-generated unique identifier for a media item. */
    export type stream_identifier = string;
    /** Includes the total number of videos associated with the submitted query parameters. */
    export type stream_include_counts = boolean;
    export interface stream_input {
        /** The video height in pixels. A value of \`-1\` means the height is unknown. The value becomes available after the upload and before the video is ready. */
        height?: number;
        /** The video width in pixels. A value of \`-1\` means the width is unknown. The value becomes available after the upload and before the video is ready. */
        width?: number;
    }
    /** Details for streaming to an live input using RTMPS. */
    export interface stream_input_rtmps {
        streamKey?: Schemas.stream_input_rtmps_stream_key;
        url?: Schemas.stream_input_rtmps_url;
    }
    /** The secret key to use when streaming via RTMPS to a live input. */
    export type stream_input_rtmps_stream_key = string;
    /** The RTMPS URL you provide to the broadcaster, which they stream live video to. */
    export type stream_input_rtmps_url = string;
    /** Details for streaming to a live input using SRT. */
    export interface stream_input_srt {
        passphrase?: Schemas.stream_input_srt_stream_passphrase;
        streamId?: Schemas.stream_input_srt_stream_id;
        url?: Schemas.stream_input_srt_url;
    }
    /** The identifier of the live input to use when streaming via SRT. */
    export type stream_input_srt_stream_id = string;
    /** The secret key to use when streaming via SRT to a live input. */
    export type stream_input_srt_stream_passphrase = string;
    /** The SRT URL you provide to the broadcaster, which they stream live video to. */
    export type stream_input_srt_url = string;
    /** Details for streaming to a live input using WebRTC. */
    export interface stream_input_webrtc {
        url?: Schemas.stream_input_webrtc_url;
    }
    /** The WebRTC URL you provide to the broadcaster, which they stream live video to. */
    export type stream_input_webrtc_url = string;
    /** The signing key in JWK format. */
    export type stream_jwk = string;
    export type stream_key_generation_response = Schemas.stream_api$response$common & {
        result?: Schemas.stream_keys;
    };
    export type stream_key_response_collection = Schemas.stream_api$response$common & {
        result?: {
            created?: Schemas.stream_signing_key_created;
            id?: Schemas.stream_schemas$identifier;
        }[];
    };
    export interface stream_keys {
        created?: Schemas.stream_signing_key_created;
        id?: Schemas.stream_schemas$identifier;
        jwk?: Schemas.stream_jwk;
        pem?: Schemas.stream_pem;
    }
    /** The language label displayed in the native language to users. */
    export type stream_label = string;
    /** The language tag in BCP 47 format. */
    export type stream_language = string;
    export type stream_language_response_collection = Schemas.stream_api$response$common & {
        result?: Schemas.stream_captions[];
    };
    export type stream_language_response_single = Schemas.stream_api$response$single & {
        result?: {};
    };
    export type stream_listAudioTrackResponse = Schemas.stream_api$response$common & {
        result?: Schemas.stream_additionalAudio[];
    };
    /** Details about a live input. */
    export interface stream_live_input {
        created?: Schemas.stream_live_input_created;
        deleteRecordingAfterDays?: Schemas.stream_live_input_recording_deletion;
        meta?: Schemas.stream_live_input_metadata;
        modified?: Schemas.stream_live_input_modified;
        recording?: Schemas.stream_live_input_recording_settings;
        rtmps?: Schemas.stream_input_rtmps;
        rtmpsPlayback?: Schemas.stream_playback_rtmps;
        srt?: Schemas.stream_input_srt;
        srtPlayback?: Schemas.stream_playback_srt;
        status?: Schemas.stream_live_input_status;
        uid?: Schemas.stream_live_input_identifier;
        webRTC?: Schemas.stream_input_webrtc;
        webRTCPlayback?: Schemas.stream_playback_webrtc;
    }
    /** The date and time the live input was created. */
    export type stream_live_input_created = Date;
    /** Sets the creator ID asssociated with this live input. */
    export type stream_live_input_default_creator = string;
    /** A unique identifier for a live input. */
    export type stream_live_input_identifier = string;
    /** A user modifiable key-value store used to reference other systems of record for managing live inputs. */
    export interface stream_live_input_metadata {
    }
    /** The date and time the live input was last modified. */
    export type stream_live_input_modified = Date;
    export interface stream_live_input_object_without_url {
        created?: Schemas.stream_live_input_created;
        deleteRecordingAfterDays?: Schemas.stream_live_input_recording_deletion;
        meta?: Schemas.stream_live_input_metadata;
        modified?: Schemas.stream_live_input_modified;
        uid?: Schemas.stream_live_input_identifier;
    }
    /** Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use \`*\` for wildcard subdomains. An empty array allows videos to be viewed on any origin. */
    export type stream_live_input_recording_allowedOrigins = string[];
    /** Indicates the number of days after which the live inputs recordings will be deleted. When a stream completes and the recording is ready, the value is used to calculate a scheduled deletion date for that recording. Omit the field to indicate no change, or include with a \`null\` value to remove an existing scheduled deletion. */
    export type stream_live_input_recording_deletion = number;
    /** Specifies the recording behavior for the live input. Set this value to \`off\` to prevent a recording. Set the value to \`automatic\` to begin a recording and transition to on-demand after Stream Live stops receiving input. */
    export type stream_live_input_recording_mode = "off" | "automatic";
    /** Indicates if a video using the live input has the \`requireSignedURLs\` property set. Also enforces access controls on any video recording of the livestream with the live input. */
    export type stream_live_input_recording_requireSignedURLs = boolean;
    /** Records the input to a Cloudflare Stream video. Behavior depends on the mode. In most cases, the video will initially be viewable as a live video and transition to on-demand after a condition is satisfied. */
    export interface stream_live_input_recording_settings {
        allowedOrigins?: Schemas.stream_live_input_recording_allowedOrigins;
        mode?: Schemas.stream_live_input_recording_mode;
        requireSignedURLs?: Schemas.stream_live_input_recording_requireSignedURLs;
        timeoutSeconds?: Schemas.stream_live_input_recording_timeoutSeconds;
    }
    /** Determines the amount of time a live input configured in \`automatic\` mode should wait before a recording transitions from live to on-demand. \`0\` is recommended for most use cases and indicates the platform default should be used. */
    export type stream_live_input_recording_timeoutSeconds = number;
    export type stream_live_input_response_collection = Schemas.stream_api$response$common & {
        result?: {
            liveInputs?: Schemas.stream_live_input_object_without_url[];
            /** The total number of remaining live inputs based on cursor position. */
            range?: number;
            /** The total number of live inputs that match the provided filters. */
            total?: number;
        };
    };
    export type stream_live_input_response_single = Schemas.stream_api$response$single & {
        result?: Schemas.stream_live_input;
    };
    /** The connection status of a live input. */
    export type stream_live_input_status = string | null;
    /** The live input ID used to upload a video with Stream Live. */
    export type stream_liveInput = string;
    /** The maximum duration in seconds for a video upload. Can be set for a video that is not yet uploaded to limit its duration. Uploads that exceed the specified duration will fail during processing. A value of \`-1\` means the value is unknown. */
    export type stream_maxDurationSeconds = number;
    /** A user modifiable key-value store used to reference other systems of record for managing videos. */
    export interface stream_media_metadata {
    }
    /** Specifies the processing status for all quality levels for a video. */
    export type stream_media_state = "pendingupload" | "downloading" | "queued" | "inprogress" | "ready" | "error";
    /** Specifies a detailed status for a video. If the \`state\` is \`inprogress\` or \`error\`, the \`step\` field returns \`encoding\` or \`manifest\`. If the \`state\` is \`inprogress\`, \`pctComplete\` returns a number between 0 and 100 to indicate the approximate percent of completion. If the \`state\` is \`error\`, \`errorReasonCode\` and \`errorReasonText\` provide additional details. */
    export interface stream_media_status {
        errorReasonCode?: Schemas.stream_errorReasonCode;
        errorReasonText?: Schemas.stream_errorReasonText;
        pctComplete?: Schemas.stream_pctComplete;
        state?: Schemas.stream_media_state;
    }
    export type stream_messages = {
        code: number;
        message: string;
    }[];
    /** The date and time the media item was last modified. */
    export type stream_modified = Date;
    /** A short description of the watermark profile. */
    export type stream_name = string;
    /** The URL where webhooks will be sent. */
    export type stream_notificationUrl = string;
    /** The date and time when the video upload URL is no longer valid for direct user uploads. */
    export type stream_oneTimeUploadExpiry = Date;
    /** The translucency of the image. A value of \`0.0\` makes the image completely transparent, and \`1.0\` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to \`1.0\` will not make the image completely opaque. */
    export type stream_opacity = number;
    export interface stream_output {
        enabled?: Schemas.stream_output_enabled;
        streamKey?: Schemas.stream_output_streamKey;
        uid?: Schemas.stream_output_identifier;
        url?: Schemas.stream_output_url;
    }
    /** When enabled, live video streamed to the associated live input will be sent to the output URL. When disabled, live video will not be sent to the output URL, even when streaming to the associated live input. Use this to control precisely when you start and stop simulcasting to specific destinations like YouTube and Twitch. */
    export type stream_output_enabled = boolean;
    /** A unique identifier for the output. */
    export type stream_output_identifier = string;
    export type stream_output_response_collection = Schemas.stream_api$response$common & {
        result?: Schemas.stream_output[];
    };
    export type stream_output_response_single = Schemas.stream_api$response$single & {
        result?: Schemas.stream_output;
    };
    /** The streamKey used to authenticate against an output's target. */
    export type stream_output_streamKey = string;
    /** The URL an output uses to restream. */
    export type stream_output_url = string;
    /** The whitespace between the adjacent edges (determined by position) of the video and the image. \`0.0\` indicates no padding, and \`1.0\` indicates a fully padded video width or length, as determined by the algorithm. */
    export type stream_padding = number;
    /** Indicates the size of the entire upload in bytes. The value must be a non-negative integer. */
    export type stream_pctComplete = string;
    /** The signing key in PEM format. */
    export type stream_pem = string;
    export interface stream_playback {
        /** DASH Media Presentation Description for the video. */
        dash?: string;
        /** The HLS manifest for the video. */
        hls?: string;
    }
    /** Details for playback from an live input using RTMPS. */
    export interface stream_playback_rtmps {
        streamKey?: Schemas.stream_playback_rtmps_stream_key;
        url?: Schemas.stream_playback_rtmps_url;
    }
    /** The secret key to use for playback via RTMPS. */
    export type stream_playback_rtmps_stream_key = string;
    /** The URL used to play live video over RTMPS. */
    export type stream_playback_rtmps_url = string;
    /** Details for playback from an live input using SRT. */
    export interface stream_playback_srt {
        passphrase?: Schemas.stream_playback_srt_stream_passphrase;
        streamId?: Schemas.stream_playback_srt_stream_id;
        url?: Schemas.stream_playback_srt_url;
    }
    /** The identifier of the live input to use for playback via SRT. */
    export type stream_playback_srt_stream_id = string;
    /** The secret key to use for playback via SRT. */
    export type stream_playback_srt_stream_passphrase = string;
    /** The URL used to play live video over SRT. */
    export type stream_playback_srt_url = string;
    /** Details for playback from a live input using WebRTC. */
    export interface stream_playback_webrtc {
        url?: Schemas.stream_playback_webrtc_url;
    }
    /** The URL used to play live video over WebRTC. */
    export type stream_playback_webrtc_url = string;
    /** The location of the image. Valid positions are: \`upperRight\`, \`upperLeft\`, \`lowerLeft\`, \`lowerRight\`, and \`center\`. Note that \`center\` ignores the \`padding\` parameter. */
    export type stream_position = string;
    /** The video's preview page URI. This field is omitted until encoding is complete. */
    export type stream_preview = string;
    /** Indicates whether the video is playable. The field is empty if the video is not ready for viewing or the live stream is still in progress. */
    export type stream_readyToStream = boolean;
    /** Indicates the time at which the video became playable. The field is empty if the video is not ready for viewing or the live stream is still in progress. */
    export type stream_readyToStreamAt = Date;
    /** Indicates whether the video can be a accessed using the UID. When set to \`true\`, a signed token must be generated with a signing key to view the video. */
    export type stream_requireSignedURLs = boolean;
    /** The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. \`0.0\` indicates no scaling (use the size of the image as-is), and \`1.0 \`fills the entire video. */
    export type stream_scale = number;
    /** Indicates the date and time at which the video will be deleted. Omit the field to indicate no change, or include with a \`null\` value to remove an existing scheduled deletion. If specified, must be at least 30 days from upload time. */
    export type stream_scheduledDeletion = Date;
    /** Identifier */
    export type stream_schemas$identifier = string;
    /** Searches over the \`name\` key in the \`meta\` field. This field can be set with or after the upload request. */
    export type stream_search = string;
    export interface stream_signed_token_request {
        /** The optional list of access rule constraints on the token. Access can be blocked or allowed based on an IP, IP range, or by country. Access rules are evaluated from first to last. If a rule matches, the associated action is applied and no further rules are evaluated. */
        accessRules?: Schemas.stream_accessRules[];
        /** The optional boolean value that enables using signed tokens to access MP4 download links for a video. */
        downloadable?: boolean;
        /** The optional unix epoch timestamp that specficies the time after a token is not accepted. The maximum time specification is 24 hours from issuing time. If this field is not set, the default is one hour after issuing. */
        exp?: number;
        /** The optional ID of a Stream signing key. If present, the \`pem\` field is also required. */
        id?: string;
        /** The optional unix epoch timestamp that specifies the time before a the token is not accepted. If this field is not set, the default is one hour before issuing. */
        nbf?: number;
        /** The optional base64 encoded private key in PEM format associated with a Stream signing key. If present, the \`id\` field is also required. */
        pem?: string;
    }
    export type stream_signed_token_response = Schemas.stream_api$response$single & {
        result?: {
            /** The signed token used with the signed URLs feature. */
            token?: string;
        };
    };
    /** The date and time a signing key was created. */
    export type stream_signing_key_created = Date;
    /** The size of the media item in bytes. */
    export type stream_size = number;
    /** Lists videos created after the specified date. */
    export type stream_start = Date;
    /** Specifies the start time for the video clip in seconds. */
    export type stream_start_time_seconds = number;
    export type stream_storage_use_response = Schemas.stream_api$response$single & {
        result?: {
            creator?: Schemas.stream_creator;
            /** The total minutes of video content stored in the account. */
            totalStorageMinutes?: number;
            /** The storage capacity alloted for the account. */
            totalStorageMinutesLimit?: number;
            /** The total count of videos associated with the account. */
            videoCount?: number;
        };
    };
    /** The media item's thumbnail URI. This field is omitted until encoding is complete. */
    export type stream_thumbnail_url = string;
    /** The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video. */
    export type stream_thumbnailTimestampPct = number;
    /**
     * Specifies the TUS protocol version. This value must be included in every upload request.
     * Notes: The only supported version of TUS protocol is 1.0.0.
     */
    export type stream_tus_resumable = "1.0.0";
    /** Specifies whether the video is \`vod\` or \`live\`. */
    export type stream_type = string;
    export interface stream_update_input_request {
        defaultCreator?: Schemas.stream_live_input_default_creator;
        deleteRecordingAfterDays?: Schemas.stream_live_input_recording_deletion;
        meta?: Schemas.stream_live_input_metadata;
        recording?: Schemas.stream_live_input_recording_settings;
    }
    export interface stream_update_output_request {
        enabled: Schemas.stream_output_enabled;
    }
    /** Indicates the size of the entire upload in bytes. The value must be a non-negative integer. */
    export type stream_upload_length = number;
    /**
     * Comma-separated key-value pairs following the TUS protocol specification. Values are Base-64 encoded.
     * Supported keys: \`name\`, \`requiresignedurls\`, \`allowedorigins\`, \`thumbnailtimestamppct\`, \`watermark\`, \`scheduleddeletion\`.
     */
    export type stream_upload_metadata = string;
    /** The date and time the media item was uploaded. */
    export type stream_uploaded = Date;
    export interface stream_video_copy_request {
        allowedOrigins?: Schemas.stream_allowedOrigins;
        creator?: Schemas.stream_creator;
        meta?: Schemas.stream_media_metadata;
        requireSignedURLs?: Schemas.stream_requireSignedURLs;
        scheduledDeletion?: Schemas.stream_scheduledDeletion;
        thumbnailTimestampPct?: Schemas.stream_thumbnailTimestampPct;
        /** A video's URL. The server must be publicly routable and support \`HTTP HEAD\` requests and \`HTTP GET\` range requests. The server should respond to \`HTTP HEAD\` requests with a \`content-range\` header that includes the size of the file. */
        url: string;
        watermark?: Schemas.stream_watermark_at_upload;
    }
    export type stream_video_response_collection = Schemas.stream_api$response$common & {
        result?: Schemas.stream_videos[];
    } & {
        /** The total number of remaining videos based on cursor position. */
        range?: number;
        /** The total number of videos that match the provided filters. */
        total?: number;
    };
    export type stream_video_response_single = Schemas.stream_api$response$single & {
        result?: Schemas.stream_videos;
    };
    export interface stream_video_update {
        allowedOrigins?: Schemas.stream_allowedOrigins;
        creator?: Schemas.stream_creator;
        maxDurationSeconds?: Schemas.stream_maxDurationSeconds;
        meta?: Schemas.stream_media_metadata;
        requireSignedURLs?: Schemas.stream_requireSignedURLs;
        scheduledDeletion?: Schemas.stream_scheduledDeletion;
        thumbnailTimestampPct?: Schemas.stream_thumbnailTimestampPct;
        uploadExpiry?: Schemas.stream_oneTimeUploadExpiry;
    }
    export interface stream_videoClipStandard {
        allowedOrigins?: Schemas.stream_allowedOrigins;
        clippedFromVideoUID: Schemas.stream_clipped_from_video_uid;
        creator?: Schemas.stream_creator;
        endTimeSeconds: Schemas.stream_end_time_seconds;
        maxDurationSeconds?: Schemas.stream_maxDurationSeconds;
        requireSignedURLs?: Schemas.stream_requireSignedURLs;
        startTimeSeconds: Schemas.stream_start_time_seconds;
        thumbnailTimestampPct?: Schemas.stream_thumbnailTimestampPct;
        watermark?: Schemas.stream_watermarkAtUpload;
    }
    export interface stream_videos {
        allowedOrigins?: Schemas.stream_allowedOrigins;
        created?: Schemas.stream_created;
        creator?: Schemas.stream_creator;
        duration?: Schemas.stream_duration;
        input?: Schemas.stream_input;
        liveInput?: Schemas.stream_liveInput;
        maxDurationSeconds?: Schemas.stream_maxDurationSeconds;
        meta?: Schemas.stream_media_metadata;
        modified?: Schemas.stream_modified;
        playback?: Schemas.stream_playback;
        preview?: Schemas.stream_preview;
        readyToStream?: Schemas.stream_readyToStream;
        readyToStreamAt?: Schemas.stream_readyToStreamAt;
        requireSignedURLs?: Schemas.stream_requireSignedURLs;
        scheduledDeletion?: Schemas.stream_scheduledDeletion;
        size?: Schemas.stream_size;
        status?: Schemas.stream_media_status;
        thumbnail?: Schemas.stream_thumbnail_url;
        thumbnailTimestampPct?: Schemas.stream_thumbnailTimestampPct;
        uid?: Schemas.stream_identifier;
        uploadExpiry?: Schemas.stream_oneTimeUploadExpiry;
        uploaded?: Schemas.stream_uploaded;
        watermark?: Schemas.stream_watermarks;
    }
    export interface stream_watermark_at_upload {
        /** The unique identifier for the watermark profile. */
        uid?: string;
    }
    export interface stream_watermark_basic_upload {
        /** The image file to upload. */
        file: string;
        name?: Schemas.stream_name;
        opacity?: Schemas.stream_opacity;
        padding?: Schemas.stream_padding;
        position?: Schemas.stream_position;
        scale?: Schemas.stream_scale;
    }
    /** The date and a time a watermark profile was created. */
    export type stream_watermark_created = Date;
    /** The unique identifier for a watermark profile. */
    export type stream_watermark_identifier = string;
    export type stream_watermark_response_collection = Schemas.stream_api$response$common & {
        result?: Schemas.stream_watermarks[];
    };
    export type stream_watermark_response_single = Schemas.stream_api$response$single & {
        result?: {};
    };
    /** The size of the image in bytes. */
    export type stream_watermark_size = number;
    export interface stream_watermarkAtUpload {
        /** The unique identifier for the watermark profile. */
        uid?: string;
    }
    export interface stream_watermarks {
        created?: Schemas.stream_watermark_created;
        downloadedFrom?: Schemas.stream_downloadedFrom;
        height?: Schemas.stream_height;
        name?: Schemas.stream_name;
        opacity?: Schemas.stream_opacity;
        padding?: Schemas.stream_padding;
        position?: Schemas.stream_position;
        scale?: Schemas.stream_scale;
        size?: Schemas.stream_watermark_size;
        uid?: Schemas.stream_watermark_identifier;
        width?: Schemas.stream_width;
    }
    export interface stream_webhook_request {
        notificationUrl: Schemas.stream_notificationUrl;
    }
    export type stream_webhook_response_single = Schemas.stream_api$response$single & {
        result?: {};
    };
    /** The width of the image in pixels. */
    export type stream_width = number;
    /** Whether to allow the user to switch WARP between modes. */
    export type teams$devices_allow_mode_switch = boolean;
    /** Whether to receive update notifications when a new version of the client is available. */
    export type teams$devices_allow_updates = boolean;
    /** Whether to allow devices to leave the organization. */
    export type teams$devices_allowed_to_leave = boolean;
    export type teams$devices_api$response$collection = Schemas.teams$devices_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.teams$devices_result_info;
    };
    export type teams$devices_api$response$collection$common = Schemas.teams$devices_api$response$common & {
        result?: {}[] | null;
    };
    export interface teams$devices_api$response$common {
        errors: Schemas.teams$devices_messages;
        messages: Schemas.teams$devices_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful. */
        success: true;
    }
    export interface teams$devices_api$response$common$failure {
        errors: Schemas.teams$devices_messages;
        messages: Schemas.teams$devices_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type teams$devices_api$response$single = Schemas.teams$devices_api$response$common & {
        result?: ({} | string) | null;
    };
    export interface teams$devices_application_input_request {
        /** Operating system */
        operating_system: "windows" | "linux" | "mac";
        /** Path for the application. */
        path: string;
        /** SHA-256. */
        sha256?: string;
        /** Signing certificate thumbprint. */
        thumbprint?: string;
    }
    /** The amount of time in minutes to reconnect after having been disabled. */
    export type teams$devices_auto_connect = number;
    /** Turn on the captive portal after the specified amount of time. */
    export type teams$devices_captive_portal = number;
    export interface teams$devices_carbonblack_input_request {
        /** Operating system */
        operating_system: "windows" | "linux" | "mac";
        /** File path. */
        path: string;
        /** SHA-256. */
        sha256?: string;
        /** Signing certificate thumbprint. */
        thumbprint?: string;
    }
    /** List of volume names to be checked for encryption. */
    export type teams$devices_checkDisks = string[];
    export interface teams$devices_client_certificate_input_request {
        /** UUID of Cloudflare managed certificate. */
        certificate_id: string;
        /** Common Name that is protected by the certificate */
        cn: string;
    }
    /** The name of the device posture integration. */
    export type teams$devices_components$schemas$name = string;
    export type teams$devices_components$schemas$response_collection = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_device$managed$networks[];
    };
    export type teams$devices_components$schemas$single_response = Schemas.teams$devices_api$response$single & {
        result?: Schemas.teams$devices_device$managed$networks;
    };
    /** The type of device managed network. */
    export type teams$devices_components$schemas$type = "tls";
    /** UUID */
    export type teams$devices_components$schemas$uuid = string;
    export type teams$devices_config_request = Schemas.teams$devices_workspace_one_config_request | Schemas.teams$devices_crowdstrike_config_request | Schemas.teams$devices_uptycs_config_request | Schemas.teams$devices_intune_config_request | Schemas.teams$devices_kolide_config_request | Schemas.teams$devices_tanium_config_request | Schemas.teams$devices_sentinelone_s2s_config_request;
    export type teams$devices_config_response = Schemas.teams$devices_workspace_one_config_response;
    /** When the device was created. */
    export type teams$devices_created = Date;
    export interface teams$devices_crowdstrike_config_request {
        /** The Crowdstrike API URL. */
        api_url: string;
        /** The Crowdstrike client ID. */
        client_id: string;
        /** The Crowdstrike client secret. */
        client_secret: string;
        /** The Crowdstrike customer ID. */
        customer_id: string;
    }
    export interface teams$devices_crowdstrike_input_request {
        /** Posture Integration ID. */
        connection_id: string;
        /** Operator */
        operator?: "<" | "<=" | ">" | ">=" | "==";
        /** Os Version */
        os?: string;
        /** overall */
        overall?: string;
        /** SensorConfig */
        sensor_config?: string;
        /** Version */
        version?: string;
        /** Version Operator */
        versionOperator?: "<" | "<=" | ">" | ">=" | "==";
    }
    /** Whether the policy is the default policy for an account. */
    export type teams$devices_default = boolean;
    export interface teams$devices_default_device_settings_policy {
        allow_mode_switch?: Schemas.teams$devices_allow_mode_switch;
        allow_updates?: Schemas.teams$devices_allow_updates;
        allowed_to_leave?: Schemas.teams$devices_allowed_to_leave;
        auto_connect?: Schemas.teams$devices_auto_connect;
        captive_portal?: Schemas.teams$devices_captive_portal;
        /** Whether the policy will be applied to matching devices. */
        default?: boolean;
        disable_auto_fallback?: Schemas.teams$devices_disable_auto_fallback;
        /** Whether the policy will be applied to matching devices. */
        enabled?: boolean;
        exclude?: Schemas.teams$devices_exclude;
        exclude_office_ips?: Schemas.teams$devices_exclude_office_ips;
        fallback_domains?: Schemas.teams$devices_fallback_domains;
        gateway_unique_id?: Schemas.teams$devices_gateway_unique_id;
        include?: Schemas.teams$devices_include;
        service_mode_v2?: Schemas.teams$devices_service_mode_v2;
        support_url?: Schemas.teams$devices_support_url;
        switch_locked?: Schemas.teams$devices_switch_locked;
    }
    export type teams$devices_default_device_settings_response = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_default_device_settings_policy;
    };
    /** True if the device was deleted. */
    export type teams$devices_deleted = boolean;
    /** The description of the device posture rule. */
    export type teams$devices_description = string;
    /** The configuration object which contains the details for the WARP client to conduct the test. */
    export interface teams$devices_device$dex$test$schemas$data {
        /** The desired endpoint to test. */
        host?: string;
        /** The type of test. */
        kind?: string;
        /** The HTTP request method type. */
        method?: string;
    }
    /** Additional details about the test. */
    export type teams$devices_device$dex$test$schemas$description = string;
    /** Determines whether or not the test is active. */
    export type teams$devices_device$dex$test$schemas$enabled = boolean;
    export interface teams$devices_device$dex$test$schemas$http {
        data: Schemas.teams$devices_device$dex$test$schemas$data;
        description?: Schemas.teams$devices_device$dex$test$schemas$description;
        enabled: Schemas.teams$devices_device$dex$test$schemas$enabled;
        interval: Schemas.teams$devices_device$dex$test$schemas$interval;
        name: Schemas.teams$devices_device$dex$test$schemas$name;
    }
    /** How often the test will run. */
    export type teams$devices_device$dex$test$schemas$interval = string;
    /** The name of the DEX test. Must be unique. */
    export type teams$devices_device$dex$test$schemas$name = string;
    export interface teams$devices_device$managed$networks {
        config?: Schemas.teams$devices_schemas$config_response;
        name?: Schemas.teams$devices_device$managed$networks_components$schemas$name;
        network_id?: Schemas.teams$devices_uuid;
        type?: Schemas.teams$devices_components$schemas$type;
    }
    /** The name of the device managed network. This name must be unique. */
    export type teams$devices_device$managed$networks_components$schemas$name = string;
    export interface teams$devices_device$posture$integrations {
        config?: Schemas.teams$devices_config_response;
        id?: Schemas.teams$devices_uuid;
        interval?: Schemas.teams$devices_interval;
        name?: Schemas.teams$devices_components$schemas$name;
        type?: Schemas.teams$devices_schemas$type;
    }
    export interface teams$devices_device$posture$rules {
        description?: Schemas.teams$devices_description;
        expiration?: Schemas.teams$devices_expiration;
        id?: Schemas.teams$devices_uuid;
        input?: Schemas.teams$devices_input;
        match?: Schemas.teams$devices_match;
        name?: Schemas.teams$devices_name;
        schedule?: Schemas.teams$devices_schedule;
        type?: Schemas.teams$devices_type;
    }
    export type teams$devices_device_response = Schemas.teams$devices_api$response$single & {
        result?: {};
    };
    export interface teams$devices_device_settings_policy {
        allow_mode_switch?: Schemas.teams$devices_allow_mode_switch;
        allow_updates?: Schemas.teams$devices_allow_updates;
        allowed_to_leave?: Schemas.teams$devices_allowed_to_leave;
        auto_connect?: Schemas.teams$devices_auto_connect;
        captive_portal?: Schemas.teams$devices_captive_portal;
        default?: Schemas.teams$devices_default;
        description?: Schemas.teams$devices_schemas$description;
        disable_auto_fallback?: Schemas.teams$devices_disable_auto_fallback;
        /** Whether the policy will be applied to matching devices. */
        enabled?: boolean;
        exclude?: Schemas.teams$devices_exclude;
        exclude_office_ips?: Schemas.teams$devices_exclude_office_ips;
        fallback_domains?: Schemas.teams$devices_fallback_domains;
        gateway_unique_id?: Schemas.teams$devices_gateway_unique_id;
        include?: Schemas.teams$devices_include;
        lan_allow_minutes?: Schemas.teams$devices_lan_allow_minutes;
        lan_allow_subnet_size?: Schemas.teams$devices_lan_allow_subnet_size;
        match?: Schemas.teams$devices_schemas$match;
        /** The name of the device settings profile. */
        name?: string;
        policy_id?: Schemas.teams$devices_schemas$uuid;
        precedence?: Schemas.teams$devices_precedence;
        service_mode_v2?: Schemas.teams$devices_service_mode_v2;
        support_url?: Schemas.teams$devices_support_url;
        switch_locked?: Schemas.teams$devices_switch_locked;
    }
    export type teams$devices_device_settings_response = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_device_settings_policy;
    };
    export type teams$devices_device_settings_response_collection = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_device_settings_policy[];
    };
    export interface teams$devices_devices {
        created?: Schemas.teams$devices_created;
        deleted?: Schemas.teams$devices_deleted;
        device_type?: Schemas.teams$devices_platform;
        id?: Schemas.teams$devices_schemas$uuid;
        ip?: Schemas.teams$devices_ip;
        key?: Schemas.teams$devices_key;
        last_seen?: Schemas.teams$devices_last_seen;
        mac_address?: Schemas.teams$devices_mac_address;
        manufacturer?: Schemas.teams$devices_manufacturer;
        model?: Schemas.teams$devices_model;
        name?: Schemas.teams$devices_schemas$name;
        os_distro_name?: Schemas.teams$devices_os_distro_name;
        os_distro_revision?: Schemas.teams$devices_os_distro_revision;
        os_version?: Schemas.teams$devices_os_version;
        os_version_extra?: Schemas.teams$devices_os_version_extra;
        revoked_at?: Schemas.teams$devices_revoked_at;
        serial_number?: Schemas.teams$devices_serial_number;
        updated?: Schemas.teams$devices_updated;
        user?: Schemas.teams$devices_user;
        version?: Schemas.teams$devices_version;
    }
    export type teams$devices_devices_response = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_devices[];
    };
    export type teams$devices_dex$response_collection = Schemas.teams$devices_api$response$collection$common & {
        result?: Schemas.teams$devices_device$dex$test$schemas$http[];
    };
    export type teams$devices_dex$single_response = Schemas.teams$devices_api$response$single & {
        result?: Schemas.teams$devices_device$dex$test$schemas$http;
    };
    /** If the \`dns_server\` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to \`true\`. */
    export type teams$devices_disable_auto_fallback = boolean;
    export interface teams$devices_disable_for_time {
        /** Override code that is valid for 1 hour. */
        "1"?: any;
        /** Override code that is valid for 3 hours. */
        "3"?: any;
        /** Override code that is valid for 6 hours. */
        "6"?: any;
        /** Override code that is valid for 12 hour2. */
        "12"?: any;
        /** Override code that is valid for 24 hour.2. */
        "24"?: any;
    }
    export interface teams$devices_disk_encryption_input_request {
        checkDisks?: Schemas.teams$devices_checkDisks;
        requireAll?: Schemas.teams$devices_requireAll;
    }
    export interface teams$devices_domain_joined_input_request {
        /** Domain */
        domain?: string;
        /** Operating System */
        operating_system: "windows";
    }
    /** The contact email address of the user. */
    export type teams$devices_email = string;
    export type teams$devices_exclude = Schemas.teams$devices_split_tunnel[];
    /** Whether to add Microsoft IPs to Split Tunnel exclusions. */
    export type teams$devices_exclude_office_ips = boolean;
    /** Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client. */
    export type teams$devices_expiration = string;
    export interface teams$devices_fallback_domain {
        /** A description of the fallback domain, displayed in the client UI. */
        description?: string;
        /** A list of IP addresses to handle domain resolution. */
        dns_server?: {}[];
        /** The domain suffix to match when resolving locally. */
        suffix: string;
    }
    export type teams$devices_fallback_domain_response_collection = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_fallback_domain[];
    };
    export type teams$devices_fallback_domains = Schemas.teams$devices_fallback_domain[];
    export interface teams$devices_file_input_request {
        /** Whether or not file exists */
        exists?: boolean;
        /** Operating system */
        operating_system: "windows" | "linux" | "mac";
        /** File path. */
        path: string;
        /** SHA-256. */
        sha256?: string;
        /** Signing certificate thumbprint. */
        thumbprint?: string;
    }
    export interface teams$devices_firewall_input_request {
        /** Enabled */
        enabled: boolean;
        /** Operating System */
        operating_system: "windows" | "mac";
    }
    export type teams$devices_gateway_unique_id = string;
    export type teams$devices_id_response = Schemas.teams$devices_api$response$single & {
        result?: {
            id?: Schemas.teams$devices_uuid;
        };
    };
    export type teams$devices_identifier = any;
    export type teams$devices_include = Schemas.teams$devices_split_tunnel_include[];
    export type teams$devices_input = Schemas.teams$devices_file_input_request | Schemas.teams$devices_unique_client_id_input_request | Schemas.teams$devices_domain_joined_input_request | Schemas.teams$devices_os_version_input_request | Schemas.teams$devices_firewall_input_request | Schemas.teams$devices_sentinelone_input_request | Schemas.teams$devices_carbonblack_input_request | Schemas.teams$devices_disk_encryption_input_request | Schemas.teams$devices_application_input_request | Schemas.teams$devices_client_certificate_input_request | Schemas.teams$devices_workspace_one_input_request | Schemas.teams$devices_crowdstrike_input_request | Schemas.teams$devices_intune_input_request | Schemas.teams$devices_kolide_input_request | Schemas.teams$devices_tanium_input_request | Schemas.teams$devices_sentinelone_s2s_input_request;
    /** The interval between each posture check with the third-party API. Use \`m\` for minutes (e.g. \`5m\`) and \`h\` for hours (e.g. \`12h\`). */
    export type teams$devices_interval = string;
    export interface teams$devices_intune_config_request {
        /** The Intune client ID. */
        client_id: string;
        /** The Intune client secret. */
        client_secret: string;
        /** The Intune customer ID. */
        customer_id: string;
    }
    export interface teams$devices_intune_input_request {
        /** Compliance Status */
        compliance_status: "compliant" | "noncompliant" | "unknown" | "notapplicable" | "ingraceperiod" | "error";
        /** Posture Integration ID. */
        connection_id: string;
    }
    /** IPv4 or IPv6 address. */
    export type teams$devices_ip = string;
    /** The device's public key. */
    export type teams$devices_key = string;
    export interface teams$devices_kolide_config_request {
        /** The Kolide client ID. */
        client_id: string;
        /** The Kolide client secret. */
        client_secret: string;
    }
    export interface teams$devices_kolide_input_request {
        /** Posture Integration ID. */
        connection_id: string;
        /** Count Operator */
        countOperator: "<" | "<=" | ">" | ">=" | "==";
        /** The Number of Issues. */
        issue_count: string;
    }
    /** The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset. */
    export type teams$devices_lan_allow_minutes = number;
    /** The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset. */
    export type teams$devices_lan_allow_subnet_size = number;
    /** When the device last connected to Cloudflare services. */
    export type teams$devices_last_seen = Date;
    /** The device mac address. */
    export type teams$devices_mac_address = string;
    /** The device manufacturer name. */
    export type teams$devices_manufacturer = string;
    /** The conditions that the client must match to run the rule. */
    export type teams$devices_match = Schemas.teams$devices_match_item[];
    export interface teams$devices_match_item {
        platform?: Schemas.teams$devices_platform;
    }
    export type teams$devices_messages = {
        code: number;
        message: string;
    }[];
    /** The device model name. */
    export type teams$devices_model = string;
    /** The name of the device posture rule. */
    export type teams$devices_name = string;
    /** The Linux distro name. */
    export type teams$devices_os_distro_name = string;
    /** The Linux distro revision. */
    export type teams$devices_os_distro_revision = string;
    /** The operating system version. */
    export type teams$devices_os_version = string;
    /** The operating system version extra parameter. */
    export type teams$devices_os_version_extra = string;
    export interface teams$devices_os_version_input_request {
        /** Operating System */
        operating_system: "windows";
        /** Operator */
        operator: "<" | "<=" | ">" | ">=" | "==";
        /** Operating System Distribution Name (linux only) */
        os_distro_name?: string;
        /** Version of OS Distribution (linux only) */
        os_distro_revision?: string;
        /** Additional version data. For Mac or iOS, the Product Verison Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only) */
        os_version_extra?: string;
        /** Version of OS */
        version: string;
    }
    export type teams$devices_override_codes_response = Schemas.teams$devices_api$response$collection & {
        result?: {
            disable_for_time?: Schemas.teams$devices_disable_for_time;
        };
    };
    export type teams$devices_platform = "windows" | "mac" | "linux" | "android" | "ios";
    /** The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field. */
    export type teams$devices_precedence = number;
    /** Whether to check all disks for encryption. */
    export type teams$devices_requireAll = boolean;
    export type teams$devices_response_collection = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_device$posture$rules[];
    };
    export interface teams$devices_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** A list of device ids to revoke. */
    export type teams$devices_revoke_devices_request = Schemas.teams$devices_schemas$uuid[];
    /** When the device was revoked. */
    export type teams$devices_revoked_at = Date;
    /** Polling frequency for the WARP client posture check. Default: \`5m\` (poll every five minutes). Minimum: \`1m\`. */
    export type teams$devices_schedule = string;
    export type teams$devices_schemas$config_request = Schemas.teams$devices_tls_config_request;
    export type teams$devices_schemas$config_response = Schemas.teams$devices_tls_config_response;
    /** A description of the policy. */
    export type teams$devices_schemas$description = string;
    export type teams$devices_schemas$id_response = Schemas.teams$devices_api$response$single & {
        result?: {} | null;
    };
    /** The wirefilter expression to match devices. */
    export type teams$devices_schemas$match = string;
    /** The device name. */
    export type teams$devices_schemas$name = string;
    export type teams$devices_schemas$response_collection = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_device$posture$integrations[];
    };
    export type teams$devices_schemas$single_response = Schemas.teams$devices_api$response$single & {
        result?: Schemas.teams$devices_device$posture$integrations;
    };
    /** The type of device posture integration. */
    export type teams$devices_schemas$type = "workspace_one" | "crowdstrike_s2s" | "uptycs" | "intune" | "kolide" | "tanium" | "sentinelone_s2s";
    /** Device ID. */
    export type teams$devices_schemas$uuid = string;
    export interface teams$devices_sentinelone_input_request {
        /** Operating system */
        operating_system: "windows" | "linux" | "mac";
        /** File path. */
        path: string;
        /** SHA-256. */
        sha256?: string;
        /** Signing certificate thumbprint. */
        thumbprint?: string;
    }
    export interface teams$devices_sentinelone_s2s_config_request {
        /** The SentinelOne S2S API URL. */
        api_url: string;
        /** The SentinelOne S2S client secret. */
        client_secret: string;
    }
    export interface teams$devices_sentinelone_s2s_input_request {
        /** The Number of active threats. */
        active_threats?: number;
        /** Posture Integration ID. */
        connection_id: string;
        /** Whether device is infected. */
        infected?: boolean;
        /** Whether device is active. */
        is_active?: boolean;
        /** Network status of device. */
        network_status?: "connected" | "disconnected" | "disconnecting" | "connecting";
        /** operator */
        operator?: "<" | "<=" | ">" | ">=" | "==";
    }
    /** The device serial number. */
    export type teams$devices_serial_number = string;
    export interface teams$devices_service_mode_v2 {
        /** The mode to run the WARP client under. */
        mode?: string;
        /** The port number when used with proxy mode. */
        port?: number;
    }
    export type teams$devices_single_response = Schemas.teams$devices_api$response$single & {
        result?: Schemas.teams$devices_device$posture$rules;
    };
    export interface teams$devices_split_tunnel {
        /** The address in CIDR format to exclude from the tunnel. If \`address\` is present, \`host\` must not be present. */
        address: string;
        /** A description of the Split Tunnel item, displayed in the client UI. */
        description: string;
        /** The domain name to exclude from the tunnel. If \`host\` is present, \`address\` must not be present. */
        host?: string;
    }
    export interface teams$devices_split_tunnel_include {
        /** The address in CIDR format to include in the tunnel. If address is present, host must not be present. */
        address: string;
        /** A description of the split tunnel item, displayed in the client UI. */
        description: string;
        /** The domain name to include in the tunnel. If host is present, address must not be present. */
        host?: string;
    }
    export type teams$devices_split_tunnel_include_response_collection = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_split_tunnel_include[];
    };
    export type teams$devices_split_tunnel_response_collection = Schemas.teams$devices_api$response$collection & {
        result?: Schemas.teams$devices_split_tunnel[];
    };
    /** The URL to launch when the Send Feedback button is clicked. */
    export type teams$devices_support_url = string;
    /** Whether to allow the user to turn off the WARP switch and disconnect the client. */
    export type teams$devices_switch_locked = boolean;
    export interface teams$devices_tanium_config_request {
        /** If present, this id will be passed in the \`CF-Access-Client-ID\` header when hitting the \`api_url\` */
        access_client_id?: string;
        /** If present, this secret will be passed in the \`CF-Access-Client-Secret\` header when hitting the \`api_url\` */
        access_client_secret?: string;
        /** The Tanium API URL. */
        api_url: string;
        /** The Tanium client secret. */
        client_secret: string;
    }
    export interface teams$devices_tanium_input_request {
        /** Posture Integration ID. */
        connection_id: string;
        /** For more details on eid last seen, refer to the Tanium documentation. */
        eid_last_seen?: string;
        /** Operator to evaluate risk_level or eid_last_seen. */
        operator?: "<" | "<=" | ">" | ">=" | "==";
        /** For more details on risk level, refer to the Tanium documentation. */
        risk_level?: "low" | "medium" | "high" | "critical";
        /** Score Operator */
        scoreOperator?: "<" | "<=" | ">" | ">=" | "==";
        /** For more details on total score, refer to the Tanium documentation. */
        total_score?: number;
    }
    export interface teams$devices_tls_config_request {
        /** The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate. */
        sha256?: string;
        /** A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host. */
        tls_sockaddr: string;
    }
    /** The Managed Network TLS Config Response. */
    export interface teams$devices_tls_config_response {
        /** The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate. */
        sha256?: string;
        /** A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host. */
        tls_sockaddr: string;
    }
    /** The type of device posture rule. */
    export type teams$devices_type = "file" | "application" | "tanium" | "gateway" | "warp" | "disk_encryption" | "sentinelone" | "carbonblack" | "firewall" | "os_version" | "domain_joined" | "client_certificate" | "unique_client_id" | "kolide" | "tanium_s2s" | "crowdstrike_s2s" | "intune" | "workspace_one" | "sentinelone_s2s";
    export interface teams$devices_unique_client_id_input_request {
        /** List ID. */
        id: string;
        /** Operating System */
        operating_system: "android" | "ios" | "chromeos";
    }
    /** A list of device ids to unrevoke. */
    export type teams$devices_unrevoke_devices_request = Schemas.teams$devices_schemas$uuid[];
    /** When the device was updated. */
    export type teams$devices_updated = Date;
    export interface teams$devices_uptycs_config_request {
        /** The Uptycs API URL. */
        api_url: string;
        /** The Uptycs client secret. */
        client_key: string;
        /** The Uptycs client secret. */
        client_secret: string;
        /** The Uptycs customer ID. */
        customer_id: string;
    }
    export interface teams$devices_user {
        email?: Schemas.teams$devices_email;
        id?: Schemas.teams$devices_components$schemas$uuid;
        /** The enrolled device user's name. */
        name?: string;
    }
    /** API UUID. */
    export type teams$devices_uuid = string;
    /** The WARP client version. */
    export type teams$devices_version = string;
    export interface teams$devices_workspace_one_config_request {
        /** The Workspace One API URL provided in the Workspace One Admin Dashboard. */
        api_url: string;
        /** The Workspace One Authorization URL depending on your region. */
        auth_url: string;
        /** The Workspace One client ID provided in the Workspace One Admin Dashboard. */
        client_id: string;
        /** The Workspace One client secret provided in the Workspace One Admin Dashboard. */
        client_secret: string;
    }
    /** The Workspace One Config Response. */
    export interface teams$devices_workspace_one_config_response {
        /** The Workspace One API URL provided in the Workspace One Admin Dashboard. */
        api_url: string;
        /** The Workspace One Authorization URL depending on your region. */
        auth_url: string;
        /** The Workspace One client ID provided in the Workspace One Admin Dashboard. */
        client_id: string;
    }
    export interface teams$devices_workspace_one_input_request {
        /** Compliance Status */
        compliance_status: "compliant" | "noncompliant" | "unknown";
        /** Posture Integration ID. */
        connection_id: string;
    }
    export interface teams$devices_zero$trust$account$device$settings {
        /** Enable gateway proxy filtering on TCP. */
        gateway_proxy_enabled?: boolean;
        /** Enable gateway proxy filtering on UDP. */
        gateway_udp_proxy_enabled?: boolean;
        /** Enable installation of cloudflare managed root certificate. */
        root_certificate_installation_enabled?: boolean;
        /** Enable using CGNAT virtual IPv4. */
        use_zt_virtual_ip?: boolean;
    }
    export type teams$devices_zero$trust$account$device$settings$response = Schemas.teams$devices_api$response$single & {
        result?: Schemas.teams$devices_zero$trust$account$device$settings;
    };
    export interface tt1FM6Ha_api$response$common {
        errors: Schemas.tt1FM6Ha_messages;
        messages: Schemas.tt1FM6Ha_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface tt1FM6Ha_api$response$common$failure {
        errors: Schemas.tt1FM6Ha_messages;
        messages: Schemas.tt1FM6Ha_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type tt1FM6Ha_api$response$single = Schemas.tt1FM6Ha_api$response$common & {
        result?: {} | string;
    };
    /** Identifier */
    export type tt1FM6Ha_identifier = string;
    export type tt1FM6Ha_messages = {
        code: number;
        message: string;
    }[];
    export type tunnel_api$response$collection = Schemas.tunnel_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.tunnel_result_info;
    };
    export interface tunnel_api$response$common {
        errors: Schemas.tunnel_messages;
        messages: Schemas.tunnel_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface tunnel_api$response$common$failure {
        errors: Schemas.tunnel_messages;
        messages: Schemas.tunnel_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type tunnel_api$response$single = Schemas.tunnel_api$response$common;
    /** The cloudflared OS architecture used to establish this connection. */
    export type tunnel_arch = string;
    export interface tunnel_argo$tunnel {
        /** The tunnel connections between your origin and Cloudflare's edge. */
        connections: Schemas.tunnel_connection[];
        created_at: Schemas.tunnel_created_at;
        deleted_at?: Schemas.tunnel_deleted_at;
        id: Schemas.tunnel_tunnel_id;
        name: Schemas.tunnel_tunnel_name;
    }
    /** Cloudflare account ID */
    export type tunnel_cf_account_id = string;
    /** A Cloudflare Tunnel that connects your origin to Cloudflare's edge. */
    export interface tunnel_cfd_tunnel {
        account_tag?: Schemas.tunnel_cf_account_id;
        connections?: Schemas.tunnel_connections;
        conns_active_at?: Schemas.tunnel_conns_active_at;
        conns_inactive_at?: Schemas.tunnel_conns_inactive_at;
        created_at?: Schemas.tunnel_created_at;
        deleted_at?: Schemas.tunnel_deleted_at;
        id?: Schemas.tunnel_tunnel_id;
        metadata?: Schemas.tunnel_metadata;
        name?: Schemas.tunnel_tunnel_name;
        remote_config?: Schemas.tunnel_remote_config;
        status?: Schemas.tunnel_status;
        tun_type?: Schemas.tunnel_tunnel_type;
    }
    /** UUID of the Cloudflare Tunnel client. */
    export type tunnel_client_id = string;
    /** The Cloudflare data center used for this connection. */
    export type tunnel_colo_name = string;
    /** Optional remark describing the route. */
    export type tunnel_comment = string;
    /** The tunnel configuration and ingress rules. */
    export interface tunnel_config {
        /** List of public hostname definitions */
        ingress?: Schemas.tunnel_ingressRule[];
        originRequest?: Schemas.tunnel_originRequest;
        /** Enable private network access from WARP users to private network routes */
        "warp-routing"?: {
            enabled?: boolean;
        };
    }
    export type tunnel_config_response_single = Schemas.tunnel_api$response$single & {
        result?: {};
    };
    /** Indicates if this is a locally or remotely configured tunnel. If \`local\`, manage the tunnel using a YAML file on the origin machine. If \`cloudflare\`, manage the tunnel on the Zero Trust dashboard or using the [Cloudflare Tunnel configuration](https://api.cloudflare.com/#cloudflare-tunnel-configuration-properties) endpoint. */
    export type tunnel_config_src = "local" | "cloudflare";
    /** The version of the remote tunnel configuration. Used internally to sync cloudflared with the Zero Trust dashboard. */
    export type tunnel_config_version = number;
    export interface tunnel_connection {
        colo_name?: Schemas.tunnel_colo_name;
        is_pending_reconnect?: Schemas.tunnel_is_pending_reconnect;
        uuid?: Schemas.tunnel_connection_id;
    }
    /** UUID of the Cloudflare Tunnel connection. */
    export type tunnel_connection_id = string;
    /** The Cloudflare Tunnel connections between your origin and Cloudflare's edge. */
    export type tunnel_connections = Schemas.tunnel_schemas$connection[];
    /** Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If \`null\`, the tunnel is inactive. */
    export type tunnel_conns_active_at = (Date) | null;
    /** Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If \`null\`, the tunnel is active. */
    export type tunnel_conns_inactive_at = (Date) | null;
    /** Timestamp of when the tunnel was created. */
    export type tunnel_created_at = Date;
    /** Timestamp of when the tunnel was deleted. If \`null\`, the tunnel has not been deleted. */
    export type tunnel_deleted_at = (Date) | null;
    export type tunnel_empty_response = Schemas.tunnel_api$response$common & {
        result?: {};
    };
    /** If provided, include only tunnels that were created (and not deleted) before this time. */
    export type tunnel_existed_at = Date;
    /** Features enabled for the Cloudflare Tunnel. */
    export type tunnel_features = string[];
    /** A flag to enable the ICMP proxy for the account network. */
    export type tunnel_icmp_proxy_enabled = boolean;
    /** Identifier */
    export type tunnel_identifier = string;
    /** Public hostname */
    export interface tunnel_ingressRule {
        /** Public hostname for this service. */
        hostname: string;
        originRequest?: Schemas.tunnel_originRequest;
        /** Requests with this path route to this public hostname. */
        path?: string;
        /** Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http_status:[code] e.g. 'http_status:404'. */
        service: string;
    }
    export type tunnel_ip = string;
    /** The private IPv4 or IPv6 range connected by the route, in CIDR notation. */
    export type tunnel_ip_network = string;
    /** IP/CIDR range in URL-encoded format */
    export type tunnel_ip_network_encoded = string;
    /** If \`true\`, this virtual network is the default for the account. */
    export type tunnel_is_default_network = boolean;
    /** Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If \`true\`, the connection has disconnected but is still being tracked. If \`false\`, the connection is actively serving traffic. */
    export type tunnel_is_pending_reconnect = boolean;
    export type tunnel_legacy$tunnel$response$collection = Schemas.tunnel_api$response$collection & {
        result?: Schemas.tunnel_argo$tunnel[];
    };
    export type tunnel_legacy$tunnel$response$single = Schemas.tunnel_api$response$single & {
        result?: Schemas.tunnel_argo$tunnel;
    };
    /** Management resources the token will have access to. */
    export type tunnel_management$resources = "logs";
    export type tunnel_messages = {
        code: number;
        message: string;
    }[];
    /** Metadata associated with the tunnel. */
    export interface tunnel_metadata {
    }
    /** A flag to enable WARP to WARP traffic. */
    export type tunnel_offramp_warp_enabled = boolean;
    /** Configuration parameters of connection between cloudflared and origin server. */
    export interface tunnel_originRequest {
        /** For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header. */
        access?: {
            /** Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API. */
            audTag: string[];
            /** Deny traffic that has not fulfilled Access authorization. */
            required?: boolean;
            teamName: string;
        };
        /** Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. */
        caPool?: string;
        /** Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout. */
        connectTimeout?: number;
        /** Disables chunked transfer encoding. Useful if you are running a WSGI server. */
        disableChunkedEncoding?: boolean;
        /** Attempt to connect to origin using HTTP2. Origin must be configured as https. */
        http2Origin?: boolean;
        /** Sets the HTTP Host header on requests sent to the local service. */
        httpHostHeader?: string;
        /** Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. */
        keepAliveConnections?: number;
        /** Timeout after which an idle keepalive connection can be discarded. */
        keepAliveTimeout?: number;
        /** Disable the â€œhappy eyeballsâ€ algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. */
        noHappyEyeballs?: boolean;
        /** Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. */
        noTLSVerify?: boolean;
        /** Hostname that cloudflared should expect from your origin server certificate. */
        originServerName?: string;
        /** cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy. */
        proxyType?: string;
        /** The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. */
        tcpKeepAlive?: number;
        /** Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. */
        tlsTimeout?: number;
    }
    /** Number of results to display. */
    export type tunnel_per_page = number;
    /** If \`true\`, the tunnel can be configured remotely from the Zero Trust dashboard. If \`false\`, the tunnel must be configured locally on the origin machine. */
    export type tunnel_remote_config = boolean;
    export interface tunnel_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export interface tunnel_route {
        comment?: Schemas.tunnel_comment;
        /** Timestamp of when the route was created. */
        created_at?: any;
        /** Timestamp of when the route was deleted. If \`null\`, the route has not been deleted. */
        readonly deleted_at?: Date;
        id?: Schemas.tunnel_route_id;
        network?: Schemas.tunnel_ip_network;
        tunnel_id?: Schemas.tunnel_route_tunnel_id;
        virtual_network_id?: Schemas.tunnel_route_virtual_network_id;
    }
    /** UUID of the route. */
    export type tunnel_route_id = string;
    export type tunnel_route_response_single = Schemas.tunnel_api$response$single & {
        result?: Schemas.tunnel_route;
    };
    /** UUID of the Cloudflare Tunnel serving the route. */
    export type tunnel_route_tunnel_id = any;
    /** The user-friendly name of the Cloudflare Tunnel serving the route. */
    export type tunnel_route_tunnel_name = any;
    /** UUID of the Tunnel Virtual Network this route belongs to. If no virtual networks are configured, the route is assigned to the default virtual network of the account. */
    export type tunnel_route_virtual_network_id = any;
    /** Timestamp of when the tunnel connection was started. */
    export type tunnel_run_at = Date;
    /** Optional remark describing the virtual network. */
    export type tunnel_schemas$comment = string;
    export interface tunnel_schemas$connection {
        /** UUID of the cloudflared instance. */
        client_id?: any;
        client_version?: Schemas.tunnel_version;
        colo_name?: Schemas.tunnel_colo_name;
        id?: Schemas.tunnel_connection_id;
        is_pending_reconnect?: Schemas.tunnel_is_pending_reconnect;
        /** Timestamp of when the connection was established. */
        opened_at?: Date;
        /** The public IP address of the host running cloudflared. */
        origin_ip?: string;
        uuid?: Schemas.tunnel_connection_id;
    }
    /** The status of the tunnel. Valid values are \`inactive\` (tunnel has never been run), \`degraded\` (tunnel is active and able to serve traffic but in an unhealthy state), \`healthy\` (tunnel is active and able to serve traffic), or \`down\` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge). */
    export type tunnel_status = string;
    export interface tunnel_teamnet {
        comment?: Schemas.tunnel_comment;
        /** Timestamp of when the route was created. */
        created_at?: any;
        /** Timestamp of when the route was deleted. If \`null\`, the route has not been deleted. */
        readonly deleted_at?: Date;
        id?: Schemas.tunnel_route_id;
        network?: Schemas.tunnel_ip_network;
        tun_type?: Schemas.tunnel_tunnel_type;
        tunnel_id?: Schemas.tunnel_route_tunnel_id;
        tunnel_name?: Schemas.tunnel_route_tunnel_name;
        virtual_network_id?: Schemas.tunnel_route_virtual_network_id;
        virtual_network_name?: Schemas.tunnel_vnet_name;
    }
    export type tunnel_teamnet_response_collection = Schemas.tunnel_api$response$collection & {
        result?: Schemas.tunnel_teamnet[];
    };
    export type tunnel_teamnet_response_single = Schemas.tunnel_api$response$single & {
        result?: Schemas.tunnel_teamnet;
    };
    export type tunnel_tunnel$response$collection = Schemas.tunnel_api$response$collection & {
        result?: (Schemas.tunnel_cfd_tunnel | Schemas.tunnel_warp_connector_tunnel)[];
    };
    export type tunnel_tunnel$response$single = Schemas.tunnel_api$response$single & {
        result?: Schemas.tunnel_cfd_tunnel | Schemas.tunnel_warp_connector_tunnel;
    };
    /** A client (typically cloudflared) that maintains connections to a Cloudflare data center. */
    export interface tunnel_tunnel_client {
        arch?: Schemas.tunnel_arch;
        config_version?: Schemas.tunnel_config_version;
        conns?: Schemas.tunnel_connections;
        features?: Schemas.tunnel_features;
        id?: Schemas.tunnel_connection_id;
        run_at?: Schemas.tunnel_run_at;
        version?: Schemas.tunnel_version;
    }
    export type tunnel_tunnel_client_response = Schemas.tunnel_api$response$single & {
        result?: Schemas.tunnel_tunnel_client;
    };
    export type tunnel_tunnel_connections_response = Schemas.tunnel_api$response$collection & {
        result?: Schemas.tunnel_tunnel_client[];
    };
    /** UUID of the tunnel. */
    export type tunnel_tunnel_id = string;
    /** The id of the tunnel linked and the date that link was created. */
    export interface tunnel_tunnel_link {
        created_at?: Schemas.tunnel_created_at;
        linked_tunnel_id?: Schemas.tunnel_tunnel_id;
    }
    export type tunnel_tunnel_links_response = Schemas.tunnel_api$response$collection & {
        result?: Schemas.tunnel_tunnel_link[];
    };
    /** A user-friendly name for the tunnel. */
    export type tunnel_tunnel_name = string;
    export type tunnel_tunnel_response_token = Schemas.tunnel_api$response$single & {
        result?: string;
    };
    /** Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string. */
    export type tunnel_tunnel_secret = string;
    /** The type of tunnel. */
    export type tunnel_tunnel_type = "cfd_tunnel" | "warp_connector" | "ip_sec" | "gre" | "cni";
    /** The types of tunnels to filter separated by a comma. */
    export type tunnel_tunnel_types = string;
    /** The cloudflared version used to establish this connection. */
    export type tunnel_version = string;
    export interface tunnel_virtual$network {
        comment: Schemas.tunnel_schemas$comment;
        /** Timestamp of when the virtual network was created. */
        created_at: any;
        /** Timestamp of when the virtual network was deleted. If \`null\`, the virtual network has not been deleted. */
        deleted_at?: any;
        id: Schemas.tunnel_vnet_id;
        is_default_network: Schemas.tunnel_is_default_network;
        name: Schemas.tunnel_vnet_name;
    }
    /** UUID of the virtual network. */
    export type tunnel_vnet_id = string;
    /** A user-friendly name for the virtual network. */
    export type tunnel_vnet_name = string;
    export type tunnel_vnet_response_collection = Schemas.tunnel_api$response$collection & {
        result?: Schemas.tunnel_virtual$network[];
    };
    export type tunnel_vnet_response_single = Schemas.tunnel_api$response$single & {
        result?: {};
    };
    /** A Warp Connector Tunnel that connects your origin to Cloudflare's edge. */
    export interface tunnel_warp_connector_tunnel {
        account_tag?: Schemas.tunnel_cf_account_id;
        connections?: Schemas.tunnel_connections;
        conns_active_at?: Schemas.tunnel_conns_active_at;
        conns_inactive_at?: Schemas.tunnel_conns_inactive_at;
        created_at?: Schemas.tunnel_created_at;
        deleted_at?: Schemas.tunnel_deleted_at;
        id?: Schemas.tunnel_tunnel_id;
        metadata?: Schemas.tunnel_metadata;
        name?: Schemas.tunnel_tunnel_name;
        status?: Schemas.tunnel_status;
        tun_type?: Schemas.tunnel_tunnel_type;
    }
    export type tunnel_zero_trust_connectivity_settings_response = Schemas.tunnel_api$response$single & {
        result?: {
            icmp_proxy_enabled?: Schemas.tunnel_icmp_proxy_enabled;
            offramp_warp_enabled?: Schemas.tunnel_offramp_warp_enabled;
        };
    };
    export type vectorize_api$response$collection = Schemas.vectorize_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.vectorize_result_info;
    };
    export interface vectorize_api$response$common {
        errors: Schemas.vectorize_messages;
        messages: Schemas.vectorize_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface vectorize_api$response$common$failure {
        errors: Schemas.vectorize_messages;
        messages: Schemas.vectorize_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type vectorize_api$response$single = Schemas.vectorize_api$response$common & {
        result?: ({} | string) | null;
    };
    export interface vectorize_create$index$request {
        config: Schemas.vectorize_index$configuration & {
            preset: any;
            dimensions: any;
            metric: any;
        };
        description?: Schemas.vectorize_index$description;
        name: Schemas.vectorize_index$name;
    }
    export interface vectorize_create$index$response {
        config?: Schemas.vectorize_index$dimension$configuration;
        /** Specifies the timestamp the resource was created as an ISO8601 string. */
        readonly created_on?: any;
        description?: Schemas.vectorize_index$description;
        /** Specifies the timestamp the resource was modified as an ISO8601 string. */
        readonly modified_on?: any;
        name?: Schemas.vectorize_index$name;
    }
    /** Identifier */
    export type vectorize_identifier = string;
    export type vectorize_index$configuration = Schemas.vectorize_index$preset$configuration | Schemas.vectorize_index$dimension$configuration;
    export interface vectorize_index$delete$vectors$by$id$request {
        /** A list of vector identifiers to delete from the index indicated by the path. */
        ids?: Schemas.vectorize_identifier[];
    }
    export interface vectorize_index$delete$vectors$by$id$response {
        /** The count of the vectors successfully deleted. */
        count?: number;
        /** Array of vector identifiers of the vectors that were successfully processed for deletion. */
        ids?: Schemas.vectorize_identifier[];
    }
    /** Specifies the description of the index. */
    export type vectorize_index$description = string;
    export interface vectorize_index$dimension$configuration {
        dimensions: Schemas.vectorize_index$dimensions;
        metric: Schemas.vectorize_index$metric;
    }
    /** Specifies the number of dimensions for the index */
    export type vectorize_index$dimensions = number;
    export interface vectorize_index$get$vectors$by$id$request {
        /** A list of vector identifiers to retrieve from the index indicated by the path. */
        ids?: Schemas.vectorize_identifier[];
    }
    /** Array of vectors with matching ids. */
    export type vectorize_index$get$vectors$by$id$response = {
        id?: Schemas.vectorize_identifier;
        metadata?: {};
        namespace?: string | null;
        values?: number[];
    }[];
    export interface vectorize_index$insert$response {
        /** Specifies the count of the vectors successfully inserted. */
        count?: number;
        /** Array of vector identifiers of the vectors successfully inserted. */
        ids?: Schemas.vectorize_identifier[];
    }
    /** Specifies the type of metric to use calculating distance. */
    export type vectorize_index$metric = "cosine" | "euclidean" | "dot-product";
    export type vectorize_index$name = string;
    /** Specifies the preset to use for the index. */
    export type vectorize_index$preset = "@cf/baai/bge-small-en-v1.5" | "@cf/baai/bge-base-en-v1.5" | "@cf/baai/bge-large-en-v1.5" | "openai/text-embedding-ada-002" | "cohere/embed-multilingual-v2.0";
    export interface vectorize_index$preset$configuration {
        preset: Schemas.vectorize_index$preset;
    }
    export interface vectorize_index$query$request {
        /** Whether to return the metadata associated with the closest vectors. */
        returnMetadata?: boolean;
        /** Whether to return the values associated with the closest vectors. */
        returnValues?: boolean;
        /** The number of nearest neighbors to find. */
        topK?: number;
        /** The search vector that will be used to find the nearest neighbors. */
        vector?: number[];
    }
    export interface vectorize_index$query$response {
        /** Specifies the count of vectors returned by the search */
        count?: number;
        /** Array of vectors matched by the search */
        matches?: {
            id?: Schemas.vectorize_identifier;
            metadata?: {};
            /** The score of the vector according to the index's distance metric */
            score?: number;
            values?: number[];
        }[];
    }
    export interface vectorize_index$upsert$response {
        /** Specifies the count of the vectors successfully inserted. */
        count?: number;
        /** Array of vector identifiers of the vectors successfully inserted. */
        ids?: Schemas.vectorize_identifier[];
    }
    export type vectorize_messages = {
        code: number;
        message: string;
    }[];
    export interface vectorize_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export interface vectorize_update$index$request {
        description: Schemas.vectorize_index$description;
    }
    export type vusJxt3o_account_identifier = any;
    export interface vusJxt3o_acl {
        id: Schemas.vusJxt3o_components$schemas$identifier;
        ip_range: Schemas.vusJxt3o_ip_range;
        name: Schemas.vusJxt3o_acl_components$schemas$name;
    }
    /** The name of the acl. */
    export type vusJxt3o_acl_components$schemas$name = string;
    /** TSIG algorithm. */
    export type vusJxt3o_algo = string;
    export type vusJxt3o_api$response$collection = Schemas.vusJxt3o_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.vusJxt3o_result_info;
    };
    export interface vusJxt3o_api$response$common {
        errors: Schemas.vusJxt3o_messages;
        messages: Schemas.vusJxt3o_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface vusJxt3o_api$response$common$failure {
        errors: Schemas.vusJxt3o_messages;
        messages: Schemas.vusJxt3o_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type vusJxt3o_api$response$single = Schemas.vusJxt3o_api$response$common & {
        result?: {} | string;
    };
    /**
     * How often should a secondary zone auto refresh regardless of DNS NOTIFY.
     * Not applicable for primary zones.
     */
    export type vusJxt3o_auto_refresh_seconds = number;
    export type vusJxt3o_components$schemas$id_response = Schemas.vusJxt3o_api$response$single & {
        result?: {
            id?: Schemas.vusJxt3o_components$schemas$identifier;
        };
    };
    export type vusJxt3o_components$schemas$identifier = any;
    /** The name of the peer. */
    export type vusJxt3o_components$schemas$name = string;
    export type vusJxt3o_components$schemas$response_collection = Schemas.vusJxt3o_api$response$collection & {
        result?: Schemas.vusJxt3o_acl[];
    };
    export type vusJxt3o_components$schemas$single_response = Schemas.vusJxt3o_api$response$single & {
        result?: Schemas.vusJxt3o_acl;
    };
    export type vusJxt3o_disable_transfer_response = Schemas.vusJxt3o_api$response$single & {
        result?: Schemas.vusJxt3o_disable_transfer_result;
    };
    /** The zone transfer status of a primary zone */
    export type vusJxt3o_disable_transfer_result = string;
    export interface vusJxt3o_dns$secondary$secondary$zone {
        auto_refresh_seconds: Schemas.vusJxt3o_auto_refresh_seconds;
        id: Schemas.vusJxt3o_identifier;
        name: Schemas.vusJxt3o_name;
        peers: Schemas.vusJxt3o_peers;
    }
    export type vusJxt3o_enable_transfer_response = Schemas.vusJxt3o_api$response$single & {
        result?: Schemas.vusJxt3o_enable_transfer_result;
    };
    /** The zone transfer status of a primary zone */
    export type vusJxt3o_enable_transfer_result = string;
    export type vusJxt3o_force_response = Schemas.vusJxt3o_api$response$single & {
        result?: Schemas.vusJxt3o_force_result;
    };
    /** When force_axfr query parameter is set to true, the response is a simple string */
    export type vusJxt3o_force_result = string;
    export type vusJxt3o_id_response = Schemas.vusJxt3o_api$response$single & {
        result?: {
            id?: Schemas.vusJxt3o_identifier;
        };
    };
    export type vusJxt3o_identifier = any;
    /** IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to. */
    export type vusJxt3o_ip = string;
    /** Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively. */
    export type vusJxt3o_ip_range = string;
    /** Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones. */
    export type vusJxt3o_ixfr_enable = boolean;
    export type vusJxt3o_messages = {
        code: number;
        message: string;
    }[];
    /** Zone name. */
    export type vusJxt3o_name = string;
    export interface vusJxt3o_peer {
        id: Schemas.vusJxt3o_components$schemas$identifier;
        ip?: Schemas.vusJxt3o_ip;
        ixfr_enable?: Schemas.vusJxt3o_ixfr_enable;
        name: Schemas.vusJxt3o_components$schemas$name;
        port?: Schemas.vusJxt3o_port;
        tsig_id?: Schemas.vusJxt3o_tsig_id;
    }
    /** A list of peer tags. */
    export type vusJxt3o_peers = {}[];
    /** DNS port of primary or secondary nameserver, depending on what zone this peer is linked to. */
    export type vusJxt3o_port = number;
    export type vusJxt3o_response_collection = Schemas.vusJxt3o_api$response$collection & {
        result?: Schemas.vusJxt3o_tsig[];
    };
    export interface vusJxt3o_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type vusJxt3o_schemas$force_response = Schemas.vusJxt3o_api$response$single & {
        result?: Schemas.vusJxt3o_schemas$force_result;
    };
    /** When force_notify query parameter is set to true, the response is a simple string */
    export type vusJxt3o_schemas$force_result = string;
    export type vusJxt3o_schemas$id_response = Schemas.vusJxt3o_api$response$single & {
        result?: {
            id?: Schemas.vusJxt3o_schemas$identifier;
        };
    };
    export type vusJxt3o_schemas$identifier = any;
    /** TSIG key name. */
    export type vusJxt3o_schemas$name = string;
    export type vusJxt3o_schemas$response_collection = Schemas.vusJxt3o_api$response$collection & {
        result?: Schemas.vusJxt3o_peer[];
    };
    export type vusJxt3o_schemas$single_response = Schemas.vusJxt3o_api$response$single & {
        result?: Schemas.vusJxt3o_peer;
    };
    /** TSIG secret. */
    export type vusJxt3o_secret = string;
    export interface vusJxt3o_single_request_outgoing {
        id: Schemas.vusJxt3o_identifier;
        name: Schemas.vusJxt3o_name;
        peers: Schemas.vusJxt3o_peers;
    }
    export type vusJxt3o_single_response = Schemas.vusJxt3o_api$response$single & {
        result?: Schemas.vusJxt3o_tsig;
    };
    export type vusJxt3o_single_response_incoming = Schemas.vusJxt3o_api$response$single & {
        result?: {
            auto_refresh_seconds?: Schemas.vusJxt3o_auto_refresh_seconds;
            checked_time?: Schemas.vusJxt3o_time;
            created_time?: Schemas.vusJxt3o_time;
            id?: Schemas.vusJxt3o_identifier;
            modified_time?: Schemas.vusJxt3o_time;
            name?: Schemas.vusJxt3o_name;
            peers?: Schemas.vusJxt3o_peers;
            soa_serial?: Schemas.vusJxt3o_soa_serial;
        };
    };
    export type vusJxt3o_single_response_outgoing = Schemas.vusJxt3o_api$response$single & {
        result?: {
            checked_time?: Schemas.vusJxt3o_time;
            created_time?: Schemas.vusJxt3o_time;
            id?: Schemas.vusJxt3o_identifier;
            last_transferred_time?: Schemas.vusJxt3o_time;
            name?: Schemas.vusJxt3o_name;
            peers?: Schemas.vusJxt3o_peers;
            soa_serial?: Schemas.vusJxt3o_soa_serial;
        };
    };
    /** The serial number of the SOA for the given zone. */
    export type vusJxt3o_soa_serial = number;
    /** The time for a specific event. */
    export type vusJxt3o_time = string;
    export interface vusJxt3o_tsig {
        algo: Schemas.vusJxt3o_algo;
        id: Schemas.vusJxt3o_schemas$identifier;
        name: Schemas.vusJxt3o_schemas$name;
        secret: Schemas.vusJxt3o_secret;
    }
    /** TSIG authentication will be used for zone transfer if configured. */
    export type vusJxt3o_tsig_id = string;
    /** The account id */
    export type w2PBr26F_account$id = string;
    export interface w2PBr26F_alert$types {
        description?: Schemas.w2PBr26F_description;
        display_name?: Schemas.w2PBr26F_display_name;
        filter_options?: Schemas.w2PBr26F_filter_options;
        type?: Schemas.w2PBr26F_type;
    }
    /** Message body included in the notification sent. */
    export type w2PBr26F_alert_body = string;
    /** Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values. */
    export type w2PBr26F_alert_type = "access_custom_certificate_expiration_type" | "advanced_ddos_attack_l4_alert" | "advanced_ddos_attack_l7_alert" | "advanced_http_alert_error" | "bgp_hijack_notification" | "billing_usage_alert" | "block_notification_block_removed" | "block_notification_new_block" | "block_notification_review_rejected" | "brand_protection_alert" | "brand_protection_digest" | "clickhouse_alert_fw_anomaly" | "clickhouse_alert_fw_ent_anomaly" | "custom_ssl_certificate_event_type" | "dedicated_ssl_certificate_event_type" | "dos_attack_l4" | "dos_attack_l7" | "expiring_service_token_alert" | "failing_logpush_job_disabled_alert" | "fbm_auto_advertisement" | "fbm_dosd_attack" | "fbm_volumetric_attack" | "health_check_status_notification" | "hostname_aop_custom_certificate_expiration_type" | "http_alert_edge_error" | "http_alert_origin_error" | "incident_alert" | "load_balancing_health_alert" | "load_balancing_pool_enablement_alert" | "logo_match_alert" | "magic_tunnel_health_check_event" | "maintenance_event_notification" | "mtls_certificate_store_certificate_expiration_type" | "pages_event_alert" | "radar_notification" | "real_origin_monitoring" | "scriptmonitor_alert_new_code_change_detections" | "scriptmonitor_alert_new_hosts" | "scriptmonitor_alert_new_malicious_hosts" | "scriptmonitor_alert_new_malicious_scripts" | "scriptmonitor_alert_new_malicious_url" | "scriptmonitor_alert_new_max_length_resource_url" | "scriptmonitor_alert_new_resources" | "secondary_dns_all_primaries_failing" | "secondary_dns_primaries_failing" | "secondary_dns_zone_successfully_updated" | "secondary_dns_zone_validation_warning" | "sentinel_alert" | "stream_live_notifications" | "tunnel_health_event" | "tunnel_update_event" | "universal_ssl_event_type" | "web_analytics_metrics_update" | "zone_aop_custom_certificate_expiration_type";
    export type w2PBr26F_api$response$collection = Schemas.w2PBr26F_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.w2PBr26F_result_info;
    };
    export interface w2PBr26F_api$response$common {
        errors: Schemas.w2PBr26F_messages;
        messages: Schemas.w2PBr26F_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface w2PBr26F_api$response$common$failure {
        errors: Schemas.w2PBr26F_messages;
        messages: Schemas.w2PBr26F_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type w2PBr26F_api$response$single = Schemas.w2PBr26F_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export interface w2PBr26F_audit$logs {
        action?: {
            /** A boolean that indicates if the action attempted was successful. */
            result?: boolean;
            /** A short string that describes the action that was performed. */
            type?: string;
        };
        actor?: {
            /** The email of the user that performed the action. */
            email?: string;
            /** The ID of the actor that performed the action. If a user performed the action, this will be their User ID. */
            id?: string;
            /** The IP address of the request that performed the action. */
            ip?: string;
            /** The type of actor, whether a User, Cloudflare Admin, or an Automated System. */
            type?: "user" | "admin" | "Cloudflare";
        };
        /** A string that uniquely identifies the audit log. */
        id?: string;
        /** The source of the event. */
        interface?: string;
        /** An object which can lend more context to the action being logged. This is a flexible value and varies between different actions. */
        metadata?: {};
        /** The new value of the resource that was modified. */
        newValue?: string;
        /** The value of the resource before it was modified. */
        oldValue?: string;
        owner?: {
            id?: Schemas.w2PBr26F_identifier;
        };
        resource?: {
            /** An identifier for the resource that was affected by the action. */
            id?: string;
            /** A short string that describes the resource that was affected by the action. */
            type?: string;
        };
        /** A UTC RFC3339 timestamp that specifies when the action being logged occured. */
        when?: Date;
    }
    export type w2PBr26F_audit_logs_response_collection = {
        errors?: {} | null;
        messages?: {}[];
        result?: Schemas.w2PBr26F_audit$logs[];
        success?: boolean;
    } | Schemas.w2PBr26F_api$response$common;
    /** Limit the returned results to history records older than the specified date. This must be a timestamp that conforms to RFC3339. */
    export type w2PBr26F_before = Date;
    /** Description of the notification policy (if present). */
    export type w2PBr26F_components$schemas$description = string;
    /** The name of the webhook destination. This will be included in the request body when you receive a webhook notification. */
    export type w2PBr26F_components$schemas$name = string;
    export type w2PBr26F_components$schemas$response_collection = Schemas.w2PBr26F_api$response$collection & {
        result?: Schemas.w2PBr26F_pagerduty[];
    };
    /** Type of webhook endpoint. */
    export type w2PBr26F_components$schemas$type = "slack" | "generic" | "gchat";
    /** Timestamp of when the webhook destination was created. */
    export type w2PBr26F_created_at = Date;
    /** Describes the alert type. */
    export type w2PBr26F_description = string;
    /** Alert type name. */
    export type w2PBr26F_display_name = string;
    export interface w2PBr26F_eligibility {
        eligible?: Schemas.w2PBr26F_eligible;
        ready?: Schemas.w2PBr26F_ready;
        type?: Schemas.w2PBr26F_schemas$type;
    }
    /** Determines whether or not the account is eligible for the delivery mechanism. */
    export type w2PBr26F_eligible = boolean;
    /** Whether or not the Notification policy is enabled. */
    export type w2PBr26F_enabled = boolean;
    /** Format of additional configuration options (filters) for the alert type. Data type of filters during policy creation: Array of strings. */
    export type w2PBr26F_filter_options = {}[];
    /** Optional filters that allow you to be alerted only on a subset of events for that alert type based on some criteria. This is only available for select alert types. See alert type documentation for more details. */
    export interface w2PBr26F_filters {
        /** Usage depends on specific alert type */
        actions?: string[];
        /** Used for configuring radar_notification */
        affected_asns?: string[];
        /** Used for configuring incident_alert */
        affected_components?: string[];
        /** Used for configuring radar_notification */
        affected_locations?: string[];
        /** Used for configuring maintenance_event_notification */
        airport_code?: string[];
        /** Usage depends on specific alert type */
        alert_trigger_preferences?: string[];
        /** Used for configuring magic_tunnel_health_check_event */
        alert_trigger_preferences_value?: ("99.0" | "98.0" | "97.0")[];
        /** Used for configuring load_balancing_pool_enablement_alert */
        enabled?: string[];
        /** Used for configuring pages_event_alert */
        environment?: string[];
        /** Used for configuring pages_event_alert */
        event?: string[];
        /** Used for configuring load_balancing_health_alert */
        event_source?: string[];
        /** Usage depends on specific alert type */
        event_type?: string[];
        /** Usage depends on specific alert type */
        group_by?: string[];
        /** Used for configuring health_check_status_notification */
        health_check_id?: string[];
        /** Used for configuring incident_alert */
        incident_impact?: ("INCIDENT_IMPACT_NONE" | "INCIDENT_IMPACT_MINOR" | "INCIDENT_IMPACT_MAJOR" | "INCIDENT_IMPACT_CRITICAL")[];
        /** Used for configuring stream_live_notifications */
        input_id?: string[];
        /** Used for configuring billing_usage_alert */
        limit?: string[];
        /** Used for configuring logo_match_alert */
        logo_tag?: string[];
        /** Used for configuring advanced_ddos_attack_l4_alert */
        megabits_per_second?: string[];
        /** Used for configuring load_balancing_health_alert */
        new_health?: string[];
        /** Used for configuring tunnel_health_event */
        new_status?: string[];
        /** Used for configuring advanced_ddos_attack_l4_alert */
        packets_per_second?: string[];
        /** Usage depends on specific alert type */
        pool_id?: string[];
        /** Used for configuring billing_usage_alert */
        product?: string[];
        /** Used for configuring pages_event_alert */
        project_id?: string[];
        /** Used for configuring advanced_ddos_attack_l4_alert */
        protocol?: string[];
        /** Usage depends on specific alert type */
        query_tag?: string[];
        /** Used for configuring advanced_ddos_attack_l7_alert */
        requests_per_second?: string[];
        /** Usage depends on specific alert type */
        selectors?: string[];
        /** Used for configuring clickhouse_alert_fw_ent_anomaly */
        services?: string[];
        /** Usage depends on specific alert type */
        slo?: string[];
        /** Used for configuring health_check_status_notification */
        status?: string[];
        /** Used for configuring advanced_ddos_attack_l7_alert */
        target_hostname?: string[];
        /** Used for configuring advanced_ddos_attack_l4_alert */
        target_ip?: string[];
        /** Used for configuring advanced_ddos_attack_l7_alert */
        target_zone_name?: string[];
        /** Used for configuring traffic_anomalies_alert */
        traffic_exclusions?: ("security_events")[];
        /** Used for configuring tunnel_health_event */
        tunnel_id?: string[];
        /** Used for configuring magic_tunnel_health_check_event */
        tunnel_name?: string[];
        /** Usage depends on specific alert type */
        where?: string[];
        /** Usage depends on specific alert type */
        zones?: string[];
    }
    export interface w2PBr26F_history {
        alert_body?: Schemas.w2PBr26F_alert_body;
        alert_type?: Schemas.w2PBr26F_schemas$alert_type;
        description?: Schemas.w2PBr26F_components$schemas$description;
        id?: Schemas.w2PBr26F_uuid;
        mechanism?: Schemas.w2PBr26F_mechanism;
        mechanism_type?: Schemas.w2PBr26F_mechanism_type;
        name?: Schemas.w2PBr26F_schemas$name;
        policy_id?: Schemas.w2PBr26F_policy$id;
        sent?: Schemas.w2PBr26F_sent;
    }
    export type w2PBr26F_history_components$schemas$response_collection = Schemas.w2PBr26F_api$response$collection & {
        result?: Schemas.w2PBr26F_history[];
        result_info?: {};
    };
    export type w2PBr26F_id_response = Schemas.w2PBr26F_api$response$single & {
        result?: {
            id?: Schemas.w2PBr26F_uuid;
        };
    };
    /** Identifier */
    export type w2PBr26F_identifier = string;
    /** Timestamp of the last time an attempt to dispatch a notification to this webhook failed. */
    export type w2PBr26F_last_failure = Date;
    /** Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook. */
    export type w2PBr26F_last_success = Date;
    /** The mechanism to which the notification has been dispatched. */
    export type w2PBr26F_mechanism = string;
    /** The type of mechanism to which the notification has been dispatched. This can be email/pagerduty/webhook based on the mechanism configured. */
    export type w2PBr26F_mechanism_type = "email" | "pagerduty" | "webhook";
    /** List of IDs that will be used when dispatching a notification. IDs for email type will be the email address. */
    export interface w2PBr26F_mechanisms {
    }
    export type w2PBr26F_messages = {
        code: number;
        message: string;
    }[];
    /** The name of the pagerduty service. */
    export type w2PBr26F_name = string;
    export interface w2PBr26F_pagerduty {
        id?: Schemas.w2PBr26F_uuid;
        name?: Schemas.w2PBr26F_name;
    }
    /** Number of items per page. */
    export type w2PBr26F_per_page = number;
    export interface w2PBr26F_policies {
        alert_type?: Schemas.w2PBr26F_alert_type;
        created?: Schemas.w2PBr26F_timestamp;
        description?: Schemas.w2PBr26F_schemas$description;
        enabled?: Schemas.w2PBr26F_enabled;
        filters?: Schemas.w2PBr26F_filters;
        id?: Schemas.w2PBr26F_policy$id;
        mechanisms?: Schemas.w2PBr26F_mechanisms;
        modified?: Schemas.w2PBr26F_timestamp;
        name?: Schemas.w2PBr26F_schemas$name;
    }
    export type w2PBr26F_policies_components$schemas$response_collection = Schemas.w2PBr26F_api$response$collection & {
        result?: Schemas.w2PBr26F_policies[];
    };
    /** The unique identifier of a notification policy */
    export type w2PBr26F_policy$id = string;
    /** Beta flag. Users can create a policy with a mechanism that is not ready, but we cannot guarantee successful delivery of notifications. */
    export type w2PBr26F_ready = boolean;
    export type w2PBr26F_response_collection = Schemas.w2PBr26F_api$response$collection & {
        result?: {};
    };
    export interface w2PBr26F_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Type of notification that has been dispatched. */
    export type w2PBr26F_schemas$alert_type = string;
    /** Optional description for the Notification policy. */
    export type w2PBr26F_schemas$description = string;
    /** Name of the policy. */
    export type w2PBr26F_schemas$name = string;
    export type w2PBr26F_schemas$response_collection = Schemas.w2PBr26F_api$response$collection & {
        result?: {};
    };
    export type w2PBr26F_schemas$single_response = Schemas.w2PBr26F_api$response$single & {
        result?: Schemas.w2PBr26F_webhooks;
    };
    /** Determines type of delivery mechanism. */
    export type w2PBr26F_schemas$type = "email" | "pagerduty" | "webhook";
    /** Optional secret that will be passed in the \`cf-webhook-auth\` header when dispatching generic webhook notifications or formatted for supported destinations. Secrets are not returned in any API response body. */
    export type w2PBr26F_secret = string;
    /** Timestamp of when the notification was dispatched in ISO 8601 format. */
    export type w2PBr26F_sent = Date;
    export type w2PBr26F_single_response = Schemas.w2PBr26F_api$response$single & {
        result?: Schemas.w2PBr26F_policies;
    };
    export type w2PBr26F_timestamp = Date;
    /** The token id */
    export type w2PBr26F_token$id = string;
    /** Use this value when creating and updating a notification policy. */
    export type w2PBr26F_type = string;
    /** The POST endpoint to call when dispatching a notification. */
    export type w2PBr26F_url = string;
    /** UUID */
    export type w2PBr26F_uuid = string;
    /** The unique identifier of a webhook */
    export type w2PBr26F_webhook$id = string;
    export interface w2PBr26F_webhooks {
        created_at?: Schemas.w2PBr26F_created_at;
        id?: Schemas.w2PBr26F_webhook$id;
        last_failure?: Schemas.w2PBr26F_last_failure;
        last_success?: Schemas.w2PBr26F_last_success;
        name?: Schemas.w2PBr26F_components$schemas$name;
        secret?: Schemas.w2PBr26F_secret;
        type?: Schemas.w2PBr26F_components$schemas$type;
        url?: Schemas.w2PBr26F_url;
    }
    export type w2PBr26F_webhooks_components$schemas$response_collection = Schemas.w2PBr26F_api$response$collection & {
        result?: Schemas.w2PBr26F_webhooks[];
    };
    /** The available states for the rule group. */
    export type waf$managed$rules_allowed_modes = Schemas.waf$managed$rules_mode[];
    /** Defines the available modes for the current WAF rule. */
    export type waf$managed$rules_allowed_modes_allow_traditional = Schemas.waf$managed$rules_mode_allow_traditional[];
    /** Defines the available modes for the current WAF rule. Applies to anomaly detection WAF rules. */
    export type waf$managed$rules_allowed_modes_anomaly = Schemas.waf$managed$rules_mode_anomaly[];
    /** The list of possible actions of the WAF rule when it is triggered. */
    export type waf$managed$rules_allowed_modes_deny_traditional = Schemas.waf$managed$rules_mode_deny_traditional[];
    export type waf$managed$rules_anomaly_rule = Schemas.waf$managed$rules_schemas$base & {
        allowed_modes?: Schemas.waf$managed$rules_allowed_modes_anomaly;
        mode?: Schemas.waf$managed$rules_mode_anomaly;
    };
    export type waf$managed$rules_api$response$collection = Schemas.waf$managed$rules_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.waf$managed$rules_result_info;
    };
    export interface waf$managed$rules_api$response$common {
        errors: Schemas.waf$managed$rules_messages;
        messages: Schemas.waf$managed$rules_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface waf$managed$rules_api$response$common$failure {
        errors: Schemas.waf$managed$rules_messages;
        messages: Schemas.waf$managed$rules_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type waf$managed$rules_api$response$single = Schemas.waf$managed$rules_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export interface waf$managed$rules_base {
        description?: Schemas.waf$managed$rules_schemas$description;
        /** The rule group to which the current WAF rule belongs. */
        readonly group?: {
            id?: Schemas.waf$managed$rules_components$schemas$identifier;
            name?: Schemas.waf$managed$rules_name;
        };
        id?: Schemas.waf$managed$rules_rule_components$schemas$identifier;
        package_id?: Schemas.waf$managed$rules_identifier;
        priority?: Schemas.waf$managed$rules_priority;
    }
    /** The unique identifier of the rule group. */
    export type waf$managed$rules_components$schemas$identifier = string;
    /** The default action/mode of a rule. */
    export type waf$managed$rules_default_mode = "disable" | "simulate" | "block" | "challenge";
    /** An informative summary of what the rule group does. */
    export type waf$managed$rules_description = string | null;
    export interface waf$managed$rules_group {
        description?: Schemas.waf$managed$rules_description;
        id?: Schemas.waf$managed$rules_components$schemas$identifier;
        modified_rules_count?: Schemas.waf$managed$rules_modified_rules_count;
        name?: Schemas.waf$managed$rules_name;
        package_id?: Schemas.waf$managed$rules_identifier;
        rules_count?: Schemas.waf$managed$rules_rules_count;
    }
    /** The unique identifier of a WAF package. */
    export type waf$managed$rules_identifier = string;
    export type waf$managed$rules_messages = {
        code: number;
        message: string;
    }[];
    /** The state of the rules contained in the rule group. When \`on\`, the rules in the group are configurable/usable. */
    export type waf$managed$rules_mode = "on" | "off";
    /** When set to \`on\`, the current rule will be used when evaluating the request. Applies to traditional (allow) WAF rules. */
    export type waf$managed$rules_mode_allow_traditional = "on" | "off";
    /** When set to \`on\`, the current WAF rule will be used when evaluating the request. Applies to anomaly detection WAF rules. */
    export type waf$managed$rules_mode_anomaly = "on" | "off";
    /** The action that the current WAF rule will perform when triggered. Applies to traditional (deny) WAF rules. */
    export type waf$managed$rules_mode_deny_traditional = "default" | "disable" | "simulate" | "block" | "challenge";
    /** The number of rules within the group that have been modified from their default configuration. */
    export type waf$managed$rules_modified_rules_count = number;
    /** The name of the rule group. */
    export type waf$managed$rules_name = string;
    /** The order in which the individual WAF rule is executed within its rule group. */
    export type waf$managed$rules_priority = string;
    export interface waf$managed$rules_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type waf$managed$rules_rule = Schemas.waf$managed$rules_anomaly_rule | Schemas.waf$managed$rules_traditional_deny_rule | Schemas.waf$managed$rules_traditional_allow_rule;
    /** The unique identifier of the WAF rule. */
    export type waf$managed$rules_rule_components$schemas$identifier = string;
    export type waf$managed$rules_rule_group_response_collection = Schemas.waf$managed$rules_api$response$collection & {
        result?: Schemas.waf$managed$rules_schemas$group[];
    };
    export type waf$managed$rules_rule_group_response_single = Schemas.waf$managed$rules_api$response$single & {
        result?: {};
    };
    export type waf$managed$rules_rule_response_collection = Schemas.waf$managed$rules_api$response$collection & {
        result?: Schemas.waf$managed$rules_rule[];
    };
    export type waf$managed$rules_rule_response_single = Schemas.waf$managed$rules_api$response$single & {
        result?: {};
    };
    /** The number of rules in the current rule group. */
    export type waf$managed$rules_rules_count = number;
    export type waf$managed$rules_schemas$base = Schemas.waf$managed$rules_base;
    /** The public description of the WAF rule. */
    export type waf$managed$rules_schemas$description = string;
    export type waf$managed$rules_schemas$group = Schemas.waf$managed$rules_group & {
        allowed_modes?: Schemas.waf$managed$rules_allowed_modes;
        mode?: Schemas.waf$managed$rules_mode;
    };
    /** Identifier */
    export type waf$managed$rules_schemas$identifier = string;
    export type waf$managed$rules_traditional_allow_rule = Schemas.waf$managed$rules_base & {
        allowed_modes?: Schemas.waf$managed$rules_allowed_modes_allow_traditional;
        mode?: Schemas.waf$managed$rules_mode_allow_traditional;
    };
    export type waf$managed$rules_traditional_deny_rule = Schemas.waf$managed$rules_base & {
        allowed_modes?: Schemas.waf$managed$rules_allowed_modes_deny_traditional;
        default_mode?: Schemas.waf$managed$rules_default_mode;
        mode?: Schemas.waf$managed$rules_mode_deny_traditional;
    };
    /** Only available for the Waiting Room Advanced subscription. Additional hostname and path combinations to which this waiting room will be applied. There is an implied wildcard at the end of the path. The hostname and path combination must be unique to this and all other waiting rooms.  */
    export type waitingroom_additional_routes = {
        /** The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://). */
        host?: string;
        /** Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported. */
        path?: string;
    }[];
    export type waitingroom_api$response$collection = Schemas.waitingroom_schemas$api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.waitingroom_result_info;
    };
    export interface waitingroom_api$response$common {
    }
    export interface waitingroom_api$response$common$failure {
        errors: Schemas.waitingroom_messages;
        messages: Schemas.waitingroom_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type waitingroom_api$response$single = Schemas.waitingroom_api$response$common & {
        result?: {} | string;
    };
    /** Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position. */
    export interface waitingroom_cookie_attributes {
        /** Configures the SameSite attribute on the waiting room cookie. Value \`auto\` will be translated to \`lax\` or \`none\` depending if **Always Use HTTPS** is enabled. Note that when using value \`none\`, the secure attribute cannot be set to \`never\`. */
        samesite?: "auto" | "lax" | "none" | "strict";
        /** Configures the Secure attribute on the waiting room cookie. Value \`always\` indicates that the Secure attribute will be set in the Set-Cookie header, \`never\` indicates that the Secure attribute will not be set, and \`auto\` will set the Secure attribute depending if **Always Use HTTPS** is enabled. */
        secure?: "auto" | "always" | "never";
    }
    /** Appends a '_' + a custom suffix to the end of Cloudflare Waiting Room's cookie name(__cf_waitingroom). If \`cookie_suffix\` is "abcd", the cookie name will be \`__cf_waitingroom_abcd\`. This field is required if using \`additional_routes\`. */
    export type waitingroom_cookie_suffix = string;
    export interface waitingroom_create_rule {
        action: Schemas.waitingroom_rule_action;
        description?: Schemas.waitingroom_rule_description;
        enabled?: Schemas.waitingroom_rule_enabled;
        expression: Schemas.waitingroom_rule_expression;
    }
    /**
     * Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom_page_html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:
     * 1. {{\`waitTimeKnown\`}} Acts like a boolean value that indicates the behavior to take when wait time is not available, for instance when queue_all is **true**.
     * 2. {{\`waitTimeFormatted\`}} Estimated wait time for the user. For example, five minutes. Alternatively, you can use:
     * 3. {{\`waitTime\`}} Number of minutes of estimated wait for a user.
     * 4. {{\`waitTimeHours\`}} Number of hours of estimated wait for a user (\`Math.floor(waitTime/60)\`).
     * 5. {{\`waitTimeHourMinutes\`}} Number of minutes above the \`waitTimeHours\` value (\`waitTime%60\`).
     * 6. {{\`queueIsFull\`}} Changes to **true** when no more people can be added to the queue.
     *
     * To view the full list of variables, look at the \`cfWaitingRoom\` object described under the \`json_response_enabled\` property in other Waiting Room API calls.
     */
    export type waitingroom_custom_page_html = string;
    /** The language of the default page template. If no default_template_language is provided, then \`en-US\` (English) will be used. */
    export type waitingroom_default_template_language = "en-US" | "es-ES" | "de-DE" | "fr-FR" | "it-IT" | "ja-JP" | "ko-KR" | "pt-BR" | "zh-CN" | "zh-TW" | "nl-NL" | "pl-PL" | "id-ID" | "tr-TR" | "ar-EG" | "ru-RU" | "fa-IR";
    /** A note that you can use to add more details about the waiting room. */
    export type waitingroom_description = string;
    /** Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If \`true\`, an accepted user will have session_duration minutes to browse the site. After that, they will have to go through the waiting room again. If \`false\`, a user's session cookie will be automatically renewed on every request. */
    export type waitingroom_disable_session_renewal = boolean;
    export type waitingroom_estimated_queued_users = number;
    export type waitingroom_estimated_total_active_users = number;
    /** If set, the event will override the waiting room's \`custom_page_html\` property while it is active. If null, the event will inherit it. */
    export type waitingroom_event_custom_page_html = string | null;
    /** A note that you can use to add more details about the event. */
    export type waitingroom_event_description = string;
    export type waitingroom_event_details_custom_page_html = string;
    export type waitingroom_event_details_disable_session_renewal = boolean;
    export type waitingroom_event_details_new_users_per_minute = number;
    export type waitingroom_event_details_queueing_method = string;
    export type waitingroom_event_details_response = Schemas.waitingroom_api$response$single & {
        result?: Schemas.waitingroom_event_details_result;
    };
    export interface waitingroom_event_details_result {
        created_on?: Schemas.waitingroom_timestamp;
        custom_page_html?: Schemas.waitingroom_event_details_custom_page_html;
        description?: Schemas.waitingroom_event_description;
        disable_session_renewal?: Schemas.waitingroom_event_details_disable_session_renewal;
        event_end_time?: Schemas.waitingroom_event_end_time;
        event_start_time?: Schemas.waitingroom_event_start_time;
        id?: Schemas.waitingroom_event_id;
        modified_on?: Schemas.waitingroom_timestamp;
        name?: Schemas.waitingroom_event_name;
        new_users_per_minute?: Schemas.waitingroom_event_details_new_users_per_minute;
        prequeue_start_time?: Schemas.waitingroom_event_prequeue_start_time;
        queueing_method?: Schemas.waitingroom_event_details_queueing_method;
        session_duration?: Schemas.waitingroom_event_details_session_duration;
        shuffle_at_event_start?: Schemas.waitingroom_event_shuffle_at_event_start;
        suspended?: Schemas.waitingroom_event_suspended;
        total_active_users?: Schemas.waitingroom_event_details_total_active_users;
    }
    export type waitingroom_event_details_session_duration = number;
    export type waitingroom_event_details_total_active_users = number;
    /** If set, the event will override the waiting room's \`disable_session_renewal\` property while it is active. If null, the event will inherit it. */
    export type waitingroom_event_disable_session_renewal = boolean | null;
    /** An ISO 8601 timestamp that marks the end of the event. */
    export type waitingroom_event_end_time = string;
    export type waitingroom_event_id = any;
    export type waitingroom_event_id_response = Schemas.waitingroom_api$response$single & {
        result?: {
            id?: Schemas.waitingroom_event_id;
        };
    };
    /** A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed. */
    export type waitingroom_event_name = string;
    /** If set, the event will override the waiting room's \`new_users_per_minute\` property while it is active. If null, the event will inherit it. This can only be set if the event's \`total_active_users\` property is also set. */
    export type waitingroom_event_new_users_per_minute = number | null;
    /** An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before \`event_start_time\`. */
    export type waitingroom_event_prequeue_start_time = string | null;
    /** If set, the event will override the waiting room's \`queueing_method\` property while it is active. If null, the event will inherit it. */
    export type waitingroom_event_queueing_method = string | null;
    export type waitingroom_event_response = Schemas.waitingroom_api$response$single & {
        result?: Schemas.waitingroom_event_result;
    };
    export type waitingroom_event_response_collection = Schemas.waitingroom_api$response$collection & {
        result?: Schemas.waitingroom_event_result[];
    };
    export interface waitingroom_event_result {
        created_on?: Schemas.waitingroom_timestamp;
        custom_page_html?: Schemas.waitingroom_event_custom_page_html;
        description?: Schemas.waitingroom_event_description;
        disable_session_renewal?: Schemas.waitingroom_event_disable_session_renewal;
        event_end_time?: Schemas.waitingroom_event_end_time;
        event_start_time?: Schemas.waitingroom_event_start_time;
        id?: Schemas.waitingroom_event_id;
        modified_on?: Schemas.waitingroom_timestamp;
        name?: Schemas.waitingroom_event_name;
        new_users_per_minute?: Schemas.waitingroom_event_new_users_per_minute;
        prequeue_start_time?: Schemas.waitingroom_event_prequeue_start_time;
        queueing_method?: Schemas.waitingroom_event_queueing_method;
        session_duration?: Schemas.waitingroom_event_session_duration;
        shuffle_at_event_start?: Schemas.waitingroom_event_shuffle_at_event_start;
        suspended?: Schemas.waitingroom_event_suspended;
        total_active_users?: Schemas.waitingroom_event_total_active_users;
    }
    /** If set, the event will override the waiting room's \`session_duration\` property while it is active. If null, the event will inherit it. */
    export type waitingroom_event_session_duration = number | null;
    /** If enabled, users in the prequeue will be shuffled randomly at the \`event_start_time\`. Requires that \`prequeue_start_time\` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the \`queueing_method\` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary. */
    export type waitingroom_event_shuffle_at_event_start = boolean;
    /** An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before \`event_end_time\`. */
    export type waitingroom_event_start_time = string;
    /** Suspends or allows an event. If set to \`true\`, the event is ignored and traffic will be handled based on the waiting room configuration. */
    export type waitingroom_event_suspended = boolean;
    /** If set, the event will override the waiting room's \`total_active_users\` property while it is active. If null, the event will inherit it. This can only be set if the event's \`new_users_per_minute\` property is also set. */
    export type waitingroom_event_total_active_users = number | null;
    /** The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique. */
    export type waitingroom_host = string;
    /** Identifier */
    export type waitingroom_identifier = string;
    /**
     * Only available for the Waiting Room Advanced subscription. If \`true\`, requests to the waiting room with the header \`Accept: application/json\` will receive a JSON response object with information on the user's status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property \`cfWaitingRoom\` which is an object containing the following fields:
     * 1. \`inWaitingRoom\`: Boolean indicating if the user is in the waiting room (always **true**).
     * 2. \`waitTimeKnown\`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.
     * 3. \`waitTime\`: Valid only when \`waitTimeKnown\` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When \`queueingMethod\` is **random**, this is set to \`waitTime50Percentile\`.
     * 4. \`waitTime25Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).
     * 5. \`waitTime50Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before \`waitTime50Percentile\` and half are expected to be let in after it.
     * 6. \`waitTime75Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).
     * 7. \`waitTimeFormatted\`: String displaying the \`waitTime\` formatted in English for users. If \`waitTimeKnown\` is **false**, \`waitTimeFormatted\` will display **unavailable**.
     * 8. \`queueIsFull\`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.
     * 9. \`queueAll\`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.
     * 10. \`lastUpdated\`: String displaying the timestamp as an ISO 8601 string of the user's last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after \`refreshIntervalSeconds\` past this time. If the user makes a request too soon, it will be ignored and \`lastUpdated\` will not change.
     * 11. \`refreshIntervalSeconds\`: Integer indicating the number of seconds after \`lastUpdated\` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the \`queueingMethod\` is \`reject\`, there is no specified refresh time â€” it will always be **zero**.
     * 12. \`queueingMethod\`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.
     * 13. \`isFIFOQueue\`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.
     * 14. \`isRandomQueue\`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.
     * 15. \`isPassthroughQueue\`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when \`queueAll\` is **true** or \`isEventPrequeueing\` is **true** because in all other cases requests will go directly to the origin.
     * 16. \`isRejectQueue\`: Boolean indicating if the waiting room uses a reject queue.
     * 17. \`isEventActive\`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room's behavior during a specified period of time. For additional information, look at the event properties \`prequeue_start_time\`, \`event_start_time\`, and \`event_end_time\` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.
     * 18. \`isEventPrequeueing\`: Valid only when \`isEventActive\` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.
     * 19. \`timeUntilEventStart\`: Valid only when \`isEventPrequeueing\` is **true**. Integer indicating the number of minutes until the event starts.
     * 20. \`timeUntilEventStartFormatted\`: String displaying the \`timeUntilEventStart\` formatted in English for users. If \`isEventPrequeueing\` is **false**, \`timeUntilEventStartFormatted\` will display **unavailable**.
     * 21. \`timeUntilEventEnd\`: Valid only when \`isEventActive\` is **true**. Integer indicating the number of minutes until the event ends.
     * 22. \`timeUntilEventEndFormatted\`: String displaying the \`timeUntilEventEnd\` formatted in English for users. If \`isEventActive\` is **false**, \`timeUntilEventEndFormatted\` will display **unavailable**.
     * 23. \`shuffleAtEventStart\`: Valid only when \`isEventActive\` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.
     *
     * An example cURL to a waiting room could be:
     *
     * 	curl -X GET "https://example.com/waitingroom" \\
     * 		-H "Accept: application/json"
     *
     * If \`json_response_enabled\` is **true** and the request hits the waiting room, an example JSON response when \`queueingMethod\` is **fifo** and no event is active could be:
     *
     * 	{
     * 		"cfWaitingRoom": {
     * 			"inWaitingRoom": true,
     * 			"waitTimeKnown": true,
     * 			"waitTime": 10,
     * 			"waitTime25Percentile": 0,
     * 			"waitTime50Percentile": 0,
     * 			"waitTime75Percentile": 0,
     * 			"waitTimeFormatted": "10 minutes",
     * 			"queueIsFull": false,
     * 			"queueAll": false,
     * 			"lastUpdated": "2020-08-03T23:46:00.000Z",
     * 			"refreshIntervalSeconds": 20,
     * 			"queueingMethod": "fifo",
     * 			"isFIFOQueue": true,
     * 			"isRandomQueue": false,
     * 			"isPassthroughQueue": false,
     * 			"isRejectQueue": false,
     * 			"isEventActive": false,
     * 			"isEventPrequeueing": false,
     * 			"timeUntilEventStart": 0,
     * 			"timeUntilEventStartFormatted": "unavailable",
     * 			"timeUntilEventEnd": 0,
     * 			"timeUntilEventEndFormatted": "unavailable",
     * 			"shuffleAtEventStart": false
     * 		}
     * 	}
     *
     * If \`json_response_enabled\` is **true** and the request hits the waiting room, an example JSON response when \`queueingMethod\` is **random** and an event is active could be:
     *
     * 	{
     * 		"cfWaitingRoom": {
     * 			"inWaitingRoom": true,
     * 			"waitTimeKnown": true,
     * 			"waitTime": 10,
     * 			"waitTime25Percentile": 5,
     * 			"waitTime50Percentile": 10,
     * 			"waitTime75Percentile": 15,
     * 			"waitTimeFormatted": "5 minutes to 15 minutes",
     * 			"queueIsFull": false,
     * 			"queueAll": false,
     * 			"lastUpdated": "2020-08-03T23:46:00.000Z",
     * 			"refreshIntervalSeconds": 20,
     * 			"queueingMethod": "random",
     * 			"isFIFOQueue": false,
     * 			"isRandomQueue": true,
     * 			"isPassthroughQueue": false,
     * 			"isRejectQueue": false,
     * 			"isEventActive": true,
     * 			"isEventPrequeueing": false,
     * 			"timeUntilEventStart": 0,
     * 			"timeUntilEventStartFormatted": "unavailable",
     * 			"timeUntilEventEnd": 15,
     * 			"timeUntilEventEndFormatted": "15 minutes",
     * 			"shuffleAtEventStart": true
     * 		}
     * 	}.
     */
    export type waitingroom_json_response_enabled = boolean;
    export type waitingroom_max_estimated_time_minutes = number;
    export type waitingroom_messages = {
        code: number;
        message: string;
    }[];
    /** A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed. */
    export type waitingroom_name = string;
    /** Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world. */
    export type waitingroom_new_users_per_minute = number;
    /** An ISO 8601 timestamp that marks when the next event will begin queueing. */
    export type waitingroom_next_event_prequeue_start_time = string | null;
    /** An ISO 8601 timestamp that marks when the next event will start. */
    export type waitingroom_next_event_start_time = string | null;
    export interface waitingroom_patch_rule {
        action: Schemas.waitingroom_rule_action;
        description?: Schemas.waitingroom_rule_description;
        enabled?: Schemas.waitingroom_rule_enabled;
        expression: Schemas.waitingroom_rule_expression;
        position?: Schemas.waitingroom_rule_position;
    }
    /** Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported. */
    export type waitingroom_path = string;
    export type waitingroom_preview_response = Schemas.waitingroom_api$response$single & {
        result?: {
            preview_url?: Schemas.waitingroom_preview_url;
        };
    };
    /** URL where the custom waiting room page can temporarily be previewed. */
    export type waitingroom_preview_url = string;
    export interface waitingroom_query_event {
        custom_page_html?: Schemas.waitingroom_event_custom_page_html;
        description?: Schemas.waitingroom_event_description;
        disable_session_renewal?: Schemas.waitingroom_event_disable_session_renewal;
        event_end_time: Schemas.waitingroom_event_end_time;
        event_start_time: Schemas.waitingroom_event_start_time;
        name: Schemas.waitingroom_event_name;
        new_users_per_minute?: Schemas.waitingroom_event_new_users_per_minute;
        prequeue_start_time?: Schemas.waitingroom_event_prequeue_start_time;
        queueing_method?: Schemas.waitingroom_event_queueing_method;
        session_duration?: Schemas.waitingroom_event_session_duration;
        shuffle_at_event_start?: Schemas.waitingroom_event_shuffle_at_event_start;
        suspended?: Schemas.waitingroom_event_suspended;
        total_active_users?: Schemas.waitingroom_event_total_active_users;
    }
    export interface waitingroom_query_preview {
        custom_html: Schemas.waitingroom_custom_page_html;
    }
    export interface waitingroom_query_waitingroom {
        additional_routes?: Schemas.waitingroom_additional_routes;
        cookie_attributes?: Schemas.waitingroom_cookie_attributes;
        cookie_suffix?: Schemas.waitingroom_cookie_suffix;
        custom_page_html?: Schemas.waitingroom_custom_page_html;
        default_template_language?: Schemas.waitingroom_default_template_language;
        description?: Schemas.waitingroom_description;
        disable_session_renewal?: Schemas.waitingroom_disable_session_renewal;
        host: Schemas.waitingroom_host;
        json_response_enabled?: Schemas.waitingroom_json_response_enabled;
        name: Schemas.waitingroom_name;
        new_users_per_minute: Schemas.waitingroom_new_users_per_minute;
        path?: Schemas.waitingroom_path;
        queue_all?: Schemas.waitingroom_queue_all;
        queueing_method?: Schemas.waitingroom_queueing_method;
        queueing_status_code?: Schemas.waitingroom_queueing_status_code;
        session_duration?: Schemas.waitingroom_session_duration;
        suspended?: Schemas.waitingroom_suspended;
        total_active_users: Schemas.waitingroom_total_active_users;
    }
    /** If queue_all is \`true\`, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable. */
    export type waitingroom_queue_all = boolean;
    /**
     * Sets the queueing method used by the waiting room. Changing this parameter from the **default** queueing method is only available for the Waiting Room Advanced subscription. Regardless of the queueing method, if \`queue_all\` is enabled or an event is prequeueing, users in the waiting room will not be accepted to the origin. These users will always see a waiting room page that refreshes automatically. The valid queueing methods are:
     * 1. \`fifo\` **(default)**: First-In-First-Out queue where customers gain access in the order they arrived.
     * 2. \`random\`: Random queue where customers gain access randomly, regardless of arrival time.
     * 3. \`passthrough\`: Users will pass directly through the waiting room and into the origin website. As a result, any configured limits will not be respected while this is enabled. This method can be used as an alternative to disabling a waiting room (with \`suspended\`) so that analytics are still reported. This can be used if you wish to allow all traffic normally, but want to restrict traffic during a waiting room event, or vice versa.
     * 4. \`reject\`: Users will be immediately rejected from the waiting room. As a result, no users will reach the origin website while this is enabled. This can be used if you wish to reject all traffic while performing maintenance, block traffic during a specified period of time (an event), or block traffic while events are not occurring. Consider a waiting room used for vaccine distribution that only allows traffic during sign-up events, and otherwise blocks all traffic. For this case, the waiting room uses \`reject\`, and its events override this with \`fifo\`, \`random\`, or \`passthrough\`. When this queueing method is enabled and neither \`queueAll\` is enabled nor an event is prequeueing, the waiting room page **will not refresh automatically**.
     */
    export type waitingroom_queueing_method = "fifo" | "random" | "passthrough" | "reject";
    /** HTTP status code returned to a user while in the queue. */
    export type waitingroom_queueing_status_code = 200 | 202 | 429;
    export type waitingroom_response_collection = Schemas.waitingroom_api$response$collection & {
        result?: Schemas.waitingroom_waitingroom[];
    };
    export interface waitingroom_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** The action to take when the expression matches. */
    export type waitingroom_rule_action = "bypass_waiting_room";
    /** The description of the rule. */
    export type waitingroom_rule_description = string;
    /** When set to true, the rule is enabled. */
    export type waitingroom_rule_enabled = boolean;
    /** Criteria defining when there is a match for the current rule. */
    export type waitingroom_rule_expression = string;
    /** The ID of the rule. */
    export type waitingroom_rule_id = string;
    export type waitingroom_rule_position = {
        /**  Places the rule in the exact position specified by the integer number <POSITION_NUMBER>. Position numbers start with 1. Existing rules in the ruleset from the specified position number onward are shifted one position (no rule is overwritten). */
        index?: number;
    } | {
        /**  Places the rule before rule <RULE_ID>. Use this argument with an empty rule ID value ("") to set the rule as the first rule in the ruleset. */
        before?: string;
    } | {
        /** Places the rule after rule <RULE_ID>. Use this argument with an empty rule ID value ("") to set the rule as the last rule in the ruleset. */
        after?: string;
    };
    export interface waitingroom_rule_result {
        action?: Schemas.waitingroom_rule_action;
        description?: Schemas.waitingroom_rule_description;
        enabled?: Schemas.waitingroom_rule_enabled;
        expression?: Schemas.waitingroom_rule_expression;
        id?: Schemas.waitingroom_rule_id;
        last_updated?: Schemas.waitingroom_timestamp;
        version?: Schemas.waitingroom_rule_version;
    }
    /** The version of the rule. */
    export type waitingroom_rule_version = string;
    export type waitingroom_rules_response_collection = Schemas.waitingroom_api$response$collection & {
        result?: Schemas.waitingroom_rule_result[];
    };
    export interface waitingroom_schemas$api$response$common {
        errors: Schemas.waitingroom_messages;
        messages: Schemas.waitingroom_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    /**
     * Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone.
     * Verified search engine crawlers will not be tracked or counted by the waiting room system,
     * and will not appear in waiting room analytics.
     */
    export type waitingroom_search_engine_crawler_bypass = boolean;
    /** Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route. */
    export type waitingroom_session_duration = number;
    export type waitingroom_single_response = Schemas.waitingroom_api$response$single & {
        result?: Schemas.waitingroom_waitingroom;
    };
    export type waitingroom_status = "event_prequeueing" | "not_queueing" | "queueing";
    export type waitingroom_status_event_id = string;
    export type waitingroom_status_response = Schemas.waitingroom_api$response$single & {
        result?: {
            estimated_queued_users?: Schemas.waitingroom_estimated_queued_users;
            estimated_total_active_users?: Schemas.waitingroom_estimated_total_active_users;
            event_id?: Schemas.waitingroom_status_event_id;
            max_estimated_time_minutes?: Schemas.waitingroom_max_estimated_time_minutes;
            status?: Schemas.waitingroom_status;
        };
    };
    /** Suspends or allows traffic going to the waiting room. If set to \`true\`, the traffic will not go to the waiting room. */
    export type waitingroom_suspended = boolean;
    export type waitingroom_timestamp = Date;
    /** Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world. */
    export type waitingroom_total_active_users = number;
    export type waitingroom_update_rules = Schemas.waitingroom_create_rule[];
    export type waitingroom_waiting_room_id = any;
    export type waitingroom_waiting_room_id_response = Schemas.waitingroom_api$response$single & {
        result?: {
            id?: Schemas.waitingroom_waiting_room_id;
        };
    };
    export interface waitingroom_waitingroom {
        additional_routes?: Schemas.waitingroom_additional_routes;
        cookie_attributes?: Schemas.waitingroom_cookie_attributes;
        cookie_suffix?: Schemas.waitingroom_cookie_suffix;
        created_on?: Schemas.waitingroom_timestamp;
        custom_page_html?: Schemas.waitingroom_custom_page_html;
        default_template_language?: Schemas.waitingroom_default_template_language;
        description?: Schemas.waitingroom_description;
        disable_session_renewal?: Schemas.waitingroom_disable_session_renewal;
        host?: Schemas.waitingroom_host;
        id?: Schemas.waitingroom_waiting_room_id;
        json_response_enabled?: Schemas.waitingroom_json_response_enabled;
        modified_on?: Schemas.waitingroom_timestamp;
        name?: Schemas.waitingroom_name;
        new_users_per_minute?: Schemas.waitingroom_new_users_per_minute;
        next_event_prequeue_start_time?: Schemas.waitingroom_next_event_prequeue_start_time;
        next_event_start_time?: Schemas.waitingroom_next_event_start_time;
        path?: Schemas.waitingroom_path;
        queue_all?: Schemas.waitingroom_queue_all;
        queueing_method?: Schemas.waitingroom_queueing_method;
        queueing_status_code?: Schemas.waitingroom_queueing_status_code;
        session_duration?: Schemas.waitingroom_session_duration;
        suspended?: Schemas.waitingroom_suspended;
        total_active_users?: Schemas.waitingroom_total_active_users;
    }
    export interface waitingroom_zone_settings {
        search_engine_crawler_bypass?: Schemas.waitingroom_search_engine_crawler_bypass;
    }
    export type waitingroom_zone_settings_response = Schemas.waitingroom_api$response$single & {
        result: {
            search_engine_crawler_bypass: Schemas.waitingroom_search_engine_crawler_bypass;
        };
    };
    export type workers$kv_api$response$collection = Schemas.workers$kv_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.workers$kv_result_info;
    };
    export interface workers$kv_api$response$common {
        errors: Schemas.workers$kv_messages;
        messages: Schemas.workers$kv_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface workers$kv_api$response$common$failure {
        errors: Schemas.workers$kv_messages;
        messages: Schemas.workers$kv_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type workers$kv_api$response$single = Schemas.workers$kv_api$response$common & {
        result?: {} | string;
    };
    export type workers$kv_bulk_delete = Schemas.workers$kv_key_name_bulk[];
    export type workers$kv_bulk_write = {
        /** Whether or not the server should base64 decode the value before storing it. Useful for writing values that wouldn't otherwise be valid JSON strings, such as images. */
        base64?: boolean;
        expiration?: Schemas.workers$kv_expiration;
        expiration_ttl?: Schemas.workers$kv_expiration_ttl;
        key?: Schemas.workers$kv_key_name_bulk;
        metadata?: Schemas.workers$kv_list_metadata;
        /** A UTF-8 encoded string to be stored, up to 25 MiB in length. */
        value?: string;
    }[];
    export type workers$kv_components$schemas$result = Schemas.workers$kv_result & {
        data?: any;
        max?: any;
        min?: any;
        query?: Schemas.workers$kv_query;
        totals?: any;
    };
    export interface workers$kv_create_rename_namespace_body {
        title: Schemas.workers$kv_namespace_title;
    }
    /** Opaque token indicating the position from which to continue when requesting the next set of records if the amount of list results was limited by the limit parameter. A valid value for the cursor can be obtained from the cursors object in the result_info structure. */
    export type workers$kv_cursor = string;
    /** The time, measured in number of seconds since the UNIX epoch, at which the key should expire. */
    export type workers$kv_expiration = number;
    /** The number of seconds for which the key should be visible before it expires. At least 60. */
    export type workers$kv_expiration_ttl = number;
    /** Identifier */
    export type workers$kv_identifier = string;
    /** A name for a value. A value stored under a given key may be retrieved via the same key. */
    export interface workers$kv_key {
        /** The time, measured in number of seconds since the UNIX epoch, at which the key will expire. This property is omitted for keys that will not expire. */
        expiration?: number;
        metadata?: Schemas.workers$kv_list_metadata;
        name: Schemas.workers$kv_key_name;
    }
    /** A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL. */
    export type workers$kv_key_name = string;
    /** A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. */
    export type workers$kv_key_name_bulk = string;
    /** Arbitrary JSON that is associated with a key. */
    export interface workers$kv_list_metadata {
    }
    export type workers$kv_messages = {
        code: number;
        message: string;
    }[];
    /** Arbitrary JSON to be associated with a key/value pair. */
    export type workers$kv_metadata = string;
    export interface workers$kv_namespace {
        id: Schemas.workers$kv_namespace_identifier;
        /** True if keys written on the URL will be URL-decoded before storing. For example, if set to "true", a key written on the URL as "%3F" will be stored as "?". */
        readonly supports_url_encoding?: boolean;
        title: Schemas.workers$kv_namespace_title;
    }
    /** Namespace identifier tag. */
    export type workers$kv_namespace_identifier = string;
    /** A human-readable string name for a Namespace. */
    export type workers$kv_namespace_title = string;
    /** For specifying result metrics. */
    export interface workers$kv_query {
        /** Can be used to break down the data by given attributes. */
        dimensions?: string[];
        /**
         * Used to filter rows by one or more dimensions. Filters can be combined using OR and AND boolean logic. AND takes precedence over OR in all the expressions. The OR operator is defined using a comma (,) or OR keyword surrounded by whitespace. The AND operator is defined using a semicolon (;) or AND keyword surrounded by whitespace. Note that the semicolon is a reserved character in URLs (rfc1738) and needs to be percent-encoded as %3B. Comparison options are:
         *
         * Operator                  | Name                            | URL Encoded
         * --------------------------|---------------------------------|--------------------------
         * ==                        | Equals                          | %3D%3D
         * !=                        | Does not equals                 | !%3D
         * >                        | Greater Than                    | %3E
         * <                         | Less Than                       | %3C
         * >=                       | Greater than or equal to        | %3E%3D
         * <=                        | Less than or equal to           | %3C%3D     .
         */
        filters?: string;
        /** Limit number of returned metrics. */
        limit?: number;
        /** One or more metrics to compute. */
        metrics?: string[];
        /** Start of time interval to query, defaults to 6 hours before request received. */
        since?: Date;
        /** Array of dimensions or metrics to sort by, each dimension/metric may be prefixed by - (descending) or + (ascending). */
        sort?: {}[];
        /** End of time interval to query, defaults to current time. */
        until?: Date;
    }
    /** Metrics on Workers KV requests. */
    export interface workers$kv_result {
        data: {
            /** List of metrics returned by the query. */
            metrics: {}[];
        }[] | null;
        /** Number of seconds between current time and last processed event, i.e. how many seconds of data could be missing. */
        data_lag: number;
        /** Maximum results for each metric. */
        max: any;
        /** Minimum results for each metric. */
        min: any;
        query: Schemas.workers$kv_query;
        /** Total number of rows in the result. */
        rows: number;
        /** Total results for metrics across all data. */
        totals: any;
    }
    export interface workers$kv_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type workers$kv_schemas$result = Schemas.workers$kv_result & {
        data?: any;
        max?: any;
        min?: any;
        query?: Schemas.workers$kv_query;
        totals?: any;
    };
    /** A byte sequence to be stored, up to 25 MiB in length. */
    export type workers$kv_value = string;
    export type workers_account$settings$response = Schemas.workers_api$response$common & {
        result?: {
            readonly default_usage_model?: any;
            readonly green_compute?: any;
        };
    };
    export type workers_account_identifier = any;
    export type workers_api$response$collection = Schemas.workers_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.workers_result_info;
    };
    export interface workers_api$response$common {
        errors: Schemas.workers_messages;
        messages: Schemas.workers_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface workers_api$response$common$failure {
        errors: Schemas.workers_messages;
        messages: Schemas.workers_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type workers_api$response$single = Schemas.workers_api$response$common & {
        result?: {} | string;
    };
    export type workers_api$response$single$id = Schemas.workers_api$response$common & {
        result?: {
            id: Schemas.workers_identifier;
        } | null;
    };
    export type workers_batch_size = number;
    export type workers_binding = Schemas.workers_kv_namespace_binding | Schemas.workers_service_binding | Schemas.workers_do_binding | Schemas.workers_r2_binding | Schemas.workers_queue_binding | Schemas.workers_d1_binding | Schemas.workers_dispatch_namespace_binding | Schemas.workers_mtls_cert_binding;
    /** A JavaScript variable name for the binding. */
    export type workers_binding_name = string;
    /** List of bindings attached to this Worker */
    export type workers_bindings = Schemas.workers_binding[];
    /** Opt your Worker into changes after this date */
    export type workers_compatibility_date = string;
    /** A flag to opt into a specific change */
    export type workers_compatibility_flag = string;
    /** Opt your Worker into specific changes */
    export type workers_compatibility_flags = Schemas.workers_compatibility_flag[];
    export interface workers_consumer {
        readonly created_on?: any;
        readonly environment?: any;
        readonly queue_name?: any;
        readonly service?: any;
        settings?: {
            batch_size?: Schemas.workers_batch_size;
            max_retries?: Schemas.workers_max_retries;
            max_wait_time_ms?: Schemas.workers_max_wait_time_ms;
        };
    }
    export interface workers_consumer_created {
        readonly created_on?: any;
        dead_letter_queue?: Schemas.workers_dlq_name;
        readonly environment?: any;
        readonly queue_name?: any;
        readonly script_name?: any;
        settings?: {
            batch_size?: Schemas.workers_batch_size;
            max_retries?: Schemas.workers_max_retries;
            max_wait_time_ms?: Schemas.workers_max_wait_time_ms;
        };
    }
    export type workers_consumer_name = string;
    export interface workers_consumer_updated {
        readonly created_on?: any;
        dead_letter_queue?: any;
        readonly environment?: any;
        readonly queue_name?: any;
        readonly script_name?: any;
        settings?: {
            batch_size?: number;
            max_retries?: Schemas.workers_max_retries;
            max_wait_time_ms?: Schemas.workers_max_wait_time_ms;
        };
    }
    /** When the script was created. */
    export type workers_created_on = Date;
    export type workers_cron$trigger$response$collection = Schemas.workers_api$response$common & {
        result?: {
            schedules?: {
                readonly created_on?: any;
                readonly cron?: any;
                readonly modified_on?: any;
            }[];
        };
    };
    /** Opaque token indicating the position from which to continue when requesting the next set of records. A valid value for the cursor can be obtained from the cursors object in the result_info structure. */
    export type workers_cursor = string;
    export interface workers_d1_binding {
        binding: Schemas.workers_binding_name;
        /** ID of the D1 database to bind to */
        id: string;
        /** The name of the D1 database associated with the 'id' provided. */
        name: string;
        /** The class of resource that the binding provides. */
        type: "d1";
    }
    export type workers_deployment_identifier = string;
    export type workers_deployments$list$response = Schemas.workers_api$response$common & {
        result?: {
            items?: {}[];
            latest?: {};
        };
    };
    export type workers_deployments$single$response = Schemas.workers_api$response$common & {
        result?: {
            id?: string;
            metadata?: {};
            number?: number;
            resources?: {};
        };
    };
    export interface workers_dispatch_namespace_binding {
        name: Schemas.workers_binding_name;
        /** Namespace to bind to */
        namespace: string;
        /** Outbound worker */
        outbound?: {
            /** Pass information from the Dispatch Worker to the Outbound Worker through the parameters */
            params?: string[];
            /** Outbound worker */
            worker?: {
                /** Environment of the outbound worker */
                environment?: string;
                /** Name of the outbound worker */
                service?: string;
            };
        };
        /** The class of resource that the binding provides. */
        type: "dispatch_namespace";
    }
    /** Name of the Workers for Platforms dispatch namespace. */
    export type workers_dispatch_namespace_name = string;
    export type workers_dlq_name = string;
    export interface workers_do_binding {
        /** The exported class name of the Durable Object */
        class_name: string;
        /** The environment of the script_name to bind to */
        environment?: string;
        name: Schemas.workers_binding_name;
        namespace_id?: Schemas.workers_namespace_identifier;
        /** The script where the Durable Object is defined, if it is external to this Worker */
        script_name?: string;
        /** The class of resource that the binding provides. */
        type: "durable_object_namespace";
    }
    export interface workers_domain {
        environment?: Schemas.workers_schemas$environment;
        hostname?: Schemas.workers_hostname;
        id?: Schemas.workers_domain_identifier;
        service?: Schemas.workers_schemas$service;
        zone_id?: Schemas.workers_zone_identifier;
        zone_name?: Schemas.workers_zone_name;
    }
    export type workers_domain$response$collection = Schemas.workers_api$response$common & {
        result?: Schemas.workers_domain[];
    };
    export type workers_domain$response$single = Schemas.workers_api$response$common & {
        result?: Schemas.workers_domain;
    };
    /** Identifer of the Worker Domain. */
    export type workers_domain_identifier = any;
    /** Whether or not this filter will run a script */
    export type workers_enabled = boolean;
    /** Optional environment if the Worker utilizes one. */
    export type workers_environment = string;
    /** Hashed script content, can be used in a If-None-Match header when updating. */
    export type workers_etag = string;
    export interface workers_filter$no$id {
        enabled: Schemas.workers_enabled;
        pattern: Schemas.workers_schemas$pattern;
    }
    export type workers_filter$response$collection = Schemas.workers_api$response$common & {
        result?: Schemas.workers_filters[];
    };
    export type workers_filter$response$single = Schemas.workers_api$response$single & {
        result?: Schemas.workers_filters;
    };
    export interface workers_filters {
        enabled: Schemas.workers_enabled;
        id: Schemas.workers_identifier;
        pattern: Schemas.workers_schemas$pattern;
    }
    /** Hostname of the Worker Domain. */
    export type workers_hostname = string;
    /** Identifier for the tail. */
    export type workers_id = string;
    /** Identifier */
    export type workers_identifier = string;
    export interface workers_kv_namespace_binding {
        name: Schemas.workers_binding_name;
        namespace_id: Schemas.workers_namespace_identifier;
        /** The class of resource that the binding provides. */
        type: "kv_namespace";
    }
    /** Whether Logpush is turned on for the Worker. */
    export type workers_logpush = boolean;
    export type workers_max_retries = number;
    export type workers_max_wait_time_ms = number;
    export type workers_messages = {
        code: number;
        message: string;
    }[];
    export interface workers_migration_step {
        /** A list of classes to delete Durable Object namespaces from. */
        deleted_classes?: string[];
        /** A list of classes to create Durable Object namespaces from. */
        new_classes?: string[];
        /** A list of classes with Durable Object namespaces that were renamed. */
        renamed_classes?: {
            from?: string;
            to?: string;
        }[];
        /** A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker. */
        transferred_classes?: {
            from?: string;
            from_script?: string;
            to?: string;
        }[];
    }
    export interface workers_migration_tag_conditions {
        /** Tag to set as the latest migration tag. */
        new_tag?: string;
        /** Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected. */
        old_tag?: string;
    }
    /** When the script was last modified. */
    export type workers_modified_on = Date;
    export interface workers_mtls_cert_binding {
        /** ID of the certificate to bind to */
        certificate_id?: string;
        name: Schemas.workers_binding_name;
        /** The class of resource that the binding provides. */
        type: "mtls_certificate";
    }
    export type workers_name = string;
    export interface workers_namespace {
        readonly class?: any;
        readonly id?: any;
        readonly name?: any;
        readonly script?: any;
    }
    /** Details about a worker uploaded to a Workers for Platforms namespace. */
    export interface workers_namespace$script$response {
        created_on?: Schemas.workers_created_on;
        dispatch_namespace?: Schemas.workers_dispatch_namespace_name;
        modified_on?: Schemas.workers_modified_on;
        script?: Schemas.workers_script$response;
    }
    export type workers_namespace$script$response$single = Schemas.workers_api$response$common & {
        result?: Schemas.workers_namespace$script$response;
    };
    /** Namespace identifier tag. */
    export type workers_namespace_identifier = string;
    export interface workers_object {
        /** Whether the Durable Object has stored data. */
        readonly hasStoredData?: boolean;
        /** ID of the Durable Object. */
        readonly id?: string;
    }
    /** Route pattern */
    export type workers_pattern = string;
    /** Deprecated. Deployment metadata for internal usage. */
    export type workers_pipeline_hash = string;
    export interface workers_placement_config {
        /** Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement). Only \`"smart"\` is currently supported */
        mode?: "smart";
    }
    /** Specifies the placement mode for the Worker (e.g. 'smart'). */
    export type workers_placement_mode = string;
    export interface workers_queue {
        readonly consumers?: any;
        readonly consumers_total_count?: any;
        readonly created_on?: any;
        readonly modified_on?: any;
        readonly producers?: any;
        readonly producers_total_count?: any;
        readonly queue_id?: any;
        queue_name?: Schemas.workers_name;
    }
    export interface workers_queue_binding {
        name: Schemas.workers_binding_name;
        /** Name of the Queue to bind to */
        queue_name: string;
        /** The class of resource that the binding provides. */
        type: "queue";
    }
    export interface workers_queue_created {
        readonly created_on?: any;
        readonly modified_on?: any;
        readonly queue_id?: any;
        queue_name?: Schemas.workers_name;
    }
    export interface workers_queue_updated {
        readonly created_on?: any;
        readonly modified_on?: any;
        readonly queue_id?: any;
        queue_name?: Schemas.workers_renamed_name;
    }
    export interface workers_r2_binding {
        /** R2 bucket to bind to */
        bucket_name: string;
        name: Schemas.workers_binding_name;
        /** The class of resource that the binding provides. */
        type: "r2_bucket";
    }
    export type workers_renamed_name = string;
    export interface workers_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export interface workers_route$no$id {
        pattern: Schemas.workers_pattern;
        script?: Schemas.workers_script_name;
    }
    export type workers_route$response$collection = Schemas.workers_api$response$common & {
        result?: Schemas.workers_routes[];
    };
    export type workers_route$response$single = Schemas.workers_api$response$single & {
        result?: Schemas.workers_routes;
    };
    export interface workers_routes {
        id: Schemas.workers_identifier;
        pattern: Schemas.workers_pattern;
        script: Schemas.workers_script_name;
    }
    export type workers_schemas$binding = Schemas.workers_kv_namespace_binding | Schemas.workers_wasm_module_binding;
    /** Worker environment associated with the zone and hostname. */
    export type workers_schemas$environment = string;
    /** ID of the namespace. */
    export type workers_schemas$id = string;
    /** Filter pattern */
    export type workers_schemas$pattern = string;
    export type workers_schemas$script$response$single = Schemas.workers_api$response$single & {
        result?: {};
    };
    /** Worker service associated with the zone and hostname. */
    export type workers_schemas$service = string;
    export interface workers_script$response {
        created_on?: Schemas.workers_created_on;
        etag?: Schemas.workers_etag;
        /** The id of the script in the Workers system. Usually the script name. */
        readonly id?: string;
        logpush?: Schemas.workers_logpush;
        modified_on?: Schemas.workers_modified_on;
        pipeline_hash?: Schemas.workers_pipeline_hash;
        placement_mode?: Schemas.workers_placement_mode;
        tail_consumers?: Schemas.workers_tail_consumers;
        usage_model?: Schemas.workers_usage_model;
    }
    export type workers_script$response$collection = Schemas.workers_api$response$common & {
        result?: Schemas.workers_script$response[];
    };
    export type workers_script$response$single = Schemas.workers_api$response$single & {
        result?: Schemas.workers_script$response;
    };
    export type workers_script$settings$response = Schemas.workers_api$response$common & {
        result?: {
            bindings?: Schemas.workers_bindings;
            compatibility_date?: Schemas.workers_compatibility_date;
            compatibility_flags?: Schemas.workers_compatibility_flags;
            logpush?: Schemas.workers_logpush;
            /** Migrations to apply for Durable Objects associated with this Worker. */
            migrations?: Schemas.workers_single_step_migrations | Schemas.workers_stepped_migrations;
            placement?: Schemas.workers_placement_config;
            tags?: Schemas.workers_tags;
            tail_consumers?: Schemas.workers_tail_consumers;
            usage_model?: Schemas.workers_usage_model;
        };
    };
    export type workers_script_identifier = string;
    /** Name of the script, used in URLs and route configuration. */
    export type workers_script_name = string;
    /** Name of Worker to bind to */
    export type workers_service = string;
    export interface workers_service_binding {
        /** Optional environment if the Worker utilizes one. */
        environment: string;
        name: Schemas.workers_binding_name;
        /** Name of Worker to bind to */
        service: string;
        /** The class of resource that the binding provides. */
        type: "service";
    }
    export type workers_single_step_migrations = Schemas.workers_migration_tag_conditions & Schemas.workers_migration_step;
    export type workers_stepped_migrations = Schemas.workers_migration_tag_conditions & {
        /** Migrations to apply in order. */
        steps?: Schemas.workers_migration_step[];
    };
    export type workers_subdomain$response = Schemas.workers_api$response$common & {
        result?: {
            readonly name?: any;
        };
    };
    /** Tag to help you manage your Worker */
    export type workers_tag = string;
    /** Tags to help you manage your Workers */
    export type workers_tags = Schemas.workers_tag[];
    export type workers_tail$response = Schemas.workers_api$response$common & {
        result?: {
            readonly expires_at?: any;
            readonly id?: any;
            readonly url?: any;
        };
    };
    /** List of Workers that will consume logs from the attached Worker. */
    export type workers_tail_consumers = Schemas.workers_tail_consumers_script[];
    /** A reference to a script that will consume logs from the attached Worker. */
    export interface workers_tail_consumers_script {
        /** Optional environment if the Worker utilizes one. */
        environment?: string;
        /** Optional dispatch namespace the script belongs to. */
        namespace?: string;
        /** Name of Worker that is to be the consumer. */
        service: string;
    }
    export type workers_usage$model$response = Schemas.workers_api$response$common & {
        result?: {
            readonly usage_model?: any;
        };
    };
    /** Specifies the usage model for the Worker (e.g. 'bundled' or 'unbound'). */
    export type workers_usage_model = string;
    /** API Resource UUID tag. */
    export type workers_uuid = string;
    export interface workers_wasm_module_binding {
        name: Schemas.workers_binding_name;
        /** The class of resource that the binding provides. */
        type: "wasm_module";
    }
    /** Identifier of the zone. */
    export type workers_zone_identifier = any;
    /** Name of the zone. */
    export type workers_zone_name = string;
    export interface zaraz_api$response$common {
        errors: Schemas.zaraz_messages;
        messages: Schemas.zaraz_messages;
        /** Whether the API call was successful */
        success: boolean;
    }
    export interface zaraz_api$response$common$failure {
        errors: Schemas.zaraz_messages;
        messages: Schemas.zaraz_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type zaraz_base$mc = Schemas.zaraz_base$tool & {
        /** Actions configured on a tool. Either this or neoEvents field is required. */
        actions?: {};
        /** Tool's internal name */
        component: string;
        /** DEPRECATED - List of actions configured on a tool. Either this or actions field is required. If both are present, actions field will take precedence. */
        neoEvents?: {
            /** Tool event type */
            actionType: string;
            /** List of blocking triggers IDs */
            blockingTriggers: string[];
            /** Event payload */
            data: {};
            /** List of firing triggers IDs */
            firingTriggers: string[];
        }[];
        /** List of permissions granted to the component */
        permissions: string[];
        /** Tool's settings */
        settings: {};
    };
    export interface zaraz_base$tool {
        /** List of blocking trigger IDs */
        blockingTriggers: string[];
        /** Default fields for tool's actions */
        defaultFields: {};
        /** Default consent purpose ID */
        defaultPurpose?: string;
        /** Whether tool is enabled */
        enabled: boolean;
        /** Tool's name defined by the user */
        name: string;
    }
    export interface zaraz_click$listener$rule {
        action: "clickListener";
        id: string;
        settings: {
            selector: string;
            type: "xpath" | "css";
            waitForTags: number;
        };
    }
    export type zaraz_custom$managed$component = Schemas.zaraz_base$mc & {
        type: "custom-mc";
        /** Cloudflare worker that acts as a managed component */
        worker: {
            escapedWorkerName: string;
            workerTag: string;
        };
    };
    export interface zaraz_element$visibility$rule {
        action: "elementVisibility";
        id: string;
        settings: {
            selector: string;
        };
    }
    export interface zaraz_form$submission$rule {
        action: "formSubmission";
        id: string;
        settings: {
            selector: string;
            validate: boolean;
        };
    }
    /** Identifier */
    export type zaraz_identifier = string;
    export type zaraz_legacy$tool = Schemas.zaraz_base$tool & {
        /** Tool's internal name */
        library: string;
        /** List of actions configured on a tool */
        neoEvents: {
            /** List of blocking triggers IDs */
            blockingTriggers: string[];
            /** Event payload */
            data: {};
            /** List of firing triggers IDs */
            firingTriggers: string[];
        }[];
        type: "library";
    };
    export interface zaraz_load$rule {
        id: string;
        match: string;
        op: "CONTAINS" | "EQUALS" | "STARTS_WITH" | "ENDS_WITH" | "MATCH_REGEX" | "NOT_MATCH_REGEX" | "GREATER_THAN" | "GREATER_THAN_OR_EQUAL" | "LESS_THAN" | "LESS_THAN_OR_EQUAL";
        value: string;
    }
    export type zaraz_managed$component = Schemas.zaraz_base$mc & {
        type: "component";
    };
    export type zaraz_messages = {
        code: number;
        message: string;
    }[];
    export interface zaraz_scroll$depth$rule {
        action: "scrollDepth";
        id: string;
        settings: {
            positions: string;
        };
    }
    export interface zaraz_timer$rule {
        action: "timer";
        id: string;
        settings: {
            interval: number;
            limit: number;
        };
    }
    export interface zaraz_variable$match$rule {
        action: "variableMatch";
        id: string;
        settings: {
            match: string;
            variable: string;
        };
    }
    /** Zaraz configuration */
    export interface zaraz_zaraz$config$base {
        /** Consent management configuration. */
        consent?: {
            buttonTextTranslations?: {
                /** Object where keys are language codes */
                accept_all: {};
                /** Object where keys are language codes */
                confirm_my_choices: {};
                /** Object where keys are language codes */
                reject_all: {};
            };
            companyEmail?: string;
            companyName?: string;
            companyStreetAddress?: string;
            consentModalIntroHTML?: string;
            /** Object where keys are language codes */
            consentModalIntroHTMLWithTranslations?: {};
            cookieName?: string;
            customCSS?: string;
            customIntroDisclaimerDismissed?: boolean;
            defaultLanguage?: string;
            enabled: boolean;
            hideModal?: boolean;
            /** Object where keys are purpose alpha-numeric IDs */
            purposes?: {};
            /** Object where keys are purpose alpha-numeric IDs */
            purposesWithTranslations?: {};
        };
        /** Data layer compatibility mode enabled. */
        dataLayer: boolean;
        /** The key for Zaraz debug mode. */
        debugKey: string;
        /** Single Page Application support enabled. */
        historyChange?: boolean;
        /** General Zaraz settings. */
        settings: {
            /** Automatic injection of Zaraz scripts enabled. */
            autoInjectScript: boolean;
            /** Details of the worker that receives and edits Zaraz Context object. */
            contextEnricher?: {
                escapedWorkerName: string;
                workerTag: string;
            };
            /** The domain Zaraz will use for writing and reading its cookies. */
            cookieDomain?: string;
            /** Ecommerce API enabled. */
            ecommerce?: boolean;
            /** Custom endpoint for server-side track events. */
            eventsApiPath?: string;
            /** Hiding external referrer URL enabled. */
            hideExternalReferer?: boolean;
            /** Trimming IP address enabled. */
            hideIPAddress?: boolean;
            /** Removing URL query params enabled. */
            hideQueryParams?: boolean;
            /** Removing sensitive data from User Aagent string enabled. */
            hideUserAgent?: boolean;
            /** Custom endpoint for Zaraz init script. */
            initPath?: string;
            /** Injection of Zaraz scripts into iframes enabled. */
            injectIframes?: boolean;
            /** Custom path for Managed Components server functionalities. */
            mcRootPath?: string;
            /** Custom endpoint for Zaraz main script. */
            scriptPath?: string;
            /** Custom endpoint for Zaraz tracking requests. */
            trackPath?: string;
        };
        /** Triggers set up under Zaraz configuration, where key is the trigger alpha-numeric ID and value is the trigger configuration. */
        triggers: {};
        /** Variables set up under Zaraz configuration, where key is the variable alpha-numeric ID and value is the variable configuration. Values of variables of type secret are not included. */
        variables: {};
        /** Zaraz internal version of the config. */
        zarazVersion: number;
    }
    export type zaraz_zaraz$config$body = Schemas.zaraz_zaraz$config$base & {
        /** Tools set up under Zaraz configuration, where key is the alpha-numeric tool ID and value is the tool configuration object. */
        tools?: {};
    };
    export type zaraz_zaraz$config$history$response = Schemas.zaraz_api$response$common & {
        /** Object where keys are numericc onfiguration IDs */
        result?: {};
    };
    export type zaraz_zaraz$config$response = Schemas.zaraz_api$response$common & {
        result?: Schemas.zaraz_zaraz$config$return;
    };
    export type zaraz_zaraz$config$return = Schemas.zaraz_zaraz$config$base & {
        /** Tools set up under Zaraz configuration, where key is the alpha-numeric tool ID and value is the tool configuration object. */
        tools?: {};
    };
    export interface zaraz_zaraz$config$row$base {
        /** Date and time the configuration was created */
        createdAt: Date;
        /** ID of the configuration */
        id: number;
        /** Date and time the configuration was last updated */
        updatedAt: Date;
        /** Alpha-numeric ID of the account user who published the configuration */
        userId: string;
    }
    export type zaraz_zaraz$history$response = Schemas.zaraz_api$response$common & {
        result?: (Schemas.zaraz_zaraz$config$row$base & {
            /** Configuration description provided by the user who published this configuration */
            description: string;
        })[];
    };
    /** Zaraz workflow */
    export type zaraz_zaraz$workflow = "realtime" | "preview";
    export type zaraz_zaraz$workflow$response = Schemas.zaraz_api$response$common & {
        result?: Schemas.zaraz_zaraz$workflow;
    };
    export type zaraz_zone$identifier = Schemas.zaraz_identifier;
    /** The action to preform when the associated traffic, identity, and device posture expressions are either absent or evaluate to \`true\`. */
    export type zero$trust$gateway_action = "on" | "off" | "allow" | "block" | "scan" | "noscan" | "safesearch" | "ytrestricted" | "isolate" | "noisolate" | "override" | "l4_override" | "egress" | "audit_ssh";
    /** Activity log settings. */
    export interface zero$trust$gateway_activity$log$settings {
        /** Enable activity logging. */
        enabled?: boolean;
    }
    /** Anti-virus settings. */
    export interface zero$trust$gateway_anti$virus$settings {
        enabled_download_phase?: Schemas.zero$trust$gateway_enabled_download_phase;
        enabled_upload_phase?: Schemas.zero$trust$gateway_enabled_upload_phase;
        fail_closed?: Schemas.zero$trust$gateway_fail_closed;
        notification_settings?: Schemas.zero$trust$gateway_notification_settings;
    }
    export type zero$trust$gateway_api$response$collection = Schemas.zero$trust$gateway_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.zero$trust$gateway_result_info;
    };
    export interface zero$trust$gateway_api$response$common {
        errors: Schemas.zero$trust$gateway_messages;
        messages: Schemas.zero$trust$gateway_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface zero$trust$gateway_api$response$common$failure {
        errors: Schemas.zero$trust$gateway_messages;
        messages: Schemas.zero$trust$gateway_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type zero$trust$gateway_api$response$single = Schemas.zero$trust$gateway_api$response$common & {
        result?: {} | string;
    };
    export type zero$trust$gateway_app$types = Schemas.zero$trust$gateway_application | Schemas.zero$trust$gateway_application_type;
    /** The name of the application or application type. */
    export type zero$trust$gateway_app$types_components$schemas$name = string;
    export type zero$trust$gateway_app$types_components$schemas$response_collection = Schemas.zero$trust$gateway_api$response$collection & {
        result?: Schemas.zero$trust$gateway_app$types[];
    };
    /** The identifier for this application. There is only one application per ID. */
    export type zero$trust$gateway_app_id = number;
    /** The identifier for the type of this application. There can be many applications with the same type. This refers to the \`id\` of a returned application type. */
    export type zero$trust$gateway_app_type_id = number;
    export interface zero$trust$gateway_application {
        application_type_id?: Schemas.zero$trust$gateway_app_type_id;
        created_at?: Schemas.zero$trust$gateway_timestamp;
        id?: Schemas.zero$trust$gateway_app_id;
        name?: Schemas.zero$trust$gateway_app$types_components$schemas$name;
    }
    export interface zero$trust$gateway_application_type {
        created_at?: Schemas.zero$trust$gateway_timestamp;
        /** A short summary of applications with this type. */
        description?: string;
        id?: Schemas.zero$trust$gateway_app_type_id;
        name?: Schemas.zero$trust$gateway_app$types_components$schemas$name;
    }
    export type zero$trust$gateway_audit_ssh_settings_components$schemas$single_response = Schemas.zero$trust$gateway_api$response$single & {
        result?: Schemas.zero$trust$gateway_settings;
    };
    /** Seed ID */
    export type zero$trust$gateway_audit_ssh_settings_components$schemas$uuid = string;
    /** True if the category is in beta and subject to change. */
    export type zero$trust$gateway_beta = boolean;
    /** Block page layout settings. */
    export interface zero$trust$gateway_block$page$settings {
        /** Block page background color in #rrggbb format. */
        background_color?: string;
        /** Enable only cipher suites and TLS versions compliant with FIPS 140-2. */
        enabled?: boolean;
        /** Block page footer text. */
        footer_text?: string;
        /** Block page header text. */
        header_text?: string;
        /** Full URL to the logo file. */
        logo_path?: string;
        /** Admin email for users to contact. */
        mailto_address?: string;
        /** Subject line for emails created from block page. */
        mailto_subject?: string;
        /** Block page title. */
        name?: string;
        /** Suppress detailed info at the bottom of the block page. */
        suppress_footer?: boolean;
    }
    /** DLP body scanning settings. */
    export interface zero$trust$gateway_body$scanning$settings {
        /** Set the inspection mode to either \`deep\` or \`shallow\`. */
        inspection_mode?: string;
    }
    /** Browser isolation settings. */
    export interface zero$trust$gateway_browser$isolation$settings {
        /** Enable non-identity onramp support for Browser Isolation. */
        non_identity_enabled?: boolean;
        /** Enable Clientless Browser Isolation. */
        url_browser_isolation_enabled?: boolean;
    }
    export interface zero$trust$gateway_categories {
        beta?: Schemas.zero$trust$gateway_beta;
        class?: Schemas.zero$trust$gateway_class;
        description?: Schemas.zero$trust$gateway_components$schemas$description;
        id?: Schemas.zero$trust$gateway_id;
        name?: Schemas.zero$trust$gateway_categories_components$schemas$name;
        /** All subcategories for this category. */
        subcategories?: Schemas.zero$trust$gateway_subcategory[];
    }
    /** The name of the category. */
    export type zero$trust$gateway_categories_components$schemas$name = string;
    export type zero$trust$gateway_categories_components$schemas$response_collection = Schemas.zero$trust$gateway_api$response$collection & {
        result?: Schemas.zero$trust$gateway_categories[];
    };
    /** Cloudflare account ID. */
    export type zero$trust$gateway_cf_account_id = string;
    /** Which account types are allowed to create policies based on this category. \`blocked\` categories are blocked unconditionally for all accounts. \`removalPending\` categories can be removed from policies but not added. \`noBlock\` categories cannot be blocked. */
    export type zero$trust$gateway_class = "free" | "premium" | "blocked" | "removalPending" | "noBlock";
    /** True if the location is the default location. */
    export type zero$trust$gateway_client$default = boolean;
    /** A short summary of domains in the category. */
    export type zero$trust$gateway_components$schemas$description = string;
    /** The name of the rule. */
    export type zero$trust$gateway_components$schemas$name = string;
    export type zero$trust$gateway_components$schemas$response_collection = Schemas.zero$trust$gateway_api$response$collection & {
        result?: Schemas.zero$trust$gateway_rules[];
    };
    export type zero$trust$gateway_components$schemas$single_response = Schemas.zero$trust$gateway_api$response$single & {
        result?: Schemas.zero$trust$gateway_rules;
    };
    /** The API resource UUID. */
    export type zero$trust$gateway_components$schemas$uuid = string;
    /** The number of items in the list. */
    export type zero$trust$gateway_count = number;
    /** Custom certificate settings for BYO-PKI. */
    export interface zero$trust$gateway_custom$certificate$settings {
        /** Certificate status (internal). */
        readonly binding_status?: string;
        /** Enable use of custom certificate authority for signing Gateway traffic. */
        enabled: boolean;
        /** UUID of certificate (ID from MTLS certificate store). */
        id?: string;
        readonly updated_at?: Date;
    }
    /** Date of deletion, if any. */
    export type zero$trust$gateway_deleted_at = (Date) | null;
    /** The description of the list. */
    export type zero$trust$gateway_description = string;
    /** The wirefilter expression used for device posture check matching. */
    export type zero$trust$gateway_device_posture = string;
    export interface zero$trust$gateway_dns_resolver_settings {
        /** IP address of upstream resolver. */
        ip: string;
        /** A port number to use for upstream resolver. */
        port?: number;
        /** Whether to connect to this resolver over a private network. Must be set when vnet_id is set. */
        route_through_private_network?: boolean;
        /** Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted. */
        vnet_id?: string;
    }
    /** True if the location needs to resolve EDNS queries. */
    export type zero$trust$gateway_ecs$support = boolean;
    export type zero$trust$gateway_empty_response = Schemas.zero$trust$gateway_api$response$single & {
        result?: {};
    };
    /** True if the rule is enabled. */
    export type zero$trust$gateway_enabled = boolean;
    /** Enable anti-virus scanning on downloads. */
    export type zero$trust$gateway_enabled_download_phase = boolean;
    /** Enable anti-virus scanning on uploads. */
    export type zero$trust$gateway_enabled_upload_phase = boolean;
    /** Extended e-mail matching settings. */
    export interface zero$trust$gateway_extended$email$matching {
        /** Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies. */
        enabled?: boolean;
    }
    /** Block requests for files that cannot be scanned. */
    export type zero$trust$gateway_fail_closed = boolean;
    /** The protocol or layer to evaluate the traffic, identity, and device posture expressions. */
    export type zero$trust$gateway_filters = ("http" | "dns" | "l4" | "egress")[];
    /** FIPS settings. */
    export interface zero$trust$gateway_fips$settings {
        /** Enable only cipher suites and TLS versions compliant with FIPS 140-2. */
        tls?: boolean;
    }
    export interface zero$trust$gateway_gateway$account$logging$settings {
        /** Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent). */
        redact_pii?: boolean;
        /** Logging settings by rule type. */
        settings_by_rule_type?: {
            /** Logging settings for DNS firewall. */
            dns?: {};
            /** Logging settings for HTTP/HTTPS firewall. */
            http?: {};
            /** Logging settings for Network firewall. */
            l4?: {};
        };
    }
    export type zero$trust$gateway_gateway$account$logging$settings$response = Schemas.zero$trust$gateway_api$response$single & {
        result?: Schemas.zero$trust$gateway_gateway$account$logging$settings;
    };
    /** account settings. */
    export interface zero$trust$gateway_gateway$account$settings {
        /** account settings. */
        settings?: {
            activity_log?: Schemas.zero$trust$gateway_activity$log$settings;
            antivirus?: Schemas.zero$trust$gateway_anti$virus$settings;
            block_page?: Schemas.zero$trust$gateway_block$page$settings;
            body_scanning?: Schemas.zero$trust$gateway_body$scanning$settings;
            browser_isolation?: Schemas.zero$trust$gateway_browser$isolation$settings;
            custom_certificate?: Schemas.zero$trust$gateway_custom$certificate$settings;
            extended_email_matching?: Schemas.zero$trust$gateway_extended$email$matching;
            fips?: Schemas.zero$trust$gateway_fips$settings;
            protocol_detection?: Schemas.zero$trust$gateway_protocol$detection;
            tls_decrypt?: Schemas.zero$trust$gateway_tls$settings;
        };
    }
    export type zero$trust$gateway_gateway_account = Schemas.zero$trust$gateway_api$response$single & {
        result?: {
            gateway_tag?: Schemas.zero$trust$gateway_gateway_tag;
            id?: Schemas.zero$trust$gateway_cf_account_id;
            provider_name?: Schemas.zero$trust$gateway_provider_name;
        };
    };
    export type zero$trust$gateway_gateway_account_config = Schemas.zero$trust$gateway_api$response$single & {
        result?: Schemas.zero$trust$gateway_gateway$account$settings & {
            created_at?: Schemas.zero$trust$gateway_timestamp;
            updated_at?: Schemas.zero$trust$gateway_timestamp;
        };
    };
    /** Gateway internal ID. */
    export type zero$trust$gateway_gateway_tag = string;
    /** The identifier for this category. There is only one category per ID. */
    export type zero$trust$gateway_id = number;
    export type zero$trust$gateway_identifier = any;
    /** The wirefilter expression used for identity matching. */
    export type zero$trust$gateway_identity = string;
    /** IPV6 destination ip assigned to this location. DNS requests sent to this IP will counted as the request under this location. This field is auto-generated by Gateway. */
    export type zero$trust$gateway_ip = string;
    /** A list of CIDRs to restrict ingress connections. */
    export type zero$trust$gateway_ips = string[];
    /** The items in the list. */
    export type zero$trust$gateway_items = {
        created_at?: Schemas.zero$trust$gateway_timestamp;
        value?: Schemas.zero$trust$gateway_value;
    }[];
    export type zero$trust$gateway_list_item_response_collection = Schemas.zero$trust$gateway_api$response$collection & {
        result?: Schemas.zero$trust$gateway_items[];
    } & {
        result_info?: {
            /** Total results returned based on your search parameters. */
            count?: number;
            /** Current page within paginated list of results. */
            page?: number;
            /** Number of results per page of results. */
            per_page?: number;
            /** Total results available without any search parameters. */
            total_count?: number;
        };
    };
    export interface zero$trust$gateway_lists {
        count?: Schemas.zero$trust$gateway_count;
        created_at?: Schemas.zero$trust$gateway_timestamp;
        description?: Schemas.zero$trust$gateway_description;
        id?: Schemas.zero$trust$gateway_uuid;
        name?: Schemas.zero$trust$gateway_name;
        type?: Schemas.zero$trust$gateway_type;
        updated_at?: Schemas.zero$trust$gateway_timestamp;
    }
    export interface zero$trust$gateway_locations {
        client_default?: Schemas.zero$trust$gateway_client$default;
        created_at?: Schemas.zero$trust$gateway_timestamp;
        doh_subdomain?: Schemas.zero$trust$gateway_subdomain;
        ecs_support?: Schemas.zero$trust$gateway_ecs$support;
        id?: Schemas.zero$trust$gateway_schemas$uuid;
        ip?: Schemas.zero$trust$gateway_ip;
        name?: Schemas.zero$trust$gateway_schemas$name;
        networks?: Schemas.zero$trust$gateway_networks;
        updated_at?: Schemas.zero$trust$gateway_timestamp;
    }
    export type zero$trust$gateway_messages = {
        code: number;
        message: string;
    }[];
    /** The name of the list. */
    export type zero$trust$gateway_name = string;
    export interface zero$trust$gateway_network {
        /** The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24. */
        network: string;
    }
    /** A list of network ranges that requests from this location would originate from. */
    export type zero$trust$gateway_networks = Schemas.zero$trust$gateway_network[];
    /** Configure a message to display on the user's device when an antivirus search is performed. */
    export interface zero$trust$gateway_notification_settings {
        /** Set notification on */
        enabled?: boolean;
        /** Customize the message shown in the notification. */
        msg?: string;
        /** Optional URL to direct users to additional information. If not set, the notification will open a block page. */
        support_url?: string;
    }
    /** Precedence sets the order of your rules. Lower values indicate higher precedence. At each processing phase, applicable rules are evaluated in ascending order of this value. */
    export type zero$trust$gateway_precedence = number;
    /** Protocol Detection settings. */
    export interface zero$trust$gateway_protocol$detection {
        /** Enable detecting protocol on initial bytes of client traffic. */
        enabled?: boolean;
    }
    /** The name of the provider. Usually Cloudflare. */
    export type zero$trust$gateway_provider_name = string;
    export interface zero$trust$gateway_proxy$endpoints {
        created_at?: Schemas.zero$trust$gateway_timestamp;
        id?: Schemas.zero$trust$gateway_schemas$uuid;
        ips?: Schemas.zero$trust$gateway_ips;
        name?: Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$name;
        subdomain?: Schemas.zero$trust$gateway_schemas$subdomain;
        updated_at?: Schemas.zero$trust$gateway_timestamp;
    }
    /** The name of the proxy endpoint. */
    export type zero$trust$gateway_proxy$endpoints_components$schemas$name = string;
    export type zero$trust$gateway_proxy$endpoints_components$schemas$response_collection = Schemas.zero$trust$gateway_api$response$collection & {
        result?: Schemas.zero$trust$gateway_proxy$endpoints[];
    };
    export type zero$trust$gateway_proxy$endpoints_components$schemas$single_response = Schemas.zero$trust$gateway_api$response$single & {
        result?: Schemas.zero$trust$gateway_proxy$endpoints;
    };
    /** SSH encryption public key */
    export type zero$trust$gateway_public_key = string;
    export type zero$trust$gateway_response_collection = Schemas.zero$trust$gateway_api$response$collection & {
        result?: Schemas.zero$trust$gateway_lists[];
    };
    export interface zero$trust$gateway_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    /** Additional settings that modify the rule's action. */
    export interface zero$trust$gateway_rule$settings {
        /** Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s). */
        add_headers?: {};
        /** Set by parent MSP accounts to enable their children to bypass this rule. */
        allow_child_bypass?: boolean;
        /** Settings for the Audit SSH action. */
        audit_ssh?: {
            /** Enable to turn on SSH command logging. */
            command_logging?: boolean;
        };
        /** Configure how browser isolation behaves. */
        biso_admin_controls?: {
            /** Set to true to enable copy-pasting. */
            dcp?: boolean;
            /** Set to true to enable downloading. */
            dd?: boolean;
            /** Set to true to enable keyboard usage. */
            dk?: boolean;
            /** Set to true to enable printing. */
            dp?: boolean;
            /** Set to true to enable uploading. */
            du?: boolean;
        };
        /** Enable the custom block page. */
        block_page_enabled?: boolean;
        /** The text describing why this block occurred, displayed on the custom block page (if enabled). */
        block_reason?: string;
        /** Set by children MSP accounts to bypass their parent's rules. */
        bypass_parent_rule?: boolean;
        /** Configure how session check behaves. */
        check_session?: {
            /** Configure how fresh the session needs to be to be considered valid. */
            duration?: string;
            /** Set to true to enable session enforcement. */
            enforce?: boolean;
        };
        /** Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve_dns_through_cloudflare is set. DNS queries will route to the address closest to their origin. */
        dns_resolvers?: {
            ipv4?: Schemas.zero$trust$gateway_dns_resolver_settings[];
            ipv6?: Schemas.zero$trust$gateway_dns_resolver_settings[];
        };
        /** Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs. */
        egress?: {
            /** The IPv4 address to be used for egress. */
            ipv4?: string;
            /** The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs. */
            ipv4_fallback?: string;
            /** The IPv6 range to be used for egress. */
            ipv6?: string;
        };
        /** INSECURE - disable DNSSEC validation (for Allow actions). */
        insecure_disable_dnssec_validation?: boolean;
        /** Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names. */
        ip_categories?: boolean;
        /** Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names. */
        ip_indicator_feeds?: boolean;
        /** Send matching traffic to the supplied destination IP address and port. */
        l4override?: {
            /** IPv4 or IPv6 address. */
            ip?: string;
            /** A port number to use for TCP/UDP overrides. */
            port?: number;
        };
        /** Configure a notification to display on the user's device when this rule is matched. */
        notification_settings?: {
            /** Set notification on */
            enabled?: boolean;
            /** Customize the message shown in the notification. */
            msg?: string;
            /** Optional URL to direct users to additional information. If not set, the notification will open a block page. */
            support_url?: string;
        };
        /** Override matching DNS queries with a hostname. */
        override_host?: string;
        /** Override matching DNS queries with an IP or set of IPs. */
        override_ips?: string[];
        /** Configure DLP payload logging. */
        payload_log?: {
            /** Set to true to enable DLP payload logging for this rule. */
            enabled?: boolean;
        };
        /** Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when dns_resolvers are specified. */
        resolve_dns_through_cloudflare?: boolean;
        /** Configure behavior when an upstream cert is invalid or an SSL error occurs. */
        untrusted_cert?: {
            /** The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526. */
            action?: "pass_through" | "block" | "error";
        };
    }
    export interface zero$trust$gateway_rules {
        action?: Schemas.zero$trust$gateway_action;
        created_at?: Schemas.zero$trust$gateway_timestamp;
        deleted_at?: Schemas.zero$trust$gateway_deleted_at;
        description?: Schemas.zero$trust$gateway_schemas$description;
        device_posture?: Schemas.zero$trust$gateway_device_posture;
        enabled?: Schemas.zero$trust$gateway_enabled;
        filters?: Schemas.zero$trust$gateway_filters;
        id?: Schemas.zero$trust$gateway_components$schemas$uuid;
        identity?: Schemas.zero$trust$gateway_identity;
        name?: Schemas.zero$trust$gateway_components$schemas$name;
        precedence?: Schemas.zero$trust$gateway_precedence;
        rule_settings?: Schemas.zero$trust$gateway_rule$settings;
        schedule?: Schemas.zero$trust$gateway_schedule;
        traffic?: Schemas.zero$trust$gateway_traffic;
        updated_at?: Schemas.zero$trust$gateway_timestamp;
    }
    /** The schedule for activating DNS policies. This does not apply to HTTP or network policies. */
    export interface zero$trust$gateway_schedule {
        /** The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays. */
        fri?: string;
        /** The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays. */
        mon?: string;
        /** The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays. */
        sat?: string;
        /** The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays. */
        sun?: string;
        /** The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays. */
        thu?: string;
        /** The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center. */
        time_zone?: string;
        /** The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays. */
        tue?: string;
        /** The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays. */
        wed?: string;
    }
    /** The description of the rule. */
    export type zero$trust$gateway_schemas$description = string;
    /** Identifier */
    export type zero$trust$gateway_schemas$identifier = string;
    /** The name of the location. */
    export type zero$trust$gateway_schemas$name = string;
    export type zero$trust$gateway_schemas$response_collection = Schemas.zero$trust$gateway_api$response$collection & {
        result?: Schemas.zero$trust$gateway_locations[];
    };
    export type zero$trust$gateway_schemas$single_response = Schemas.zero$trust$gateway_api$response$single & {
        result?: Schemas.zero$trust$gateway_locations;
    };
    /** The subdomain to be used as the destination in the proxy client. */
    export type zero$trust$gateway_schemas$subdomain = string;
    export type zero$trust$gateway_schemas$uuid = any;
    export interface zero$trust$gateway_settings {
        created_at?: Schemas.zero$trust$gateway_timestamp;
        public_key?: Schemas.zero$trust$gateway_public_key;
        seed_id?: Schemas.zero$trust$gateway_audit_ssh_settings_components$schemas$uuid;
        updated_at?: Schemas.zero$trust$gateway_timestamp;
    }
    export type zero$trust$gateway_single_response = Schemas.zero$trust$gateway_api$response$single & {
        result?: Schemas.zero$trust$gateway_lists;
    };
    export type zero$trust$gateway_single_response_with_list_items = Schemas.zero$trust$gateway_api$response$single & {
        result?: {
            created_at?: Schemas.zero$trust$gateway_timestamp;
            description?: Schemas.zero$trust$gateway_description;
            id?: Schemas.zero$trust$gateway_uuid;
            items?: Schemas.zero$trust$gateway_items;
            name?: Schemas.zero$trust$gateway_name;
            type?: Schemas.zero$trust$gateway_type;
            updated_at?: Schemas.zero$trust$gateway_timestamp;
        };
    };
    export interface zero$trust$gateway_subcategory {
        beta?: Schemas.zero$trust$gateway_beta;
        class?: Schemas.zero$trust$gateway_class;
        description?: Schemas.zero$trust$gateway_components$schemas$description;
        id?: Schemas.zero$trust$gateway_id;
        name?: Schemas.zero$trust$gateway_categories_components$schemas$name;
    }
    /** The DNS over HTTPS domain to send DNS requests to. This field is auto-generated by Gateway. */
    export type zero$trust$gateway_subdomain = string;
    export type zero$trust$gateway_timestamp = Date;
    /** TLS interception settings. */
    export interface zero$trust$gateway_tls$settings {
        /** Enable inspecting encrypted HTTP traffic. */
        enabled?: boolean;
    }
    /** The wirefilter expression used for traffic matching. */
    export type zero$trust$gateway_traffic = string;
    /** The type of list. */
    export type zero$trust$gateway_type = "SERIAL" | "URL" | "DOMAIN" | "EMAIL" | "IP";
    /** API Resource UUID tag. */
    export type zero$trust$gateway_uuid = string;
    /** The value of the item in a list. */
    export type zero$trust$gateway_value = string;
    export type zhLWtXLP_account_identifier = any;
    export type zhLWtXLP_api$response$collection = Schemas.zhLWtXLP_api$response$common & {
        result?: {}[] | null;
        result_info?: Schemas.zhLWtXLP_result_info;
    };
    export interface zhLWtXLP_api$response$common {
        errors: Schemas.zhLWtXLP_messages;
        messages: Schemas.zhLWtXLP_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface zhLWtXLP_api$response$common$failure {
        errors: Schemas.zhLWtXLP_messages;
        messages: Schemas.zhLWtXLP_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type zhLWtXLP_api$response$single = Schemas.zhLWtXLP_api$response$common & {
        result?: ({} | null) | (string | null);
    };
    export type zhLWtXLP_messages = {
        code: number;
        message: string;
    }[];
    export interface zhLWtXLP_mnm_config {
        default_sampling: Schemas.zhLWtXLP_mnm_config_default_sampling;
        name: Schemas.zhLWtXLP_mnm_config_name;
        router_ips: Schemas.zhLWtXLP_mnm_config_router_ips;
    }
    /** Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router. */
    export type zhLWtXLP_mnm_config_default_sampling = number;
    /** The account name. */
    export type zhLWtXLP_mnm_config_name = string;
    /** IPv4 CIDR of the router sourcing flow data. Only /32 addresses are currently supported. */
    export type zhLWtXLP_mnm_config_router_ip = string;
    export type zhLWtXLP_mnm_config_router_ips = Schemas.zhLWtXLP_mnm_config_router_ip[];
    export type zhLWtXLP_mnm_config_single_response = Schemas.zhLWtXLP_api$response$single & {
        result?: Schemas.zhLWtXLP_mnm_config;
    };
    export type zhLWtXLP_mnm_rule = {
        automatic_advertisement: Schemas.zhLWtXLP_mnm_rule_automatic_advertisement;
        bandwidth_threshold?: Schemas.zhLWtXLP_mnm_rule_bandwidth_threshold;
        duration: Schemas.zhLWtXLP_mnm_rule_duration;
        id?: Schemas.zhLWtXLP_rule_identifier;
        name: Schemas.zhLWtXLP_mnm_rule_name;
        packet_threshold?: Schemas.zhLWtXLP_mnm_rule_packet_threshold;
        prefixes: Schemas.zhLWtXLP_mnm_rule_ip_prefixes;
    } | null;
    export type zhLWtXLP_mnm_rule_advertisable_response = {
        automatic_advertisement: Schemas.zhLWtXLP_mnm_rule_automatic_advertisement;
    } | null;
    export type zhLWtXLP_mnm_rule_advertisement_single_response = Schemas.zhLWtXLP_api$response$single & {
        result?: Schemas.zhLWtXLP_mnm_rule_advertisable_response;
    };
    /** Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit. */
    export type zhLWtXLP_mnm_rule_automatic_advertisement = boolean | null;
    /** The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum. */
    export type zhLWtXLP_mnm_rule_bandwidth_threshold = number;
    /** The amount of time that the rule threshold must be exceeded to send an alert notification. The final value must be equivalent to one of the following 8 values ["1m","5m","10m","15m","20m","30m","45m","60m"]. The format is AhBmCsDmsEusFns where A, B, C, D, E and F durations are optional; however at least one unit must be provided. */
    export type zhLWtXLP_mnm_rule_duration = string;
    /** The IP prefixes that are monitored for this rule. Must be a CIDR range like 203.0.113.0/24. Max 5000 different CIDR ranges. */
    export type zhLWtXLP_mnm_rule_ip_prefix = string;
    export type zhLWtXLP_mnm_rule_ip_prefixes = Schemas.zhLWtXLP_mnm_rule_ip_prefix[];
    /** The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You canâ€™t have a space in the rule name. Max 256 characters. */
    export type zhLWtXLP_mnm_rule_name = string;
    /** The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum. */
    export type zhLWtXLP_mnm_rule_packet_threshold = number;
    export type zhLWtXLP_mnm_rules_collection_response = Schemas.zhLWtXLP_api$response$collection & {
        result?: Schemas.zhLWtXLP_mnm_rule[] | null;
    };
    export type zhLWtXLP_mnm_rules_single_response = Schemas.zhLWtXLP_api$response$single & {
        result?: Schemas.zhLWtXLP_mnm_rule;
    };
    export interface zhLWtXLP_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type zhLWtXLP_rule_identifier = any;
    export type zones_0rtt = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "0rtt";
        value?: Schemas.zones_0rtt_value;
    };
    /** Value of the 0-RTT setting. */
    export type zones_0rtt_value = "on" | "off";
    /** The set of actions to perform if the targets of this rule match the request. Actions can redirect to another URL or override settings, but not both. */
    export type zones_actions = (Schemas.zones_route)[];
    export type zones_advanced_ddos = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "advanced_ddos";
        value?: Schemas.zones_advanced_ddos_value;
    };
    /**
     * Value of the zone setting.
     * Notes: Defaults to on for Business+ plans
     */
    export type zones_advanced_ddos_value = "on" | "off";
    export type zones_always_online = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "always_online";
        value?: Schemas.zones_always_online_value;
    };
    /** Value of the zone setting. */
    export type zones_always_online_value = "on" | "off";
    export type zones_always_use_https = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "always_use_https";
        value?: Schemas.zones_always_use_https_value;
    };
    /** Value of the zone setting. */
    export type zones_always_use_https_value = "on" | "off";
    export interface zones_api$response$common {
        errors: Schemas.zones_messages;
        messages: Schemas.zones_messages;
        /** Whether the API call was successful */
        success: boolean;
    }
    export interface zones_api$response$common$failure {
        errors: Schemas.zones_messages;
        messages: Schemas.zones_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: boolean;
    }
    export type zones_api$response$single = Schemas.zones_schemas$api$response$common & {
        result?: {} | string;
    };
    export type zones_api$response$single$id = Schemas.zones_api$response$common & {
        result?: {
            id: Schemas.zones_identifier;
        } | null;
    };
    export type zones_automatic_https_rewrites = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "automatic_https_rewrites";
        value?: Schemas.zones_automatic_https_rewrites_value;
    };
    /**
     * Value of the zone setting.
     * Notes: Default value depends on the zone's plan level.
     */
    export type zones_automatic_https_rewrites_value = "on" | "off";
    export interface zones_automatic_platform_optimization {
        /** Indicates whether or not [cache by device type](https://developers.cloudflare.com/automatic-platform-optimization/reference/cache-device-type/) is enabled. */
        cache_by_device_type: boolean;
        /** Indicates whether or not Cloudflare proxy is enabled. */
        cf: boolean;
        /** Indicates whether or not Automatic Platform Optimization is enabled. */
        enabled: boolean;
        /** An array of hostnames where Automatic Platform Optimization for WordPress is activated. */
        hostnames: string[];
        /** Indicates whether or not site is powered by WordPress. */
        wordpress: boolean;
        /** Indicates whether or not [Cloudflare for WordPress plugin](https://wordpress.org/plugins/cloudflare/) is installed. */
        wp_plugin: boolean;
    }
    export interface zones_base {
        /** Whether or not this setting can be modified for this zone (based on your Cloudflare plan level). */
        readonly editable?: true | false;
        /** Identifier of the zone setting. */
        id: string;
        /** last time this setting was modified. */
        readonly modified_on?: Date;
        /** Current value of the zone setting. */
        value: any;
    }
    export type zones_brotli = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "brotli";
        value?: Schemas.zones_brotli_value;
    };
    /** Value of the zone setting. */
    export type zones_brotli_value = "off" | "on";
    export type zones_browser_cache_ttl = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "browser_cache_ttl";
        value?: Schemas.zones_browser_cache_ttl_value;
    };
    /**
     * Value of the zone setting.
     * Notes: Setting a TTL of 0 is equivalent to selecting \`Respect Existing Headers\`
     */
    export type zones_browser_cache_ttl_value = 0 | 30 | 60 | 120 | 300 | 1200 | 1800 | 3600 | 7200 | 10800 | 14400 | 18000 | 28800 | 43200 | 57600 | 72000 | 86400 | 172800 | 259200 | 345600 | 432000 | 691200 | 1382400 | 2073600 | 2678400 | 5356800 | 16070400 | 31536000;
    export type zones_browser_check = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "browser_check";
        value?: Schemas.zones_browser_check_value;
    };
    /** Value of the zone setting. */
    export type zones_browser_check_value = "on" | "off";
    export type zones_cache_level = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "cache_level";
        value?: Schemas.zones_cache_level_value;
    };
    /** Value of the zone setting. */
    export type zones_cache_level_value = "aggressive" | "basic" | "simplified";
    export type zones_challenge_ttl = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "challenge_ttl";
        value?: Schemas.zones_challenge_ttl_value;
    };
    /** Value of the zone setting. */
    export type zones_challenge_ttl_value = 300 | 900 | 1800 | 2700 | 3600 | 7200 | 10800 | 14400 | 28800 | 57600 | 86400 | 604800 | 2592000 | 31536000;
    export type zones_ciphers = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "ciphers";
        value?: Schemas.zones_ciphers_value;
    };
    /** Value of the zone setting. */
    export type zones_ciphers_value = string[];
    export type zones_cname_flattening = Schemas.zones_base & {
        /** How to flatten the cname destination. */
        id?: "cname_flattening";
        value?: Schemas.zones_cname_flattening_value;
    };
    /** Value of the cname flattening setting. */
    export type zones_cname_flattening_value = "flatten_at_root" | "flatten_all";
    /** The timestamp of when the Page Rule was created. */
    export type zones_created_on = Date;
    export type zones_development_mode = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "development_mode";
        /**
         * Value of the zone setting.
         * Notes: The interval (in seconds) from when development mode expires (positive integer) or last expired (negative integer) for the domain. If development mode has never been enabled, this value is false.
         */
        readonly time_remaining?: number;
        value?: Schemas.zones_development_mode_value;
    };
    /** Value of the zone setting. */
    export type zones_development_mode_value = "on" | "off";
    export type zones_early_hints = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "early_hints";
        value?: Schemas.zones_early_hints_value;
    };
    /** Value of the zone setting. */
    export type zones_early_hints_value = "on" | "off";
    export type zones_edge_cache_ttl = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "edge_cache_ttl";
        value?: Schemas.zones_edge_cache_ttl_value;
    };
    /**
     * Value of the zone setting.
     * Notes: The minimum TTL available depends on the plan level of the zone. (Enterprise = 30, Business = 1800, Pro = 3600, Free = 7200)
     */
    export type zones_edge_cache_ttl_value = 30 | 60 | 300 | 1200 | 1800 | 3600 | 7200 | 10800 | 14400 | 18000 | 28800 | 43200 | 57600 | 72000 | 86400 | 172800 | 259200 | 345600 | 432000 | 518400 | 604800;
    export type zones_email_obfuscation = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "email_obfuscation";
        value?: Schemas.zones_email_obfuscation_value;
    };
    /** Value of the zone setting. */
    export type zones_email_obfuscation_value = "on" | "off";
    export type zones_h2_prioritization = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "h2_prioritization";
        value?: Schemas.zones_h2_prioritization_value;
    };
    /** Value of the zone setting. */
    export type zones_h2_prioritization_value = "on" | "off" | "custom";
    export type zones_hotlink_protection = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "hotlink_protection";
        value?: Schemas.zones_hotlink_protection_value;
    };
    /** Value of the zone setting. */
    export type zones_hotlink_protection_value = "on" | "off";
    export type zones_http2 = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "http2";
        value?: Schemas.zones_http2_value;
    };
    /** Value of the HTTP2 setting. */
    export type zones_http2_value = "on" | "off";
    export type zones_http3 = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "http3";
        value?: Schemas.zones_http3_value;
    };
    /** Value of the HTTP3 setting. */
    export type zones_http3_value = "on" | "off";
    /** Identifier */
    export type zones_identifier = string;
    export type zones_image_resizing = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "image_resizing";
        value?: Schemas.zones_image_resizing_value;
    };
    /** Whether the feature is enabled, disabled, or enabled in \`open proxy\` mode. */
    export type zones_image_resizing_value = "on" | "off" | "open";
    export type zones_ip_geolocation = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "ip_geolocation";
        value?: Schemas.zones_ip_geolocation_value;
    };
    /** Value of the zone setting. */
    export type zones_ip_geolocation_value = "on" | "off";
    export type zones_ipv6 = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "ipv6";
        value?: Schemas.zones_ipv6_value;
    };
    /** Value of the zone setting. */
    export type zones_ipv6_value = "off" | "on";
    export type zones_max_upload = Schemas.zones_base & {
        /** identifier of the zone setting. */
        id?: "max_upload";
        value?: Schemas.zones_max_upload_value;
    };
    /**
     * Value of the zone setting.
     * Notes: The size depends on the plan level of the zone. (Enterprise = 500, Business = 200, Pro = 100, Free = 100)
     */
    export type zones_max_upload_value = 100 | 200 | 500;
    export type zones_messages = {
        code: number;
        message: string;
    }[];
    export type zones_min_tls_version = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "min_tls_version";
        value?: Schemas.zones_min_tls_version_value;
    };
    /** Value of the zone setting. */
    export type zones_min_tls_version_value = "1.0" | "1.1" | "1.2" | "1.3";
    export type zones_minify = Schemas.zones_base & {
        /** Zone setting identifier. */
        id?: "minify";
        value?: Schemas.zones_minify_value;
    };
    /** Value of the zone setting. */
    export interface zones_minify_value {
        /** Automatically minify all CSS files for your website. */
        css?: "on" | "off";
        /** Automatically minify all HTML files for your website. */
        html?: "on" | "off";
        /** Automatically minify all JavaScript files for your website. */
        js?: "on" | "off";
    }
    export type zones_mirage = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "mirage";
        value?: Schemas.zones_mirage_value;
    };
    /** Value of the zone setting. */
    export type zones_mirage_value = "on" | "off";
    export type zones_mobile_redirect = Schemas.zones_base & {
        /** Identifier of the zone setting. */
        id?: "mobile_redirect";
        value?: Schemas.zones_mobile_redirect_value;
    };
    /** Value of the zone setting. */
    export interface zones_mobile_redirect_value {
        /** Which subdomain prefix you wish to redirect visitors on mobile devices to (subdomain must already exist). */
        mobile_subdomain?: string | null;
        /** Whether or not mobile redirect is enabled. */
        status?: "on" | "off";
        /** Whether to drop the current page path and redirect to the mobile subdomain URL root, or keep the path and redirect to the same page on the mobile subdomain. */
        strip_uri?: boolean;
    }
    /** The domain name */
    export type zones_name = string;
    export type zones_nel = Schemas.zones_base & {
        /** Zone setting identifier. */
        id?: "nel";
        value?: Schemas.zones_nel_value;
    };
    /** Value of the zone setting. */
    export interface zones_nel_value {
        enabled?: boolean;
    }
    export type zones_opportunistic_encryption = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "opportunistic_encryption";
        value?: Schemas.zones_opportunistic_encryption_value;
    };
    /**
     * Value of the zone setting.
     * Notes: Default value depends on the zone's plan level.
     */
    export type zones_opportunistic_encryption_value = "on" | "off";
    export type zones_opportunistic_onion = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "opportunistic_onion";
        value?: Schemas.zones_opportunistic_onion_value;
    };
    /**
     * Value of the zone setting.
     * Notes: Default value depends on the zone's plan level.
     */
    export type zones_opportunistic_onion_value = "on" | "off";
    export type zones_orange_to_orange = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "orange_to_orange";
        value?: Schemas.zones_orange_to_orange_value;
    };
    /** Value of the zone setting. */
    export type zones_orange_to_orange_value = "on" | "off";
    export type zones_origin_error_page_pass_thru = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "origin_error_page_pass_thru";
        value?: Schemas.zones_origin_error_page_pass_thru_value;
    };
    /** Value of the zone setting. */
    export type zones_origin_error_page_pass_thru_value = "on" | "off";
    export interface zones_page$rule {
        actions: Schemas.zones_actions;
        created_on: Schemas.zones_created_on;
        id: Schemas.zones_schemas$identifier;
        modified_on: Schemas.zones_schemas$modified_on;
        priority: Schemas.zones_priority;
        status: Schemas.zones_status;
        targets: Schemas.zones_targets;
    }
    export type zones_pagerule_response_collection = Schemas.zones_schemas$api$response$common & {
        result?: Schemas.zones_page$rule[];
    };
    export type zones_pagerule_response_single = Schemas.zones_api$response$single & {
        result?: {};
    };
    export type zones_pagerule_settings_response_collection = Schemas.zones_schemas$api$response$common & {
        result?: Schemas.zones_settings;
    };
    /**
     * Indicates whether the zone is only using Cloudflare DNS services. A
     * true value means the zone will not receive security or performance
     * benefits.
     */
    export type zones_paused = boolean;
    export type zones_polish = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "polish";
        value?: Schemas.zones_polish_value;
    };
    /** Value of the zone setting. */
    export type zones_polish_value = "off" | "lossless" | "lossy";
    export type zones_prefetch_preload = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "prefetch_preload";
        value?: Schemas.zones_prefetch_preload_value;
    };
    /** Value of the zone setting. */
    export type zones_prefetch_preload_value = "on" | "off";
    /** The priority of the rule, used to define which Page Rule is processed over another. A higher number indicates a higher priority. For example, if you have a catch-all Page Rule (rule A: \`/images/\\\\*\`) but want a more specific Page Rule to take precedence (rule B: \`/images/special/*\`), specify a higher priority for rule B so it overrides rule A. */
    export type zones_priority = number;
    export type zones_proxy_read_timeout = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "proxy_read_timeout";
        value?: Schemas.zones_proxy_read_timeout_value;
    };
    /**
     * Value of the zone setting.
     * Notes: Value must be between 1 and 6000
     */
    export type zones_proxy_read_timeout_value = number;
    export type zones_pseudo_ipv4 = Schemas.zones_base & {
        /** Value of the Pseudo IPv4 setting. */
        id?: "pseudo_ipv4";
        value?: Schemas.zones_pseudo_ipv4_value;
    };
    /** Value of the Pseudo IPv4 setting. */
    export type zones_pseudo_ipv4_value = "off" | "add_header" | "overwrite_header";
    export type zones_response_buffering = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "response_buffering";
        value?: Schemas.zones_response_buffering_value;
    };
    /** Value of the zone setting. */
    export type zones_response_buffering_value = "on" | "off";
    export interface zones_result_info {
        /** Total number of results for the requested service */
        count?: number;
        /** Current page within paginated list of results */
        page?: number;
        /** Number of results per page of results */
        per_page?: number;
        /** Total results available without any search parameters */
        total_count?: number;
    }
    export type zones_rocket_loader = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "rocket_loader";
        value?: Schemas.zones_rocket_loader_value;
    };
    /** Value of the zone setting. */
    export type zones_rocket_loader_value = "on" | "off";
    export interface zones_route {
        /** The timestamp of when the override was last modified. */
        readonly modified_on?: Date;
        /** The type of route. */
        name?: "forward_url";
        value?: {
            /** The response type for the URL redirect. */
            type?: "temporary" | "permanent";
            /**
             * The URL to redirect the request to.
             * Notes: \${num} refers to the position of '*' in the constraint value.
             */
            url?: string;
        };
    }
    export interface zones_schemas$api$response$common {
        errors: Schemas.zones_messages;
        messages: Schemas.zones_messages;
        result: {} | {}[] | string;
        /** Whether the API call was successful */
        success: true;
    }
    export interface zones_schemas$api$response$common$failure {
        errors: Schemas.zones_messages;
        messages: Schemas.zones_messages;
        result: {} | null;
        /** Whether the API call was successful */
        success: false;
    }
    export type zones_schemas$api$response$single$id = Schemas.zones_schemas$api$response$common & {
        result?: {
            id: Schemas.zones_schemas$identifier;
        } | null;
    };
    export type zones_schemas$automatic_platform_optimization = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "automatic_platform_optimization";
        value?: Schemas.zones_automatic_platform_optimization;
    };
    /** Identifier */
    export type zones_schemas$identifier = string;
    /** The timestamp of when the Page Rule was last modified. */
    export type zones_schemas$modified_on = Date;
    export type zones_security_header = Schemas.zones_base & {
        /** ID of the zone's security header. */
        id?: "security_header";
        value?: Schemas.zones_security_header_value;
    };
    export interface zones_security_header_value {
        /** Strict Transport Security. */
        strict_transport_security?: {
            /** Whether or not strict transport security is enabled. */
            enabled?: boolean;
            /** Include all subdomains for strict transport security. */
            include_subdomains?: boolean;
            /** Max age in seconds of the strict transport security. */
            max_age?: number;
            /** Whether or not to include 'X-Content-Type-Options: nosniff' header. */
            nosniff?: boolean;
        };
    }
    export type zones_security_level = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "security_level";
        value?: Schemas.zones_security_level_value;
    };
    /** Value of the zone setting. */
    export type zones_security_level_value = "off" | "essentially_off" | "low" | "medium" | "high" | "under_attack";
    export type zones_server_side_exclude = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "server_side_exclude";
        value?: Schemas.zones_server_side_exclude_value;
    };
    /** Value of the zone setting. */
    export type zones_server_side_exclude_value = "on" | "off";
    export type zones_setting = Schemas.zones_0rtt | Schemas.zones_advanced_ddos | Schemas.zones_always_online | Schemas.zones_always_use_https | Schemas.zones_automatic_https_rewrites | Schemas.zones_brotli | Schemas.zones_browser_cache_ttl | Schemas.zones_browser_check | Schemas.zones_cache_level | Schemas.zones_challenge_ttl | Schemas.zones_ciphers | Schemas.zones_cname_flattening | Schemas.zones_development_mode | Schemas.zones_early_hints | Schemas.zones_edge_cache_ttl | Schemas.zones_email_obfuscation | Schemas.zones_h2_prioritization | Schemas.zones_hotlink_protection | Schemas.zones_http2 | Schemas.zones_http3 | Schemas.zones_image_resizing | Schemas.zones_ip_geolocation | Schemas.zones_ipv6 | Schemas.zones_max_upload | Schemas.zones_min_tls_version | Schemas.zones_minify | Schemas.zones_mirage | Schemas.zones_mobile_redirect | Schemas.zones_nel | Schemas.zones_opportunistic_encryption | Schemas.zones_opportunistic_onion | Schemas.zones_orange_to_orange | Schemas.zones_origin_error_page_pass_thru | Schemas.zones_polish | Schemas.zones_prefetch_preload | Schemas.zones_proxy_read_timeout | Schemas.zones_pseudo_ipv4 | Schemas.zones_response_buffering | Schemas.zones_rocket_loader | Schemas.zones_schemas$automatic_platform_optimization | Schemas.zones_security_header | Schemas.zones_security_level | Schemas.zones_server_side_exclude | Schemas.zones_sha1_support | Schemas.zones_sort_query_string_for_cache | Schemas.zones_ssl | Schemas.zones_ssl_recommender | Schemas.zones_tls_1_2_only | Schemas.zones_tls_1_3 | Schemas.zones_tls_client_auth | Schemas.zones_true_client_ip_header | Schemas.zones_waf | Schemas.zones_webp | Schemas.zones_websockets;
    /** Settings available for the zone. */
    export type zones_settings = {}[];
    export type zones_sha1_support = Schemas.zones_base & {
        /** Zone setting identifier. */
        id?: "sha1_support";
        value?: Schemas.zones_sha1_support_value;
    };
    /** Value of the zone setting. */
    export type zones_sha1_support_value = "off" | "on";
    export type zones_sort_query_string_for_cache = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "sort_query_string_for_cache";
        value?: Schemas.zones_sort_query_string_for_cache_value;
    };
    /** Value of the zone setting. */
    export type zones_sort_query_string_for_cache_value = "on" | "off";
    export type zones_ssl = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "ssl";
        value?: Schemas.zones_ssl_value;
    };
    export type zones_ssl_recommender = {
        enabled?: Schemas.zones_ssl_recommender_enabled;
        /** Enrollment value for SSL/TLS Recommender. */
        id?: "ssl_recommender";
    };
    /** ssl-recommender enrollment setting. */
    export type zones_ssl_recommender_enabled = boolean;
    /**
     * Value of the zone setting.
     * Notes: Depends on the zone's plan level
     */
    export type zones_ssl_value = "off" | "flexible" | "full" | "strict";
    /** The status of the Page Rule. */
    export type zones_status = "active" | "disabled";
    /** String constraint. */
    export interface zones_string_constraint {
        /** The matches operator can use asterisks and pipes as wildcard and 'or' operators. */
        operator: "matches" | "contains" | "equals" | "not_equal" | "not_contain";
        /** The value to apply the operator to. */
        value: string;
    }
    export type zones_target = Schemas.zones_url_target;
    /** The rule targets to evaluate on each request. */
    export type zones_targets = Schemas.zones_target[];
    export type zones_tls_1_2_only = Schemas.zones_base & {
        /** Zone setting identifier. */
        id?: "tls_1_2_only";
        value?: Schemas.zones_tls_1_2_only_value;
    };
    /** Value of the zone setting. */
    export type zones_tls_1_2_only_value = "off" | "on";
    export type zones_tls_1_3 = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "tls_1_3";
        value?: Schemas.zones_tls_1_3_value;
    };
    /**
     * Value of the zone setting.
     * Notes: Default value depends on the zone's plan level.
     */
    export type zones_tls_1_3_value = "on" | "off" | "zrt";
    export type zones_tls_client_auth = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "tls_client_auth";
        value?: Schemas.zones_tls_client_auth_value;
    };
    /** value of the zone setting. */
    export type zones_tls_client_auth_value = "on" | "off";
    export type zones_true_client_ip_header = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "true_client_ip_header";
        value?: Schemas.zones_true_client_ip_header_value;
    };
    /** Value of the zone setting. */
    export type zones_true_client_ip_header_value = "on" | "off";
    /**
     * A full zone implies that DNS is hosted with Cloudflare. A partial zone is
     * typically a partner-hosted zone or a CNAME setup.
     */
    export type zones_type = "full" | "partial" | "secondary";
    /** URL target. */
    export interface zones_url_target {
        /** The constraint of a target. */
        constraint?: Schemas.zones_string_constraint & {
            /** The URL pattern to match against the current request. The pattern may contain up to four asterisks ('*') as placeholders. */
            value?: string;
        };
        /** A target based on the URL of the request. */
        target?: "url";
    }
    /**
     * An array of domains used for custom name servers. This is only
     * available for Business and Enterprise plans.
     */
    export type zones_vanity_name_servers = string[];
    export type zones_waf = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "waf";
        value?: Schemas.zones_waf_value;
    };
    /** Value of the zone setting. */
    export type zones_waf_value = "on" | "off";
    export type zones_webp = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "webp";
        value?: Schemas.zones_webp_value;
    };
    /** Value of the zone setting. */
    export type zones_webp_value = "off" | "on";
    export type zones_websockets = Schemas.zones_base & {
        /** ID of the zone setting. */
        id?: "websockets";
        value?: Schemas.zones_websockets_value;
    };
    /** Value of the zone setting. */
    export type zones_websockets_value = "off" | "on";
    export interface zones_zone {
        /** The account the zone belongs to */
        account: {
            id?: Schemas.zones_identifier;
            /** The name of the account */
            name?: string;
        };
        /**
         * The last time proof of ownership was detected and the zone was made
         * active
         */
        readonly activated_on: Date;
        /** When the zone was created */
        readonly created_on: Date;
        /**
         * The interval (in seconds) from when development mode expires
         * (positive integer) or last expired (negative integer) for the
         * domain. If development mode has never been enabled, this value is 0.
         */
        readonly development_mode: number;
        id: Schemas.zones_identifier;
        /** Metadata about the zone */
        meta: {
            /** The zone is only configured for CDN */
            cdn_only?: boolean;
            /** Number of Custom Certificates the zone can have */
            custom_certificate_quota?: number;
            /** The zone is only configured for DNS */
            dns_only?: boolean;
            /** The zone is setup with Foundation DNS */
            foundation_dns?: boolean;
            /** Number of Page Rules a zone can have */
            page_rule_quota?: number;
            /** The zone has been flagged for phishing */
            phishing_detected?: boolean;
            step?: number;
        };
        /** When the zone was last modified */
        readonly modified_on: Date;
        /** The domain name */
        name: string;
        /** DNS host at the time of switching to Cloudflare */
        readonly original_dnshost: string | null;
        /**
         * Original name servers before moving to Cloudflare
         * Notes: Is this only available for full zones?
         */
        readonly original_name_servers: string[] | null;
        /** Registrar for the domain at the time of switching to Cloudflare */
        readonly original_registrar: string | null;
        /** The owner of the zone */
        owner: {
            id?: Schemas.zones_identifier;
            /** Name of the owner */
            name?: string;
            /** The type of owner */
            type?: string;
        };
        /** An array of domains used for custom name servers. This is only available for Business and Enterprise plans. */
        vanity_name_servers?: string[];
    }
    export type zones_zone_settings_response_collection = Schemas.zones_api$response$common & {
        result?: (Schemas.zones_0rtt | Schemas.zones_advanced_ddos | Schemas.zones_always_online | Schemas.zones_always_use_https | Schemas.zones_automatic_https_rewrites | Schemas.zones_brotli | Schemas.zones_browser_cache_ttl | Schemas.zones_browser_check | Schemas.zones_cache_level | Schemas.zones_challenge_ttl | Schemas.zones_ciphers | Schemas.zones_cname_flattening | Schemas.zones_development_mode | Schemas.zones_early_hints | Schemas.zones_edge_cache_ttl | Schemas.zones_email_obfuscation | Schemas.zones_h2_prioritization | Schemas.zones_hotlink_protection | Schemas.zones_http2 | Schemas.zones_http3 | Schemas.zones_image_resizing | Schemas.zones_ip_geolocation | Schemas.zones_ipv6 | Schemas.zones_max_upload | Schemas.zones_min_tls_version | Schemas.zones_minify | Schemas.zones_mirage | Schemas.zones_mobile_redirect | Schemas.zones_nel | Schemas.zones_opportunistic_encryption | Schemas.zones_opportunistic_onion | Schemas.zones_orange_to_orange | Schemas.zones_origin_error_page_pass_thru | Schemas.zones_polish | Schemas.zones_prefetch_preload | Schemas.zones_proxy_read_timeout | Schemas.zones_pseudo_ipv4 | Schemas.zones_response_buffering | Schemas.zones_rocket_loader | Schemas.zones_schemas$automatic_platform_optimization | Schemas.zones_security_header | Schemas.zones_security_level | Schemas.zones_server_side_exclude | Schemas.zones_sha1_support | Schemas.zones_sort_query_string_for_cache | Schemas.zones_ssl | Schemas.zones_ssl_recommender | Schemas.zones_tls_1_2_only | Schemas.zones_tls_1_3 | Schemas.zones_tls_client_auth | Schemas.zones_true_client_ip_header | Schemas.zones_waf | Schemas.zones_webp | Schemas.zones_websockets)[];
    };
    export type zones_zone_settings_response_single = Schemas.zones_api$response$common & {
        result?: {};
    };
}
export namespace Responses {
    /** Upload Worker Module response failure */
    export namespace workers_4XX {
        export interface Content {
            "application/json": any & Schemas.workers_api$response$common$failure;
        }
    }
    /** Upload Worker Module response */
    export namespace workers_200 {
        export interface Content {
            "application/json": Schemas.workers_script$response$single & any;
        }
    }
}
export namespace Parameters {
    /**
     * Filter results to only include discovery results sourced from a particular discovery engine
     *   * \`ML\` - Discovered operations that were sourced using ML API Discovery
     *   * \`SessionIdentifier\` - Discovered operations that were sourced using Session Identifier API Discovery
     */
    export type api$shield_api_discovery_origin_parameter = Schemas.api$shield_api_discovery_origin;
    /**
     * Filter results to only include discovery results in a particular state. States are as follows
     *   * \`review\` - Discovered operations that are not saved into API Shield Endpoint Management
     *   * \`saved\` - Discovered operations that are already saved into API Shield Endpoint Management
     *   * \`ignored\` - Discovered operations that have been marked as ignored
     */
    export type api$shield_api_discovery_state_parameter = Schemas.api$shield_api_discovery_state;
    export type api$shield_diff_parameter = boolean;
    export type api$shield_direction_parameter = "asc" | "desc";
    export type api$shield_endpoint_parameter = string;
    export type api$shield_host_parameter = string[];
    export type api$shield_method_parameter = string[];
    /** Omit the source-files of schemas and only retrieve their meta-data. */
    export type api$shield_omit_source = boolean;
    /** Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning. */
    export type api$shield_operation_feature_parameter = ("thresholds" | "parameter_schemas" | "schema_info")[];
    /** Identifier for the operation */
    export type api$shield_operation_id = string;
    export type api$shield_order_parameter = "host" | "method" | "endpoint" | "traffic_stats.requests" | "traffic_stats.last_updated";
    /** Page number of paginated results. */
    export type api$shield_page = any;
    /** Identifier for the discovered operation */
    export type api$shield_parameters$operation_id = Schemas.api$shield_uuid;
    /** Maximum number of results per page. */
    export type api$shield_per_page = any;
    /** Identifier for the schema-ID */
    export type api$shield_schema_id = string;
    export type api$shield_zone_id = Schemas.api$shield_identifier;
}
export namespace RequestBodies {
    export namespace workers_script_upload {
        export interface Content {
            /** Raw javascript content comprising a Worker. Must be in service worker syntax. */
            "application/javascript": string;
            "multipart/form-data": {
                /** A module comprising a Worker script, often a javascript file. Multiple modules may be provided as separate named parts, but at least one module must be present and referenced in the metadata as \`main_module\` or \`body_part\` by part name. */
                "<any part name>"?: (Blob)[];
                /** JSON encoded metadata about the uploaded parts and Worker configuration. */
                metadata?: {
                    /** List of bindings available to the worker. */
                    bindings?: {}[];
                    /** Name of the part in the multipart request that contains the script (e.g. the file adding a listener to the \`fetch\` event). Indicates a \`service worker syntax\` Worker. */
                    body_part?: string;
                    /** Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker. */
                    compatibility_date?: string;
                    /** Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a \`compatibility_date\`. */
                    compatibility_flags?: string[];
                    /** List of binding types to keep from previous_upload. */
                    keep_bindings?: string[];
                    logpush?: Schemas.workers_logpush;
                    /** Name of the part in the multipart request that contains the main module (e.g. the file exporting a \`fetch\` handler). Indicates a \`module syntax\` Worker. */
                    main_module?: string;
                    /** Migrations to apply for Durable Objects associated with this Worker. */
                    migrations?: Schemas.workers_single_step_migrations | Schemas.workers_stepped_migrations;
                    placement?: Schemas.workers_placement_config;
                    /** List of strings to use as tags for this Worker */
                    tags?: string[];
                    tail_consumers?: Schemas.workers_tail_consumers;
                    /** Usage model to apply to invocations. */
                    usage_model?: "bundled" | "unbound";
                    /** Key-value pairs to use as tags for this version of this Worker */
                    version_tags?: {};
                };
            } | {
                /** Rollback message to be associated with this deployment. Only parsed when query param \`"rollback_to"\` is present. */
                message?: string;
            };
            /** Raw javascript content comprising a Worker. Must be in service worker syntax. */
            "text/javascript": string;
        }
    }
}
export interface Parameter$accounts$list$accounts {
    name?: string;
    page?: number;
    per_page?: number;
    direction?: "asc" | "desc";
}
export interface Response$accounts$list$accounts$Status$200 {
    "application/json": Schemas.mrUXABdt_response_collection;
}
export interface Response$accounts$list$accounts$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_collection & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$notification$alert$types$get$alert$types {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface Response$notification$alert$types$get$alert$types$Status$200 {
    "application/json": Schemas.w2PBr26F_response_collection;
}
export interface Response$notification$alert$types$get$alert$types$Status$4XX {
    "application/json": Schemas.w2PBr26F_response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$mechanism$eligibility$get$delivery$mechanism$eligibility {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface Response$notification$mechanism$eligibility$get$delivery$mechanism$eligibility$Status$200 {
    "application/json": Schemas.w2PBr26F_schemas$response_collection;
}
export interface Response$notification$mechanism$eligibility$get$delivery$mechanism$eligibility$Status$4XX {
    "application/json": Schemas.w2PBr26F_schemas$response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$destinations$with$pager$duty$list$pager$duty$services {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface Response$notification$destinations$with$pager$duty$list$pager$duty$services$Status$200 {
    "application/json": Schemas.w2PBr26F_components$schemas$response_collection;
}
export interface Response$notification$destinations$with$pager$duty$list$pager$duty$services$Status$4XX {
    "application/json": Schemas.w2PBr26F_components$schemas$response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$destinations$with$pager$duty$delete$pager$duty$services {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface Response$notification$destinations$with$pager$duty$delete$pager$duty$services$Status$200 {
    "application/json": Schemas.w2PBr26F_api$response$collection;
}
export interface Response$notification$destinations$with$pager$duty$delete$pager$duty$services$Status$4XX {
    "application/json": Schemas.w2PBr26F_api$response$collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$destinations$with$pager$duty$connect$pager$duty {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface Response$notification$destinations$with$pager$duty$connect$pager$duty$Status$201 {
    "application/json": Schemas.w2PBr26F_id_response;
}
export interface Response$notification$destinations$with$pager$duty$connect$pager$duty$Status$4XX {
    "application/json": Schemas.w2PBr26F_id_response & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$destinations$with$pager$duty$connect$pager$duty$token {
    account_id: Schemas.w2PBr26F_account$id;
    token_id: Schemas.w2PBr26F_token$id;
}
export interface Response$notification$destinations$with$pager$duty$connect$pager$duty$token$Status$200 {
    "application/json": Schemas.w2PBr26F_id_response;
}
export interface Response$notification$destinations$with$pager$duty$connect$pager$duty$token$Status$4XX {
    "application/json": Schemas.w2PBr26F_id_response & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$webhooks$list$webhooks {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface Response$notification$webhooks$list$webhooks$Status$200 {
    "application/json": Schemas.w2PBr26F_webhooks_components$schemas$response_collection;
}
export interface Response$notification$webhooks$list$webhooks$Status$4XX {
    "application/json": Schemas.w2PBr26F_webhooks_components$schemas$response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$webhooks$create$a$webhook {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface RequestBody$notification$webhooks$create$a$webhook {
    "application/json": {
        name: Schemas.w2PBr26F_components$schemas$name;
        secret?: Schemas.w2PBr26F_secret;
        url: Schemas.w2PBr26F_url;
    };
}
export interface Response$notification$webhooks$create$a$webhook$Status$201 {
    "application/json": Schemas.w2PBr26F_id_response;
}
export interface Response$notification$webhooks$create$a$webhook$Status$4XX {
    "application/json": Schemas.w2PBr26F_id_response & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$webhooks$get$a$webhook {
    account_id: Schemas.w2PBr26F_account$id;
    webhook_id: Schemas.w2PBr26F_webhook$id;
}
export interface Response$notification$webhooks$get$a$webhook$Status$200 {
    "application/json": Schemas.w2PBr26F_schemas$single_response;
}
export interface Response$notification$webhooks$get$a$webhook$Status$4XX {
    "application/json": Schemas.w2PBr26F_schemas$single_response & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$webhooks$update$a$webhook {
    webhook_id: Schemas.w2PBr26F_webhook$id;
    account_id: Schemas.w2PBr26F_account$id;
}
export interface RequestBody$notification$webhooks$update$a$webhook {
    "application/json": {
        name: Schemas.w2PBr26F_components$schemas$name;
        secret?: Schemas.w2PBr26F_secret;
        url: Schemas.w2PBr26F_url;
    };
}
export interface Response$notification$webhooks$update$a$webhook$Status$200 {
    "application/json": Schemas.w2PBr26F_id_response;
}
export interface Response$notification$webhooks$update$a$webhook$Status$4XX {
    "application/json": Schemas.w2PBr26F_id_response & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$webhooks$delete$a$webhook {
    webhook_id: Schemas.w2PBr26F_webhook$id;
    account_id: Schemas.w2PBr26F_account$id;
}
export interface Response$notification$webhooks$delete$a$webhook$Status$200 {
    "application/json": Schemas.w2PBr26F_api$response$collection;
}
export interface Response$notification$webhooks$delete$a$webhook$Status$4XX {
    "application/json": Schemas.w2PBr26F_api$response$collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$history$list$history {
    account_id: Schemas.w2PBr26F_account$id;
    per_page?: Schemas.w2PBr26F_per_page;
    before?: Schemas.w2PBr26F_before;
    page?: number;
    since?: Date;
}
export interface Response$notification$history$list$history$Status$200 {
    "application/json": Schemas.w2PBr26F_history_components$schemas$response_collection;
}
export interface Response$notification$history$list$history$Status$4XX {
    "application/json": Schemas.w2PBr26F_history_components$schemas$response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$policies$list$notification$policies {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface Response$notification$policies$list$notification$policies$Status$200 {
    "application/json": Schemas.w2PBr26F_policies_components$schemas$response_collection;
}
export interface Response$notification$policies$list$notification$policies$Status$4XX {
    "application/json": Schemas.w2PBr26F_policies_components$schemas$response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$policies$create$a$notification$policy {
    account_id: Schemas.w2PBr26F_account$id;
}
export interface RequestBody$notification$policies$create$a$notification$policy {
    "application/json": {
        alert_type: Schemas.w2PBr26F_alert_type;
        description?: Schemas.w2PBr26F_schemas$description;
        enabled: Schemas.w2PBr26F_enabled;
        filters?: Schemas.w2PBr26F_filters;
        mechanisms: Schemas.w2PBr26F_mechanisms;
        name: Schemas.w2PBr26F_schemas$name;
    };
}
export interface Response$notification$policies$create$a$notification$policy$Status$200 {
    "application/json": Schemas.w2PBr26F_id_response;
}
export interface Response$notification$policies$create$a$notification$policy$Status$4XX {
    "application/json": Schemas.w2PBr26F_id_response & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$policies$get$a$notification$policy {
    account_id: Schemas.w2PBr26F_account$id;
    policy_id: Schemas.w2PBr26F_policy$id;
}
export interface Response$notification$policies$get$a$notification$policy$Status$200 {
    "application/json": Schemas.w2PBr26F_single_response;
}
export interface Response$notification$policies$get$a$notification$policy$Status$4XX {
    "application/json": Schemas.w2PBr26F_single_response & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$policies$update$a$notification$policy {
    account_id: Schemas.w2PBr26F_account$id;
    policy_id: Schemas.w2PBr26F_policy$id;
}
export interface RequestBody$notification$policies$update$a$notification$policy {
    "application/json": {
        alert_type?: Schemas.w2PBr26F_alert_type;
        description?: Schemas.w2PBr26F_schemas$description;
        enabled?: Schemas.w2PBr26F_enabled;
        filters?: Schemas.w2PBr26F_filters;
        mechanisms?: Schemas.w2PBr26F_mechanisms;
        name?: Schemas.w2PBr26F_schemas$name;
    };
}
export interface Response$notification$policies$update$a$notification$policy$Status$200 {
    "application/json": Schemas.w2PBr26F_id_response;
}
export interface Response$notification$policies$update$a$notification$policy$Status$4XX {
    "application/json": Schemas.w2PBr26F_id_response & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$notification$policies$delete$a$notification$policy {
    account_id: Schemas.w2PBr26F_account$id;
    policy_id: Schemas.w2PBr26F_policy$id;
}
export interface Response$notification$policies$delete$a$notification$policy$Status$200 {
    "application/json": Schemas.w2PBr26F_api$response$collection;
}
export interface Response$notification$policies$delete$a$notification$policy$Status$4XX {
    "application/json": Schemas.w2PBr26F_api$response$collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$phishing$url$scanner$submit$suspicious$url$for$scanning {
    account_id: Schemas.intel_identifier;
}
export interface RequestBody$phishing$url$scanner$submit$suspicious$url$for$scanning {
    "application/json": Schemas.intel_url_param;
}
export interface Response$phishing$url$scanner$submit$suspicious$url$for$scanning$Status$200 {
    "application/json": Schemas.intel_phishing$url$submit_components$schemas$single_response;
}
export interface Response$phishing$url$scanner$submit$suspicious$url$for$scanning$Status$4XX {
    "application/json": Schemas.intel_phishing$url$submit_components$schemas$single_response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$phishing$url$information$get$results$for$a$url$scan {
    account_id: Schemas.intel_identifier;
    url_id_param?: Schemas.intel_url_id_param;
    url?: string;
}
export interface Response$phishing$url$information$get$results$for$a$url$scan$Status$200 {
    "application/json": Schemas.intel_phishing$url$info_components$schemas$single_response;
}
export interface Response$phishing$url$information$get$results$for$a$url$scan$Status$4XX {
    "application/json": Schemas.intel_phishing$url$info_components$schemas$single_response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$list$cloudflare$tunnels {
    account_id: Schemas.tunnel_cf_account_id;
    name?: string;
    is_deleted?: boolean;
    existed_at?: Schemas.tunnel_existed_at;
    uuid?: Schemas.tunnel_tunnel_id;
    was_active_at?: Date;
    was_inactive_at?: Date;
    include_prefix?: string;
    exclude_prefix?: string;
    per_page?: Schemas.tunnel_per_page;
    page?: number;
}
export interface Response$cloudflare$tunnel$list$cloudflare$tunnels$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$collection;
}
export interface Response$cloudflare$tunnel$list$cloudflare$tunnels$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$collection & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$create$a$cloudflare$tunnel {
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$cloudflare$tunnel$create$a$cloudflare$tunnel {
    "application/json": {
        config_src?: Schemas.tunnel_config_src;
        name: Schemas.tunnel_tunnel_name;
        tunnel_secret?: Schemas.tunnel_tunnel_secret;
    };
}
export interface Response$cloudflare$tunnel$create$a$cloudflare$tunnel$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$single;
}
export interface Response$cloudflare$tunnel$create$a$cloudflare$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$get$a$cloudflare$tunnel {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$cloudflare$tunnel$get$a$cloudflare$tunnel$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$single;
}
export interface Response$cloudflare$tunnel$get$a$cloudflare$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$delete$a$cloudflare$tunnel {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$cloudflare$tunnel$delete$a$cloudflare$tunnel {
    "application/json": {};
}
export interface Response$cloudflare$tunnel$delete$a$cloudflare$tunnel$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$single;
}
export interface Response$cloudflare$tunnel$delete$a$cloudflare$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$update$a$cloudflare$tunnel {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$cloudflare$tunnel$update$a$cloudflare$tunnel {
    "application/json": {
        name?: Schemas.tunnel_tunnel_name;
        tunnel_secret?: Schemas.tunnel_tunnel_secret;
    };
}
export interface Response$cloudflare$tunnel$update$a$cloudflare$tunnel$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$single;
}
export interface Response$cloudflare$tunnel$update$a$cloudflare$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$configuration$get$configuration {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_identifier;
}
export interface Response$cloudflare$tunnel$configuration$get$configuration$Status$200 {
    "application/json": Schemas.tunnel_config_response_single;
}
export interface Response$cloudflare$tunnel$configuration$get$configuration$Status$4XX {
    "application/json": Schemas.tunnel_config_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$configuration$put$configuration {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_identifier;
}
export interface RequestBody$cloudflare$tunnel$configuration$put$configuration {
    "application/json": {
        config?: Schemas.tunnel_config;
    };
}
export interface Response$cloudflare$tunnel$configuration$put$configuration$Status$200 {
    "application/json": Schemas.tunnel_config_response_single;
}
export interface Response$cloudflare$tunnel$configuration$put$configuration$Status$4XX {
    "application/json": Schemas.tunnel_config_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$list$cloudflare$tunnel$connections {
    account_id: Schemas.tunnel_cf_account_id;
    tunnel_id: Schemas.tunnel_tunnel_id;
}
export interface Response$cloudflare$tunnel$list$cloudflare$tunnel$connections$Status$200 {
    "application/json": Schemas.tunnel_tunnel_connections_response;
}
export interface Response$cloudflare$tunnel$list$cloudflare$tunnel$connections$Status$4XX {
    "application/json": Schemas.tunnel_tunnel_connections_response & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections {
    account_id: Schemas.tunnel_cf_account_id;
    tunnel_id: Schemas.tunnel_tunnel_id;
    client_id?: string;
}
export interface RequestBody$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections {
    "application/json": {};
}
export interface Response$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections$Status$200 {
    "application/json": Schemas.tunnel_empty_response;
}
export interface Response$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections$Status$4XX {
    "application/json": Schemas.tunnel_empty_response & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$get$cloudflare$tunnel$connector {
    account_id: Schemas.tunnel_cf_account_id;
    tunnel_id: Schemas.tunnel_tunnel_id;
    connector_id: Schemas.tunnel_client_id;
}
export interface Response$cloudflare$tunnel$get$cloudflare$tunnel$connector$Status$200 {
    "application/json": Schemas.tunnel_tunnel_client_response;
}
export interface Response$cloudflare$tunnel$get$cloudflare$tunnel$connector$Status$4XX {
    "application/json": Schemas.tunnel_tunnel_client_response & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token {
    "application/json": {
        resources: Schemas.tunnel_management$resources[];
    };
}
export interface Response$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token$Status$200 {
    "application/json": Schemas.tunnel_tunnel_response_token;
}
export interface Response$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token$Status$4XX {
    "application/json": Schemas.tunnel_tunnel_response_token & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$get$a$cloudflare$tunnel$token {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$cloudflare$tunnel$get$a$cloudflare$tunnel$token$Status$200 {
    "application/json": Schemas.tunnel_tunnel_response_token;
}
export interface Response$cloudflare$tunnel$get$a$cloudflare$tunnel$token$Status$4XX {
    "application/json": Schemas.tunnel_tunnel_response_token & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$account$level$custom$nameservers$list$account$custom$nameservers {
    account_id: Schemas.dns$custom$nameservers_identifier;
}
export interface Response$account$level$custom$nameservers$list$account$custom$nameservers$Status$200 {
    "application/json": Schemas.dns$custom$nameservers_acns_response_collection;
}
export interface Response$account$level$custom$nameservers$list$account$custom$nameservers$Status$4XX {
    "application/json": Schemas.dns$custom$nameservers_acns_response_collection & Schemas.dns$custom$nameservers_api$response$common$failure;
}
export interface Parameter$account$level$custom$nameservers$add$account$custom$nameserver {
    account_id: Schemas.dns$custom$nameservers_identifier;
}
export interface RequestBody$account$level$custom$nameservers$add$account$custom$nameserver {
    "application/json": Schemas.dns$custom$nameservers_CustomNSInput;
}
export interface Response$account$level$custom$nameservers$add$account$custom$nameserver$Status$200 {
    "application/json": Schemas.dns$custom$nameservers_acns_response_single;
}
export interface Response$account$level$custom$nameservers$add$account$custom$nameserver$Status$4XX {
    "application/json": Schemas.dns$custom$nameservers_acns_response_single & Schemas.dns$custom$nameservers_api$response$common$failure;
}
export interface Parameter$account$level$custom$nameservers$delete$account$custom$nameserver {
    custom_ns_id: Schemas.dns$custom$nameservers_ns_name;
    account_id: Schemas.dns$custom$nameservers_identifier;
}
export interface Response$account$level$custom$nameservers$delete$account$custom$nameserver$Status$200 {
    "application/json": Schemas.dns$custom$nameservers_empty_response;
}
export interface Response$account$level$custom$nameservers$delete$account$custom$nameserver$Status$4XX {
    "application/json": Schemas.dns$custom$nameservers_empty_response & Schemas.dns$custom$nameservers_api$response$common$failure;
}
export interface Parameter$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers {
    account_id: Schemas.dns$custom$nameservers_identifier;
}
export interface Response$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers$Status$200 {
    "application/json": Schemas.dns$custom$nameservers_availability_response;
}
export interface Response$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers$Status$4XX {
    "application/json": Schemas.dns$custom$nameservers_availability_response & Schemas.dns$custom$nameservers_api$response$common$failure;
}
export interface Parameter$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records {
    account_id: Schemas.dns$custom$nameservers_identifier;
}
export interface Response$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records$Status$200 {
    "application/json": Schemas.dns$custom$nameservers_acns_response_collection;
}
export interface Response$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records$Status$4XX {
    "application/json": Schemas.dns$custom$nameservers_acns_response_collection & Schemas.dns$custom$nameservers_api$response$common$failure;
}
export interface Parameter$cloudflare$d1$list$databases {
    account_id: Schemas.d1_account$identifier;
    name?: string;
    page?: number;
    per_page?: number;
}
export interface Response$cloudflare$d1$list$databases$Status$200 {
    "application/json": Schemas.d1_api$response$common & {
        result?: Schemas.d1_create$database$response[];
    };
}
export interface Response$cloudflare$d1$list$databases$Status$4XX {
    "application/json": (Schemas.d1_api$response$single & {
        result?: {} | null;
    }) & Schemas.d1_api$response$common$failure;
}
export interface Parameter$cloudflare$d1$create$database {
    account_id: Schemas.d1_account$identifier;
}
export interface RequestBody$cloudflare$d1$create$database {
    "application/json": {
        name: Schemas.d1_database$name;
    };
}
export interface Response$cloudflare$d1$create$database$Status$200 {
    "application/json": Schemas.d1_api$response$single & {
        result?: Schemas.d1_create$database$response;
    };
}
export interface Response$cloudflare$d1$create$database$Status$4XX {
    "application/json": (Schemas.d1_api$response$single & {
        result?: {} | null;
    }) & Schemas.d1_api$response$common$failure;
}
export interface Parameter$dex$endpoints$list$colos {
    /** unique identifier linked to an account in the API request path. */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** Start time for connection period in RFC3339 (ISO 8601) format. */
    timeStart: string;
    /** End time for connection period in RFC3339 (ISO 8601) format. */
    timeEnd: string;
    /** Type of usage that colos should be sorted by. If unspecified, returns all Cloudflare colos sorted alphabetically. */
    sortBy?: "fleet-status-usage" | "application-tests-usage";
}
export interface Response$dex$endpoints$list$colos$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$collection & {
        result?: Schemas.digital$experience$monitoring_colos_response;
    };
}
export interface Response$dex$endpoints$list$colos$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$fleet$status$devices {
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    time_end: Schemas.digital$experience$monitoring_timestamp;
    time_start: Schemas.digital$experience$monitoring_timestamp;
    page: Schemas.digital$experience$monitoring_page;
    per_page: Schemas.digital$experience$monitoring_per_page;
    sort_by?: Schemas.digital$experience$monitoring_sort_by;
    colo?: Schemas.digital$experience$monitoring_colo;
    device_id?: Schemas.digital$experience$monitoring_device_id;
    mode?: Schemas.digital$experience$monitoring_mode;
    status?: Schemas.digital$experience$monitoring_status;
    platform?: Schemas.digital$experience$monitoring_platform;
    version?: Schemas.digital$experience$monitoring_version;
}
export interface Response$dex$fleet$status$devices$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_fleet_status_devices_response;
}
export interface Response$dex$fleet$status$devices$Status$4xx {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$fleet$status$live {
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    since_minutes: Schemas.digital$experience$monitoring_since_minutes;
}
export interface Response$dex$fleet$status$live$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_fleet_status_live_response;
}
export interface Response$dex$fleet$status$live$Status$4xx {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$fleet$status$over$time {
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    time_end: Schemas.digital$experience$monitoring_timestamp;
    time_start: Schemas.digital$experience$monitoring_timestamp;
    colo?: Schemas.digital$experience$monitoring_colo;
    device_id?: Schemas.digital$experience$monitoring_device_id;
}
export interface Response$dex$fleet$status$over$time$Status$4xx {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$endpoints$http$test$details {
    /** unique identifier linked to an account in the API request path. */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** unique identifier for a specific test */
    test_id: Schemas.digital$experience$monitoring_uuid;
    /** Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
    deviceId?: string[];
    /** Start time for aggregate metrics in ISO ms */
    timeStart: string;
    /** End time for aggregate metrics in ISO ms */
    timeEnd: string;
    /** Time interval for aggregate time slots. */
    interval: "minute" | "hour";
    /** Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
    colo?: string;
}
export interface Response$dex$endpoints$http$test$details$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & {
        result?: Schemas.digital$experience$monitoring_http_details_response;
    };
}
export interface Response$dex$endpoints$http$test$details$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$endpoints$http$test$percentiles {
    /** unique identifier linked to an account in the API request path. */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** unique identifier for a specific test */
    test_id: Schemas.digital$experience$monitoring_uuid;
    /** Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
    deviceId?: string[];
    /** Start time for aggregate metrics in ISO format */
    timeStart: string;
    /** End time for aggregate metrics in ISO format */
    timeEnd: string;
    /** Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
    colo?: string;
}
export interface Response$dex$endpoints$http$test$percentiles$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & {
        result?: Schemas.digital$experience$monitoring_http_details_percentiles_response;
    };
}
export interface Response$dex$endpoints$http$test$percentiles$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$endpoints$list$tests {
    /** unique identifier linked to an account in the API request path. */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
    colo?: string;
    /** Optionally filter results by test name */
    testName?: string;
    /** Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
    deviceId?: string[];
    /** Page number of paginated results */
    page?: number;
    /** Number of items per page */
    per_page?: number;
}
export interface Response$dex$endpoints$list$tests$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & {
        result?: Schemas.digital$experience$monitoring_tests_response;
        result_info?: Schemas.digital$experience$monitoring_result_info;
    };
}
export interface Response$dex$endpoints$list$tests$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$endpoints$tests$unique$devices {
    /** unique identifier linked to an account in the API request path. */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** Optionally filter results by test name */
    testName?: string;
    /** Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
    deviceId?: string[];
}
export interface Response$dex$endpoints$tests$unique$devices$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & {
        result?: Schemas.digital$experience$monitoring_unique_devices_response;
    };
}
export interface Response$dex$endpoints$tests$unique$devices$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$endpoints$traceroute$test$result$network$path {
    /** unique identifier linked to an account */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** unique identifier for a specific traceroute test */
    test_result_id: Schemas.digital$experience$monitoring_uuid;
}
export interface Response$dex$endpoints$traceroute$test$result$network$path$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & {
        result?: Schemas.digital$experience$monitoring_traceroute_test_result_network_path_response;
    };
}
export interface Response$dex$endpoints$traceroute$test$result$network$path$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$endpoints$traceroute$test$details {
    /** Unique identifier linked to an account */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** Unique identifier for a specific test */
    test_id: Schemas.digital$experience$monitoring_uuid;
    /** Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
    deviceId?: string[];
    /** Start time for aggregate metrics in ISO ms */
    timeStart: string;
    /** End time for aggregate metrics in ISO ms */
    timeEnd: string;
    /** Time interval for aggregate time slots. */
    interval: "minute" | "hour";
    /** Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
    colo?: string;
}
export interface Response$dex$endpoints$traceroute$test$details$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & {
        result?: Schemas.digital$experience$monitoring_traceroute_details_response;
    };
}
export interface Response$dex$endpoints$traceroute$test$details$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$endpoints$traceroute$test$network$path {
    /** unique identifier linked to an account */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** unique identifier for a specific test */
    test_id: Schemas.digital$experience$monitoring_uuid;
    /** Device to filter tracroute result runs to */
    deviceId: string;
    /** Start time for aggregate metrics in ISO ms */
    timeStart: string;
    /** End time for aggregate metrics in ISO ms */
    timeEnd: string;
    /** Time interval for aggregate time slots. */
    interval: "minute" | "hour";
}
export interface Response$dex$endpoints$traceroute$test$network$path$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & {
        result?: Schemas.digital$experience$monitoring_traceroute_test_network_path_response;
    };
}
export interface Response$dex$endpoints$traceroute$test$network$path$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dex$endpoints$traceroute$test$percentiles {
    /** unique identifier linked to an account in the API request path. */
    account_id: Schemas.digital$experience$monitoring_account_identifier;
    /** unique identifier for a specific test */
    test_id: Schemas.digital$experience$monitoring_uuid;
    /** Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param. */
    deviceId?: string[];
    /** Start time for aggregate metrics in ISO format */
    timeStart: string;
    /** End time for aggregate metrics in ISO format */
    timeEnd: string;
    /** Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param. */
    colo?: string;
}
export interface Response$dex$endpoints$traceroute$test$percentiles$Status$200 {
    "application/json": Schemas.digital$experience$monitoring_api$response$single & {
        result?: Schemas.digital$experience$monitoring_traceroute_details_percentiles_response;
    };
}
export interface Response$dex$endpoints$traceroute$test$percentiles$Status$4XX {
    "application/json": Schemas.digital$experience$monitoring_api$response$common$failure;
}
export interface Parameter$dlp$datasets$read$all {
    account_id: string;
}
export interface Response$dlp$datasets$read$all$Status$200 {
    "application/json": Schemas.dlp_DatasetArrayResponse;
}
export interface Response$dlp$datasets$read$all$Status$4XX {
    "application/json": Schemas.dlp_V4ResponseError;
}
export interface Parameter$dlp$datasets$create {
    account_id: string;
}
export interface RequestBody$dlp$datasets$create {
    "application/json": Schemas.dlp_NewDataset;
}
export interface Response$dlp$datasets$create$Status$200 {
    "application/json": Schemas.dlp_DatasetCreationResponse;
}
export interface Response$dlp$datasets$create$Status$4XX {
    "application/json": Schemas.dlp_V4ResponseError;
}
export interface Parameter$dlp$datasets$read {
    account_id: string;
    dataset_id: string;
}
export interface Response$dlp$datasets$read$Status$200 {
    "application/json": Schemas.dlp_DatasetResponse;
}
export interface Response$dlp$datasets$read$Status$4XX {
    "application/json": Schemas.dlp_V4ResponseError;
}
export interface Parameter$dlp$datasets$update {
    account_id: string;
    dataset_id: string;
}
export interface RequestBody$dlp$datasets$update {
    "application/json": Schemas.dlp_DatasetUpdate;
}
export interface Response$dlp$datasets$update$Status$200 {
    "application/json": Schemas.dlp_DatasetResponse;
}
export interface Response$dlp$datasets$update$Status$4XX {
    "application/json": Schemas.dlp_V4ResponseError;
}
export interface Parameter$dlp$datasets$delete {
    account_id: string;
    dataset_id: string;
}
export interface Response$dlp$datasets$delete$Status$4XX {
    "application/json": Schemas.dlp_V4ResponseError;
}
export interface Parameter$dlp$datasets$create$version {
    account_id: string;
    dataset_id: string;
}
export interface Response$dlp$datasets$create$version$Status$200 {
    "application/json": Schemas.dlp_DatasetNewVersionResponse;
}
export interface Response$dlp$datasets$create$version$Status$4XX {
    "application/json": Schemas.dlp_V4ResponseError;
}
export interface Parameter$dlp$datasets$upload$version {
    account_id: string;
    dataset_id: string;
    version: number;
}
export interface RequestBody$dlp$datasets$upload$version {
    "application/octet-stream": string;
}
export interface Response$dlp$datasets$upload$version$Status$200 {
    "application/json": Schemas.dlp_DatasetResponse;
}
export interface Response$dlp$datasets$upload$version$Status$4XX {
    "application/json": Schemas.dlp_V4ResponseError;
}
export interface Parameter$dlp$pattern$validation$validate$pattern {
    account_id: Schemas.dlp_identifier;
}
export interface RequestBody$dlp$pattern$validation$validate$pattern {
    "application/json": Schemas.dlp_validate_pattern;
}
export interface Response$dlp$pattern$validation$validate$pattern$Status$200 {
    "application/json": Schemas.dlp_validate_response;
}
export interface Response$dlp$pattern$validation$validate$pattern$Status$4XX {
    "application/json": Schemas.dlp_validate_response & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$payload$log$settings$get$settings {
    account_id: Schemas.dlp_identifier;
}
export interface Response$dlp$payload$log$settings$get$settings$Status$200 {
    "application/json": Schemas.dlp_get_settings_response;
}
export interface Response$dlp$payload$log$settings$get$settings$Status$4XX {
    "application/json": Schemas.dlp_get_settings_response & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$payload$log$settings$update$settings {
    account_id: Schemas.dlp_identifier;
}
export interface RequestBody$dlp$payload$log$settings$update$settings {
    "application/json": Schemas.dlp_update_settings;
}
export interface Response$dlp$payload$log$settings$update$settings$Status$200 {
    "application/json": Schemas.dlp_update_settings_response;
}
export interface Response$dlp$payload$log$settings$update$settings$Status$4XX {
    "application/json": Schemas.dlp_update_settings_response & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$profiles$list$all$profiles {
    account_id: Schemas.dlp_identifier;
}
export interface Response$dlp$profiles$list$all$profiles$Status$200 {
    "application/json": Schemas.dlp_response_collection;
}
export interface Response$dlp$profiles$list$all$profiles$Status$4XX {
    "application/json": Schemas.dlp_response_collection & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$profiles$get$dlp$profile {
    profile_id: Schemas.dlp_profile_id;
    account_id: Schemas.dlp_identifier;
}
export interface Response$dlp$profiles$get$dlp$profile$Status$200 {
    "application/json": Schemas.dlp_either_profile_response;
}
export interface Response$dlp$profiles$get$dlp$profile$Status$4XX {
    "application/json": Schemas.dlp_either_profile_response & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$profiles$create$custom$profiles {
    account_id: Schemas.dlp_identifier;
}
export interface RequestBody$dlp$profiles$create$custom$profiles {
    "application/json": Schemas.dlp_create_custom_profiles;
}
export interface Response$dlp$profiles$create$custom$profiles$Status$200 {
    "application/json": Schemas.dlp_create_custom_profile_response;
}
export interface Response$dlp$profiles$create$custom$profiles$Status$4XX {
    "application/json": Schemas.dlp_create_custom_profile_response & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$profiles$get$custom$profile {
    profile_id: Schemas.dlp_profile_id;
    account_id: Schemas.dlp_identifier;
}
export interface Response$dlp$profiles$get$custom$profile$Status$200 {
    "application/json": Schemas.dlp_custom_profile_response;
}
export interface Response$dlp$profiles$get$custom$profile$Status$4XX {
    "application/json": Schemas.dlp_custom_profile_response & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$profiles$update$custom$profile {
    profile_id: Schemas.dlp_profile_id;
    account_id: Schemas.dlp_identifier;
}
export interface RequestBody$dlp$profiles$update$custom$profile {
    "application/json": Schemas.dlp_update_custom_profile;
}
export interface Response$dlp$profiles$update$custom$profile$Status$200 {
    "application/json": Schemas.dlp_custom_profile;
}
export interface Response$dlp$profiles$update$custom$profile$Status$4XX {
    "application/json": Schemas.dlp_custom_profile & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$profiles$delete$custom$profile {
    profile_id: Schemas.dlp_profile_id;
    account_id: Schemas.dlp_identifier;
}
export interface Response$dlp$profiles$delete$custom$profile$Status$200 {
    "application/json": Schemas.dlp_api$response$single;
}
export interface Response$dlp$profiles$delete$custom$profile$Status$4XX {
    "application/json": Schemas.dlp_api$response$single & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$profiles$get$predefined$profile {
    profile_id: Schemas.dlp_profile_id;
    account_id: Schemas.dlp_identifier;
}
export interface Response$dlp$profiles$get$predefined$profile$Status$200 {
    "application/json": Schemas.dlp_predefined_profile_response;
}
export interface Response$dlp$profiles$get$predefined$profile$Status$4XX {
    "application/json": Schemas.dlp_predefined_profile_response & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dlp$profiles$update$predefined$profile {
    profile_id: Schemas.dlp_profile_id;
    account_id: Schemas.dlp_identifier;
}
export interface RequestBody$dlp$profiles$update$predefined$profile {
    "application/json": Schemas.dlp_update_predefined_profile;
}
export interface Response$dlp$profiles$update$predefined$profile$Status$200 {
    "application/json": Schemas.dlp_predefined_profile;
}
export interface Response$dlp$profiles$update$predefined$profile$Status$4XX {
    "application/json": Schemas.dlp_predefined_profile & Schemas.dlp_api$response$common$failure;
}
export interface Parameter$dns$firewall$list$dns$firewall$clusters {
    account_id: Schemas.dns$firewall_identifier;
    page?: number;
    per_page?: number;
}
export interface Response$dns$firewall$list$dns$firewall$clusters$Status$200 {
    "application/json": Schemas.dns$firewall_dns_firewall_response_collection;
}
export interface Response$dns$firewall$list$dns$firewall$clusters$Status$4XX {
    "application/json": Schemas.dns$firewall_dns_firewall_response_collection & Schemas.dns$firewall_api$response$common$failure;
}
export interface Parameter$dns$firewall$create$dns$firewall$cluster {
    account_id: Schemas.dns$firewall_identifier;
}
export interface RequestBody$dns$firewall$create$dns$firewall$cluster {
    "application/json": {
        attack_mitigation?: Schemas.dns$firewall_attack_mitigation;
        deprecate_any_requests?: Schemas.dns$firewall_deprecate_any_requests;
        ecs_fallback?: Schemas.dns$firewall_ecs_fallback;
        maximum_cache_ttl?: Schemas.dns$firewall_maximum_cache_ttl;
        minimum_cache_ttl?: Schemas.dns$firewall_minimum_cache_ttl;
        name: Schemas.dns$firewall_name;
        negative_cache_ttl?: Schemas.dns$firewall_negative_cache_ttl;
        /** Deprecated alias for "upstream_ips". */
        origin_ips?: any;
        ratelimit?: Schemas.dns$firewall_ratelimit;
        retries?: Schemas.dns$firewall_retries;
        upstream_ips: Schemas.dns$firewall_upstream_ips;
    };
}
export interface Response$dns$firewall$create$dns$firewall$cluster$Status$200 {
    "application/json": Schemas.dns$firewall_dns_firewall_single_response;
}
export interface Response$dns$firewall$create$dns$firewall$cluster$Status$4XX {
    "application/json": Schemas.dns$firewall_dns_firewall_single_response & Schemas.dns$firewall_api$response$common$failure;
}
export interface Parameter$dns$firewall$dns$firewall$cluster$details {
    dns_firewall_id: Schemas.dns$firewall_identifier;
    account_id: Schemas.dns$firewall_identifier;
}
export interface Response$dns$firewall$dns$firewall$cluster$details$Status$200 {
    "application/json": Schemas.dns$firewall_dns_firewall_single_response;
}
export interface Response$dns$firewall$dns$firewall$cluster$details$Status$4XX {
    "application/json": Schemas.dns$firewall_dns_firewall_single_response & Schemas.dns$firewall_api$response$common$failure;
}
export interface Parameter$dns$firewall$delete$dns$firewall$cluster {
    dns_firewall_id: Schemas.dns$firewall_identifier;
    account_id: Schemas.dns$firewall_identifier;
}
export interface Response$dns$firewall$delete$dns$firewall$cluster$Status$200 {
    "application/json": Schemas.dns$firewall_api$response$single & {
        result?: {
            id?: Schemas.dns$firewall_identifier;
        };
    };
}
export interface Response$dns$firewall$delete$dns$firewall$cluster$Status$4XX {
    "application/json": (Schemas.dns$firewall_api$response$single & {
        result?: {
            id?: Schemas.dns$firewall_identifier;
        };
    }) & Schemas.dns$firewall_api$response$common$failure;
}
export interface Parameter$dns$firewall$update$dns$firewall$cluster {
    dns_firewall_id: Schemas.dns$firewall_identifier;
    account_id: Schemas.dns$firewall_identifier;
}
export interface RequestBody$dns$firewall$update$dns$firewall$cluster {
    "application/json": Schemas.dns$firewall_schemas$dns$firewall;
}
export interface Response$dns$firewall$update$dns$firewall$cluster$Status$200 {
    "application/json": Schemas.dns$firewall_dns_firewall_single_response;
}
export interface Response$dns$firewall$update$dns$firewall$cluster$Status$4XX {
    "application/json": Schemas.dns$firewall_dns_firewall_single_response & Schemas.dns$firewall_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$get$zero$trust$account$information {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$accounts$get$zero$trust$account$information$Status$200 {
    "application/json": Schemas.zero$trust$gateway_gateway_account;
}
export interface Response$zero$trust$accounts$get$zero$trust$account$information$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_gateway_account & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$create$zero$trust$account {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$accounts$create$zero$trust$account$Status$200 {
    "application/json": Schemas.zero$trust$gateway_gateway_account;
}
export interface Response$zero$trust$accounts$create$zero$trust$account$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_gateway_account & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings {
    account_id: Schemas.zero$trust$gateway_schemas$identifier;
}
export interface Response$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings$Status$200 {
    "application/json": Schemas.zero$trust$gateway_app$types_components$schemas$response_collection;
}
export interface Response$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_app$types_components$schemas$response_collection & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$get$audit$ssh$settings {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$get$audit$ssh$settings$Status$200 {
    "application/json": Schemas.zero$trust$gateway_audit_ssh_settings_components$schemas$single_response;
}
export interface Response$zero$trust$get$audit$ssh$settings$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_audit_ssh_settings_components$schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$update$audit$ssh$settings {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$update$audit$ssh$settings {
    "application/json": {
        public_key: Schemas.zero$trust$gateway_public_key;
        seed_id?: Schemas.zero$trust$gateway_audit_ssh_settings_components$schemas$uuid;
    };
}
export interface Response$zero$trust$update$audit$ssh$settings$Status$200 {
    "application/json": Schemas.zero$trust$gateway_audit_ssh_settings_components$schemas$single_response;
}
export interface Response$zero$trust$update$audit$ssh$settings$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_audit_ssh_settings_components$schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$categories$list$categories {
    account_id: Schemas.zero$trust$gateway_schemas$identifier;
}
export interface Response$zero$trust$gateway$categories$list$categories$Status$200 {
    "application/json": Schemas.zero$trust$gateway_categories_components$schemas$response_collection;
}
export interface Response$zero$trust$gateway$categories$list$categories$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_categories_components$schemas$response_collection & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$get$zero$trust$account$configuration {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$accounts$get$zero$trust$account$configuration$Status$200 {
    "application/json": Schemas.zero$trust$gateway_gateway_account_config;
}
export interface Response$zero$trust$accounts$get$zero$trust$account$configuration$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_gateway_account_config & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$update$zero$trust$account$configuration {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$accounts$update$zero$trust$account$configuration {
    "application/json": Schemas.zero$trust$gateway_gateway$account$settings;
}
export interface Response$zero$trust$accounts$update$zero$trust$account$configuration$Status$200 {
    "application/json": Schemas.zero$trust$gateway_gateway_account_config;
}
export interface Response$zero$trust$accounts$update$zero$trust$account$configuration$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_gateway_account_config & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$patch$zero$trust$account$configuration {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$accounts$patch$zero$trust$account$configuration {
    "application/json": Schemas.zero$trust$gateway_gateway$account$settings;
}
export interface Response$zero$trust$accounts$patch$zero$trust$account$configuration$Status$200 {
    "application/json": Schemas.zero$trust$gateway_gateway_account_config;
}
export interface Response$zero$trust$accounts$patch$zero$trust$account$configuration$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_gateway_account_config & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$lists$list$zero$trust$lists {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$lists$list$zero$trust$lists$Status$200 {
    "application/json": Schemas.zero$trust$gateway_response_collection;
}
export interface Response$zero$trust$lists$list$zero$trust$lists$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_response_collection & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$lists$create$zero$trust$list {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$lists$create$zero$trust$list {
    "application/json": {
        description?: Schemas.zero$trust$gateway_description;
        items?: Schemas.zero$trust$gateway_items;
        name: Schemas.zero$trust$gateway_name;
        type: Schemas.zero$trust$gateway_type;
    };
}
export interface Response$zero$trust$lists$create$zero$trust$list$Status$200 {
    "application/json": Schemas.zero$trust$gateway_single_response_with_list_items;
}
export interface Response$zero$trust$lists$create$zero$trust$list$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_single_response_with_list_items & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$lists$zero$trust$list$details {
    list_id: Schemas.zero$trust$gateway_uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$lists$zero$trust$list$details$Status$200 {
    "application/json": Schemas.zero$trust$gateway_single_response;
}
export interface Response$zero$trust$lists$zero$trust$list$details$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$lists$update$zero$trust$list {
    list_id: Schemas.zero$trust$gateway_uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$lists$update$zero$trust$list {
    "application/json": {
        description?: Schemas.zero$trust$gateway_description;
        name: Schemas.zero$trust$gateway_name;
    };
}
export interface Response$zero$trust$lists$update$zero$trust$list$Status$200 {
    "application/json": Schemas.zero$trust$gateway_single_response;
}
export interface Response$zero$trust$lists$update$zero$trust$list$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$lists$delete$zero$trust$list {
    list_id: Schemas.zero$trust$gateway_uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$lists$delete$zero$trust$list$Status$200 {
    "application/json": Schemas.zero$trust$gateway_empty_response;
}
export interface Response$zero$trust$lists$delete$zero$trust$list$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_empty_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$lists$patch$zero$trust$list {
    list_id: Schemas.zero$trust$gateway_uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$lists$patch$zero$trust$list {
    "application/json": {
        append?: Schemas.zero$trust$gateway_items;
        /** A list of the item values you want to remove. */
        remove?: Schemas.zero$trust$gateway_value[];
    };
}
export interface Response$zero$trust$lists$patch$zero$trust$list$Status$200 {
    "application/json": Schemas.zero$trust$gateway_single_response;
}
export interface Response$zero$trust$lists$patch$zero$trust$list$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$lists$zero$trust$list$items {
    list_id: Schemas.zero$trust$gateway_uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$lists$zero$trust$list$items$Status$200 {
    "application/json": Schemas.zero$trust$gateway_list_item_response_collection;
}
export interface Response$zero$trust$lists$zero$trust$list$items$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_list_item_response_collection & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$locations$list$zero$trust$gateway$locations {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$locations$list$zero$trust$gateway$locations$Status$200 {
    "application/json": Schemas.zero$trust$gateway_schemas$response_collection;
}
export interface Response$zero$trust$gateway$locations$list$zero$trust$gateway$locations$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_schemas$response_collection & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$locations$create$zero$trust$gateway$location {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$gateway$locations$create$zero$trust$gateway$location {
    "application/json": {
        client_default?: Schemas.zero$trust$gateway_client$default;
        ecs_support?: Schemas.zero$trust$gateway_ecs$support;
        name: Schemas.zero$trust$gateway_schemas$name;
        networks?: Schemas.zero$trust$gateway_networks;
    };
}
export interface Response$zero$trust$gateway$locations$create$zero$trust$gateway$location$Status$200 {
    "application/json": Schemas.zero$trust$gateway_schemas$single_response;
}
export interface Response$zero$trust$gateway$locations$create$zero$trust$gateway$location$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$locations$zero$trust$gateway$location$details {
    location_id: Schemas.zero$trust$gateway_schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$locations$zero$trust$gateway$location$details$Status$200 {
    "application/json": Schemas.zero$trust$gateway_schemas$single_response;
}
export interface Response$zero$trust$gateway$locations$zero$trust$gateway$location$details$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$locations$update$zero$trust$gateway$location {
    location_id: Schemas.zero$trust$gateway_schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$gateway$locations$update$zero$trust$gateway$location {
    "application/json": {
        client_default?: Schemas.zero$trust$gateway_client$default;
        ecs_support?: Schemas.zero$trust$gateway_ecs$support;
        name: Schemas.zero$trust$gateway_schemas$name;
        networks?: Schemas.zero$trust$gateway_networks;
    };
}
export interface Response$zero$trust$gateway$locations$update$zero$trust$gateway$location$Status$200 {
    "application/json": Schemas.zero$trust$gateway_schemas$single_response;
}
export interface Response$zero$trust$gateway$locations$update$zero$trust$gateway$location$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$locations$delete$zero$trust$gateway$location {
    location_id: Schemas.zero$trust$gateway_schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$locations$delete$zero$trust$gateway$location$Status$200 {
    "application/json": Schemas.zero$trust$gateway_empty_response;
}
export interface Response$zero$trust$gateway$locations$delete$zero$trust$gateway$location$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_empty_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account$Status$200 {
    "application/json": Schemas.zero$trust$gateway_gateway$account$logging$settings$response;
}
export interface Response$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_gateway$account$logging$settings$response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account {
    "application/json": Schemas.zero$trust$gateway_gateway$account$logging$settings;
}
export interface Response$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account$Status$200 {
    "application/json": Schemas.zero$trust$gateway_gateway$account$logging$settings$response;
}
export interface Response$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_gateway$account$logging$settings$response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints$Status$200 {
    "application/json": Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$response_collection;
}
export interface Response$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$response_collection & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint {
    "application/json": {
        ips: Schemas.zero$trust$gateway_ips;
        name: Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$name;
        subdomain?: Schemas.zero$trust$gateway_schemas$subdomain;
    };
}
export interface Response$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint$Status$200 {
    "application/json": Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$single_response;
}
export interface Response$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details {
    proxy_endpoint_id: Schemas.zero$trust$gateway_schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details$Status$200 {
    "application/json": Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$single_response;
}
export interface Response$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint {
    proxy_endpoint_id: Schemas.zero$trust$gateway_schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint$Status$200 {
    "application/json": Schemas.zero$trust$gateway_empty_response;
}
export interface Response$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_empty_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint {
    proxy_endpoint_id: Schemas.zero$trust$gateway_schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint {
    "application/json": {
        ips?: Schemas.zero$trust$gateway_ips;
        name?: Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$name;
        subdomain?: Schemas.zero$trust$gateway_schemas$subdomain;
    };
}
export interface Response$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint$Status$200 {
    "application/json": Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$single_response;
}
export interface Response$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_proxy$endpoints_components$schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$rules$list$zero$trust$gateway$rules {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$rules$list$zero$trust$gateway$rules$Status$200 {
    "application/json": Schemas.zero$trust$gateway_components$schemas$response_collection;
}
export interface Response$zero$trust$gateway$rules$list$zero$trust$gateway$rules$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_components$schemas$response_collection & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$rules$create$zero$trust$gateway$rule {
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$gateway$rules$create$zero$trust$gateway$rule {
    "application/json": {
        action: Schemas.zero$trust$gateway_action;
        description?: Schemas.zero$trust$gateway_schemas$description;
        device_posture?: Schemas.zero$trust$gateway_device_posture;
        enabled?: Schemas.zero$trust$gateway_enabled;
        filters?: Schemas.zero$trust$gateway_filters;
        identity?: Schemas.zero$trust$gateway_identity;
        name: Schemas.zero$trust$gateway_components$schemas$name;
        precedence?: Schemas.zero$trust$gateway_precedence;
        rule_settings?: Schemas.zero$trust$gateway_rule$settings;
        schedule?: Schemas.zero$trust$gateway_schedule;
        traffic?: Schemas.zero$trust$gateway_traffic;
    };
}
export interface Response$zero$trust$gateway$rules$create$zero$trust$gateway$rule$Status$200 {
    "application/json": Schemas.zero$trust$gateway_components$schemas$single_response;
}
export interface Response$zero$trust$gateway$rules$create$zero$trust$gateway$rule$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_components$schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$rules$zero$trust$gateway$rule$details {
    rule_id: Schemas.zero$trust$gateway_components$schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$rules$zero$trust$gateway$rule$details$Status$200 {
    "application/json": Schemas.zero$trust$gateway_components$schemas$single_response;
}
export interface Response$zero$trust$gateway$rules$zero$trust$gateway$rule$details$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_components$schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$rules$update$zero$trust$gateway$rule {
    rule_id: Schemas.zero$trust$gateway_components$schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface RequestBody$zero$trust$gateway$rules$update$zero$trust$gateway$rule {
    "application/json": {
        action: Schemas.zero$trust$gateway_action;
        description?: Schemas.zero$trust$gateway_schemas$description;
        device_posture?: Schemas.zero$trust$gateway_device_posture;
        enabled?: Schemas.zero$trust$gateway_enabled;
        filters?: Schemas.zero$trust$gateway_filters;
        identity?: Schemas.zero$trust$gateway_identity;
        name: Schemas.zero$trust$gateway_components$schemas$name;
        precedence?: Schemas.zero$trust$gateway_precedence;
        rule_settings?: Schemas.zero$trust$gateway_rule$settings;
        schedule?: Schemas.zero$trust$gateway_schedule;
        traffic?: Schemas.zero$trust$gateway_traffic;
    };
}
export interface Response$zero$trust$gateway$rules$update$zero$trust$gateway$rule$Status$200 {
    "application/json": Schemas.zero$trust$gateway_components$schemas$single_response;
}
export interface Response$zero$trust$gateway$rules$update$zero$trust$gateway$rule$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_components$schemas$single_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$zero$trust$gateway$rules$delete$zero$trust$gateway$rule {
    rule_id: Schemas.zero$trust$gateway_components$schemas$uuid;
    account_id: Schemas.zero$trust$gateway_identifier;
}
export interface Response$zero$trust$gateway$rules$delete$zero$trust$gateway$rule$Status$200 {
    "application/json": Schemas.zero$trust$gateway_empty_response;
}
export interface Response$zero$trust$gateway$rules$delete$zero$trust$gateway$rule$Status$4XX {
    "application/json": Schemas.zero$trust$gateway_empty_response & Schemas.zero$trust$gateway_api$response$common$failure;
}
export interface Parameter$list$hyperdrive {
    account_id: Schemas.hyperdrive_identifier;
}
export interface Response$list$hyperdrive$Status$200 {
    "application/json": Schemas.hyperdrive_api$response$common & {
        result?: Schemas.hyperdrive_hyperdrive$with$identifier[];
    };
}
export interface Response$list$hyperdrive$Status$4XX {
    "application/json": (Schemas.hyperdrive_api$response$single & {
        result?: {} | null;
    }) & Schemas.hyperdrive_api$response$common$failure;
}
export interface Parameter$create$hyperdrive {
    account_id: Schemas.hyperdrive_identifier;
}
export interface RequestBody$create$hyperdrive {
    "application/json": Schemas.hyperdrive_hyperdrive$with$password;
}
export interface Response$create$hyperdrive$Status$200 {
    "application/json": Schemas.hyperdrive_api$response$single & {
        result?: Schemas.hyperdrive_hyperdrive$with$identifier;
    };
}
export interface Response$create$hyperdrive$Status$4XX {
    "application/json": (Schemas.hyperdrive_api$response$single & {
        result?: {} | null;
    }) & Schemas.hyperdrive_api$response$common$failure;
}
export interface Parameter$get$hyperdrive {
    account_id: Schemas.hyperdrive_identifier;
    hyperdrive_id: Schemas.hyperdrive_identifier;
}
export interface Response$get$hyperdrive$Status$200 {
    "application/json": Schemas.hyperdrive_api$response$single & {
        result?: Schemas.hyperdrive_hyperdrive$with$identifier;
    };
}
export interface Response$get$hyperdrive$Status$4XX {
    "application/json": (Schemas.hyperdrive_api$response$single & {
        result?: {} | null;
    }) & Schemas.hyperdrive_api$response$common$failure;
}
export interface Parameter$update$hyperdrive {
    account_id: Schemas.hyperdrive_identifier;
    hyperdrive_id: Schemas.hyperdrive_identifier;
}
export interface RequestBody$update$hyperdrive {
    "application/json": Schemas.hyperdrive_hyperdrive$with$password;
}
export interface Response$update$hyperdrive$Status$200 {
    "application/json": Schemas.hyperdrive_api$response$single & {
        result?: Schemas.hyperdrive_hyperdrive$with$identifier;
    };
}
export interface Response$update$hyperdrive$Status$4XX {
    "application/json": (Schemas.hyperdrive_api$response$single & {
        result?: {} | null;
    }) & Schemas.hyperdrive_api$response$common$failure;
}
export interface Parameter$delete$hyperdrive {
    account_id: Schemas.hyperdrive_identifier;
    hyperdrive_id: Schemas.hyperdrive_identifier;
}
export interface Response$delete$hyperdrive$Status$200 {
    "application/json": Schemas.hyperdrive_api$response$single & {
        result?: {} | null;
    };
}
export interface Response$delete$hyperdrive$Status$4XX {
    "application/json": (Schemas.hyperdrive_api$response$single & {
        result?: {} | null;
    }) & Schemas.hyperdrive_api$response$common$failure;
}
export interface Parameter$cloudflare$images$list$images {
    account_id: Schemas.images_account_identifier;
    page?: number;
    per_page?: number;
}
export interface Response$cloudflare$images$list$images$Status$200 {
    "application/json": Schemas.images_images_list_response;
}
export interface Response$cloudflare$images$list$images$Status$4XX {
    "application/json": Schemas.images_images_list_response & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$upload$an$image$via$url {
    account_id: Schemas.images_account_identifier;
}
export interface RequestBody$cloudflare$images$upload$an$image$via$url {
    "multipart/form-data": Schemas.images_image_basic_upload;
}
export interface Response$cloudflare$images$upload$an$image$via$url$Status$200 {
    "application/json": Schemas.images_image_response_single;
}
export interface Response$cloudflare$images$upload$an$image$via$url$Status$4XX {
    "application/json": Schemas.images_image_response_single & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$image$details {
    image_id: Schemas.images_image_identifier;
    account_id: Schemas.images_account_identifier;
}
export interface Response$cloudflare$images$image$details$Status$200 {
    "application/json": Schemas.images_image_response_single;
}
export interface Response$cloudflare$images$image$details$Status$4XX {
    "application/json": Schemas.images_image_response_single & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$delete$image {
    image_id: Schemas.images_image_identifier;
    account_id: Schemas.images_account_identifier;
}
export interface Response$cloudflare$images$delete$image$Status$200 {
    "application/json": Schemas.images_deleted_response;
}
export interface Response$cloudflare$images$delete$image$Status$4XX {
    "application/json": Schemas.images_deleted_response & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$update$image {
    image_id: Schemas.images_image_identifier;
    account_id: Schemas.images_account_identifier;
}
export interface RequestBody$cloudflare$images$update$image {
    "application/json": Schemas.images_image_patch_request;
}
export interface Response$cloudflare$images$update$image$Status$200 {
    "application/json": Schemas.images_image_response_single;
}
export interface Response$cloudflare$images$update$image$Status$4XX {
    "application/json": Schemas.images_image_response_single & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$base$image {
    image_id: Schemas.images_image_identifier;
    account_id: Schemas.images_account_identifier;
}
export interface Response$cloudflare$images$base$image$Status$200 {
    "image/*": Blob;
}
export interface Response$cloudflare$images$base$image$Status$4XX {
    "application/json": Schemas.images_image_response_blob & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$keys$list$signing$keys {
    account_id: Schemas.images_account_identifier;
}
export interface Response$cloudflare$images$keys$list$signing$keys$Status$200 {
    "application/json": Schemas.images_image_key_response_collection;
}
export interface Response$cloudflare$images$keys$list$signing$keys$Status$4XX {
    "application/json": Schemas.images_image_key_response_collection & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$images$usage$statistics {
    account_id: Schemas.images_account_identifier;
}
export interface Response$cloudflare$images$images$usage$statistics$Status$200 {
    "application/json": Schemas.images_images_stats_response;
}
export interface Response$cloudflare$images$images$usage$statistics$Status$4XX {
    "application/json": Schemas.images_images_stats_response & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$variants$list$variants {
    account_id: Schemas.images_account_identifier;
}
export interface Response$cloudflare$images$variants$list$variants$Status$200 {
    "application/json": Schemas.images_image_variant_list_response;
}
export interface Response$cloudflare$images$variants$list$variants$Status$4XX {
    "application/json": Schemas.images_image_variant_list_response & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$variants$create$a$variant {
    account_id: Schemas.images_account_identifier;
}
export interface RequestBody$cloudflare$images$variants$create$a$variant {
    "application/json": Schemas.images_image_variant_definition;
}
export interface Response$cloudflare$images$variants$create$a$variant$Status$200 {
    "application/json": Schemas.images_image_variant_simple_response;
}
export interface Response$cloudflare$images$variants$create$a$variant$Status$4XX {
    "application/json": Schemas.images_image_variant_simple_response & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$variants$variant$details {
    variant_id: Schemas.images_image_variant_identifier;
    account_id: Schemas.images_account_identifier;
}
export interface Response$cloudflare$images$variants$variant$details$Status$200 {
    "application/json": Schemas.images_image_variant_simple_response;
}
export interface Response$cloudflare$images$variants$variant$details$Status$4XX {
    "application/json": Schemas.images_image_variant_simple_response & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$variants$delete$a$variant {
    variant_id: Schemas.images_image_variant_identifier;
    account_id: Schemas.images_account_identifier;
}
export interface Response$cloudflare$images$variants$delete$a$variant$Status$200 {
    "application/json": Schemas.images_deleted_response;
}
export interface Response$cloudflare$images$variants$delete$a$variant$Status$4XX {
    "application/json": Schemas.images_deleted_response & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$variants$update$a$variant {
    variant_id: Schemas.images_image_variant_identifier;
    account_id: Schemas.images_account_identifier;
}
export interface RequestBody$cloudflare$images$variants$update$a$variant {
    "application/json": Schemas.images_image_variant_patch_request;
}
export interface Response$cloudflare$images$variants$update$a$variant$Status$200 {
    "application/json": Schemas.images_image_variant_simple_response;
}
export interface Response$cloudflare$images$variants$update$a$variant$Status$4XX {
    "application/json": Schemas.images_image_variant_simple_response & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$list$images$v2 {
    account_id: Schemas.images_account_identifier;
    continuation_token?: string | null;
    per_page?: number;
    sort_order?: "asc" | "desc";
}
export interface Response$cloudflare$images$list$images$v2$Status$200 {
    "application/json": Schemas.images_images_list_response_v2;
}
export interface Response$cloudflare$images$list$images$v2$Status$4XX {
    "application/json": Schemas.images_images_list_response_v2 & Schemas.images_api$response$common$failure;
}
export interface Parameter$cloudflare$images$create$authenticated$direct$upload$url$v$2 {
    account_id: Schemas.images_account_identifier;
}
export interface RequestBody$cloudflare$images$create$authenticated$direct$upload$url$v$2 {
    "multipart/form-data": Schemas.images_image_direct_upload_request_v2;
}
export interface Response$cloudflare$images$create$authenticated$direct$upload$url$v$2$Status$200 {
    "application/json": Schemas.images_image_direct_upload_response_v2;
}
export interface Response$cloudflare$images$create$authenticated$direct$upload$url$v$2$Status$4XX {
    "application/json": Schemas.images_image_direct_upload_response_v2 & Schemas.images_api$response$common$failure;
}
export interface Parameter$asn$intelligence$get$asn$overview {
    asn: Schemas.intel_schemas$asn;
    account_id: Schemas.intel_identifier;
}
export interface Response$asn$intelligence$get$asn$overview$Status$200 {
    "application/json": Schemas.intel_asn_components$schemas$response;
}
export interface Response$asn$intelligence$get$asn$overview$Status$4XX {
    "application/json": Schemas.intel_asn_components$schemas$response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$asn$intelligence$get$asn$subnets {
    asn: Schemas.intel_asn;
    account_id: Schemas.intel_identifier;
}
export interface Response$asn$intelligence$get$asn$subnets$Status$200 {
    "application/json": {
        asn?: Schemas.intel_asn;
        count?: Schemas.intel_count;
        ip_count_total?: number;
        page?: Schemas.intel_page;
        per_page?: Schemas.intel_per_page;
        subnets?: string[];
    };
}
export interface Response$asn$intelligence$get$asn$subnets$Status$4XX {
    "application/json": {
        asn?: Schemas.intel_asn;
        count?: Schemas.intel_count;
        ip_count_total?: number;
        page?: Schemas.intel_page;
        per_page?: Schemas.intel_per_page;
        subnets?: string[];
    } & Schemas.intel_api$response$common$failure;
}
export interface Parameter$passive$dns$by$ip$get$passive$dns$by$ip {
    account_id: Schemas.intel_identifier;
    start_end_params?: Schemas.intel_start_end_params;
    ipv4?: string;
    page?: number;
    per_page?: number;
}
export interface Response$passive$dns$by$ip$get$passive$dns$by$ip$Status$200 {
    "application/json": Schemas.intel_components$schemas$single_response;
}
export interface Response$passive$dns$by$ip$get$passive$dns$by$ip$Status$4XX {
    "application/json": Schemas.intel_components$schemas$single_response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$domain$intelligence$get$domain$details {
    account_id: Schemas.intel_identifier;
    domain?: string;
}
export interface Response$domain$intelligence$get$domain$details$Status$200 {
    "application/json": Schemas.intel_single_response;
}
export interface Response$domain$intelligence$get$domain$details$Status$4XX {
    "application/json": Schemas.intel_single_response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$domain$history$get$domain$history {
    account_id: Schemas.intel_identifier;
    domain?: any;
}
export interface Response$domain$history$get$domain$history$Status$200 {
    "application/json": Schemas.intel_response;
}
export interface Response$domain$history$get$domain$history$Status$4XX {
    "application/json": Schemas.intel_response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$domain$intelligence$get$multiple$domain$details {
    account_id: Schemas.intel_identifier;
    domain?: any;
}
export interface Response$domain$intelligence$get$multiple$domain$details$Status$200 {
    "application/json": Schemas.intel_collection_response;
}
export interface Response$domain$intelligence$get$multiple$domain$details$Status$4XX {
    "application/json": Schemas.intel_collection_response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$ip$intelligence$get$ip$overview {
    account_id: Schemas.intel_identifier;
    ipv4?: string;
    ipv6?: string;
}
export interface Response$ip$intelligence$get$ip$overview$Status$200 {
    "application/json": Schemas.intel_schemas$response;
}
export interface Response$ip$intelligence$get$ip$overview$Status$4XX {
    "application/json": Schemas.intel_schemas$response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$ip$list$get$ip$lists {
    account_id: Schemas.intel_identifier;
}
export interface Response$ip$list$get$ip$lists$Status$200 {
    "application/json": Schemas.intel_components$schemas$response;
}
export interface Response$ip$list$get$ip$lists$Status$4XX {
    "application/json": Schemas.intel_components$schemas$response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$miscategorization$create$miscategorization {
    account_id: Schemas.intel_identifier;
}
export interface RequestBody$miscategorization$create$miscategorization {
    "application/json": Schemas.intel_miscategorization;
}
export interface Response$miscategorization$create$miscategorization$Status$200 {
    "application/json": Schemas.intel_api$response$single;
}
export interface Response$miscategorization$create$miscategorization$Status$4XX {
    "application/json": Schemas.intel_api$response$single & Schemas.intel_api$response$common$failure;
}
export interface Parameter$whois$record$get$whois$record {
    account_id: Schemas.intel_identifier;
    domain?: string;
}
export interface Response$whois$record$get$whois$record$Status$200 {
    "application/json": Schemas.intel_schemas$single_response;
}
export interface Response$whois$record$get$whois$record$Status$4XX {
    "application/json": Schemas.intel_schemas$single_response & Schemas.intel_api$response$common$failure;
}
export interface Parameter$get$accounts$account_identifier$logpush$datasets$dataset$fields {
    dataset_id: Schemas.logpush_dataset;
    account_id: Schemas.logpush_identifier;
}
export interface Response$get$accounts$account_identifier$logpush$datasets$dataset$fields$Status$200 {
    "application/json": Schemas.logpush_logpush_field_response_collection;
}
export interface Response$get$accounts$account_identifier$logpush$datasets$dataset$fields$Status$4XX {
    "application/json": Schemas.logpush_logpush_field_response_collection & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$get$accounts$account_identifier$logpush$datasets$dataset$jobs {
    dataset_id: Schemas.logpush_dataset;
    account_id: Schemas.logpush_identifier;
}
export interface Response$get$accounts$account_identifier$logpush$datasets$dataset$jobs$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_collection;
}
export interface Response$get$accounts$account_identifier$logpush$datasets$dataset$jobs$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_collection & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$get$accounts$account_identifier$logpush$jobs {
    account_id: Schemas.logpush_identifier;
}
export interface Response$get$accounts$account_identifier$logpush$jobs$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_collection;
}
export interface Response$get$accounts$account_identifier$logpush$jobs$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_collection & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$accounts$account_identifier$logpush$jobs {
    account_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$accounts$account_identifier$logpush$jobs {
    "application/json": {
        dataset?: Schemas.logpush_dataset;
        destination_conf: Schemas.logpush_destination_conf;
        enabled?: Schemas.logpush_enabled;
        frequency?: Schemas.logpush_frequency;
        logpull_options?: Schemas.logpush_logpull_options;
        name?: Schemas.logpush_name;
        output_options?: Schemas.logpush_output_options;
        ownership_challenge?: Schemas.logpush_ownership_challenge;
    };
}
export interface Response$post$accounts$account_identifier$logpush$jobs$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_single;
}
export interface Response$post$accounts$account_identifier$logpush$jobs$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_single & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$get$accounts$account_identifier$logpush$jobs$job_identifier {
    job_id: Schemas.logpush_id;
    account_id: Schemas.logpush_identifier;
}
export interface Response$get$accounts$account_identifier$logpush$jobs$job_identifier$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_single;
}
export interface Response$get$accounts$account_identifier$logpush$jobs$job_identifier$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_single & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$put$accounts$account_identifier$logpush$jobs$job_identifier {
    job_id: Schemas.logpush_id;
    account_id: Schemas.logpush_identifier;
}
export interface RequestBody$put$accounts$account_identifier$logpush$jobs$job_identifier {
    "application/json": {
        destination_conf?: Schemas.logpush_destination_conf;
        enabled?: Schemas.logpush_enabled;
        frequency?: Schemas.logpush_frequency;
        logpull_options?: Schemas.logpush_logpull_options;
        output_options?: Schemas.logpush_output_options;
        ownership_challenge?: Schemas.logpush_ownership_challenge;
    };
}
export interface Response$put$accounts$account_identifier$logpush$jobs$job_identifier$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_single;
}
export interface Response$put$accounts$account_identifier$logpush$jobs$job_identifier$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_single & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$delete$accounts$account_identifier$logpush$jobs$job_identifier {
    job_id: Schemas.logpush_id;
    account_id: Schemas.logpush_identifier;
}
export interface Response$delete$accounts$account_identifier$logpush$jobs$job_identifier$Status$200 {
    "application/json": Schemas.logpush_api$response$common & {
        result?: {} | null;
    };
}
export interface Response$delete$accounts$account_identifier$logpush$jobs$job_identifier$Status$4XX {
    "application/json": (Schemas.logpush_api$response$common & {
        result?: {} | null;
    }) & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$accounts$account_identifier$logpush$ownership {
    account_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$accounts$account_identifier$logpush$ownership {
    "application/json": {
        destination_conf: Schemas.logpush_destination_conf;
    };
}
export interface Response$post$accounts$account_identifier$logpush$ownership$Status$200 {
    "application/json": Schemas.logpush_get_ownership_response;
}
export interface Response$post$accounts$account_identifier$logpush$ownership$Status$4XX {
    "application/json": Schemas.logpush_get_ownership_response & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$accounts$account_identifier$logpush$ownership$validate {
    account_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$accounts$account_identifier$logpush$ownership$validate {
    "application/json": {
        destination_conf: Schemas.logpush_destination_conf;
        ownership_challenge: Schemas.logpush_ownership_challenge;
    };
}
export interface Response$post$accounts$account_identifier$logpush$ownership$validate$Status$200 {
    "application/json": Schemas.logpush_validate_ownership_response;
}
export interface Response$post$accounts$account_identifier$logpush$ownership$validate$Status$4XX {
    "application/json": Schemas.logpush_validate_ownership_response & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$delete$accounts$account_identifier$logpush$validate$destination$exists {
    account_id: Schemas.logpush_identifier;
}
export interface RequestBody$delete$accounts$account_identifier$logpush$validate$destination$exists {
    "application/json": {
        destination_conf: Schemas.logpush_destination_conf;
    };
}
export interface Response$delete$accounts$account_identifier$logpush$validate$destination$exists$Status$200 {
    "application/json": Schemas.logpush_destination_exists_response;
}
export interface Response$delete$accounts$account_identifier$logpush$validate$destination$exists$Status$4XX {
    "application/json": Schemas.logpush_destination_exists_response & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$accounts$account_identifier$logpush$validate$origin {
    account_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$accounts$account_identifier$logpush$validate$origin {
    "application/json": {
        logpull_options: Schemas.logpush_logpull_options;
    };
}
export interface Response$post$accounts$account_identifier$logpush$validate$origin$Status$200 {
    "application/json": Schemas.logpush_validate_response;
}
export interface Response$post$accounts$account_identifier$logpush$validate$origin$Status$4XX {
    "application/json": Schemas.logpush_validate_response & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$get$accounts$account_identifier$logs$control$cmb$config {
    account_id: Schemas.logcontrol_identifier;
}
export interface Response$get$accounts$account_identifier$logs$control$cmb$config$Status$200 {
    "application/json": Schemas.logcontrol_cmb_config_response_single;
}
export interface Response$get$accounts$account_identifier$logs$control$cmb$config$Status$4XX {
    "application/json": Schemas.logcontrol_api$response$common$failure;
}
export interface Parameter$put$accounts$account_identifier$logs$control$cmb$config {
    account_id: Schemas.logcontrol_identifier;
}
export interface RequestBody$put$accounts$account_identifier$logs$control$cmb$config {
    "application/json": Schemas.logcontrol_cmb_config;
}
export interface Response$put$accounts$account_identifier$logs$control$cmb$config$Status$200 {
    "application/json": Schemas.logcontrol_cmb_config_response_single;
}
export interface Response$put$accounts$account_identifier$logs$control$cmb$config$Status$4XX {
    "application/json": Schemas.logcontrol_api$response$common$failure;
}
export interface Parameter$delete$accounts$account_identifier$logs$control$cmb$config {
    account_id: Schemas.logcontrol_identifier;
}
export interface Response$delete$accounts$account_identifier$logs$control$cmb$config$Status$200 {
    "application/json": Schemas.logcontrol_api$response$common & {
        result?: {} | null;
    };
}
export interface Response$delete$accounts$account_identifier$logs$control$cmb$config$Status$4XX {
    "application/json": (Schemas.logcontrol_api$response$common & {
        result?: {} | null;
    }) & Schemas.logcontrol_api$response$common$failure;
}
export interface Parameter$pages$project$get$projects {
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$project$get$projects$Status$200 {
    "application/json": Schemas.pages_projects$response;
}
export interface Response$pages$project$get$projects$Status$4XX {
    "application/json": Schemas.pages_projects$response & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$project$create$project {
    account_id: Schemas.pages_identifier;
}
export interface RequestBody$pages$project$create$project {
    "application/json": Schemas.pages_projects;
}
export interface Response$pages$project$create$project$Status$200 {
    "application/json": Schemas.pages_new$project$response;
}
export interface Response$pages$project$create$project$Status$4XX {
    "application/json": Schemas.pages_new$project$response & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$project$get$project {
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$project$get$project$Status$200 {
    "application/json": Schemas.pages_project$response;
}
export interface Response$pages$project$get$project$Status$4XX {
    "application/json": Schemas.pages_project$response & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$project$delete$project {
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$project$delete$project$Status$200 {
    "application/json": any;
}
export interface Response$pages$project$delete$project$Status$4XX {
    "application/json": any & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$project$update$project {
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface RequestBody$pages$project$update$project {
    "application/json": Schemas.pages_project$patch;
}
export interface Response$pages$project$update$project$Status$200 {
    "application/json": Schemas.pages_new$project$response;
}
export interface Response$pages$project$update$project$Status$4XX {
    "application/json": Schemas.pages_new$project$response & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$deployment$get$deployments {
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$deployment$get$deployments$Status$200 {
    "application/json": Schemas.pages_deployment$list$response;
}
export interface Response$pages$deployment$get$deployments$Status$4XX {
    "application/json": Schemas.pages_deployment$list$response & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$deployment$create$deployment {
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface RequestBody$pages$deployment$create$deployment {
    "multipart/form-data": {
        /** The branch to build the new deployment from. The \`HEAD\` of the branch will be used. If omitted, the production branch will be used by default. */
        branch?: string;
    };
}
export interface Response$pages$deployment$create$deployment$Status$200 {
    "application/json": Schemas.pages_deployment$new$deployment;
}
export interface Response$pages$deployment$create$deployment$Status$4XX {
    "application/json": Schemas.pages_deployment$new$deployment & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$deployment$get$deployment$info {
    deployment_id: Schemas.pages_identifier;
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$deployment$get$deployment$info$Status$200 {
    "application/json": Schemas.pages_deployment$response$details;
}
export interface Response$pages$deployment$get$deployment$info$Status$4XX {
    "application/json": Schemas.pages_deployment$response$details & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$deployment$delete$deployment {
    deployment_id: Schemas.pages_identifier;
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$deployment$delete$deployment$Status$200 {
    "application/json": any;
}
export interface Response$pages$deployment$delete$deployment$Status$4XX {
    "application/json": any & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$deployment$get$deployment$logs {
    deployment_id: Schemas.pages_identifier;
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$deployment$get$deployment$logs$Status$200 {
    "application/json": Schemas.pages_deployment$response$logs;
}
export interface Response$pages$deployment$get$deployment$logs$Status$4XX {
    "application/json": Schemas.pages_deployment$response$logs & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$deployment$retry$deployment {
    deployment_id: Schemas.pages_identifier;
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$deployment$retry$deployment$Status$200 {
    "application/json": Schemas.pages_deployment$new$deployment;
}
export interface Response$pages$deployment$retry$deployment$Status$4XX {
    "application/json": Schemas.pages_deployment$new$deployment & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$deployment$rollback$deployment {
    deployment_id: Schemas.pages_identifier;
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$deployment$rollback$deployment$Status$200 {
    "application/json": Schemas.pages_deployment$response$details;
}
export interface Response$pages$deployment$rollback$deployment$Status$4XX {
    "application/json": Schemas.pages_deployment$response$details & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$domains$get$domains {
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$domains$get$domains$Status$200 {
    "application/json": Schemas.pages_domain$response$collection;
}
export interface Response$pages$domains$get$domains$Status$4XX {
    "application/json": Schemas.pages_domain$response$collection & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$domains$add$domain {
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface RequestBody$pages$domains$add$domain {
    "application/json": Schemas.pages_domains$post;
}
export interface Response$pages$domains$add$domain$Status$200 {
    "application/json": Schemas.pages_domain$response$single;
}
export interface Response$pages$domains$add$domain$Status$4XX {
    "application/json": Schemas.pages_domain$response$single & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$domains$get$domain {
    domain_name: Schemas.pages_domain_name;
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$domains$get$domain$Status$200 {
    "application/json": Schemas.pages_domain$response$single;
}
export interface Response$pages$domains$get$domain$Status$4XX {
    "application/json": Schemas.pages_domain$response$single & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$domains$delete$domain {
    domain_name: Schemas.pages_domain_name;
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$domains$delete$domain$Status$200 {
    "application/json": any;
}
export interface Response$pages$domains$delete$domain$Status$4xx {
    "application/json": any & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$domains$patch$domain {
    domain_name: Schemas.pages_domain_name;
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$domains$patch$domain$Status$200 {
    "application/json": Schemas.pages_domain$response$single;
}
export interface Response$pages$domains$patch$domain$Status$4XX {
    "application/json": Schemas.pages_domain$response$single & Schemas.pages_api$response$common$failure;
}
export interface Parameter$pages$purge$build$cache {
    project_name: Schemas.pages_project_name;
    account_id: Schemas.pages_identifier;
}
export interface Response$pages$purge$build$cache$Status$200 {
    "application/json": any;
}
export interface Response$pages$purge$build$cache$Status$4XX {
    "application/json": Schemas.pages_api$response$common$failure;
}
export interface Parameter$r2$list$buckets {
    account_id: Schemas.r2_account_identifier;
    name_contains?: string;
    start_after?: string;
    per_page?: number;
    order?: "name";
    direction?: "asc" | "desc";
    cursor?: string;
}
export interface Response$r2$list$buckets$Status$200 {
    "application/json": Schemas.r2_v4_response_list & {
        result?: Schemas.r2_bucket[];
    };
}
export interface Response$r2$list$buckets$Status$4XX {
    "application/json": Schemas.r2_v4_response_failure;
}
export interface Parameter$r2$create$bucket {
    account_id: Schemas.r2_account_identifier;
}
export interface RequestBody$r2$create$bucket {
    "application/json": {
        locationHint?: Schemas.r2_bucket_location;
        name: Schemas.r2_bucket_name;
    };
}
export interface Response$r2$create$bucket$Status$200 {
    "application/json": Schemas.r2_v4_response & {
        result?: Schemas.r2_bucket;
    };
}
export interface Response$r2$create$bucket$Status$4XX {
    "application/json": Schemas.r2_v4_response_failure;
}
export interface Parameter$r2$get$bucket {
    account_id: Schemas.r2_account_identifier;
    bucket_name: Schemas.r2_bucket_name;
}
export interface Response$r2$get$bucket$Status$200 {
    "application/json": Schemas.r2_v4_response & {
        result?: Schemas.r2_bucket;
    };
}
export interface Response$r2$get$bucket$Status$4XX {
    "application/json": Schemas.r2_v4_response_failure;
}
export interface Parameter$r2$delete$bucket {
    bucket_name: Schemas.r2_bucket_name;
    account_id: Schemas.r2_account_identifier;
}
export interface Response$r2$delete$bucket$Status$200 {
    "application/json": Schemas.r2_v4_response;
}
export interface Response$r2$delete$bucket$Status$4XX {
    "application/json": Schemas.r2_v4_response_failure;
}
export interface Parameter$r2$get$bucket$sippy$config {
    account_id: Schemas.r2_account_identifier;
    bucket_name: Schemas.r2_bucket_name;
}
export interface Response$r2$get$bucket$sippy$config$Status$200 {
    "application/json": Schemas.r2_v4_response & {
        result?: Schemas.r2_sippy;
    };
}
export interface Response$r2$get$bucket$sippy$config$Status$4XX {
    "application/json": Schemas.r2_v4_response_failure;
}
export interface Parameter$r2$put$bucket$sippy$config {
    account_id: Schemas.r2_account_identifier;
    bucket_name: Schemas.r2_bucket_name;
}
export interface RequestBody$r2$put$bucket$sippy$config {
    "application/json": Schemas.r2_enable_sippy_aws | Schemas.r2_enable_sippy_gcs;
}
export interface Response$r2$put$bucket$sippy$config$Status$200 {
    "application/json": Schemas.r2_v4_response & {
        result?: Schemas.r2_sippy;
    };
}
export interface Response$r2$put$bucket$sippy$config$Status$4XX {
    "application/json": Schemas.r2_v4_response_failure;
}
export interface Parameter$r2$delete$bucket$sippy$config {
    bucket_name: Schemas.r2_bucket_name;
    account_id: Schemas.r2_account_identifier;
}
export interface Response$r2$delete$bucket$sippy$config$Status$200 {
    "application/json": Schemas.r2_v4_response & {
        result?: {
            enabled?: false;
        };
    };
}
export interface Response$r2$delete$bucket$sippy$config$Status$4XX {
    "application/json": Schemas.r2_v4_response_failure;
}
export interface Parameter$registrar$domains$list$domains {
    account_id: Schemas.registrar$api_identifier;
}
export interface Response$registrar$domains$list$domains$Status$200 {
    "application/json": Schemas.registrar$api_domain_response_collection;
}
export interface Response$registrar$domains$list$domains$Status$4XX {
    "application/json": Schemas.registrar$api_domain_response_collection & Schemas.registrar$api_api$response$common$failure;
}
export interface Parameter$registrar$domains$get$domain {
    domain_name: Schemas.registrar$api_domain_name;
    account_id: Schemas.registrar$api_identifier;
}
export interface Response$registrar$domains$get$domain$Status$200 {
    "application/json": Schemas.registrar$api_domain_response_single;
}
export interface Response$registrar$domains$get$domain$Status$4XX {
    "application/json": Schemas.registrar$api_domain_response_single & Schemas.registrar$api_api$response$common$failure;
}
export interface Parameter$registrar$domains$update$domain {
    domain_name: Schemas.registrar$api_domain_name;
    account_id: Schemas.registrar$api_identifier;
}
export interface RequestBody$registrar$domains$update$domain {
    "application/json": Schemas.registrar$api_domain_update_properties;
}
export interface Response$registrar$domains$update$domain$Status$200 {
    "application/json": Schemas.registrar$api_domain_response_single;
}
export interface Response$registrar$domains$update$domain$Status$4XX {
    "application/json": Schemas.registrar$api_domain_response_single & Schemas.registrar$api_api$response$common$failure;
}
export interface Parameter$lists$get$lists {
    account_id: Schemas.lists_identifier;
}
export interface Response$lists$get$lists$Status$200 {
    "application/json": Schemas.lists_lists$response$collection;
}
export interface Response$lists$get$lists$Status$4XX {
    "application/json": Schemas.lists_lists$response$collection & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$create$a$list {
    account_id: Schemas.lists_identifier;
}
export interface RequestBody$lists$create$a$list {
    "application/json": {
        description?: Schemas.lists_description;
        kind: Schemas.lists_kind;
        name: Schemas.lists_name;
    };
}
export interface Response$lists$create$a$list$Status$200 {
    "application/json": Schemas.lists_list$response$collection;
}
export interface Response$lists$create$a$list$Status$4XX {
    "application/json": Schemas.lists_list$response$collection & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$get$a$list {
    list_id: Schemas.lists_list_id;
    account_id: Schemas.lists_identifier;
}
export interface Response$lists$get$a$list$Status$200 {
    "application/json": Schemas.lists_list$response$collection;
}
export interface Response$lists$get$a$list$Status$4XX {
    "application/json": Schemas.lists_list$response$collection & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$update$a$list {
    list_id: Schemas.lists_list_id;
    account_id: Schemas.lists_identifier;
}
export interface RequestBody$lists$update$a$list {
    "application/json": {
        description?: Schemas.lists_description;
    };
}
export interface Response$lists$update$a$list$Status$200 {
    "application/json": Schemas.lists_list$response$collection;
}
export interface Response$lists$update$a$list$Status$4XX {
    "application/json": Schemas.lists_list$response$collection & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$delete$a$list {
    list_id: Schemas.lists_list_id;
    account_id: Schemas.lists_identifier;
}
export interface Response$lists$delete$a$list$Status$200 {
    "application/json": Schemas.lists_list$delete$response$collection;
}
export interface Response$lists$delete$a$list$Status$4XX {
    "application/json": Schemas.lists_list$delete$response$collection & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$get$list$items {
    list_id: Schemas.lists_list_id;
    account_id: Schemas.lists_identifier;
    cursor?: string;
    per_page?: number;
    search?: string;
}
export interface Response$lists$get$list$items$Status$200 {
    "application/json": Schemas.lists_items$list$response$collection;
}
export interface Response$lists$get$list$items$Status$4XX {
    "application/json": Schemas.lists_items$list$response$collection & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$update$all$list$items {
    list_id: Schemas.lists_list_id;
    account_id: Schemas.lists_identifier;
}
export interface RequestBody$lists$update$all$list$items {
    "application/json": Schemas.lists_items$update$request$collection;
}
export interface Response$lists$update$all$list$items$Status$200 {
    "application/json": Schemas.lists_lists$async$response;
}
export interface Response$lists$update$all$list$items$Status$4XX {
    "application/json": Schemas.lists_lists$async$response & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$create$list$items {
    list_id: Schemas.lists_list_id;
    account_id: Schemas.lists_identifier;
}
export interface RequestBody$lists$create$list$items {
    "application/json": Schemas.lists_items$update$request$collection;
}
export interface Response$lists$create$list$items$Status$200 {
    "application/json": Schemas.lists_lists$async$response;
}
export interface Response$lists$create$list$items$Status$4XX {
    "application/json": Schemas.lists_lists$async$response & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$delete$list$items {
    list_id: Schemas.lists_list_id;
    account_id: Schemas.lists_identifier;
}
export interface RequestBody$lists$delete$list$items {
    "application/json": {
        items?: {
            id?: Schemas.lists_item_id;
        }[];
    };
}
export interface Response$lists$delete$list$items$Status$200 {
    "application/json": Schemas.lists_lists$async$response;
}
export interface Response$lists$delete$list$items$Status$4XX {
    "application/json": Schemas.lists_lists$async$response & Schemas.lists_api$response$common$failure;
}
export interface Parameter$listAccountRulesets {
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$listAccountRulesets$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetsResponse;
    };
}
export interface Response$listAccountRulesets$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$createAccountRuleset {
    account_id: Schemas.rulesets_AccountId;
}
export interface RequestBody$createAccountRuleset {
    "application/json": Schemas.rulesets_CreateRulesetRequest;
}
export interface Response$createAccountRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$createAccountRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$getAccountRuleset {
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$getAccountRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$getAccountRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$updateAccountRuleset {
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface RequestBody$updateAccountRuleset {
    "application/json": Schemas.rulesets_UpdateRulesetRequest;
}
export interface Response$updateAccountRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$updateAccountRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$deleteAccountRuleset {
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$deleteAccountRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$createAccountRulesetRule {
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface RequestBody$createAccountRulesetRule {
    "application/json": Schemas.rulesets_CreateOrUpdateRuleRequest;
}
export interface Response$createAccountRulesetRule$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$createAccountRulesetRule$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$deleteAccountRulesetRule {
    rule_id: Schemas.rulesets_RuleId;
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$deleteAccountRulesetRule$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$deleteAccountRulesetRule$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$updateAccountRulesetRule {
    rule_id: Schemas.rulesets_RuleId;
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface RequestBody$updateAccountRulesetRule {
    "application/json": Schemas.rulesets_CreateOrUpdateRuleRequest;
}
export interface Response$updateAccountRulesetRule$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$updateAccountRulesetRule$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$listAccountRulesetVersions {
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$listAccountRulesetVersions$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetsResponse;
    };
}
export interface Response$listAccountRulesetVersions$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$getAccountRulesetVersion {
    ruleset_version: Schemas.rulesets_RulesetVersion;
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$getAccountRulesetVersion$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$getAccountRulesetVersion$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$deleteAccountRulesetVersion {
    ruleset_version: Schemas.rulesets_RulesetVersion;
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$deleteAccountRulesetVersion$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$listAccountRulesetVersionRulesByTag {
    rule_tag: Schemas.rulesets_RuleCategory;
    ruleset_version: Schemas.rulesets_RulesetVersion;
    ruleset_id: Schemas.rulesets_RulesetId;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$listAccountRulesetVersionRulesByTag$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$listAccountRulesetVersionRulesByTag$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$getAccountEntrypointRuleset {
    ruleset_phase: Schemas.rulesets_RulesetPhase;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$getAccountEntrypointRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$getAccountEntrypointRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$updateAccountEntrypointRuleset {
    ruleset_phase: Schemas.rulesets_RulesetPhase;
    account_id: Schemas.rulesets_AccountId;
}
export interface RequestBody$updateAccountEntrypointRuleset {
    "application/json": Schemas.rulesets_UpdateRulesetRequest;
}
export interface Response$updateAccountEntrypointRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$updateAccountEntrypointRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$listAccountEntrypointRulesetVersions {
    ruleset_phase: Schemas.rulesets_RulesetPhase;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$listAccountEntrypointRulesetVersions$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetsResponse;
    };
}
export interface Response$listAccountEntrypointRulesetVersions$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$getAccountEntrypointRulesetVersion {
    ruleset_version: Schemas.rulesets_RulesetVersion;
    ruleset_phase: Schemas.rulesets_RulesetPhase;
    account_id: Schemas.rulesets_AccountId;
}
export interface Response$getAccountEntrypointRulesetVersion$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$getAccountEntrypointRulesetVersion$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$stream$videos$list$videos {
    account_id: Schemas.stream_account_identifier;
    status?: Schemas.stream_media_state;
    creator?: Schemas.stream_creator;
    type?: Schemas.stream_type;
    asc?: Schemas.stream_asc;
    search?: Schemas.stream_search;
    start?: Schemas.stream_start;
    end?: Schemas.stream_end;
    include_counts?: Schemas.stream_include_counts;
}
export interface Response$stream$videos$list$videos$Status$200 {
    "application/json": Schemas.stream_video_response_collection;
}
export interface Response$stream$videos$list$videos$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$videos$initiate$video$uploads$using$tus {
    "Tus-Resumable": Schemas.stream_tus_resumable;
    "Upload-Creator"?: Schemas.stream_creator;
    "Upload-Length": Schemas.stream_upload_length;
    "Upload-Metadata"?: Schemas.stream_upload_metadata;
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$videos$initiate$video$uploads$using$tus$Status$200 {
}
export interface Response$stream$videos$initiate$video$uploads$using$tus$Status$4XX {
}
export interface Parameter$stream$videos$retrieve$video$details {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$videos$retrieve$video$details$Status$200 {
    "application/json": Schemas.stream_video_response_single;
}
export interface Response$stream$videos$retrieve$video$details$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$videos$update$video$details {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_account_identifier;
}
export interface RequestBody$stream$videos$update$video$details {
    "application/json": Schemas.stream_video_update;
}
export interface Response$stream$videos$update$video$details$Status$200 {
    "application/json": Schemas.stream_video_response_single;
}
export interface Response$stream$videos$update$video$details$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$videos$delete$video {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$videos$delete$video$Status$200 {
}
export interface Response$stream$videos$delete$video$Status$4XX {
}
export interface Parameter$list$audio$tracks {
    account_id: Schemas.stream_account_identifier;
    identifier: Schemas.stream_identifier;
}
export interface Response$list$audio$tracks$Status$200 {
    "application/json": Schemas.stream_listAudioTrackResponse;
}
export interface Response$list$audio$tracks$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$delete$audio$tracks {
    account_id: Schemas.stream_account_identifier;
    identifier: Schemas.stream_identifier;
    audio_identifier: Schemas.stream_audio_identifier;
}
export interface Response$delete$audio$tracks$Status$200 {
    "application/json": Schemas.stream_deleted_response;
}
export interface Response$delete$audio$tracks$Status$4XX {
    "application/json": Schemas.stream_deleted_response;
}
export interface Parameter$edit$audio$tracks {
    account_id: Schemas.stream_account_identifier;
    identifier: Schemas.stream_identifier;
    audio_identifier: Schemas.stream_audio_identifier;
}
export interface RequestBody$edit$audio$tracks {
    "application/json": Schemas.stream_editAudioTrack;
}
export interface Response$edit$audio$tracks$Status$200 {
    "application/json": Schemas.stream_addAudioTrackResponse;
}
export interface Response$edit$audio$tracks$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$add$audio$track {
    account_id: Schemas.stream_account_identifier;
    identifier: Schemas.stream_identifier;
}
export interface RequestBody$add$audio$track {
    "application/json": Schemas.stream_copyAudioTrack;
}
export interface Response$add$audio$track$Status$200 {
    "application/json": Schemas.stream_addAudioTrackResponse;
}
export interface Response$add$audio$track$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$subtitles$$captions$list$captions$or$subtitles {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$subtitles$$captions$list$captions$or$subtitles$Status$200 {
    "application/json": Schemas.stream_language_response_collection;
}
export interface Response$stream$subtitles$$captions$list$captions$or$subtitles$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$subtitles$$captions$upload$captions$or$subtitles {
    language: Schemas.stream_language;
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface RequestBody$stream$subtitles$$captions$upload$captions$or$subtitles {
    "multipart/form-data": Schemas.stream_caption_basic_upload;
}
export interface Response$stream$subtitles$$captions$upload$captions$or$subtitles$Status$200 {
    "application/json": Schemas.stream_language_response_single;
}
export interface Response$stream$subtitles$$captions$upload$captions$or$subtitles$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$subtitles$$captions$delete$captions$or$subtitles {
    language: Schemas.stream_language;
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$subtitles$$captions$delete$captions$or$subtitles$Status$200 {
    "application/json": Schemas.stream_api$response$common & {
        result?: string;
    };
}
export interface Response$stream$subtitles$$captions$delete$captions$or$subtitles$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$m$p$4$downloads$list$downloads {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$m$p$4$downloads$list$downloads$Status$200 {
    "application/json": Schemas.stream_downloads_response;
}
export interface Response$stream$m$p$4$downloads$list$downloads$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$m$p$4$downloads$create$downloads {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$m$p$4$downloads$create$downloads$Status$200 {
    "application/json": Schemas.stream_downloads_response;
}
export interface Response$stream$m$p$4$downloads$create$downloads$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$m$p$4$downloads$delete$downloads {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$m$p$4$downloads$delete$downloads$Status$200 {
    "application/json": Schemas.stream_deleted_response;
}
export interface Response$stream$m$p$4$downloads$delete$downloads$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$videos$retreieve$embed$code$html {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$videos$retreieve$embed$code$html$Status$200 {
    "application/json": any;
}
export interface Response$stream$videos$retreieve$embed$code$html$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$videos$create$signed$url$tokens$for$videos {
    identifier: Schemas.stream_identifier;
    account_id: Schemas.stream_account_identifier;
}
export interface RequestBody$stream$videos$create$signed$url$tokens$for$videos {
    "application/json": Schemas.stream_signed_token_request;
}
export interface Response$stream$videos$create$signed$url$tokens$for$videos$Status$200 {
    "application/json": Schemas.stream_signed_token_response;
}
export interface Response$stream$videos$create$signed$url$tokens$for$videos$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$video$clipping$clip$videos$given$a$start$and$end$time {
    account_id: Schemas.stream_account_identifier;
}
export interface RequestBody$stream$video$clipping$clip$videos$given$a$start$and$end$time {
    "application/json": Schemas.stream_videoClipStandard;
}
export interface Response$stream$video$clipping$clip$videos$given$a$start$and$end$time$Status$200 {
    "application/json": Schemas.stream_clipResponseSingle;
}
export interface Response$stream$video$clipping$clip$videos$given$a$start$and$end$time$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$videos$upload$videos$from$a$url {
    account_id: Schemas.stream_account_identifier;
    "Upload-Creator"?: Schemas.stream_creator;
    "Upload-Metadata"?: Schemas.stream_upload_metadata;
}
export interface RequestBody$stream$videos$upload$videos$from$a$url {
    "application/json": Schemas.stream_video_copy_request;
}
export interface Response$stream$videos$upload$videos$from$a$url$Status$200 {
    "application/json": Schemas.stream_video_response_single;
}
export interface Response$stream$videos$upload$videos$from$a$url$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$videos$upload$videos$via$direct$upload$ur$ls {
    account_id: Schemas.stream_account_identifier;
    "Upload-Creator"?: Schemas.stream_creator;
}
export interface RequestBody$stream$videos$upload$videos$via$direct$upload$ur$ls {
    "application/json": Schemas.stream_direct_upload_request;
}
export interface Response$stream$videos$upload$videos$via$direct$upload$ur$ls$Status$200 {
    "application/json": Schemas.stream_direct_upload_response;
}
export interface Response$stream$videos$upload$videos$via$direct$upload$ur$ls$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$signing$keys$list$signing$keys {
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$signing$keys$list$signing$keys$Status$200 {
    "application/json": Schemas.stream_key_response_collection;
}
export interface Response$stream$signing$keys$list$signing$keys$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$signing$keys$create$signing$keys {
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$signing$keys$create$signing$keys$Status$200 {
    "application/json": Schemas.stream_key_generation_response;
}
export interface Response$stream$signing$keys$create$signing$keys$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$signing$keys$delete$signing$keys {
    identifier: Schemas.stream_schemas$identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$signing$keys$delete$signing$keys$Status$200 {
    "application/json": Schemas.stream_deleted_response;
}
export interface Response$stream$signing$keys$delete$signing$keys$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$live$inputs$list$live$inputs {
    account_id: Schemas.stream_schemas$identifier;
    include_counts?: Schemas.stream_include_counts;
}
export interface Response$stream$live$inputs$list$live$inputs$Status$200 {
    "application/json": Schemas.stream_live_input_response_collection;
}
export interface Response$stream$live$inputs$list$live$inputs$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$live$inputs$create$a$live$input {
    account_id: Schemas.stream_schemas$identifier;
}
export interface RequestBody$stream$live$inputs$create$a$live$input {
    "application/json": Schemas.stream_create_input_request;
}
export interface Response$stream$live$inputs$create$a$live$input$Status$200 {
    "application/json": Schemas.stream_live_input_response_single;
}
export interface Response$stream$live$inputs$create$a$live$input$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$live$inputs$retrieve$a$live$input {
    live_input_identifier: Schemas.stream_live_input_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$live$inputs$retrieve$a$live$input$Status$200 {
    "application/json": Schemas.stream_live_input_response_single;
}
export interface Response$stream$live$inputs$retrieve$a$live$input$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$live$inputs$update$a$live$input {
    live_input_identifier: Schemas.stream_live_input_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface RequestBody$stream$live$inputs$update$a$live$input {
    "application/json": Schemas.stream_update_input_request;
}
export interface Response$stream$live$inputs$update$a$live$input$Status$200 {
    "application/json": Schemas.stream_live_input_response_single;
}
export interface Response$stream$live$inputs$update$a$live$input$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$live$inputs$delete$a$live$input {
    live_input_identifier: Schemas.stream_live_input_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$live$inputs$delete$a$live$input$Status$200 {
}
export interface Response$stream$live$inputs$delete$a$live$input$Status$4XX {
}
export interface Parameter$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input {
    live_input_identifier: Schemas.stream_live_input_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input$Status$200 {
    "application/json": Schemas.stream_output_response_collection;
}
export interface Response$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$live$inputs$create$a$new$output$$connected$to$a$live$input {
    live_input_identifier: Schemas.stream_live_input_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface RequestBody$stream$live$inputs$create$a$new$output$$connected$to$a$live$input {
    "application/json": Schemas.stream_create_output_request;
}
export interface Response$stream$live$inputs$create$a$new$output$$connected$to$a$live$input$Status$200 {
    "application/json": Schemas.stream_output_response_single;
}
export interface Response$stream$live$inputs$create$a$new$output$$connected$to$a$live$input$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$live$inputs$update$an$output {
    output_identifier: Schemas.stream_output_identifier;
    live_input_identifier: Schemas.stream_live_input_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface RequestBody$stream$live$inputs$update$an$output {
    "application/json": Schemas.stream_update_output_request;
}
export interface Response$stream$live$inputs$update$an$output$Status$200 {
    "application/json": Schemas.stream_output_response_single;
}
export interface Response$stream$live$inputs$update$an$output$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$live$inputs$delete$an$output {
    output_identifier: Schemas.stream_output_identifier;
    live_input_identifier: Schemas.stream_live_input_identifier;
    account_id: Schemas.stream_schemas$identifier;
}
export interface Response$stream$live$inputs$delete$an$output$Status$200 {
}
export interface Response$stream$live$inputs$delete$an$output$Status$4XX {
}
export interface Parameter$stream$videos$storage$usage {
    account_id: Schemas.stream_account_identifier;
    creator?: Schemas.stream_creator;
}
export interface Response$stream$videos$storage$usage$Status$200 {
    "application/json": Schemas.stream_storage_use_response;
}
export interface Response$stream$videos$storage$usage$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$watermark$profile$list$watermark$profiles {
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$watermark$profile$list$watermark$profiles$Status$200 {
    "application/json": Schemas.stream_watermark_response_collection;
}
export interface Response$stream$watermark$profile$list$watermark$profiles$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$watermark$profile$create$watermark$profiles$via$basic$upload {
    account_id: Schemas.stream_account_identifier;
}
export interface RequestBody$stream$watermark$profile$create$watermark$profiles$via$basic$upload {
    "multipart/form-data": Schemas.stream_watermark_basic_upload;
}
export interface Response$stream$watermark$profile$create$watermark$profiles$via$basic$upload$Status$200 {
    "application/json": Schemas.stream_watermark_response_single;
}
export interface Response$stream$watermark$profile$create$watermark$profiles$via$basic$upload$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$watermark$profile$watermark$profile$details {
    identifier: Schemas.stream_watermark_identifier;
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$watermark$profile$watermark$profile$details$Status$200 {
    "application/json": Schemas.stream_watermark_response_single;
}
export interface Response$stream$watermark$profile$watermark$profile$details$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$watermark$profile$delete$watermark$profiles {
    identifier: Schemas.stream_watermark_identifier;
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$watermark$profile$delete$watermark$profiles$Status$200 {
    "application/json": Schemas.stream_api$response$single & {
        result?: string;
    };
}
export interface Response$stream$watermark$profile$delete$watermark$profiles$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$webhook$view$webhooks {
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$webhook$view$webhooks$Status$200 {
    "application/json": Schemas.stream_webhook_response_single;
}
export interface Response$stream$webhook$view$webhooks$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$webhook$create$webhooks {
    account_id: Schemas.stream_account_identifier;
}
export interface RequestBody$stream$webhook$create$webhooks {
    "application/json": Schemas.stream_webhook_request;
}
export interface Response$stream$webhook$create$webhooks$Status$200 {
    "application/json": Schemas.stream_webhook_response_single;
}
export interface Response$stream$webhook$create$webhooks$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$stream$webhook$delete$webhooks {
    account_id: Schemas.stream_account_identifier;
}
export interface Response$stream$webhook$delete$webhooks$Status$200 {
    "application/json": Schemas.stream_deleted_response;
}
export interface Response$stream$webhook$delete$webhooks$Status$4XX {
    "application/json": Schemas.stream_api$response$common$failure;
}
export interface Parameter$tunnel$route$list$tunnel$routes {
    account_id: Schemas.tunnel_cf_account_id;
    comment?: Schemas.tunnel_comment;
    is_deleted?: any;
    network_subset?: any;
    network_superset?: any;
    existed_at?: any;
    tunnel_id?: any;
    route_id?: Schemas.tunnel_route_id;
    tun_types?: Schemas.tunnel_tunnel_types;
    virtual_network_id?: any;
    per_page?: Schemas.tunnel_per_page;
    page?: number;
}
export interface Response$tunnel$route$list$tunnel$routes$Status$200 {
    "application/json": Schemas.tunnel_teamnet_response_collection;
}
export interface Response$tunnel$route$list$tunnel$routes$Status$4XX {
    "application/json": Schemas.tunnel_teamnet_response_collection & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$route$create$a$tunnel$route {
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$tunnel$route$create$a$tunnel$route {
    "application/json": {
        comment?: Schemas.tunnel_comment;
        ip_network: Schemas.tunnel_ip_network;
        tunnel_id: Schemas.tunnel_tunnel_id;
        virtual_network_id?: Schemas.tunnel_route_virtual_network_id;
    };
}
export interface Response$tunnel$route$create$a$tunnel$route$Status$200 {
    "application/json": Schemas.tunnel_route_response_single;
}
export interface Response$tunnel$route$create$a$tunnel$route$Status$4XX {
    "application/json": Schemas.tunnel_route_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$route$delete$a$tunnel$route {
    route_id: Schemas.tunnel_route_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$tunnel$route$delete$a$tunnel$route$Status$200 {
    "application/json": Schemas.tunnel_route_response_single;
}
export interface Response$tunnel$route$delete$a$tunnel$route$Status$4XX {
    "application/json": Schemas.tunnel_route_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$route$update$a$tunnel$route {
    route_id: Schemas.tunnel_route_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$tunnel$route$update$a$tunnel$route {
    "application/json": {
        comment?: Schemas.tunnel_comment;
        network?: Schemas.tunnel_ip_network;
        tun_type?: Schemas.tunnel_tunnel_type;
        tunnel_id?: Schemas.tunnel_route_tunnel_id;
        virtual_network_id?: Schemas.tunnel_route_virtual_network_id;
    };
}
export interface Response$tunnel$route$update$a$tunnel$route$Status$200 {
    "application/json": Schemas.tunnel_route_response_single;
}
export interface Response$tunnel$route$update$a$tunnel$route$Status$4XX {
    "application/json": Schemas.tunnel_route_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$route$get$tunnel$route$by$ip {
    ip: Schemas.tunnel_ip;
    account_id: Schemas.tunnel_cf_account_id;
    virtual_network_id?: Schemas.tunnel_route_virtual_network_id;
}
export interface Response$tunnel$route$get$tunnel$route$by$ip$Status$200 {
    "application/json": Schemas.tunnel_teamnet_response_single;
}
export interface Response$tunnel$route$get$tunnel$route$by$ip$Status$4XX {
    "application/json": Schemas.tunnel_teamnet_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$route$create$a$tunnel$route$with$cidr {
    ip_network_encoded: Schemas.tunnel_ip_network_encoded;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$tunnel$route$create$a$tunnel$route$with$cidr {
    "application/json": {
        comment?: Schemas.tunnel_comment;
        tunnel_id: Schemas.tunnel_tunnel_id;
        virtual_network_id?: Schemas.tunnel_route_virtual_network_id;
    };
}
export interface Response$tunnel$route$create$a$tunnel$route$with$cidr$Status$200 {
    "application/json": Schemas.tunnel_route_response_single;
}
export interface Response$tunnel$route$create$a$tunnel$route$with$cidr$Status$4XX {
    "application/json": Schemas.tunnel_route_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$route$delete$a$tunnel$route$with$cidr {
    ip_network_encoded: Schemas.tunnel_ip_network_encoded;
    account_id: Schemas.tunnel_cf_account_id;
    virtual_network_id?: Schemas.tunnel_vnet_id;
    tun_type?: Schemas.tunnel_tunnel_type;
    tunnel_id?: Schemas.tunnel_tunnel_id;
}
export interface Response$tunnel$route$delete$a$tunnel$route$with$cidr$Status$200 {
    "application/json": Schemas.tunnel_route_response_single;
}
export interface Response$tunnel$route$delete$a$tunnel$route$with$cidr$Status$4XX {
    "application/json": Schemas.tunnel_route_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$route$update$a$tunnel$route$with$cidr {
    ip_network_encoded: Schemas.tunnel_ip_network_encoded;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$tunnel$route$update$a$tunnel$route$with$cidr$Status$200 {
    "application/json": Schemas.tunnel_route_response_single;
}
export interface Response$tunnel$route$update$a$tunnel$route$with$cidr$Status$4XX {
    "application/json": Schemas.tunnel_route_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$virtual$network$list$virtual$networks {
    account_id: Schemas.tunnel_cf_account_id;
    name?: Schemas.tunnel_vnet_name;
    is_default?: any;
    is_deleted?: any;
    vnet_name?: Schemas.tunnel_vnet_name;
    vnet_id?: string;
}
export interface Response$tunnel$virtual$network$list$virtual$networks$Status$200 {
    "application/json": Schemas.tunnel_vnet_response_collection;
}
export interface Response$tunnel$virtual$network$list$virtual$networks$Status$4XX {
    "application/json": Schemas.tunnel_vnet_response_collection & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$virtual$network$create$a$virtual$network {
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$tunnel$virtual$network$create$a$virtual$network {
    "application/json": {
        comment?: Schemas.tunnel_schemas$comment;
        is_default?: Schemas.tunnel_is_default_network;
        name: Schemas.tunnel_vnet_name;
    };
}
export interface Response$tunnel$virtual$network$create$a$virtual$network$Status$200 {
    "application/json": Schemas.tunnel_vnet_response_single;
}
export interface Response$tunnel$virtual$network$create$a$virtual$network$Status$4XX {
    "application/json": Schemas.tunnel_vnet_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$virtual$network$delete$a$virtual$network {
    virtual_network_id: Schemas.tunnel_vnet_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$tunnel$virtual$network$delete$a$virtual$network$Status$200 {
    "application/json": Schemas.tunnel_vnet_response_single;
}
export interface Response$tunnel$virtual$network$delete$a$virtual$network$Status$4XX {
    "application/json": Schemas.tunnel_vnet_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$tunnel$virtual$network$update$a$virtual$network {
    virtual_network_id: Schemas.tunnel_vnet_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$tunnel$virtual$network$update$a$virtual$network {
    "application/json": {
        comment?: Schemas.tunnel_schemas$comment;
        is_default_network?: Schemas.tunnel_is_default_network;
        name?: Schemas.tunnel_vnet_name;
    };
}
export interface Response$tunnel$virtual$network$update$a$virtual$network$Status$200 {
    "application/json": Schemas.tunnel_vnet_response_single;
}
export interface Response$tunnel$virtual$network$update$a$virtual$network$Status$4XX {
    "application/json": Schemas.tunnel_vnet_response_single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$list$all$tunnels {
    account_id: Schemas.tunnel_cf_account_id;
    name?: string;
    is_deleted?: boolean;
    existed_at?: Schemas.tunnel_existed_at;
    uuid?: Schemas.tunnel_tunnel_id;
    was_active_at?: Date;
    was_inactive_at?: Date;
    include_prefix?: string;
    exclude_prefix?: string;
    tun_types?: Schemas.tunnel_tunnel_types;
    per_page?: Schemas.tunnel_per_page;
    page?: number;
}
export interface Response$cloudflare$tunnel$list$all$tunnels$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$collection;
}
export interface Response$cloudflare$tunnel$list$all$tunnels$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$collection & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$argo$tunnel$create$an$argo$tunnel {
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$argo$tunnel$create$an$argo$tunnel {
    "application/json": {
        name: Schemas.tunnel_tunnel_name;
        /** Sets the password required to run the tunnel. Must be at least 32 bytes and encoded as a base64 string. */
        tunnel_secret: any;
    };
}
export interface Response$argo$tunnel$create$an$argo$tunnel$Status$200 {
    "application/json": Schemas.tunnel_legacy$tunnel$response$single;
}
export interface Response$argo$tunnel$create$an$argo$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_legacy$tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$argo$tunnel$get$an$argo$tunnel {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$argo$tunnel$get$an$argo$tunnel$Status$200 {
    "application/json": Schemas.tunnel_legacy$tunnel$response$single;
}
export interface Response$argo$tunnel$get$an$argo$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_legacy$tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$argo$tunnel$delete$an$argo$tunnel {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$argo$tunnel$delete$an$argo$tunnel {
    "application/json": {};
}
export interface Response$argo$tunnel$delete$an$argo$tunnel$Status$200 {
    "application/json": Schemas.tunnel_legacy$tunnel$response$single;
}
export interface Response$argo$tunnel$delete$an$argo$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_legacy$tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$argo$tunnel$clean$up$argo$tunnel$connections {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$argo$tunnel$clean$up$argo$tunnel$connections {
    "application/json": {};
}
export interface Response$argo$tunnel$clean$up$argo$tunnel$connections$Status$200 {
    "application/json": Schemas.tunnel_empty_response;
}
export interface Response$argo$tunnel$clean$up$argo$tunnel$connections$Status$4XX {
    "application/json": Schemas.tunnel_empty_response & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$list$warp$connector$tunnels {
    account_id: Schemas.tunnel_cf_account_id;
    name?: string;
    is_deleted?: boolean;
    existed_at?: Schemas.tunnel_existed_at;
    uuid?: Schemas.tunnel_tunnel_id;
    was_active_at?: Date;
    was_inactive_at?: Date;
    include_prefix?: string;
    exclude_prefix?: string;
    per_page?: Schemas.tunnel_per_page;
    page?: number;
}
export interface Response$cloudflare$tunnel$list$warp$connector$tunnels$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$collection;
}
export interface Response$cloudflare$tunnel$list$warp$connector$tunnels$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$collection & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$create$a$warp$connector$tunnel {
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$cloudflare$tunnel$create$a$warp$connector$tunnel {
    "application/json": {
        name: Schemas.tunnel_tunnel_name;
    };
}
export interface Response$cloudflare$tunnel$create$a$warp$connector$tunnel$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$single;
}
export interface Response$cloudflare$tunnel$create$a$warp$connector$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$get$a$warp$connector$tunnel {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$cloudflare$tunnel$get$a$warp$connector$tunnel$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$single;
}
export interface Response$cloudflare$tunnel$get$a$warp$connector$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$delete$a$warp$connector$tunnel {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$cloudflare$tunnel$delete$a$warp$connector$tunnel {
    "application/json": {};
}
export interface Response$cloudflare$tunnel$delete$a$warp$connector$tunnel$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$single;
}
export interface Response$cloudflare$tunnel$delete$a$warp$connector$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$update$a$warp$connector$tunnel {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$cloudflare$tunnel$update$a$warp$connector$tunnel {
    "application/json": {
        name?: Schemas.tunnel_tunnel_name;
        tunnel_secret?: Schemas.tunnel_tunnel_secret;
    };
}
export interface Response$cloudflare$tunnel$update$a$warp$connector$tunnel$Status$200 {
    "application/json": Schemas.tunnel_tunnel$response$single;
}
export interface Response$cloudflare$tunnel$update$a$warp$connector$tunnel$Status$4XX {
    "application/json": Schemas.tunnel_tunnel$response$single & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$cloudflare$tunnel$get$a$warp$connector$tunnel$token {
    tunnel_id: Schemas.tunnel_tunnel_id;
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$cloudflare$tunnel$get$a$warp$connector$tunnel$token$Status$200 {
    "application/json": Schemas.tunnel_tunnel_response_token;
}
export interface Response$cloudflare$tunnel$get$a$warp$connector$tunnel$token$Status$4XX {
    "application/json": Schemas.tunnel_tunnel_response_token & Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$worker$account$settings$fetch$worker$account$settings {
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$account$settings$fetch$worker$account$settings$Status$200 {
    "application/json": Schemas.workers_account$settings$response;
}
export interface Response$worker$account$settings$fetch$worker$account$settings$Status$4XX {
    "application/json": Schemas.workers_account$settings$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$account$settings$create$worker$account$settings {
    account_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$account$settings$create$worker$account$settings {
    "application/json": any;
}
export interface Response$worker$account$settings$create$worker$account$settings$Status$200 {
    "application/json": Schemas.workers_account$settings$response;
}
export interface Response$worker$account$settings$create$worker$account$settings$Status$4XX {
    "application/json": Schemas.workers_account$settings$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$deployments$list$deployments {
    script_id: Schemas.workers_script_identifier;
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$deployments$list$deployments$Status$200 {
    "application/json": Schemas.workers_deployments$list$response;
}
export interface Response$worker$deployments$list$deployments$Status$4XX {
    "application/json": Schemas.workers_deployments$list$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$deployments$get$deployment$detail {
    deployment_id: Schemas.workers_deployment_identifier;
    script_id: Schemas.workers_script_identifier;
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$deployments$get$deployment$detail$Status$200 {
    "application/json": Schemas.workers_deployments$single$response;
}
export interface Response$worker$deployments$get$deployment$detail$Status$4XX {
    "application/json": Schemas.workers_deployments$single$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$namespace$worker$script$worker$details {
    account_id: Schemas.workers_identifier;
    dispatch_namespace: Schemas.workers_dispatch_namespace_name;
    script_name: Schemas.workers_script_name;
}
export interface Response$namespace$worker$script$worker$details$Status$200 {
    "application/json": Schemas.workers_namespace$script$response$single;
}
export interface Response$namespace$worker$script$worker$details$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$namespace$worker$script$upload$worker$module {
    account_id: Schemas.workers_identifier;
    dispatch_namespace: Schemas.workers_dispatch_namespace_name;
    script_name: Schemas.workers_script_name;
}
export type RequestBody$namespace$worker$script$upload$worker$module = RequestBodies.workers_script_upload.Content;
export type Response$namespace$worker$script$upload$worker$module$Status$200 = Responses.workers_200.Content;
export type Response$namespace$worker$script$upload$worker$module$Status$4XX = Responses.workers_4XX.Content;
export interface Parameter$namespace$worker$script$delete$worker {
    account_id: Schemas.workers_identifier;
    dispatch_namespace: Schemas.workers_dispatch_namespace_name;
    script_name: Schemas.workers_script_name;
    /** If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script. */
    force?: boolean;
}
export interface Response$namespace$worker$script$delete$worker$Status$200 {
}
export interface Response$namespace$worker$script$delete$worker$Status$4XX {
}
export interface Parameter$namespace$worker$get$script$content {
    account_id: Schemas.workers_identifier;
    dispatch_namespace: Schemas.workers_dispatch_namespace_name;
    script_name: Schemas.workers_script_name;
}
export interface Response$namespace$worker$get$script$content$Status$200 {
    string: any;
}
export interface Response$namespace$worker$get$script$content$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$namespace$worker$put$script$content {
    account_id: Schemas.workers_identifier;
    dispatch_namespace: Schemas.workers_dispatch_namespace_name;
    script_name: Schemas.workers_script_name;
    /** The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part. */
    "CF-WORKER-BODY-PART"?: string;
    /** The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part. */
    "CF-WORKER-MAIN-MODULE-PART"?: string;
}
export interface RequestBody$namespace$worker$put$script$content {
    "multipart/form-data": {
        /** A module comprising a Worker script, often a javascript file. Multiple modules may be provided as separate named parts, but at least one module must be present. This should be referenced either in the metadata as \`main_module\` (esm)/\`body_part\` (service worker) or as a header \`CF-WORKER-MAIN-MODULE-PART\` (esm) /\`CF-WORKER-BODY-PART\` (service worker) by part name. */
        "<any part name>"?: (Blob)[];
        /** JSON encoded metadata about the uploaded parts and Worker configuration. */
        metadata?: {
            /** Name of the part in the multipart request that contains the script (e.g. the file adding a listener to the \`fetch\` event). Indicates a \`service worker syntax\` Worker. */
            body_part?: string;
            /** Name of the part in the multipart request that contains the main module (e.g. the file exporting a \`fetch\` handler). Indicates a \`module syntax\` Worker. */
            main_module?: string;
        };
    };
}
export interface Response$namespace$worker$put$script$content$Status$200 {
    "application/json": Schemas.workers_script$response$single;
}
export interface Response$namespace$worker$put$script$content$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$namespace$worker$get$script$settings {
    account_id: Schemas.workers_identifier;
    dispatch_namespace: Schemas.workers_dispatch_namespace_name;
    script_name: Schemas.workers_script_name;
}
export interface Response$namespace$worker$get$script$settings$Status$200 {
    "application/json": Schemas.workers_script$settings$response;
}
export interface Response$namespace$worker$get$script$settings$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$namespace$worker$patch$script$settings {
    account_id: Schemas.workers_identifier;
    dispatch_namespace: Schemas.workers_dispatch_namespace_name;
    script_name: Schemas.workers_script_name;
}
export interface RequestBody$namespace$worker$patch$script$settings {
    "application/json": Schemas.workers_script$settings$response;
}
export interface Response$namespace$worker$patch$script$settings$Status$200 {
    "application/json": Schemas.workers_script$settings$response;
}
export interface Response$namespace$worker$patch$script$settings$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$worker$domain$list$domains {
    account_id: Schemas.workers_account_identifier;
    zone_name?: Schemas.workers_zone_name;
    service?: Schemas.workers_schemas$service;
    zone_id?: Schemas.workers_zone_identifier;
    hostname?: string;
    environment?: string;
}
export interface Response$worker$domain$list$domains$Status$200 {
    "application/json": Schemas.workers_domain$response$collection;
}
export interface Response$worker$domain$list$domains$Status$4XX {
    "application/json": Schemas.workers_domain$response$collection & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$domain$attach$to$domain {
    account_id: Schemas.workers_account_identifier;
}
export interface RequestBody$worker$domain$attach$to$domain {
    "application/json": {
        environment: Schemas.workers_schemas$environment;
        hostname: Schemas.workers_hostname;
        service: Schemas.workers_schemas$service;
        zone_id: Schemas.workers_zone_identifier;
    };
}
export interface Response$worker$domain$attach$to$domain$Status$200 {
    "application/json": Schemas.workers_domain$response$single;
}
export interface Response$worker$domain$attach$to$domain$Status$4XX {
    "application/json": Schemas.workers_domain$response$single & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$domain$get$a$domain {
    domain_id: Schemas.workers_domain_identifier;
    account_id: Schemas.workers_account_identifier;
}
export interface Response$worker$domain$get$a$domain$Status$200 {
    "application/json": Schemas.workers_domain$response$single;
}
export interface Response$worker$domain$get$a$domain$Status$4XX {
    "application/json": Schemas.workers_domain$response$single & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$domain$detach$from$domain {
    domain_id: Schemas.workers_domain_identifier;
    account_id: Schemas.workers_account_identifier;
}
export interface Response$worker$domain$detach$from$domain$Status$200 {
}
export interface Response$worker$domain$detach$from$domain$Status$4XX {
}
export interface Parameter$durable$objects$namespace$list$namespaces {
    account_id: Schemas.workers_identifier;
}
export interface Response$durable$objects$namespace$list$namespaces$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        result?: Schemas.workers_namespace[];
    };
}
export interface Response$durable$objects$namespace$list$namespaces$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        result?: Schemas.workers_namespace[];
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$durable$objects$namespace$list$objects {
    id: Schemas.workers_schemas$id;
    account_id: Schemas.workers_identifier;
    limit?: number;
    cursor?: string;
}
export interface Response$durable$objects$namespace$list$objects$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        result?: Schemas.workers_object[];
        result_info?: {
            /** Total results returned based on your list parameters. */
            count?: number;
            cursor?: Schemas.workers_cursor;
        };
    };
}
export interface Response$durable$objects$namespace$list$objects$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        result?: Schemas.workers_object[];
        result_info?: {
            /** Total results returned based on your list parameters. */
            count?: number;
            cursor?: Schemas.workers_cursor;
        };
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$list$queues {
    account_id: Schemas.workers_identifier;
}
export interface Response$queue$list$queues$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        errors?: {}[] | null;
    } & {
        messages?: {}[] | null;
    } & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
            total_pages?: any;
        };
    } & {
        result?: Schemas.workers_queue[];
    };
}
export interface Response$queue$list$queues$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        errors?: {}[] | null;
    } & {
        messages?: {}[] | null;
    } & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
            total_pages?: any;
        };
    } & {
        result?: Schemas.workers_queue[];
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$create$queue {
    account_id: Schemas.workers_identifier;
}
export interface RequestBody$queue$create$queue {
    "application/json": any;
}
export interface Response$queue$create$queue$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        result?: Schemas.workers_queue_created;
    };
}
export interface Response$queue$create$queue$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        result?: Schemas.workers_queue_created;
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$queue$details {
    name: Schemas.workers_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$queue$queue$details$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        result?: Schemas.workers_queue;
    };
}
export interface Response$queue$queue$details$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        result?: Schemas.workers_queue;
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$update$queue {
    name: Schemas.workers_name;
    account_id: Schemas.workers_identifier;
}
export interface RequestBody$queue$update$queue {
    "application/json": any;
}
export interface Response$queue$update$queue$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        result?: Schemas.workers_queue_updated;
    };
}
export interface Response$queue$update$queue$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        result?: Schemas.workers_queue_updated;
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$delete$queue {
    name: Schemas.workers_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$queue$delete$queue$Status$200 {
    "application/json": Schemas.workers_api$response$collection & ({
        result?: {}[] | null;
    } | null);
}
export interface Response$queue$delete$queue$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & ({
        result?: {}[] | null;
    } | null)) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$list$queue$consumers {
    name: Schemas.workers_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$queue$list$queue$consumers$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        errors?: {}[] | null;
    } & {
        messages?: {}[] | null;
    } & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
            total_pages?: any;
        };
    } & {
        result?: Schemas.workers_consumer[];
    };
}
export interface Response$queue$list$queue$consumers$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        errors?: {}[] | null;
    } & {
        messages?: {}[] | null;
    } & {
        result_info?: {
            count?: any;
            page?: any;
            per_page?: any;
            total_count?: any;
            total_pages?: any;
        };
    } & {
        result?: Schemas.workers_consumer[];
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$create$queue$consumer {
    name: Schemas.workers_name;
    account_id: Schemas.workers_identifier;
}
export interface RequestBody$queue$create$queue$consumer {
    "application/json": any;
}
export interface Response$queue$create$queue$consumer$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        result?: Schemas.workers_consumer_created;
    };
}
export interface Response$queue$create$queue$consumer$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        result?: Schemas.workers_consumer_created;
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$update$queue$consumer {
    consumer_name: Schemas.workers_consumer_name;
    name: Schemas.workers_name;
    account_id: Schemas.workers_identifier;
}
export interface RequestBody$queue$update$queue$consumer {
    "application/json": any;
}
export interface Response$queue$update$queue$consumer$Status$200 {
    "application/json": Schemas.workers_api$response$collection & {
        result?: Schemas.workers_consumer_updated;
    };
}
export interface Response$queue$update$queue$consumer$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & {
        result?: Schemas.workers_consumer_updated;
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$queue$delete$queue$consumer {
    consumer_name: Schemas.workers_consumer_name;
    name: Schemas.workers_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$queue$delete$queue$consumer$Status$200 {
    "application/json": Schemas.workers_api$response$collection & ({
        result?: {}[] | null;
    } | null);
}
export interface Response$queue$delete$queue$consumer$Status$4XX {
    "application/json": (Schemas.workers_api$response$collection & ({
        result?: {}[] | null;
    } | null)) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$list$workers {
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$script$list$workers$Status$200 {
    "application/json": Schemas.workers_script$response$collection;
}
export interface Response$worker$script$list$workers$Status$4XX {
    "application/json": Schemas.workers_script$response$collection & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$download$worker {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$script$download$worker$Status$200 {
    undefined: any;
}
export interface Response$worker$script$download$worker$Status$4XX {
    undefined: any;
}
export interface Parameter$worker$script$upload$worker$module {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
    /** Rollback to provided deployment based on deployment ID. Request body will only parse a "message" part. You can learn more about deployments [here](https://developers.cloudflare.com/workers/platform/deployments/). */
    rollback_to?: Schemas.workers_uuid;
}
export type RequestBody$worker$script$upload$worker$module = RequestBodies.workers_script_upload.Content;
export interface Response$worker$script$upload$worker$module$Status$200 {
    "application/json": Schemas.workers_script$response$single & any;
}
export interface Response$worker$script$upload$worker$module$Status$4XX {
    "application/json": any & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$delete$worker {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
    /** If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script. */
    force?: boolean;
}
export interface Response$worker$script$delete$worker$Status$200 {
}
export interface Response$worker$script$delete$worker$Status$4XX {
}
export interface Parameter$worker$script$put$content {
    account_id: Schemas.workers_identifier;
    script_name: Schemas.workers_script_name;
    /** The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part. */
    "CF-WORKER-BODY-PART"?: string;
    /** The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part. */
    "CF-WORKER-MAIN-MODULE-PART"?: string;
}
export interface RequestBody$worker$script$put$content {
    "multipart/form-data": {
        /** A module comprising a Worker script, often a javascript file. Multiple modules may be provided as separate named parts, but at least one module must be present. This should be referenced either in the metadata as \`main_module\` (esm)/\`body_part\` (service worker) or as a header \`CF-WORKER-MAIN-MODULE-PART\` (esm) /\`CF-WORKER-BODY-PART\` (service worker) by part name. */
        "<any part name>"?: (Blob)[];
        /** JSON encoded metadata about the uploaded parts and Worker configuration. */
        metadata?: {
            /** Name of the part in the multipart request that contains the script (e.g. the file adding a listener to the \`fetch\` event). Indicates a \`service worker syntax\` Worker. */
            body_part?: string;
            /** Name of the part in the multipart request that contains the main module (e.g. the file exporting a \`fetch\` handler). Indicates a \`module syntax\` Worker. */
            main_module?: string;
        };
    };
}
export interface Response$worker$script$put$content$Status$200 {
    "application/json": Schemas.workers_script$response$single;
}
export interface Response$worker$script$put$content$Status$4XX {
    "application/json": Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$get$content {
    account_id: Schemas.workers_identifier;
    script_name: Schemas.workers_script_name;
}
export interface Response$worker$script$get$content$Status$200 {
    string: any;
}
export interface Response$worker$script$get$content$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$worker$cron$trigger$get$cron$triggers {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$cron$trigger$get$cron$triggers$Status$200 {
    "application/json": Schemas.workers_cron$trigger$response$collection;
}
export interface Response$worker$cron$trigger$get$cron$triggers$Status$4XX {
    "application/json": Schemas.workers_cron$trigger$response$collection & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$cron$trigger$update$cron$triggers {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$cron$trigger$update$cron$triggers {
    "application/json": any;
}
export interface Response$worker$cron$trigger$update$cron$triggers$Status$200 {
    "application/json": Schemas.workers_cron$trigger$response$collection;
}
export interface Response$worker$cron$trigger$update$cron$triggers$Status$4XX {
    "application/json": Schemas.workers_cron$trigger$response$collection & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$get$settings {
    account_id: Schemas.workers_identifier;
    script_name: Schemas.workers_script_name;
}
export interface Response$worker$script$get$settings$Status$200 {
    "application/json": Schemas.workers_script$settings$response;
}
export interface Response$worker$script$get$settings$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$worker$script$patch$settings {
    account_id: Schemas.workers_identifier;
    script_name: Schemas.workers_script_name;
}
export interface RequestBody$worker$script$patch$settings {
    "multipart/form-data": {
        settings?: Schemas.workers_script$settings$response;
    };
}
export interface Response$worker$script$patch$settings$Status$200 {
    "application/json": Schemas.workers_script$settings$response;
}
export interface Response$worker$script$patch$settings$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$worker$tail$logs$list$tails {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$tail$logs$list$tails$Status$200 {
    "application/json": Schemas.workers_tail$response;
}
export interface Response$worker$tail$logs$list$tails$Status$4XX {
    "application/json": Schemas.workers_tail$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$tail$logs$start$tail {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$tail$logs$start$tail$Status$200 {
    "application/json": Schemas.workers_tail$response;
}
export interface Response$worker$tail$logs$start$tail$Status$4XX {
    "application/json": Schemas.workers_tail$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$tail$logs$delete$tail {
    id: Schemas.workers_id;
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$tail$logs$delete$tail$Status$200 {
    "application/json": Schemas.workers_api$response$common;
}
export interface Response$worker$tail$logs$delete$tail$Status$4XX {
    "application/json": Schemas.workers_api$response$common & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$fetch$usage$model {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$script$fetch$usage$model$Status$200 {
    "application/json": Schemas.workers_usage$model$response;
}
export interface Response$worker$script$fetch$usage$model$Status$4XX {
    "application/json": Schemas.workers_usage$model$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$update$usage$model {
    script_name: Schemas.workers_script_name;
    account_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$script$update$usage$model {
    "application/json": any;
}
export interface Response$worker$script$update$usage$model$Status$200 {
    "application/json": Schemas.workers_usage$model$response;
}
export interface Response$worker$script$update$usage$model$Status$4XX {
    "application/json": Schemas.workers_usage$model$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$environment$get$script$content {
    account_id: Schemas.workers_identifier;
    service_name: Schemas.workers_service;
    environment_name: Schemas.workers_environment;
}
export interface Response$worker$environment$get$script$content$Status$200 {
    string: any;
}
export interface Response$worker$environment$get$script$content$Status$4XX {
    "application/json": Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$environment$put$script$content {
    account_id: Schemas.workers_identifier;
    service_name: Schemas.workers_service;
    environment_name: Schemas.workers_environment;
    /** The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part. */
    "CF-WORKER-BODY-PART"?: string;
    /** The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part. */
    "CF-WORKER-MAIN-MODULE-PART"?: string;
}
export interface RequestBody$worker$environment$put$script$content {
    "multipart/form-data": {
        /** A module comprising a Worker script, often a javascript file. Multiple modules may be provided as separate named parts, but at least one module must be present. This should be referenced either in the metadata as \`main_module\` (esm)/\`body_part\` (service worker) or as a header \`CF-WORKER-MAIN-MODULE-PART\` (esm) /\`CF-WORKER-BODY-PART\` (service worker) by part name. */
        "<any part name>"?: (Blob)[];
        /** JSON encoded metadata about the uploaded parts and Worker configuration. */
        metadata?: {
            /** Name of the part in the multipart request that contains the script (e.g. the file adding a listener to the \`fetch\` event). Indicates a \`service worker syntax\` Worker. */
            body_part?: string;
            /** Name of the part in the multipart request that contains the main module (e.g. the file exporting a \`fetch\` handler). Indicates a \`module syntax\` Worker. */
            main_module?: string;
        };
    };
}
export interface Response$worker$environment$put$script$content$Status$200 {
    "application/json": Schemas.workers_script$response$single;
}
export interface Response$worker$environment$put$script$content$Status$4XX {
    "application/json": Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$environment$get$settings {
    account_id: Schemas.workers_identifier;
    service_name: Schemas.workers_service;
    environment_name: Schemas.workers_environment;
}
export interface Response$worker$script$environment$get$settings$Status$200 {
    "application/json": Schemas.workers_script$settings$response;
}
export interface Response$worker$script$environment$get$settings$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$worker$script$environment$patch$settings {
    account_id: Schemas.workers_identifier;
    service_name: Schemas.workers_service;
    environment_name: Schemas.workers_environment;
}
export interface RequestBody$worker$script$environment$patch$settings {
    "application/json": Schemas.workers_script$settings$response;
}
export interface Response$worker$script$environment$patch$settings$Status$200 {
    "application/json": Schemas.workers_script$settings$response;
}
export interface Response$worker$script$environment$patch$settings$Status$4XX {
    "application/json": Schemas.workers_api$response$common;
}
export interface Parameter$worker$subdomain$get$subdomain {
    account_id: Schemas.workers_identifier;
}
export interface Response$worker$subdomain$get$subdomain$Status$200 {
    "application/json": Schemas.workers_subdomain$response;
}
export interface Response$worker$subdomain$get$subdomain$Status$4XX {
    "application/json": Schemas.workers_subdomain$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$subdomain$create$subdomain {
    account_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$subdomain$create$subdomain {
    "application/json": any;
}
export interface Response$worker$subdomain$create$subdomain$Status$200 {
    "application/json": Schemas.workers_subdomain$response;
}
export interface Response$worker$subdomain$create$subdomain$Status$4XX {
    "application/json": Schemas.workers_subdomain$response & Schemas.workers_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$get$connectivity$settings {
    account_id: Schemas.tunnel_cf_account_id;
}
export interface Response$zero$trust$accounts$get$connectivity$settings$Status$200 {
    "application/json": Schemas.tunnel_zero_trust_connectivity_settings_response;
}
export interface Response$zero$trust$accounts$get$connectivity$settings$Status$4XX {
    "application/json": Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$patch$connectivity$settings {
    account_id: Schemas.tunnel_cf_account_id;
}
export interface RequestBody$zero$trust$accounts$patch$connectivity$settings {
    "application/json": {
        icmp_proxy_enabled?: Schemas.tunnel_icmp_proxy_enabled;
        offramp_warp_enabled?: Schemas.tunnel_offramp_warp_enabled;
    };
}
export interface Response$zero$trust$accounts$patch$connectivity$settings$Status$200 {
    "application/json": Schemas.tunnel_zero_trust_connectivity_settings_response;
}
export interface Response$zero$trust$accounts$patch$connectivity$settings$Status$4XX {
    "application/json": Schemas.tunnel_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$list$address$maps {
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$list$address$maps$Status$200 {
    "application/json": Schemas.addressing_components$schemas$response_collection;
}
export interface Response$ip$address$management$address$maps$list$address$maps$Status$4XX {
    "application/json": Schemas.addressing_components$schemas$response_collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$create$address$map {
    account_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$address$maps$create$address$map {
    "application/json": {
        description?: Schemas.addressing_schemas$description;
        enabled?: Schemas.addressing_enabled;
    };
}
export interface Response$ip$address$management$address$maps$create$address$map$Status$200 {
    "application/json": Schemas.addressing_full_response;
}
export interface Response$ip$address$management$address$maps$create$address$map$Status$4XX {
    "application/json": Schemas.addressing_full_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$address$map$details {
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$address$map$details$Status$200 {
    "application/json": Schemas.addressing_full_response;
}
export interface Response$ip$address$management$address$maps$address$map$details$Status$4XX {
    "application/json": Schemas.addressing_full_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$delete$address$map {
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$delete$address$map$Status$200 {
    "application/json": Schemas.addressing_api$response$collection;
}
export interface Response$ip$address$management$address$maps$delete$address$map$Status$4XX {
    "application/json": Schemas.addressing_api$response$collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$update$address$map {
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$address$maps$update$address$map {
    "application/json": {
        default_sni?: Schemas.addressing_default_sni;
        description?: Schemas.addressing_schemas$description;
        enabled?: Schemas.addressing_enabled;
    };
}
export interface Response$ip$address$management$address$maps$update$address$map$Status$200 {
    "application/json": Schemas.addressing_components$schemas$single_response;
}
export interface Response$ip$address$management$address$maps$update$address$map$Status$4XX {
    "application/json": Schemas.addressing_components$schemas$single_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$add$an$ip$to$an$address$map {
    ip_address: Schemas.addressing_ip_address;
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$add$an$ip$to$an$address$map$Status$200 {
    "application/json": Schemas.addressing_api$response$collection;
}
export interface Response$ip$address$management$address$maps$add$an$ip$to$an$address$map$Status$4XX {
    "application/json": Schemas.addressing_api$response$collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$remove$an$ip$from$an$address$map {
    ip_address: Schemas.addressing_ip_address;
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$remove$an$ip$from$an$address$map$Status$200 {
    "application/json": Schemas.addressing_api$response$collection;
}
export interface Response$ip$address$management$address$maps$remove$an$ip$from$an$address$map$Status$4XX {
    "application/json": Schemas.addressing_api$response$collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map {
    zone_identifier: Schemas.addressing_identifier;
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map$Status$200 {
    "application/json": Schemas.addressing_api$response$collection;
}
export interface Response$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map$Status$4XX {
    "application/json": Schemas.addressing_api$response$collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map {
    zone_identifier: Schemas.addressing_identifier;
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map$Status$200 {
    "application/json": Schemas.addressing_api$response$collection;
}
export interface Response$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map$Status$4XX {
    "application/json": Schemas.addressing_api$response$collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$upload$loa$document {
    account_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$prefixes$upload$loa$document {
    "multipart/form-data": {
        /** LOA document to upload. */
        loa_document: string;
    };
}
export interface Response$ip$address$management$prefixes$upload$loa$document$Status$201 {
    "application/json": Schemas.addressing_loa_upload_response;
}
export interface Response$ip$address$management$prefixes$upload$loa$document$Status$4xx {
    "application/json": Schemas.addressing_loa_upload_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$download$loa$document {
    loa_document_identifier: Schemas.addressing_loa_document_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$prefixes$download$loa$document$Status$200 {
    "application/json": {};
}
export interface Response$ip$address$management$prefixes$download$loa$document$Status$4xx {
    "application/json": {} & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$list$prefixes {
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$prefixes$list$prefixes$Status$200 {
    "application/json": Schemas.addressing_response_collection;
}
export interface Response$ip$address$management$prefixes$list$prefixes$Status$4xx {
    "application/json": Schemas.addressing_response_collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$add$prefix {
    account_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$prefixes$add$prefix {
    "application/json": {
        asn: Schemas.addressing_asn;
        cidr: Schemas.addressing_cidr;
        loa_document_id: Schemas.addressing_loa_document_identifier;
    };
}
export interface Response$ip$address$management$prefixes$add$prefix$Status$201 {
    "application/json": Schemas.addressing_single_response;
}
export interface Response$ip$address$management$prefixes$add$prefix$Status$4xx {
    "application/json": Schemas.addressing_single_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$prefix$details {
    prefix_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$prefixes$prefix$details$Status$200 {
    "application/json": Schemas.addressing_single_response;
}
export interface Response$ip$address$management$prefixes$prefix$details$Status$4xx {
    "application/json": Schemas.addressing_single_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$delete$prefix {
    prefix_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$prefixes$delete$prefix$Status$200 {
    "application/json": Schemas.addressing_api$response$collection;
}
export interface Response$ip$address$management$prefixes$delete$prefix$Status$4xx {
    "application/json": Schemas.addressing_api$response$collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$update$prefix$description {
    prefix_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$prefixes$update$prefix$description {
    "application/json": {
        description: Schemas.addressing_description;
    };
}
export interface Response$ip$address$management$prefixes$update$prefix$description$Status$200 {
    "application/json": Schemas.addressing_single_response;
}
export interface Response$ip$address$management$prefixes$update$prefix$description$Status$4xx {
    "application/json": Schemas.addressing_single_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$list$bgp$prefixes {
    account_identifier: Schemas.addressing_identifier;
    prefix_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$prefixes$list$bgp$prefixes$Status$200 {
    "application/json": Schemas.addressing_response_collection_bgp;
}
export interface Response$ip$address$management$prefixes$list$bgp$prefixes$Status$4xx {
    "application/json": Schemas.addressing_response_collection_bgp & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$fetch$bgp$prefix {
    account_identifier: Schemas.addressing_identifier;
    prefix_identifier: Schemas.addressing_identifier;
    bgp_prefix_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$prefixes$fetch$bgp$prefix$Status$200 {
    "application/json": Schemas.addressing_single_response_bgp;
}
export interface Response$ip$address$management$prefixes$fetch$bgp$prefix$Status$4xx {
    "application/json": Schemas.addressing_single_response_bgp & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefixes$update$bgp$prefix {
    account_identifier: Schemas.addressing_identifier;
    prefix_identifier: Schemas.addressing_identifier;
    bgp_prefix_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$prefixes$update$bgp$prefix {
    "application/json": Schemas.addressing_bgp_prefix_update_advertisement;
}
export interface Response$ip$address$management$prefixes$update$bgp$prefix$Status$200 {
    "application/json": Schemas.addressing_single_response_bgp;
}
export interface Response$ip$address$management$prefixes$update$bgp$prefix$Status$4xx {
    "application/json": Schemas.addressing_single_response_bgp & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$dynamic$advertisement$get$advertisement$status {
    prefix_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$dynamic$advertisement$get$advertisement$status$Status$200 {
    "application/json": Schemas.addressing_advertised_response;
}
export interface Response$ip$address$management$dynamic$advertisement$get$advertisement$status$Status$4xx {
    "application/json": Schemas.addressing_advertised_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status {
    prefix_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status {
    "application/json": {
        advertised: Schemas.addressing_schemas$advertised;
    };
}
export interface Response$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status$Status$200 {
    "application/json": Schemas.addressing_advertised_response;
}
export interface Response$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status$Status$4xx {
    "application/json": Schemas.addressing_advertised_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$service$bindings$list$service$bindings {
    account_identifier: Schemas.addressing_identifier;
    prefix_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$service$bindings$list$service$bindings$Status$200 {
    "application/json": Schemas.addressing_api$response$common & {
        result?: Schemas.addressing_service_binding[];
    };
}
export interface Response$ip$address$management$service$bindings$list$service$bindings$Status$4xx {
    "application/json": Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$service$bindings$create$service$binding {
    account_identifier: Schemas.addressing_identifier;
    prefix_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$service$bindings$create$service$binding {
    "application/json": Schemas.addressing_create_binding_request;
}
export interface Response$ip$address$management$service$bindings$create$service$binding$Status$201 {
    "application/json": Schemas.addressing_api$response$common & {
        result?: Schemas.addressing_service_binding;
    };
}
export interface Response$ip$address$management$service$bindings$create$service$binding$Status$4xx {
    "application/json": Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$service$bindings$get$service$binding {
    account_identifier: Schemas.addressing_identifier;
    prefix_identifier: Schemas.addressing_identifier;
    binding_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$service$bindings$get$service$binding$Status$200 {
    "application/json": Schemas.addressing_api$response$common & {
        result?: Schemas.addressing_service_binding;
    };
}
export interface Response$ip$address$management$service$bindings$get$service$binding$Status$4xx {
    "application/json": Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$service$bindings$delete$service$binding {
    account_identifier: Schemas.addressing_identifier;
    prefix_identifier: Schemas.addressing_identifier;
    binding_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$service$bindings$delete$service$binding$Status$200 {
    "application/json": Schemas.addressing_api$response$common;
}
export interface Response$ip$address$management$service$bindings$delete$service$binding$Status$4xx {
    "application/json": Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefix$delegation$list$prefix$delegations {
    prefix_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$prefix$delegation$list$prefix$delegations$Status$200 {
    "application/json": Schemas.addressing_schemas$response_collection;
}
export interface Response$ip$address$management$prefix$delegation$list$prefix$delegations$Status$4xx {
    "application/json": Schemas.addressing_schemas$response_collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefix$delegation$create$prefix$delegation {
    prefix_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface RequestBody$ip$address$management$prefix$delegation$create$prefix$delegation {
    "application/json": {
        cidr: Schemas.addressing_cidr;
        delegated_account_id: Schemas.addressing_delegated_account_identifier;
    };
}
export interface Response$ip$address$management$prefix$delegation$create$prefix$delegation$Status$200 {
    "application/json": Schemas.addressing_schemas$single_response;
}
export interface Response$ip$address$management$prefix$delegation$create$prefix$delegation$Status$4xx {
    "application/json": Schemas.addressing_schemas$single_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$prefix$delegation$delete$prefix$delegation {
    delegation_identifier: Schemas.addressing_delegation_identifier;
    prefix_identifier: Schemas.addressing_identifier;
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$prefix$delegation$delete$prefix$delegation$Status$200 {
    "application/json": Schemas.addressing_id_response;
}
export interface Response$ip$address$management$prefix$delegation$delete$prefix$delegation$Status$4xx {
    "application/json": Schemas.addressing_id_response & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$service$bindings$list$services {
    account_identifier: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$service$bindings$list$services$Status$200 {
    "application/json": Schemas.addressing_api$response$common & {
        result?: {
            id?: Schemas.addressing_service_identifier;
            name?: Schemas.addressing_service_name;
        }[];
    };
}
export interface Response$ip$address$management$service$bindings$list$services$Status$4xx {
    "application/json": Schemas.addressing_api$response$common$failure;
}
export interface Parameter$workers$ai$post$run$model {
    account_identifier: string;
    model_name: string;
}
export interface RequestBody$workers$ai$post$run$model {
    "application/json": {};
    "application/octet-stream": Blob;
}
export interface Response$workers$ai$post$run$model$Status$200 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: string[];
        result: {};
        success: boolean;
    };
}
export interface Response$workers$ai$post$run$model$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$audit$logs$get$account$audit$logs {
    account_identifier: Schemas.w2PBr26F_identifier;
    id?: string;
    export?: boolean;
    "action.type"?: string;
    "actor.ip"?: string;
    "actor.email"?: string;
    since?: Date;
    before?: Date;
    "zone.name"?: string;
    direction?: "desc" | "asc";
    per_page?: number;
    page?: number;
    hide_user_logs?: boolean;
}
export interface Response$audit$logs$get$account$audit$logs$Status$200 {
    "application/json": Schemas.w2PBr26F_audit_logs_response_collection;
}
export interface Response$audit$logs$get$account$audit$logs$Status$4XX {
    "application/json": Schemas.w2PBr26F_audit_logs_response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$account$billing$profile$$$deprecated$$billing$profile$details {
    account_identifier: Schemas.bill$subs$api_account_identifier;
}
export interface Response$account$billing$profile$$$deprecated$$billing$profile$details$Status$200 {
    "application/json": Schemas.bill$subs$api_billing_response_single;
}
export interface Response$account$billing$profile$$$deprecated$$billing$profile$details$Status$4XX {
    "application/json": Schemas.bill$subs$api_billing_response_single & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$accounts$turnstile$widgets$list {
    account_identifier: Schemas.grwMffPV_identifier;
    page?: number;
    per_page?: number;
    order?: "id" | "sitekey" | "name" | "created_on" | "modified_on";
    direction?: "asc" | "desc";
}
export interface Response$accounts$turnstile$widgets$list$Status$200 {
    "application/json": Schemas.grwMffPV_api$response$common & {
        result_info?: Schemas.grwMffPV_result_info;
    } & {
        result?: Schemas.grwMffPV_widget_list[];
    };
}
export interface Response$accounts$turnstile$widgets$list$Status$4XX {
    "application/json": Schemas.grwMffPV_api$response$common$failure;
}
export interface Parameter$accounts$turnstile$widget$create {
    account_identifier: Schemas.grwMffPV_identifier;
    page?: number;
    per_page?: number;
    order?: "id" | "sitekey" | "name" | "created_on" | "modified_on";
    direction?: "asc" | "desc";
}
export interface RequestBody$accounts$turnstile$widget$create {
    "application/json": {
        bot_fight_mode?: Schemas.grwMffPV_bot_fight_mode;
        clearance_level?: Schemas.grwMffPV_clearance_level;
        domains: Schemas.grwMffPV_domains;
        mode: Schemas.grwMffPV_mode;
        name: Schemas.grwMffPV_name;
        offlabel?: Schemas.grwMffPV_offlabel;
        region?: Schemas.grwMffPV_region;
    };
}
export interface Response$accounts$turnstile$widget$create$Status$200 {
    "application/json": Schemas.grwMffPV_api$response$common & {
        result_info?: Schemas.grwMffPV_result_info;
    } & {
        result?: Schemas.grwMffPV_widget_detail;
    };
}
export interface Response$accounts$turnstile$widget$create$Status$4XX {
    "application/json": Schemas.grwMffPV_api$response$common$failure;
}
export interface Parameter$accounts$turnstile$widget$get {
    account_identifier: Schemas.grwMffPV_identifier;
    sitekey: Schemas.grwMffPV_sitekey;
}
export interface Response$accounts$turnstile$widget$get$Status$200 {
    "application/json": Schemas.grwMffPV_api$response$common & {
        result?: Schemas.grwMffPV_widget_detail;
    };
}
export interface Response$accounts$turnstile$widget$get$Status$4XX {
    "application/json": Schemas.grwMffPV_api$response$common$failure;
}
export interface Parameter$accounts$turnstile$widget$update {
    account_identifier: Schemas.grwMffPV_identifier;
    sitekey: Schemas.grwMffPV_sitekey;
}
export interface RequestBody$accounts$turnstile$widget$update {
    "application/json": {
        bot_fight_mode?: Schemas.grwMffPV_bot_fight_mode;
        clearance_level?: Schemas.grwMffPV_clearance_level;
        domains: Schemas.grwMffPV_domains;
        mode: Schemas.grwMffPV_mode;
        name: Schemas.grwMffPV_name;
        offlabel?: Schemas.grwMffPV_offlabel;
    };
}
export interface Response$accounts$turnstile$widget$update$Status$200 {
    "application/json": Schemas.grwMffPV_api$response$common & {
        result?: Schemas.grwMffPV_widget_detail;
    };
}
export interface Response$accounts$turnstile$widget$update$Status$4XX {
    "application/json": Schemas.grwMffPV_api$response$common$failure;
}
export interface Parameter$accounts$turnstile$widget$delete {
    account_identifier: Schemas.grwMffPV_identifier;
    sitekey: Schemas.grwMffPV_sitekey;
}
export interface Response$accounts$turnstile$widget$delete$Status$200 {
    "application/json": Schemas.grwMffPV_api$response$common & {
        result?: Schemas.grwMffPV_widget_detail;
    };
}
export interface Response$accounts$turnstile$widget$delete$Status$4XX {
    "application/json": Schemas.grwMffPV_api$response$common$failure;
}
export interface Parameter$accounts$turnstile$widget$rotate$secret {
    account_identifier: Schemas.grwMffPV_identifier;
    sitekey: Schemas.grwMffPV_sitekey;
}
export interface RequestBody$accounts$turnstile$widget$rotate$secret {
    "application/json": {
        invalidate_immediately?: Schemas.grwMffPV_invalidate_immediately;
    };
}
export interface Response$accounts$turnstile$widget$rotate$secret$Status$200 {
    "application/json": Schemas.grwMffPV_api$response$common & {
        result?: Schemas.grwMffPV_widget_detail;
    };
}
export interface Response$accounts$turnstile$widget$rotate$secret$Status$4XX {
    "application/json": Schemas.grwMffPV_api$response$common$failure;
}
export interface Parameter$custom$pages$for$an$account$list$custom$pages {
    account_identifier: Schemas.NQKiZdJe_identifier;
}
export interface Response$custom$pages$for$an$account$list$custom$pages$Status$200 {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_collection;
}
export interface Response$custom$pages$for$an$account$list$custom$pages$Status$4xx {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_collection & Schemas.NQKiZdJe_api$response$common$failure;
}
export interface Parameter$custom$pages$for$an$account$get$a$custom$page {
    identifier: Schemas.NQKiZdJe_identifier;
    account_identifier: Schemas.NQKiZdJe_identifier;
}
export interface Response$custom$pages$for$an$account$get$a$custom$page$Status$200 {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_single;
}
export interface Response$custom$pages$for$an$account$get$a$custom$page$Status$4xx {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_single & Schemas.NQKiZdJe_api$response$common$failure;
}
export interface Parameter$custom$pages$for$an$account$update$a$custom$page {
    identifier: Schemas.NQKiZdJe_identifier;
    account_identifier: Schemas.NQKiZdJe_identifier;
}
export interface RequestBody$custom$pages$for$an$account$update$a$custom$page {
    "application/json": {
        state: Schemas.NQKiZdJe_state;
        url: Schemas.NQKiZdJe_url;
    };
}
export interface Response$custom$pages$for$an$account$update$a$custom$page$Status$200 {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_single;
}
export interface Response$custom$pages$for$an$account$update$a$custom$page$Status$4xx {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_single & Schemas.NQKiZdJe_api$response$common$failure;
}
export interface Parameter$cloudflare$d1$get$database {
    account_identifier: Schemas.d1_account$identifier;
    database_identifier: Schemas.d1_database$identifier;
}
export interface Response$cloudflare$d1$get$database$Status$200 {
    "application/json": Schemas.d1_api$response$single & {
        result?: Schemas.d1_database$details$response;
    };
}
export interface Response$cloudflare$d1$get$database$Status$4XX {
    "application/json": (Schemas.d1_api$response$single & {
        result?: {} | null;
    }) & Schemas.d1_api$response$common$failure;
}
export interface Parameter$cloudflare$d1$delete$database {
    account_identifier: Schemas.d1_account$identifier;
    database_identifier: Schemas.d1_database$identifier;
}
export interface Response$cloudflare$d1$delete$database$Status$200 {
    "application/json": Schemas.d1_api$response$single & {
        result?: {} | null;
    };
}
export interface Response$cloudflare$d1$delete$database$Status$4XX {
    "application/json": (Schemas.d1_api$response$single & {
        result?: {} | null;
    }) & Schemas.d1_api$response$common$failure;
}
export interface Parameter$cloudflare$d1$query$database {
    account_identifier: Schemas.d1_account$identifier;
    database_identifier: Schemas.d1_database$identifier;
}
export interface RequestBody$cloudflare$d1$query$database {
    "application/json": {
        params?: Schemas.d1_params;
        sql: Schemas.d1_sql;
    };
}
export interface Response$cloudflare$d1$query$database$Status$200 {
    "application/json": Schemas.d1_api$response$single & {
        result?: Schemas.d1_query$result$response[];
    };
}
export interface Response$cloudflare$d1$query$database$Status$4XX {
    "application/json": (Schemas.d1_api$response$single & {
        result?: {} | null;
    }) & Schemas.d1_api$response$common$failure;
}
export interface Parameter$diagnostics$traceroute {
    account_identifier: Schemas.aMMS9DAQ_identifier;
}
export interface RequestBody$diagnostics$traceroute {
    "application/json": {
        colos?: Schemas.aMMS9DAQ_colos;
        options?: Schemas.aMMS9DAQ_options;
        targets: Schemas.aMMS9DAQ_targets;
    };
}
export interface Response$diagnostics$traceroute$Status$200 {
    "application/json": Schemas.aMMS9DAQ_traceroute_response_collection;
}
export interface Response$diagnostics$traceroute$Status$4XX {
    "application/json": Schemas.aMMS9DAQ_traceroute_response_collection & Schemas.aMMS9DAQ_api$response$common$failure;
}
export interface Parameter$dns$firewall$analytics$table {
    identifier: Schemas.erIwb89A_identifier;
    account_identifier: Schemas.erIwb89A_identifier;
    metrics?: Schemas.erIwb89A_metrics;
    dimensions?: Schemas.erIwb89A_dimensions;
    since?: Schemas.erIwb89A_since;
    until?: Schemas.erIwb89A_until;
    limit?: Schemas.erIwb89A_limit;
    sort?: Schemas.erIwb89A_sort;
    filters?: Schemas.erIwb89A_filters;
}
export interface Response$dns$firewall$analytics$table$Status$200 {
    "application/json": Schemas.erIwb89A_api$response$single & {
        result?: Schemas.erIwb89A_report;
    };
}
export interface Response$dns$firewall$analytics$table$Status$4XX {
    "application/json": (Schemas.erIwb89A_api$response$single & {
        result?: Schemas.erIwb89A_report;
    }) & Schemas.erIwb89A_api$response$common$failure;
}
export interface Parameter$dns$firewall$analytics$by$time {
    identifier: Schemas.erIwb89A_identifier;
    account_identifier: Schemas.erIwb89A_identifier;
    metrics?: Schemas.erIwb89A_metrics;
    dimensions?: Schemas.erIwb89A_dimensions;
    since?: Schemas.erIwb89A_since;
    until?: Schemas.erIwb89A_until;
    limit?: Schemas.erIwb89A_limit;
    sort?: Schemas.erIwb89A_sort;
    filters?: Schemas.erIwb89A_filters;
    time_delta?: Schemas.erIwb89A_time_delta;
}
export interface Response$dns$firewall$analytics$by$time$Status$200 {
    "application/json": Schemas.erIwb89A_api$response$single & {
        result?: Schemas.erIwb89A_report_bytime;
    };
}
export interface Response$dns$firewall$analytics$by$time$Status$4XX {
    "application/json": (Schemas.erIwb89A_api$response$single & {
        result?: Schemas.erIwb89A_report_bytime;
    }) & Schemas.erIwb89A_api$response$common$failure;
}
export interface Parameter$email$routing$destination$addresses$list$destination$addresses {
    account_identifier: Schemas.email_identifier;
    page?: number;
    per_page?: number;
    direction?: "asc" | "desc";
    verified?: true | false;
}
export interface Response$email$routing$destination$addresses$list$destination$addresses$Status$200 {
    "application/json": Schemas.email_destination_addresses_response_collection;
}
export interface Parameter$email$routing$destination$addresses$create$a$destination$address {
    account_identifier: Schemas.email_identifier;
}
export interface RequestBody$email$routing$destination$addresses$create$a$destination$address {
    "application/json": Schemas.email_create_destination_address_properties;
}
export interface Response$email$routing$destination$addresses$create$a$destination$address$Status$200 {
    "application/json": Schemas.email_destination_address_response_single;
}
export interface Parameter$email$routing$destination$addresses$get$a$destination$address {
    destination_address_identifier: Schemas.email_destination_address_identifier;
    account_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$destination$addresses$get$a$destination$address$Status$200 {
    "application/json": Schemas.email_destination_address_response_single;
}
export interface Parameter$email$routing$destination$addresses$delete$destination$address {
    destination_address_identifier: Schemas.email_destination_address_identifier;
    account_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$destination$addresses$delete$destination$address$Status$200 {
    "application/json": Schemas.email_destination_address_response_single;
}
export interface Parameter$ip$access$rules$for$an$account$list$ip$access$rules {
    account_identifier: Schemas.legacy$jhs_account_identifier;
    filters?: Schemas.legacy$jhs_schemas$filters;
    "egs-pagination.json"?: Schemas.legacy$jhs_egs$pagination;
    page?: number;
    per_page?: number;
    order?: "configuration.target" | "configuration.value" | "mode";
    direction?: "asc" | "desc";
}
export interface Response$ip$access$rules$for$an$account$list$ip$access$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_response_collection;
}
export interface Response$ip$access$rules$for$an$account$list$ip$access$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_response_collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$an$account$create$an$ip$access$rule {
    account_identifier: Schemas.legacy$jhs_account_identifier;
}
export interface RequestBody$ip$access$rules$for$an$account$create$an$ip$access$rule {
    "application/json": {
        configuration: Schemas.legacy$jhs_schemas$configuration;
        mode: Schemas.legacy$jhs_schemas$mode;
        notes?: Schemas.legacy$jhs_notes;
    };
}
export interface Response$ip$access$rules$for$an$account$create$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_response_single;
}
export interface Response$ip$access$rules$for$an$account$create$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$an$account$get$an$ip$access$rule {
    identifier: Schemas.legacy$jhs_schemas$identifier;
    account_identifier: Schemas.legacy$jhs_account_identifier;
}
export interface Response$ip$access$rules$for$an$account$get$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_response_single;
}
export interface Response$ip$access$rules$for$an$account$get$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$an$account$delete$an$ip$access$rule {
    identifier: Schemas.legacy$jhs_schemas$identifier;
    account_identifier: Schemas.legacy$jhs_account_identifier;
}
export interface Response$ip$access$rules$for$an$account$delete$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_api$response$single$id;
}
export interface Response$ip$access$rules$for$an$account$delete$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_api$response$single$id & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$an$account$update$an$ip$access$rule {
    identifier: Schemas.legacy$jhs_schemas$identifier;
    account_identifier: Schemas.legacy$jhs_account_identifier;
}
export interface RequestBody$ip$access$rules$for$an$account$update$an$ip$access$rule {
    "application/json": Schemas.legacy$jhs_schemas$rule;
}
export interface Response$ip$access$rules$for$an$account$update$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_response_single;
}
export interface Response$ip$access$rules$for$an$account$update$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$custom$indicator$feeds$get$indicator$feeds {
    account_identifier: Schemas.lSaKXx3s_identifier;
}
export interface Response$custom$indicator$feeds$get$indicator$feeds$Status$200 {
    "application/json": Schemas.lSaKXx3s_indicator_feed_response;
}
export interface Response$custom$indicator$feeds$get$indicator$feeds$Status$4XX {
    "application/json": Schemas.lSaKXx3s_indicator_feed_response & Schemas.lSaKXx3s_api$response$common$failure;
}
export interface Parameter$custom$indicator$feeds$create$indicator$feeds {
    account_identifier: Schemas.lSaKXx3s_identifier;
}
export interface RequestBody$custom$indicator$feeds$create$indicator$feeds {
    "application/json": Schemas.lSaKXx3s_create_feed;
}
export interface Response$custom$indicator$feeds$create$indicator$feeds$Status$200 {
    "application/json": Schemas.lSaKXx3s_create_feed_response;
}
export interface Response$custom$indicator$feeds$create$indicator$feeds$Status$4XX {
    "application/json": Schemas.lSaKXx3s_create_feed_response & Schemas.lSaKXx3s_api$response$common$failure;
}
export interface Parameter$custom$indicator$feeds$get$indicator$feed$metadata {
    account_identifier: Schemas.lSaKXx3s_identifier;
    feed_id: Schemas.lSaKXx3s_feed_id;
}
export interface Response$custom$indicator$feeds$get$indicator$feed$metadata$Status$200 {
    "application/json": Schemas.lSaKXx3s_indicator_feed_metadata_response;
}
export interface Response$custom$indicator$feeds$get$indicator$feed$metadata$Status$4XX {
    "application/json": Schemas.lSaKXx3s_indicator_feed_metadata_response & Schemas.lSaKXx3s_api$response$common$failure;
}
export interface Parameter$custom$indicator$feeds$get$indicator$feed$data {
    account_identifier: Schemas.lSaKXx3s_identifier;
    feed_id: Schemas.lSaKXx3s_feed_id;
}
export interface Response$custom$indicator$feeds$get$indicator$feed$data$Status$200 {
    "text/csv": string;
}
export interface Response$custom$indicator$feeds$get$indicator$feed$data$Status$4XX {
    "application/json": Schemas.lSaKXx3s_api$response$common$failure;
}
export interface Parameter$custom$indicator$feeds$update$indicator$feed$data {
    account_identifier: Schemas.lSaKXx3s_identifier;
    feed_id: Schemas.lSaKXx3s_feed_id;
}
export interface RequestBody$custom$indicator$feeds$update$indicator$feed$data {
    "multipart/form-data": {
        /** The file to upload */
        source?: string;
    };
}
export interface Response$custom$indicator$feeds$update$indicator$feed$data$Status$200 {
    "application/json": Schemas.lSaKXx3s_update_feed_response;
}
export interface Response$custom$indicator$feeds$update$indicator$feed$data$Status$4XX {
    "application/json": Schemas.lSaKXx3s_api$response$common$failure;
}
export interface Parameter$custom$indicator$feeds$add$permission {
    account_identifier: Schemas.lSaKXx3s_identifier;
}
export interface RequestBody$custom$indicator$feeds$add$permission {
    "application/json": Schemas.lSaKXx3s_permissions$request;
}
export interface Response$custom$indicator$feeds$add$permission$Status$200 {
    "application/json": Schemas.lSaKXx3s_permissions_response;
}
export interface Response$custom$indicator$feeds$add$permission$Status$4XX {
    "application/json": Schemas.lSaKXx3s_permissions_response & Schemas.lSaKXx3s_api$response$common$failure;
}
export interface Parameter$custom$indicator$feeds$remove$permission {
    account_identifier: Schemas.lSaKXx3s_identifier;
}
export interface RequestBody$custom$indicator$feeds$remove$permission {
    "application/json": Schemas.lSaKXx3s_permissions$request;
}
export interface Response$custom$indicator$feeds$remove$permission$Status$200 {
    "application/json": Schemas.lSaKXx3s_permissions_response;
}
export interface Response$custom$indicator$feeds$remove$permission$Status$4XX {
    "application/json": Schemas.lSaKXx3s_permissions_response & Schemas.lSaKXx3s_api$response$common$failure;
}
export interface Parameter$custom$indicator$feeds$view$permissions {
    account_identifier: Schemas.lSaKXx3s_identifier;
}
export interface Response$custom$indicator$feeds$view$permissions$Status$200 {
    "application/json": Schemas.lSaKXx3s_permission_list_item_response;
}
export interface Response$custom$indicator$feeds$view$permissions$Status$4XX {
    "application/json": Schemas.lSaKXx3s_permission_list_item_response & Schemas.lSaKXx3s_api$response$common$failure;
}
export interface Parameter$sinkhole$config$get$sinkholes {
    account_identifier: Schemas.sMrrXoZ2_identifier;
}
export interface Response$sinkhole$config$get$sinkholes$Status$200 {
    "application/json": Schemas.sMrrXoZ2_get_sinkholes_response;
}
export interface Parameter$account$load$balancer$monitors$list$monitors {
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$monitors$list$monitors$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$collection;
}
export interface Response$account$load$balancer$monitors$list$monitors$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$collection & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$monitors$create$monitor {
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$monitors$create$monitor {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$account$load$balancer$monitors$create$monitor$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$single;
}
export interface Response$account$load$balancer$monitors$create$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$single & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$monitors$monitor$details {
    identifier: Schemas.load$balancing_identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$monitors$monitor$details$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$single;
}
export interface Response$account$load$balancer$monitors$monitor$details$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$single & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$monitors$update$monitor {
    identifier: Schemas.load$balancing_identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$monitors$update$monitor {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$account$load$balancer$monitors$update$monitor$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$single;
}
export interface Response$account$load$balancer$monitors$update$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$single & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$monitors$delete$monitor {
    identifier: Schemas.load$balancing_identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$monitors$delete$monitor$Status$200 {
    "application/json": Schemas.load$balancing_id_response;
}
export interface Response$account$load$balancer$monitors$delete$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_id_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$monitors$patch$monitor {
    identifier: Schemas.load$balancing_identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$monitors$patch$monitor {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$account$load$balancer$monitors$patch$monitor$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$single;
}
export interface Response$account$load$balancer$monitors$patch$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$single & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$monitors$preview$monitor {
    identifier: Schemas.load$balancing_identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$monitors$preview$monitor {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$account$load$balancer$monitors$preview$monitor$Status$200 {
    "application/json": Schemas.load$balancing_preview_response;
}
export interface Response$account$load$balancer$monitors$preview$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_preview_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$monitors$list$monitor$references {
    identifier: Schemas.load$balancing_identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$monitors$list$monitor$references$Status$200 {
    "application/json": Schemas.load$balancing_references_response;
}
export interface Response$account$load$balancer$monitors$list$monitor$references$Status$4XX {
    "application/json": Schemas.load$balancing_references_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$list$pools {
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
    monitor?: any;
}
export interface Response$account$load$balancer$pools$list$pools$Status$200 {
    "application/json": Schemas.load$balancing_schemas$response_collection;
}
export interface Response$account$load$balancer$pools$list$pools$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$response_collection & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$create$pool {
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$pools$create$pool {
    "application/json": {
        description?: Schemas.load$balancing_schemas$description;
        enabled?: Schemas.load$balancing_enabled;
        latitude?: Schemas.load$balancing_latitude;
        load_shedding?: Schemas.load$balancing_load_shedding;
        longitude?: Schemas.load$balancing_longitude;
        minimum_origins?: Schemas.load$balancing_minimum_origins;
        monitor?: Schemas.load$balancing_monitor_id;
        name: Schemas.load$balancing_name;
        notification_email?: Schemas.load$balancing_notification_email;
        notification_filter?: Schemas.load$balancing_notification_filter;
        origin_steering?: Schemas.load$balancing_origin_steering;
        origins: Schemas.load$balancing_origins;
    };
}
export interface Response$account$load$balancer$pools$create$pool$Status$200 {
    "application/json": Schemas.load$balancing_schemas$single_response;
}
export interface Response$account$load$balancer$pools$create$pool$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$patch$pools {
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$pools$patch$pools {
    "application/json": {
        notification_email?: Schemas.load$balancing_patch_pools_notification_email;
    };
}
export interface Response$account$load$balancer$pools$patch$pools$Status$200 {
    "application/json": Schemas.load$balancing_schemas$response_collection;
}
export interface Response$account$load$balancer$pools$patch$pools$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$response_collection & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$pool$details {
    identifier: Schemas.load$balancing_schemas$identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$pools$pool$details$Status$200 {
    "application/json": Schemas.load$balancing_schemas$single_response;
}
export interface Response$account$load$balancer$pools$pool$details$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$update$pool {
    identifier: Schemas.load$balancing_schemas$identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$pools$update$pool {
    "application/json": {
        check_regions?: Schemas.load$balancing_check_regions;
        description?: Schemas.load$balancing_schemas$description;
        disabled_at?: Schemas.load$balancing_schemas$disabled_at;
        enabled?: Schemas.load$balancing_enabled;
        latitude?: Schemas.load$balancing_latitude;
        load_shedding?: Schemas.load$balancing_load_shedding;
        longitude?: Schemas.load$balancing_longitude;
        minimum_origins?: Schemas.load$balancing_minimum_origins;
        monitor?: Schemas.load$balancing_monitor_id;
        name: Schemas.load$balancing_name;
        notification_email?: Schemas.load$balancing_notification_email;
        notification_filter?: Schemas.load$balancing_notification_filter;
        origin_steering?: Schemas.load$balancing_origin_steering;
        origins: Schemas.load$balancing_origins;
    };
}
export interface Response$account$load$balancer$pools$update$pool$Status$200 {
    "application/json": Schemas.load$balancing_schemas$single_response;
}
export interface Response$account$load$balancer$pools$update$pool$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$delete$pool {
    identifier: Schemas.load$balancing_schemas$identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$pools$delete$pool$Status$200 {
    "application/json": Schemas.load$balancing_schemas$id_response;
}
export interface Response$account$load$balancer$pools$delete$pool$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$id_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$patch$pool {
    identifier: Schemas.load$balancing_schemas$identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$pools$patch$pool {
    "application/json": {
        check_regions?: Schemas.load$balancing_check_regions;
        description?: Schemas.load$balancing_schemas$description;
        disabled_at?: Schemas.load$balancing_schemas$disabled_at;
        enabled?: Schemas.load$balancing_enabled;
        latitude?: Schemas.load$balancing_latitude;
        load_shedding?: Schemas.load$balancing_load_shedding;
        longitude?: Schemas.load$balancing_longitude;
        minimum_origins?: Schemas.load$balancing_minimum_origins;
        monitor?: Schemas.load$balancing_monitor_id;
        name?: Schemas.load$balancing_name;
        notification_email?: Schemas.load$balancing_notification_email;
        notification_filter?: Schemas.load$balancing_notification_filter;
        origin_steering?: Schemas.load$balancing_origin_steering;
        origins?: Schemas.load$balancing_origins;
    };
}
export interface Response$account$load$balancer$pools$patch$pool$Status$200 {
    "application/json": Schemas.load$balancing_schemas$single_response;
}
export interface Response$account$load$balancer$pools$patch$pool$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$pool$health$details {
    identifier: Schemas.load$balancing_schemas$identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$pools$pool$health$details$Status$200 {
    "application/json": Schemas.load$balancing_health_details;
}
export interface Response$account$load$balancer$pools$pool$health$details$Status$4XX {
    "application/json": Schemas.load$balancing_health_details & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$preview$pool {
    identifier: Schemas.load$balancing_schemas$identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface RequestBody$account$load$balancer$pools$preview$pool {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$account$load$balancer$pools$preview$pool$Status$200 {
    "application/json": Schemas.load$balancing_preview_response;
}
export interface Response$account$load$balancer$pools$preview$pool$Status$4XX {
    "application/json": Schemas.load$balancing_preview_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$pools$list$pool$references {
    identifier: Schemas.load$balancing_schemas$identifier;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$pools$list$pool$references$Status$200 {
    "application/json": Schemas.load$balancing_schemas$references_response;
}
export interface Response$account$load$balancer$pools$list$pool$references$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$references_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$monitors$preview$result {
    preview_id: Schemas.load$balancing_schemas$preview_id;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$account$load$balancer$monitors$preview$result$Status$200 {
    "application/json": Schemas.load$balancing_preview_result_response;
}
export interface Response$account$load$balancer$monitors$preview$result$Status$4XX {
    "application/json": Schemas.load$balancing_preview_result_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$regions$list$regions {
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
    subdivision_code?: Schemas.load$balancing_subdivision_code_a2;
    subdivision_code_a2?: Schemas.load$balancing_subdivision_code_a2;
    country_code_a2?: string;
}
export interface Response$load$balancer$regions$list$regions$Status$200 {
    "application/json": Schemas.load$balancing_region_components$schemas$response_collection;
}
export interface Response$load$balancer$regions$list$regions$Status$4XX {
    "application/json": Schemas.load$balancing_region_components$schemas$response_collection & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$regions$get$region {
    region_code: Schemas.load$balancing_region_code;
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
}
export interface Response$load$balancer$regions$get$region$Status$200 {
    "application/json": Schemas.load$balancing_components$schemas$single_response;
}
export interface Response$load$balancer$regions$get$region$Status$4XX {
    "application/json": Schemas.load$balancing_components$schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$account$load$balancer$search$search$resources {
    account_identifier: Schemas.load$balancing_components$schemas$identifier;
    search_params?: Schemas.load$balancing_search_params;
    page?: any;
    per_page?: any;
}
export interface Response$account$load$balancer$search$search$resources$Status$200 {
    "application/json": Schemas.load$balancing_api$response$collection & Schemas.load$balancing_search_result;
}
export interface Response$account$load$balancer$search$search$resources$Status$4XX {
    "application/json": (Schemas.load$balancing_api$response$collection & Schemas.load$balancing_search_result) & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$magic$interconnects$list$interconnects {
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$interconnects$list$interconnects$Status$200 {
    "application/json": Schemas.magic_components$schemas$tunnels_collection_response;
}
export interface Response$magic$interconnects$list$interconnects$Status$4xx {
    "application/json": Schemas.magic_components$schemas$tunnels_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$interconnects$update$multiple$interconnects {
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$interconnects$update$multiple$interconnects {
    "application/json": {
        id: any;
    };
}
export interface Response$magic$interconnects$update$multiple$interconnects$Status$200 {
    "application/json": Schemas.magic_components$schemas$modified_tunnels_collection_response;
}
export interface Response$magic$interconnects$update$multiple$interconnects$Status$4xx {
    "application/json": Schemas.magic_components$schemas$modified_tunnels_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$interconnects$list$interconnect$details {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$interconnects$list$interconnect$details$Status$200 {
    "application/json": Schemas.magic_components$schemas$tunnel_single_response;
}
export interface Response$magic$interconnects$list$interconnect$details$Status$4xx {
    "application/json": Schemas.magic_components$schemas$tunnel_single_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$interconnects$update$interconnect {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$interconnects$update$interconnect {
    "application/json": Schemas.magic_components$schemas$tunnel_update_request;
}
export interface Response$magic$interconnects$update$interconnect$Status$200 {
    "application/json": Schemas.magic_components$schemas$tunnel_modified_response;
}
export interface Response$magic$interconnects$update$interconnect$Status$4xx {
    "application/json": Schemas.magic_components$schemas$tunnel_modified_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$gre$tunnels$list$gre$tunnels {
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$gre$tunnels$list$gre$tunnels$Status$200 {
    "application/json": Schemas.magic_tunnels_collection_response;
}
export interface Response$magic$gre$tunnels$list$gre$tunnels$Status$4XX {
    "application/json": Schemas.magic_tunnels_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$gre$tunnels$update$multiple$gre$tunnels {
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$gre$tunnels$update$multiple$gre$tunnels {
    "application/json": {
        id: any;
    };
}
export interface Response$magic$gre$tunnels$update$multiple$gre$tunnels$Status$200 {
    "application/json": Schemas.magic_modified_tunnels_collection_response;
}
export interface Response$magic$gre$tunnels$update$multiple$gre$tunnels$Status$4XX {
    "application/json": Schemas.magic_modified_tunnels_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$gre$tunnels$create$gre$tunnels {
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$gre$tunnels$create$gre$tunnels {
    "application/json": {
        name: any;
        customer_gre_endpoint: any;
        cloudflare_gre_endpoint: any;
        interface_address: any;
    };
}
export interface Response$magic$gre$tunnels$create$gre$tunnels$Status$200 {
    "application/json": Schemas.magic_tunnels_collection_response;
}
export interface Response$magic$gre$tunnels$create$gre$tunnels$Status$4XX {
    "application/json": Schemas.magic_tunnels_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$gre$tunnels$list$gre$tunnel$details {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$gre$tunnels$list$gre$tunnel$details$Status$200 {
    "application/json": Schemas.magic_tunnel_single_response;
}
export interface Response$magic$gre$tunnels$list$gre$tunnel$details$Status$4XX {
    "application/json": Schemas.magic_tunnel_single_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$gre$tunnels$update$gre$tunnel {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$gre$tunnels$update$gre$tunnel {
    "application/json": Schemas.magic_tunnel_update_request;
}
export interface Response$magic$gre$tunnels$update$gre$tunnel$Status$200 {
    "application/json": Schemas.magic_tunnel_modified_response;
}
export interface Response$magic$gre$tunnels$update$gre$tunnel$Status$4XX {
    "application/json": Schemas.magic_tunnel_modified_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$gre$tunnels$delete$gre$tunnel {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$gre$tunnels$delete$gre$tunnel$Status$200 {
    "application/json": Schemas.magic_tunnel_deleted_response;
}
export interface Response$magic$gre$tunnels$delete$gre$tunnel$Status$4XX {
    "application/json": Schemas.magic_tunnel_deleted_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$ipsec$tunnels$list$ipsec$tunnels {
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$ipsec$tunnels$list$ipsec$tunnels$Status$200 {
    "application/json": Schemas.magic_schemas$tunnels_collection_response;
}
export interface Response$magic$ipsec$tunnels$list$ipsec$tunnels$Status$4XX {
    "application/json": Schemas.magic_schemas$tunnels_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$ipsec$tunnels$update$multiple$ipsec$tunnels {
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$ipsec$tunnels$update$multiple$ipsec$tunnels {
    "application/json": {
        id: any;
    };
}
export interface Response$magic$ipsec$tunnels$update$multiple$ipsec$tunnels$Status$200 {
    "application/json": Schemas.magic_schemas$modified_tunnels_collection_response;
}
export interface Response$magic$ipsec$tunnels$update$multiple$ipsec$tunnels$Status$4XX {
    "application/json": Schemas.magic_schemas$modified_tunnels_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$ipsec$tunnels$create$ipsec$tunnels {
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$ipsec$tunnels$create$ipsec$tunnels {
    "application/json": Schemas.magic_schemas$tunnel_add_request;
}
export interface Response$magic$ipsec$tunnels$create$ipsec$tunnels$Status$200 {
    "application/json": Schemas.magic_schemas$tunnels_collection_response;
}
export interface Response$magic$ipsec$tunnels$create$ipsec$tunnels$Status$4XX {
    "application/json": Schemas.magic_schemas$tunnels_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$ipsec$tunnels$list$ipsec$tunnel$details {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$ipsec$tunnels$list$ipsec$tunnel$details$Status$200 {
    "application/json": Schemas.magic_schemas$tunnel_single_response;
}
export interface Response$magic$ipsec$tunnels$list$ipsec$tunnel$details$Status$4XX {
    "application/json": Schemas.magic_schemas$tunnel_single_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$ipsec$tunnels$update$ipsec$tunnel {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$ipsec$tunnels$update$ipsec$tunnel {
    "application/json": Schemas.magic_schemas$tunnel_update_request;
}
export interface Response$magic$ipsec$tunnels$update$ipsec$tunnel$Status$200 {
    "application/json": Schemas.magic_schemas$tunnel_modified_response;
}
export interface Response$magic$ipsec$tunnels$update$ipsec$tunnel$Status$4XX {
    "application/json": Schemas.magic_schemas$tunnel_modified_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$ipsec$tunnels$delete$ipsec$tunnel {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$ipsec$tunnels$delete$ipsec$tunnel$Status$200 {
    "application/json": Schemas.magic_schemas$tunnel_deleted_response;
}
export interface Response$magic$ipsec$tunnels$delete$ipsec$tunnel$Status$4XX {
    "application/json": Schemas.magic_schemas$tunnel_deleted_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels {
    tunnel_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels$Status$200 {
    "application/json": Schemas.magic_psk_generation_response;
}
export interface Response$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels$Status$4xx {
    "application/json": Schemas.magic_psk_generation_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$static$routes$list$routes {
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$static$routes$list$routes$Status$200 {
    "application/json": Schemas.magic_routes_collection_response;
}
export interface Response$magic$static$routes$list$routes$Status$4XX {
    "application/json": Schemas.magic_routes_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$static$routes$update$many$routes {
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$static$routes$update$many$routes {
    "application/json": Schemas.magic_route_update_many_request;
}
export interface Response$magic$static$routes$update$many$routes$Status$200 {
    "application/json": Schemas.magic_multiple_route_modified_response;
}
export interface Response$magic$static$routes$update$many$routes$Status$4XX {
    "application/json": Schemas.magic_multiple_route_modified_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$static$routes$create$routes {
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$static$routes$create$routes {
    "application/json": {
        prefix: any;
        nexthop: any;
        priority: any;
    };
}
export interface Response$magic$static$routes$create$routes$Status$200 {
    "application/json": Schemas.magic_routes_collection_response;
}
export interface Response$magic$static$routes$create$routes$Status$4XX {
    "application/json": Schemas.magic_routes_collection_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$static$routes$delete$many$routes {
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$static$routes$delete$many$routes {
    "application/json": Schemas.magic_route_delete_many_request;
}
export interface Response$magic$static$routes$delete$many$routes$Status$200 {
    "application/json": Schemas.magic_multiple_route_delete_response;
}
export interface Response$magic$static$routes$delete$many$routes$Status$4XX {
    "application/json": Schemas.magic_multiple_route_delete_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$static$routes$route$details {
    route_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$static$routes$route$details$Status$200 {
    "application/json": Schemas.magic_route_single_response;
}
export interface Response$magic$static$routes$route$details$Status$4XX {
    "application/json": Schemas.magic_route_single_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$static$routes$update$route {
    route_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface RequestBody$magic$static$routes$update$route {
    "application/json": Schemas.magic_route_update_request;
}
export interface Response$magic$static$routes$update$route$Status$200 {
    "application/json": Schemas.magic_route_modified_response;
}
export interface Response$magic$static$routes$update$route$Status$4XX {
    "application/json": Schemas.magic_route_modified_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$magic$static$routes$delete$route {
    route_identifier: Schemas.magic_identifier;
    account_identifier: Schemas.magic_identifier;
}
export interface Response$magic$static$routes$delete$route$Status$200 {
    "application/json": Schemas.magic_route_deleted_response;
}
export interface Response$magic$static$routes$delete$route$Status$4XX {
    "application/json": Schemas.magic_route_deleted_response & Schemas.magic_api$response$common$failure;
}
export interface Parameter$account$members$list$members {
    account_identifier: Schemas.mrUXABdt_account_identifier;
    order?: "user.first_name" | "user.last_name" | "user.email" | "status";
    status?: "accepted" | "pending" | "rejected";
    page?: number;
    per_page?: number;
    direction?: "asc" | "desc";
}
export interface Response$account$members$list$members$Status$200 {
    "application/json": Schemas.mrUXABdt_collection_member_response;
}
export interface Response$account$members$list$members$Status$4xx {
    "application/json": Schemas.mrUXABdt_response_collection & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$account$members$add$member {
    account_identifier: Schemas.mrUXABdt_account_identifier;
}
export interface RequestBody$account$members$add$member {
    "application/json": Schemas.mrUXABdt_create;
}
export interface Response$account$members$add$member$Status$200 {
    "application/json": Schemas.mrUXABdt_single_member_response_with_code;
}
export interface Response$account$members$add$member$Status$4xx {
    "application/json": Schemas.mrUXABdt_response_single & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$account$members$member$details {
    identifier: Schemas.mrUXABdt_membership_components$schemas$identifier;
    account_identifier: Schemas.mrUXABdt_account_identifier;
}
export interface Response$account$members$member$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_member_response;
}
export interface Response$account$members$member$details$Status$4xx {
    "application/json": Schemas.mrUXABdt_response_single & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$account$members$update$member {
    identifier: Schemas.mrUXABdt_membership_components$schemas$identifier;
    account_identifier: Schemas.mrUXABdt_account_identifier;
}
export interface RequestBody$account$members$update$member {
    "application/json": Schemas.mrUXABdt_schemas$member;
}
export interface Response$account$members$update$member$Status$200 {
    "application/json": Schemas.mrUXABdt_single_member_response;
}
export interface Response$account$members$update$member$Status$4xx {
    "application/json": Schemas.mrUXABdt_response_single & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$account$members$remove$member {
    identifier: Schemas.mrUXABdt_membership_components$schemas$identifier;
    account_identifier: Schemas.mrUXABdt_account_identifier;
}
export interface Response$account$members$remove$member$Status$200 {
    "application/json": Schemas.mrUXABdt_api$response$single$id;
}
export interface Response$account$members$remove$member$Status$4xx {
    "application/json": Schemas.mrUXABdt_api$response$single$id & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$configuration$list$account$configuration {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$configuration$list$account$configuration$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response;
}
export interface Response$magic$network$monitoring$configuration$list$account$configuration$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$configuration$update$an$entire$account$configuration {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$configuration$update$an$entire$account$configuration$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response;
}
export interface Response$magic$network$monitoring$configuration$update$an$entire$account$configuration$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$configuration$create$account$configuration {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$configuration$create$account$configuration$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response;
}
export interface Response$magic$network$monitoring$configuration$create$account$configuration$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$configuration$delete$account$configuration {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$configuration$delete$account$configuration$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response;
}
export interface Response$magic$network$monitoring$configuration$delete$account$configuration$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$configuration$update$account$configuration$fields {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$configuration$update$account$configuration$fields$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response;
}
export interface Response$magic$network$monitoring$configuration$update$account$configuration$fields$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$configuration$list$rules$and$account$configuration {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$configuration$list$rules$and$account$configuration$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response;
}
export interface Response$magic$network$monitoring$configuration$list$rules$and$account$configuration$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_config_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$rules$list$rules {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$rules$list$rules$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_rules_collection_response;
}
export interface Response$magic$network$monitoring$rules$list$rules$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_rules_collection_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$rules$update$rules {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$rules$update$rules$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response;
}
export interface Response$magic$network$monitoring$rules$update$rules$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$rules$create$rules {
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$rules$create$rules$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response;
}
export interface Response$magic$network$monitoring$rules$create$rules$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$rules$get$rule {
    rule_identifier: Schemas.zhLWtXLP_rule_identifier;
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$rules$get$rule$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response;
}
export interface Response$magic$network$monitoring$rules$get$rule$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$rules$delete$rule {
    rule_identifier: Schemas.zhLWtXLP_rule_identifier;
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$rules$delete$rule$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response;
}
export interface Response$magic$network$monitoring$rules$delete$rule$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$rules$update$rule {
    rule_identifier: Schemas.zhLWtXLP_rule_identifier;
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$rules$update$rule$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response;
}
export interface Response$magic$network$monitoring$rules$update$rule$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_rules_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$magic$network$monitoring$rules$update$advertisement$for$rule {
    rule_identifier: Schemas.zhLWtXLP_rule_identifier;
    account_identifier: Schemas.zhLWtXLP_account_identifier;
}
export interface Response$magic$network$monitoring$rules$update$advertisement$for$rule$Status$200 {
    "application/json": Schemas.zhLWtXLP_mnm_rule_advertisement_single_response;
}
export interface Response$magic$network$monitoring$rules$update$advertisement$for$rule$Status$4XX {
    "application/json": Schemas.zhLWtXLP_mnm_rule_advertisement_single_response & Schemas.zhLWtXLP_api$response$common$failure;
}
export interface Parameter$m$tls$certificate$management$list$m$tls$certificates {
    account_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$m$tls$certificate$management$list$m$tls$certificates$Status$200 {
    "application/json": Schemas.ApQU2qAj_mtls$management_components$schemas$certificate_response_collection;
}
export interface Response$m$tls$certificate$management$list$m$tls$certificates$Status$4XX {
    "application/json": Schemas.ApQU2qAj_mtls$management_components$schemas$certificate_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$m$tls$certificate$management$upload$m$tls$certificate {
    account_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$m$tls$certificate$management$upload$m$tls$certificate {
    "application/json": {
        ca: Schemas.ApQU2qAj_ca;
        certificates: Schemas.ApQU2qAj_schemas$certificates;
        name?: Schemas.ApQU2qAj_schemas$name;
        private_key?: Schemas.ApQU2qAj_components$schemas$private_key;
    };
}
export interface Response$m$tls$certificate$management$upload$m$tls$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_single_post;
}
export interface Response$m$tls$certificate$management$upload$m$tls$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_response_single_post & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$m$tls$certificate$management$get$m$tls$certificate {
    identifier: Schemas.ApQU2qAj_identifier;
    account_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$m$tls$certificate$management$get$m$tls$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_mtls$management_components$schemas$certificate_response_single;
}
export interface Response$m$tls$certificate$management$get$m$tls$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_mtls$management_components$schemas$certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$m$tls$certificate$management$delete$m$tls$certificate {
    identifier: Schemas.ApQU2qAj_identifier;
    account_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$m$tls$certificate$management$delete$m$tls$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_mtls$management_components$schemas$certificate_response_single;
}
export interface Response$m$tls$certificate$management$delete$m$tls$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_mtls$management_components$schemas$certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$m$tls$certificate$management$list$m$tls$certificate$associations {
    identifier: Schemas.ApQU2qAj_identifier;
    account_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$m$tls$certificate$management$list$m$tls$certificate$associations$Status$200 {
    "application/json": Schemas.ApQU2qAj_association_response_collection;
}
export interface Response$m$tls$certificate$management$list$m$tls$certificate$associations$Status$4XX {
    "application/json": Schemas.ApQU2qAj_association_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$magic$pcap$collection$list$packet$capture$requests {
    account_identifier: Schemas.SxDaNi5K_identifier;
}
export interface Response$magic$pcap$collection$list$packet$capture$requests$Status$200 {
    "application/json": Schemas.SxDaNi5K_pcaps_collection_response;
}
export interface Response$magic$pcap$collection$list$packet$capture$requests$Status$default {
    "application/json": Schemas.SxDaNi5K_pcaps_collection_response | Schemas.SxDaNi5K_api$response$common$failure;
}
export interface Parameter$magic$pcap$collection$create$pcap$request {
    account_identifier: Schemas.SxDaNi5K_identifier;
}
export interface RequestBody$magic$pcap$collection$create$pcap$request {
    "application/json": Schemas.SxDaNi5K_pcaps_request_pcap;
}
export interface Response$magic$pcap$collection$create$pcap$request$Status$200 {
    "application/json": Schemas.SxDaNi5K_pcaps_single_response;
}
export interface Response$magic$pcap$collection$create$pcap$request$Status$default {
    "application/json": Schemas.SxDaNi5K_pcaps_single_response | Schemas.SxDaNi5K_api$response$common$failure;
}
export interface Parameter$magic$pcap$collection$get$pcap$request {
    identifier: Schemas.SxDaNi5K_identifier;
    account_identifier: Schemas.SxDaNi5K_identifier;
}
export interface Response$magic$pcap$collection$get$pcap$request$Status$200 {
    "application/json": Schemas.SxDaNi5K_pcaps_single_response;
}
export interface Response$magic$pcap$collection$get$pcap$request$Status$default {
    "application/json": Schemas.SxDaNi5K_pcaps_single_response | Schemas.SxDaNi5K_api$response$common$failure;
}
export interface Parameter$magic$pcap$collection$download$simple$pcap {
    identifier: Schemas.SxDaNi5K_identifier;
    account_identifier: Schemas.SxDaNi5K_identifier;
}
export interface Response$magic$pcap$collection$download$simple$pcap$Status$200 {
}
export interface Response$magic$pcap$collection$download$simple$pcap$Status$default {
}
export interface Parameter$magic$pcap$collection$list$pca$ps$bucket$ownership {
    account_identifier: Schemas.SxDaNi5K_identifier;
}
export interface Response$magic$pcap$collection$list$pca$ps$bucket$ownership$Status$200 {
    "application/json": Schemas.SxDaNi5K_pcaps_ownership_collection;
}
export interface Response$magic$pcap$collection$list$pca$ps$bucket$ownership$Status$default {
    "application/json": Schemas.SxDaNi5K_pcaps_ownership_collection | Schemas.SxDaNi5K_api$response$common$failure;
}
export interface Parameter$magic$pcap$collection$add$buckets$for$full$packet$captures {
    account_identifier: Schemas.SxDaNi5K_identifier;
}
export interface RequestBody$magic$pcap$collection$add$buckets$for$full$packet$captures {
    "application/json": Schemas.SxDaNi5K_pcaps_ownership_request;
}
export interface Response$magic$pcap$collection$add$buckets$for$full$packet$captures$Status$200 {
    "application/json": Schemas.SxDaNi5K_pcaps_ownership_single_response;
}
export interface Response$magic$pcap$collection$add$buckets$for$full$packet$captures$Status$default {
    "application/json": Schemas.SxDaNi5K_pcaps_ownership_single_response | Schemas.SxDaNi5K_api$response$common$failure;
}
export interface Parameter$magic$pcap$collection$delete$buckets$for$full$packet$captures {
    identifier: Schemas.SxDaNi5K_identifier;
    account_identifier: Schemas.SxDaNi5K_identifier;
}
export interface Response$magic$pcap$collection$delete$buckets$for$full$packet$captures$Status$default {
}
export interface Parameter$magic$pcap$collection$validate$buckets$for$full$packet$captures {
    account_identifier: Schemas.SxDaNi5K_identifier;
}
export interface RequestBody$magic$pcap$collection$validate$buckets$for$full$packet$captures {
    "application/json": Schemas.SxDaNi5K_pcaps_ownership_validate_request;
}
export interface Response$magic$pcap$collection$validate$buckets$for$full$packet$captures$Status$200 {
    "application/json": Schemas.SxDaNi5K_pcaps_ownership_single_response;
}
export interface Response$magic$pcap$collection$validate$buckets$for$full$packet$captures$Status$default {
    "application/json": Schemas.SxDaNi5K_pcaps_ownership_single_response | Schemas.SxDaNi5K_api$response$common$failure;
}
export interface Parameter$account$request$tracer$request$trace {
    account_identifier: Schemas.Zzhfoun1_identifier;
}
export interface RequestBody$account$request$tracer$request$trace {
    "application/json": {
        body?: {
            /** Base64 encoded request body */
            base64?: string;
            /** Arbitrary json as request body */
            json?: {};
            /** Request body as plain text */
            plain_text?: string;
        };
        /** Additional request parameters */
        context?: {
            /** Bot score used for evaluating tracing request processing */
            bot_score?: number;
            /** Geodata for tracing request */
            geoloc?: {
                city?: string;
                continent?: string;
                is_eu_country?: boolean;
                iso_code?: string;
                latitude?: number;
                longitude?: number;
                postal_code?: string;
                region_code?: string;
                subdivision_2_iso_code?: string;
                timezone?: string;
            };
            /** Whether to skip any challenges for tracing request (e.g.: captcha) */
            skip_challenge?: boolean;
            /** Threat score used for evaluating tracing request processing */
            threat_score?: number;
        };
        /** Cookies added to tracing request */
        cookies?: {};
        /** Headers added to tracing request */
        headers?: {};
        /** HTTP Method of tracing request */
        method: string;
        /** HTTP Protocol of tracing request */
        protocol?: string;
        /** Skip sending the request to the Origin server after all rules evaluation */
        skip_response?: boolean;
        /** URL to which perform tracing request */
        url: string;
    };
}
export interface Response$account$request$tracer$request$trace$Status$200 {
    "application/json": Schemas.Zzhfoun1_api$response$common & {
        /** Trace result with an origin status code */
        result?: {
            /** HTTP Status code of zone response */
            status_code?: number;
            trace?: Schemas.Zzhfoun1_trace;
        };
    };
}
export interface Response$account$request$tracer$request$trace$Status$4XX {
    "application/json": Schemas.Zzhfoun1_api$response$common$failure;
}
export interface Parameter$account$roles$list$roles {
    account_identifier: Schemas.mrUXABdt_account_identifier;
}
export interface Response$account$roles$list$roles$Status$200 {
    "application/json": Schemas.mrUXABdt_collection_role_response;
}
export interface Response$account$roles$list$roles$Status$4xx {
    "application/json": Schemas.mrUXABdt_response_collection & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$account$roles$role$details {
    identifier: Schemas.mrUXABdt_schemas$identifier;
    account_identifier: Schemas.mrUXABdt_account_identifier;
}
export interface Response$account$roles$role$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_role_response;
}
export interface Response$account$roles$role$details$Status$4xx {
    "application/json": Schemas.mrUXABdt_response_single & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$lists$get$a$list$item {
    item_id: Schemas.lists_item_id;
    list_id: Schemas.lists_list_id;
    account_identifier: Schemas.lists_identifier;
}
export interface Response$lists$get$a$list$item$Status$200 {
    "application/json": Schemas.lists_item$response$collection;
}
export interface Response$lists$get$a$list$item$Status$4XX {
    "application/json": Schemas.lists_item$response$collection & Schemas.lists_api$response$common$failure;
}
export interface Parameter$lists$get$bulk$operation$status {
    operation_id: Schemas.lists_operation_id;
    account_identifier: Schemas.lists_identifier;
}
export interface Response$lists$get$bulk$operation$status$Status$200 {
    "application/json": Schemas.lists_bulk$operation$response$collection;
}
export interface Response$lists$get$bulk$operation$status$Status$4XX {
    "application/json": Schemas.lists_bulk$operation$response$collection & Schemas.lists_api$response$common$failure;
}
export interface Parameter$web$analytics$create$site {
    account_identifier: Schemas.X3uh9Izk_identifier;
}
export interface RequestBody$web$analytics$create$site {
    "application/json": Schemas.X3uh9Izk_create$site$request;
}
export interface Response$web$analytics$create$site$Status$200 {
    "application/json": Schemas.X3uh9Izk_site$response$single;
}
export interface Response$web$analytics$create$site$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$get$site {
    account_identifier: Schemas.X3uh9Izk_identifier;
    site_identifier: Schemas.X3uh9Izk_identifier;
}
export interface Response$web$analytics$get$site$Status$200 {
    "application/json": Schemas.X3uh9Izk_site$response$single;
}
export interface Response$web$analytics$get$site$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$update$site {
    account_identifier: Schemas.X3uh9Izk_identifier;
    site_identifier: Schemas.X3uh9Izk_identifier;
}
export interface RequestBody$web$analytics$update$site {
    "application/json": Schemas.X3uh9Izk_create$site$request;
}
export interface Response$web$analytics$update$site$Status$200 {
    "application/json": Schemas.X3uh9Izk_site$response$single;
}
export interface Response$web$analytics$update$site$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$delete$site {
    account_identifier: Schemas.X3uh9Izk_identifier;
    site_identifier: Schemas.X3uh9Izk_identifier;
}
export interface Response$web$analytics$delete$site$Status$200 {
    "application/json": Schemas.X3uh9Izk_site$tag$response$single;
}
export interface Response$web$analytics$delete$site$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$list$sites {
    account_identifier: Schemas.X3uh9Izk_identifier;
    per_page?: Schemas.X3uh9Izk_per_page;
    page?: Schemas.X3uh9Izk_page;
    order_by?: Schemas.X3uh9Izk_order_by;
}
export interface Response$web$analytics$list$sites$Status$200 {
    "application/json": Schemas.X3uh9Izk_sites$response$collection;
}
export interface Response$web$analytics$list$sites$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$create$rule {
    account_identifier: Schemas.X3uh9Izk_identifier;
    ruleset_identifier: Schemas.X3uh9Izk_ruleset_identifier;
}
export interface RequestBody$web$analytics$create$rule {
    "application/json": Schemas.X3uh9Izk_create$rule$request;
}
export interface Response$web$analytics$create$rule$Status$200 {
    "application/json": Schemas.X3uh9Izk_rule$response$single;
}
export interface Response$web$analytics$create$rule$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$update$rule {
    account_identifier: Schemas.X3uh9Izk_identifier;
    ruleset_identifier: Schemas.X3uh9Izk_ruleset_identifier;
    rule_identifier: Schemas.X3uh9Izk_rule_identifier;
}
export interface RequestBody$web$analytics$update$rule {
    "application/json": Schemas.X3uh9Izk_create$rule$request;
}
export interface Response$web$analytics$update$rule$Status$200 {
    "application/json": Schemas.X3uh9Izk_rule$response$single;
}
export interface Response$web$analytics$update$rule$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$delete$rule {
    account_identifier: Schemas.X3uh9Izk_identifier;
    ruleset_identifier: Schemas.X3uh9Izk_ruleset_identifier;
    rule_identifier: Schemas.X3uh9Izk_rule_identifier;
}
export interface Response$web$analytics$delete$rule$Status$200 {
    "application/json": Schemas.X3uh9Izk_rule$id$response$single;
}
export interface Response$web$analytics$delete$rule$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$list$rules {
    account_identifier: Schemas.X3uh9Izk_identifier;
    ruleset_identifier: Schemas.X3uh9Izk_ruleset_identifier;
}
export interface Response$web$analytics$list$rules$Status$200 {
    "application/json": Schemas.X3uh9Izk_rules$response$collection;
}
export interface Response$web$analytics$list$rules$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$web$analytics$modify$rules {
    account_identifier: Schemas.X3uh9Izk_identifier;
    ruleset_identifier: Schemas.X3uh9Izk_ruleset_identifier;
}
export interface RequestBody$web$analytics$modify$rules {
    "application/json": Schemas.X3uh9Izk_modify$rules$request;
}
export interface Response$web$analytics$modify$rules$Status$200 {
    "application/json": Schemas.X3uh9Izk_rules$response$collection;
}
export interface Response$web$analytics$modify$rules$Status$4XX {
    "application/json": Schemas.X3uh9Izk_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$acl$$list$ac$ls {
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$acl$$list$ac$ls$Status$200 {
    "application/json": Schemas.vusJxt3o_components$schemas$response_collection;
}
export interface Response$secondary$dns$$$acl$$list$ac$ls$Status$4XX {
    "application/json": Schemas.vusJxt3o_components$schemas$response_collection & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$acl$$create$acl {
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface RequestBody$secondary$dns$$$acl$$create$acl {
    "application/json": {
        name: any;
        ip_range: any;
    };
}
export interface Response$secondary$dns$$$acl$$create$acl$Status$200 {
    "application/json": Schemas.vusJxt3o_components$schemas$single_response;
}
export interface Response$secondary$dns$$$acl$$create$acl$Status$4XX {
    "application/json": Schemas.vusJxt3o_components$schemas$single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$acl$$acl$details {
    identifier: Schemas.vusJxt3o_components$schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$acl$$acl$details$Status$200 {
    "application/json": Schemas.vusJxt3o_components$schemas$single_response;
}
export interface Response$secondary$dns$$$acl$$acl$details$Status$4XX {
    "application/json": Schemas.vusJxt3o_components$schemas$single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$acl$$update$acl {
    identifier: Schemas.vusJxt3o_components$schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface RequestBody$secondary$dns$$$acl$$update$acl {
    "application/json": Schemas.vusJxt3o_acl;
}
export interface Response$secondary$dns$$$acl$$update$acl$Status$200 {
    "application/json": Schemas.vusJxt3o_components$schemas$single_response;
}
export interface Response$secondary$dns$$$acl$$update$acl$Status$4XX {
    "application/json": Schemas.vusJxt3o_components$schemas$single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$acl$$delete$acl {
    identifier: Schemas.vusJxt3o_components$schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$acl$$delete$acl$Status$200 {
    "application/json": Schemas.vusJxt3o_components$schemas$id_response;
}
export interface Response$secondary$dns$$$acl$$delete$acl$Status$4XX {
    "application/json": Schemas.vusJxt3o_components$schemas$id_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$peer$$list$peers {
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$peer$$list$peers$Status$200 {
    "application/json": Schemas.vusJxt3o_schemas$response_collection;
}
export interface Response$secondary$dns$$$peer$$list$peers$Status$4XX {
    "application/json": Schemas.vusJxt3o_schemas$response_collection & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$peer$$create$peer {
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface RequestBody$secondary$dns$$$peer$$create$peer {
    "application/json": {
        name: any;
    };
}
export interface Response$secondary$dns$$$peer$$create$peer$Status$200 {
    "application/json": Schemas.vusJxt3o_schemas$single_response;
}
export interface Response$secondary$dns$$$peer$$create$peer$Status$4XX {
    "application/json": Schemas.vusJxt3o_schemas$single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$peer$$peer$details {
    identifier: Schemas.vusJxt3o_components$schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$peer$$peer$details$Status$200 {
    "application/json": Schemas.vusJxt3o_schemas$single_response;
}
export interface Response$secondary$dns$$$peer$$peer$details$Status$4XX {
    "application/json": Schemas.vusJxt3o_schemas$single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$peer$$update$peer {
    identifier: Schemas.vusJxt3o_components$schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface RequestBody$secondary$dns$$$peer$$update$peer {
    "application/json": Schemas.vusJxt3o_peer;
}
export interface Response$secondary$dns$$$peer$$update$peer$Status$200 {
    "application/json": Schemas.vusJxt3o_schemas$single_response;
}
export interface Response$secondary$dns$$$peer$$update$peer$Status$4XX {
    "application/json": Schemas.vusJxt3o_schemas$single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$peer$$delete$peer {
    identifier: Schemas.vusJxt3o_components$schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$peer$$delete$peer$Status$200 {
    "application/json": Schemas.vusJxt3o_components$schemas$id_response;
}
export interface Response$secondary$dns$$$peer$$delete$peer$Status$4XX {
    "application/json": Schemas.vusJxt3o_components$schemas$id_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$tsig$$list$tsi$gs {
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$tsig$$list$tsi$gs$Status$200 {
    "application/json": Schemas.vusJxt3o_response_collection;
}
export interface Response$secondary$dns$$$tsig$$list$tsi$gs$Status$4XX {
    "application/json": Schemas.vusJxt3o_response_collection & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$tsig$$create$tsig {
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface RequestBody$secondary$dns$$$tsig$$create$tsig {
    "application/json": Schemas.vusJxt3o_tsig;
}
export interface Response$secondary$dns$$$tsig$$create$tsig$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response;
}
export interface Response$secondary$dns$$$tsig$$create$tsig$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$tsig$$tsig$details {
    identifier: Schemas.vusJxt3o_schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$tsig$$tsig$details$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response;
}
export interface Response$secondary$dns$$$tsig$$tsig$details$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$tsig$$update$tsig {
    identifier: Schemas.vusJxt3o_schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface RequestBody$secondary$dns$$$tsig$$update$tsig {
    "application/json": Schemas.vusJxt3o_tsig;
}
export interface Response$secondary$dns$$$tsig$$update$tsig$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response;
}
export interface Response$secondary$dns$$$tsig$$update$tsig$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$tsig$$delete$tsig {
    identifier: Schemas.vusJxt3o_schemas$identifier;
    account_identifier: Schemas.vusJxt3o_account_identifier;
}
export interface Response$secondary$dns$$$tsig$$delete$tsig$Status$200 {
    "application/json": Schemas.vusJxt3o_schemas$id_response;
}
export interface Response$secondary$dns$$$tsig$$delete$tsig$Status$4XX {
    "application/json": Schemas.vusJxt3o_schemas$id_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$workers$kv$request$analytics$query$request$analytics {
    account_identifier: Schemas.workers$kv_identifier;
    query?: Schemas.workers$kv_query & {
        dimensions?: ("accountId" | "responseCode" | "requestType")[];
        filters?: any;
        metrics?: ("requests" | "writeKiB" | "readKiB")[];
        sort?: any;
    };
}
export interface Response$workers$kv$request$analytics$query$request$analytics$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single & {
        result?: Schemas.workers$kv_schemas$result;
    };
}
export interface Response$workers$kv$request$analytics$query$request$analytics$Status$4XX {
    "application/json": (Schemas.workers$kv_api$response$single & {
        result?: Schemas.workers$kv_result;
    }) & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$stored$data$analytics$query$stored$data$analytics {
    account_identifier: Schemas.workers$kv_identifier;
    query?: Schemas.workers$kv_query & {
        dimensions?: ("namespaceId")[];
        filters?: any;
        metrics?: ("storedBytes" | "storedKeys")[];
        sort?: any;
    };
}
export interface Response$workers$kv$stored$data$analytics$query$stored$data$analytics$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single & {
        result?: Schemas.workers$kv_components$schemas$result;
    };
}
export interface Response$workers$kv$stored$data$analytics$query$stored$data$analytics$Status$4XX {
    "application/json": (Schemas.workers$kv_api$response$single & {
        result?: Schemas.workers$kv_result;
    }) & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$list$namespaces {
    account_identifier: Schemas.workers$kv_identifier;
    page?: number;
    per_page?: number;
    order?: "id" | "title";
    direction?: "asc" | "desc";
}
export interface Response$workers$kv$namespace$list$namespaces$Status$200 {
    "application/json": Schemas.workers$kv_api$response$collection & {
        result?: Schemas.workers$kv_namespace[];
    };
}
export interface Response$workers$kv$namespace$list$namespaces$Status$4XX {
    "application/json": (Schemas.workers$kv_api$response$collection & {
        result?: Schemas.workers$kv_namespace[];
    }) & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$create$a$namespace {
    account_identifier: Schemas.workers$kv_identifier;
}
export interface RequestBody$workers$kv$namespace$create$a$namespace {
    "application/json": Schemas.workers$kv_create_rename_namespace_body;
}
export interface Response$workers$kv$namespace$create$a$namespace$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single & {
        result?: Schemas.workers$kv_namespace;
    };
}
export interface Response$workers$kv$namespace$create$a$namespace$Status$4XX {
    "application/json": (Schemas.workers$kv_api$response$single & {
        result?: Schemas.workers$kv_namespace;
    }) & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$rename$a$namespace {
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
}
export interface RequestBody$workers$kv$namespace$rename$a$namespace {
    "application/json": Schemas.workers$kv_create_rename_namespace_body;
}
export interface Response$workers$kv$namespace$rename$a$namespace$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single;
}
export interface Response$workers$kv$namespace$rename$a$namespace$Status$4XX {
    "application/json": Schemas.workers$kv_api$response$single & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$remove$a$namespace {
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
}
export interface Response$workers$kv$namespace$remove$a$namespace$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single;
}
export interface Response$workers$kv$namespace$remove$a$namespace$Status$4XX {
    "application/json": Schemas.workers$kv_api$response$single & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$write$multiple$key$value$pairs {
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
}
export interface RequestBody$workers$kv$namespace$write$multiple$key$value$pairs {
    "application/json": Schemas.workers$kv_bulk_write;
}
export interface Response$workers$kv$namespace$write$multiple$key$value$pairs$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single;
}
export interface Response$workers$kv$namespace$write$multiple$key$value$pairs$Status$4XX {
    "application/json": Schemas.workers$kv_api$response$single & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$delete$multiple$key$value$pairs {
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
}
export interface RequestBody$workers$kv$namespace$delete$multiple$key$value$pairs {
    "application/json": Schemas.workers$kv_bulk_delete;
}
export interface Response$workers$kv$namespace$delete$multiple$key$value$pairs$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single;
}
export interface Response$workers$kv$namespace$delete$multiple$key$value$pairs$Status$4XX {
    "application/json": Schemas.workers$kv_api$response$single & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$list$a$namespace$$s$keys {
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
    limit?: number;
    prefix?: string;
    cursor?: string;
}
export interface Response$workers$kv$namespace$list$a$namespace$$s$keys$Status$200 {
    "application/json": Schemas.workers$kv_api$response$common & {
        result?: Schemas.workers$kv_key[];
        result_info?: {
            /** Total results returned based on your list parameters. */
            count?: number;
            cursor?: Schemas.workers$kv_cursor;
        };
    };
}
export interface Response$workers$kv$namespace$list$a$namespace$$s$keys$Status$4XX {
    "application/json": (Schemas.workers$kv_api$response$common & {
        result?: Schemas.workers$kv_key[];
        result_info?: {
            /** Total results returned based on your list parameters. */
            count?: number;
            cursor?: Schemas.workers$kv_cursor;
        };
    }) & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$read$the$metadata$for$a$key {
    key_name: Schemas.workers$kv_key_name;
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
}
export interface Response$workers$kv$namespace$read$the$metadata$for$a$key$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single & {
        result?: Schemas.workers$kv_list_metadata;
    };
}
export interface Response$workers$kv$namespace$read$the$metadata$for$a$key$Status$4XX {
    "application/json": (Schemas.workers$kv_api$response$single & {
        result?: Schemas.workers$kv_list_metadata;
    }) & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$read$key$value$pair {
    key_name: Schemas.workers$kv_key_name;
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
}
export interface Response$workers$kv$namespace$read$key$value$pair$Status$200 {
    "application/json": Schemas.workers$kv_value;
}
export interface Response$workers$kv$namespace$read$key$value$pair$Status$4XX {
    "application/json": Schemas.workers$kv_value & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$write$key$value$pair$with$metadata {
    key_name: Schemas.workers$kv_key_name;
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
}
export interface RequestBody$workers$kv$namespace$write$key$value$pair$with$metadata {
    "multipart/form-data": {
        metadata: Schemas.workers$kv_metadata;
        value: Schemas.workers$kv_value;
    };
}
export interface Response$workers$kv$namespace$write$key$value$pair$with$metadata$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single;
}
export interface Response$workers$kv$namespace$write$key$value$pair$with$metadata$Status$4XX {
    "application/json": Schemas.workers$kv_api$response$single & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$workers$kv$namespace$delete$key$value$pair {
    key_name: Schemas.workers$kv_key_name;
    namespace_identifier: Schemas.workers$kv_namespace_identifier;
    account_identifier: Schemas.workers$kv_identifier;
}
export interface Response$workers$kv$namespace$delete$key$value$pair$Status$200 {
    "application/json": Schemas.workers$kv_api$response$single;
}
export interface Response$workers$kv$namespace$delete$key$value$pair$Status$4XX {
    "application/json": Schemas.workers$kv_api$response$single & Schemas.workers$kv_api$response$common$failure;
}
export interface Parameter$account$subscriptions$list$subscriptions {
    account_identifier: Schemas.bill$subs$api_identifier;
}
export interface Response$account$subscriptions$list$subscriptions$Status$200 {
    "application/json": Schemas.bill$subs$api_account_subscription_response_collection;
}
export interface Response$account$subscriptions$list$subscriptions$Status$4XX {
    "application/json": Schemas.bill$subs$api_account_subscription_response_collection & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$account$subscriptions$create$subscription {
    account_identifier: Schemas.bill$subs$api_identifier;
}
export interface RequestBody$account$subscriptions$create$subscription {
    "application/json": Schemas.bill$subs$api_subscription$v2;
}
export interface Response$account$subscriptions$create$subscription$Status$200 {
    "application/json": Schemas.bill$subs$api_account_subscription_response_single;
}
export interface Response$account$subscriptions$create$subscription$Status$4XX {
    "application/json": Schemas.bill$subs$api_account_subscription_response_single & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$account$subscriptions$update$subscription {
    subscription_identifier: Schemas.bill$subs$api_schemas$identifier;
    account_identifier: Schemas.bill$subs$api_identifier;
}
export interface RequestBody$account$subscriptions$update$subscription {
    "application/json": Schemas.bill$subs$api_subscription$v2;
}
export interface Response$account$subscriptions$update$subscription$Status$200 {
    "application/json": Schemas.bill$subs$api_account_subscription_response_single;
}
export interface Response$account$subscriptions$update$subscription$Status$4XX {
    "application/json": Schemas.bill$subs$api_account_subscription_response_single & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$account$subscriptions$delete$subscription {
    subscription_identifier: Schemas.bill$subs$api_schemas$identifier;
    account_identifier: Schemas.bill$subs$api_identifier;
}
export interface Response$account$subscriptions$delete$subscription$Status$200 {
    "application/json": Schemas.bill$subs$api_api$response$single & {
        result?: {
            subscription_id?: Schemas.bill$subs$api_schemas$identifier;
        };
    };
}
export interface Response$account$subscriptions$delete$subscription$Status$4XX {
    "application/json": (Schemas.bill$subs$api_api$response$single & {
        result?: {
            subscription_id?: Schemas.bill$subs$api_schemas$identifier;
        };
    }) & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$vectorize$list$vectorize$indexes {
    account_identifier: Schemas.vectorize_identifier;
}
export interface Response$vectorize$list$vectorize$indexes$Status$200 {
    "application/json": Schemas.vectorize_api$response$common & {
        result?: Schemas.vectorize_create$index$response[];
    };
}
export interface Response$vectorize$list$vectorize$indexes$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$create$vectorize$index {
    account_identifier: Schemas.vectorize_identifier;
}
export interface RequestBody$vectorize$create$vectorize$index {
    "application/json": Schemas.vectorize_create$index$request;
}
export interface Response$vectorize$create$vectorize$index$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: Schemas.vectorize_create$index$response;
    };
}
export interface Response$vectorize$create$vectorize$index$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$get$vectorize$index {
    account_identifier: Schemas.vectorize_identifier;
    index_name: Schemas.vectorize_index$name;
}
export interface Response$vectorize$get$vectorize$index$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: Schemas.vectorize_create$index$response;
    };
}
export interface Response$vectorize$get$vectorize$index$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$update$vectorize$index {
    account_identifier: Schemas.vectorize_identifier;
    index_name: Schemas.vectorize_index$name;
}
export interface RequestBody$vectorize$update$vectorize$index {
    "application/json": Schemas.vectorize_update$index$request;
}
export interface Response$vectorize$update$vectorize$index$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: Schemas.vectorize_create$index$response;
    };
}
export interface Response$vectorize$update$vectorize$index$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$delete$vectorize$index {
    account_identifier: Schemas.vectorize_identifier;
    index_name: Schemas.vectorize_index$name;
}
export interface Response$vectorize$delete$vectorize$index$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: {} | null;
    };
}
export interface Response$vectorize$delete$vectorize$index$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$delete$vectors$by$id {
    account_identifier: Schemas.vectorize_identifier;
    index_name: Schemas.vectorize_index$name;
}
export interface RequestBody$vectorize$delete$vectors$by$id {
    "application/json": Schemas.vectorize_index$delete$vectors$by$id$request;
}
export interface Response$vectorize$delete$vectors$by$id$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: Schemas.vectorize_index$delete$vectors$by$id$response;
    };
}
export interface Response$vectorize$delete$vectors$by$id$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$get$vectors$by$id {
    account_identifier: Schemas.vectorize_identifier;
    index_name: Schemas.vectorize_index$name;
}
export interface RequestBody$vectorize$get$vectors$by$id {
    "application/json": Schemas.vectorize_index$get$vectors$by$id$request;
}
export interface Response$vectorize$get$vectors$by$id$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: Schemas.vectorize_index$get$vectors$by$id$response;
    };
}
export interface Response$vectorize$get$vectors$by$id$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$insert$vector {
    account_identifier: Schemas.vectorize_identifier;
    index_name: Schemas.vectorize_index$name;
}
export interface RequestBody$vectorize$insert$vector {
    /** ndjson file containing vectors to insert. */
    "application/x-ndjson": Blob;
}
export interface Response$vectorize$insert$vector$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: Schemas.vectorize_index$insert$response;
    };
}
export interface Response$vectorize$insert$vector$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$query$vector {
    account_identifier: Schemas.vectorize_identifier;
    index_name: Schemas.vectorize_index$name;
}
export interface RequestBody$vectorize$query$vector {
    "application/json": Schemas.vectorize_index$query$request;
}
export interface Response$vectorize$query$vector$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: Schemas.vectorize_index$query$response;
    };
}
export interface Response$vectorize$query$vector$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$vectorize$upsert$vector {
    account_identifier: Schemas.vectorize_identifier;
    index_name: Schemas.vectorize_index$name;
}
export interface RequestBody$vectorize$upsert$vector {
    /** ndjson file containing vectors to upsert. */
    "application/x-ndjson": Blob;
}
export interface Response$vectorize$upsert$vector$Status$200 {
    "application/json": Schemas.vectorize_api$response$single & {
        result?: Schemas.vectorize_index$upsert$response;
    };
}
export interface Response$vectorize$upsert$vector$Status$4XX {
    "application/json": (Schemas.vectorize_api$response$single & {
        result?: {} | null;
    }) & Schemas.vectorize_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$add$an$account$membership$to$an$address$map {
    account_identifier: Schemas.addressing_identifier;
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier1: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$add$an$account$membership$to$an$address$map$Status$200 {
    "application/json": Schemas.addressing_api$response$collection;
}
export interface Response$ip$address$management$address$maps$add$an$account$membership$to$an$address$map$Status$4XX {
    "application/json": Schemas.addressing_api$response$collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map {
    account_identifier: Schemas.addressing_identifier;
    address_map_identifier: Schemas.addressing_identifier;
    account_identifier1: Schemas.addressing_identifier;
}
export interface Response$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map$Status$200 {
    "application/json": Schemas.addressing_api$response$collection;
}
export interface Response$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map$Status$4XX {
    "application/json": Schemas.addressing_api$response$collection & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$urlscanner$search$scans {
    accountId: string;
    scanId?: string;
    limit?: number;
    next_cursor?: string;
    date_start?: Date;
    date_end?: Date;
    url?: string;
    hostname?: string;
    path?: string;
    page_url?: string;
    page_hostname?: string;
    page_path?: string;
    account_scans?: boolean;
}
export interface Response$urlscanner$search$scans$Status$200 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        result: {
            tasks: {
                /** Whether scan was successful or not */
                success: boolean;
                /** When scan was submitted (UTC) */
                time: Date;
                /** Scan url (after redirects) */
                url: string;
                /** Scan id */
                uuid: string;
            }[];
        };
        /** Whether search request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$search$scans$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Parameter$urlscanner$create$scan {
    accountId: string;
}
export interface RequestBody$urlscanner$create$scan {
    "application/json": {
        /** Set custom headers */
        customHeaders?: {};
        /** Take multiple screenshots targeting different device types */
        screenshotsResolutions?: ("desktop" | "mobile" | "tablet")[];
        url: string;
        /** The option \`Public\` means it will be included in listings like recent scans and search results. \`Unlisted\` means it will not be included in the aforementioned listings, users will need to have the scan's ID to access it. A a scan will be automatically marked as unlisted if it fails, if it contains potential PII or other sensitive material. */
        visibility?: "Public" | "Unlisted";
    };
}
export interface Response$urlscanner$create$scan$Status$200 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        result: {
            /** Time when url was submitted for scanning. */
            time: Date;
            /** Canonical form of submitted URL. Use this if you want to later search by URL. */
            url: string;
            /** Scan ID. */
            uuid: string;
            /** Submitted visibility status. */
            visibility: string;
        };
        success: boolean;
    };
}
export interface Response$urlscanner$create$scan$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$create$scan$Status$409 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        result: {
            tasks: {
                /** Submitter location */
                clientLocation: string;
                clientType: "Site" | "Automatic" | "Api";
                /** URL of the primary request, after all HTTP redirects */
                effectiveUrl: string;
                errors: {
                    message: string;
                }[];
                scannedFrom: {
                    /** IATA code of Cloudflare datacenter */
                    colo: string;
                };
                status: "Queued" | "InProgress" | "InPostProcessing" | "Finished";
                success: boolean;
                time: string;
                timeEnd: string;
                /** Submitted URL */
                url: string;
                /** Scan ID */
                uuid: string;
                visibility: "Public" | "Unlisted";
            }[];
        };
        success: boolean;
    };
}
export interface Response$urlscanner$create$scan$Status$429 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        success: boolean;
    };
}
export interface Parameter$urlscanner$get$scan {
    scanId: string;
    accountId: string;
}
export interface Response$urlscanner$get$scan$Status$200 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        result: {
            scan: {
                /** Dictionary of Autonomous System Numbers where ASN's are the keys */
                asns?: {
                    /** ASN's contacted */
                    asn?: {
                        asn: string;
                        description: string;
                        location_alpha2: string;
                        name: string;
                        org_name: string;
                    };
                };
                certificates: {
                    issuer: string;
                    subjectName: string;
                    validFrom: number;
                    validTo: number;
                }[];
                domains?: {
                    "example.com"?: {
                        categories: {
                            content?: {
                                id: number;
                                name: string;
                                super_category_id?: number;
                            }[];
                            inherited: {
                                content?: {
                                    id: number;
                                    name: string;
                                    super_category_id?: number;
                                }[];
                                from?: string;
                                risks?: {
                                    id: number;
                                    name: string;
                                    super_category_id?: number;
                                }[];
                            };
                            risks?: {
                                id: number;
                                name: string;
                                super_category_id?: number;
                            }[];
                        };
                        dns: {
                            address: string;
                            dnssec_valid: boolean;
                            name: string;
                            type: string;
                        }[];
                        name: string;
                        rank: {
                            bucket: string;
                            name: string;
                            /** Rank in the Global Radar Rank, if set. See more at https://blog.cloudflare.com/radar-domain-rankings/ */
                            rank?: number;
                        };
                        type: string;
                    };
                };
                geo: {
                    /** GeoIP continent location */
                    continents: string[];
                    /** GeoIP country location */
                    locations: string[];
                };
                ips?: {
                    ip?: {
                        asn: string;
                        asnDescription: string;
                        asnLocationAlpha2: string;
                        asnName: string;
                        asnOrgName: string;
                        continent: string;
                        geonameId: string;
                        ip: string;
                        ipVersion: string;
                        latitude: string;
                        locationAlpha2: string;
                        locationName: string;
                        longitude: string;
                        subdivision1Name: string;
                        subdivision2Name: string;
                    };
                };
                links?: {
                    link?: {
                        /** Outgoing link detected in the DOM */
                        href: string;
                        text: string;
                    };
                };
                meta: {
                    processors: {
                        categories: {
                            content: {
                                id: number;
                                name: string;
                                super_category_id?: number;
                            }[];
                            risks: {
                                id: number;
                                name: string;
                                super_category_id: number;
                            }[];
                        };
                        google_safe_browsing: string[];
                        phishing: string[];
                        rank: {
                            bucket: string;
                            name: string;
                            /** Rank in the Global Radar Rank, if set. See more at https://blog.cloudflare.com/radar-domain-rankings/ */
                            rank?: number;
                        };
                        tech: {
                            categories: {
                                groups: number[];
                                id: number;
                                name: string;
                                priority: number;
                                slug: string;
                            }[];
                            confidence: number;
                            description?: string;
                            evidence: {
                                impliedBy: string[];
                                patterns: {
                                    confidence: number;
                                    excludes: string[];
                                    implies: string[];
                                    match: string;
                                    /** Header or Cookie name when set */
                                    name: string;
                                    regex: string;
                                    type: string;
                                    value: string;
                                    version: string;
                                }[];
                            };
                            icon: string;
                            name: string;
                            slug: string;
                            website: string;
                        }[];
                    };
                };
                page: {
                    asn: string;
                    asnLocationAlpha2: string;
                    asnname: string;
                    console: {
                        category: string;
                        text: string;
                        type: string;
                        url?: string;
                    }[];
                    cookies: {
                        domain: string;
                        expires: number;
                        httpOnly: boolean;
                        name: string;
                        path: string;
                        priority?: string;
                        sameParty: boolean;
                        secure: boolean;
                        session: boolean;
                        size: number;
                        sourcePort: number;
                        sourceScheme: string;
                        value: string;
                    }[];
                    country: string;
                    countryLocationAlpha2: string;
                    domain: string;
                    headers: {
                        name: string;
                        value: string;
                    }[];
                    ip: string;
                    js: {
                        variables: {
                            name: string;
                            type: string;
                        }[];
                    };
                    securityViolations: {
                        category: string;
                        text: string;
                        url: string;
                    }[];
                    status: number;
                    subdivision1Name: string;
                    subdivision2name: string;
                    url: string;
                };
                performance: {
                    connectEnd: number;
                    connectStart: number;
                    decodedBodySize: number;
                    domComplete: number;
                    domContentLoadedEventEnd: number;
                    domContentLoadedEventStart: number;
                    domInteractive: number;
                    domainLookupEnd: number;
                    domainLookupStart: number;
                    duration: number;
                    encodedBodySize: number;
                    entryType: string;
                    fetchStart: number;
                    initiatorType: string;
                    loadEventEnd: number;
                    loadEventStart: number;
                    name: string;
                    nextHopProtocol: string;
                    redirectCount: number;
                    redirectEnd: number;
                    redirectStart: number;
                    requestStart: number;
                    responseEnd: number;
                    responseStart: number;
                    secureConnectionStart: number;
                    startTime: number;
                    transferSize: number;
                    type: string;
                    unloadEventEnd: number;
                    unloadEventStart: number;
                    workerStart: number;
                }[];
                task: {
                    /** Submitter location */
                    clientLocation: string;
                    clientType: "Site" | "Automatic" | "Api";
                    /** URL of the primary request, after all HTTP redirects */
                    effectiveUrl: string;
                    errors: {
                        message: string;
                    }[];
                    scannedFrom: {
                        /** IATA code of Cloudflare datacenter */
                        colo: string;
                    };
                    status: "Queued" | "InProgress" | "InPostProcessing" | "Finished";
                    success: boolean;
                    time: string;
                    timeEnd: string;
                    /** Submitted URL */
                    url: string;
                    /** Scan ID */
                    uuid: string;
                    visibility: "Public" | "Unlisted";
                };
                verdicts: {
                    overall: {
                        categories: {
                            id: number;
                            name: string;
                            super_category_id: number;
                        }[];
                        /** Please visit https://safebrowsing.google.com/ for more information. */
                        gsb_threat_types: string[];
                        /** At least one of our subsystems marked the site as potentially malicious at the time of the scan. */
                        malicious: boolean;
                        phishing: string[];
                    };
                };
            };
        };
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$get$scan$Status$202 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        result: {
            scan: {
                task: {
                    effectiveUrl: string;
                    errors: {
                        message: string;
                    }[];
                    location: string;
                    region: string;
                    status: string;
                    success: boolean;
                    time: string;
                    url: string;
                    uuid: string;
                    visibility: string;
                };
            };
        };
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$get$scan$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$get$scan$Status$404 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Parameter$urlscanner$get$scan$har {
    scanId: string;
    accountId: string;
}
export interface Response$urlscanner$get$scan$har$Status$200 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        result: {
            har: {
                log: {
                    creator: {
                        comment: string;
                        name: string;
                        version: string;
                    };
                    entries: {
                        "_initialPriority": string;
                        "_initiator_type": string;
                        "_priority": string;
                        "_requestId": string;
                        "_requestTime": number;
                        "_resourceType": string;
                        cache: {};
                        connection: string;
                        pageref: string;
                        request: {
                            bodySize: number;
                            headers: {
                                name: string;
                                value: string;
                            }[];
                            headersSize: number;
                            httpVersion: string;
                            method: string;
                            url: string;
                        };
                        response: {
                            "_transferSize": number;
                            bodySize: number;
                            content: {
                                compression?: number;
                                mimeType: string;
                                size: number;
                            };
                            headers: {
                                name: string;
                                value: string;
                            }[];
                            headersSize: number;
                            httpVersion: string;
                            redirectURL: string;
                            status: number;
                            statusText: string;
                        };
                        serverIPAddress: string;
                        startedDateTime: string;
                        time: number;
                    }[];
                    pages: {
                        id: string;
                        pageTimings: {
                            onContentLoad: number;
                            onLoad: number;
                        };
                        startedDateTime: string;
                        title: string;
                    }[];
                    version: string;
                };
            };
        };
        /** Whether search request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$get$scan$har$Status$202 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        result: {
            scan: {
                task: {
                    effectiveUrl: string;
                    errors: {
                        message: string;
                    }[];
                    location: string;
                    region: string;
                    status: string;
                    success: boolean;
                    time: string;
                    url: string;
                    uuid: string;
                    visibility: string;
                };
            };
        };
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$get$scan$har$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$get$scan$har$Status$404 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Parameter$urlscanner$get$scan$screenshot {
    scanId: string;
    accountId: string;
    resolution?: "desktop" | "mobile" | "tablet";
}
export interface Response$urlscanner$get$scan$screenshot$Status$200 {
    /** PNG Image */
    "image/png": string;
}
export interface Response$urlscanner$get$scan$screenshot$Status$202 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        result: {
            scan: {
                task: {
                    effectiveUrl: string;
                    errors: {
                        message: string;
                    }[];
                    location: string;
                    region: string;
                    status: string;
                    success: boolean;
                    time: string;
                    url: string;
                    uuid: string;
                    visibility: string;
                };
            };
        };
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$get$scan$screenshot$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Response$urlscanner$get$scan$screenshot$Status$404 {
    "application/json": {
        errors: {
            message: string;
        }[];
        messages: {
            message: string;
        }[];
        /** Whether request was successful or not */
        success: boolean;
    };
}
export interface Parameter$accounts$account$details {
    identifier: Schemas.mrUXABdt_schemas$identifier;
}
export interface Response$accounts$account$details$Status$200 {
    "application/json": Schemas.mrUXABdt_response_single;
}
export interface Response$accounts$account$details$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_single & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$accounts$update$account {
    identifier: Schemas.mrUXABdt_schemas$identifier;
}
export interface RequestBody$accounts$update$account {
    "application/json": Schemas.mrUXABdt_components$schemas$account;
}
export interface Response$accounts$update$account$Status$200 {
    "application/json": Schemas.mrUXABdt_response_single;
}
export interface Response$accounts$update$account$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_single & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$access$applications$list$access$applications {
    identifier: Schemas.access_identifier;
}
export interface Response$access$applications$list$access$applications$Status$200 {
    "application/json": Schemas.access_apps_components$schemas$response_collection;
}
export interface Response$access$applications$list$access$applications$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$applications$add$an$application {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$applications$add$an$application {
    "application/json": Schemas.access_apps;
}
export interface Response$access$applications$add$an$application$Status$201 {
    "application/json": Schemas.access_apps_components$schemas$single_response & {
        result?: Schemas.access_apps;
    };
}
export interface Response$access$applications$add$an$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$applications$get$an$access$application {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface Response$access$applications$get$an$access$application$Status$200 {
    "application/json": Schemas.access_apps_components$schemas$single_response;
}
export interface Response$access$applications$get$an$access$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$applications$update$a$bookmark$application {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$applications$update$a$bookmark$application {
    "application/json": Schemas.access_apps;
}
export interface Response$access$applications$update$a$bookmark$application$Status$200 {
    "application/json": Schemas.access_apps_components$schemas$single_response & {
        result?: Schemas.access_apps;
    };
}
export interface Response$access$applications$update$a$bookmark$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$applications$delete$an$access$application {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface Response$access$applications$delete$an$access$application$Status$202 {
    "application/json": Schemas.access_id_response;
}
export interface Response$access$applications$delete$an$access$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$applications$revoke$service$tokens {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface Response$access$applications$revoke$service$tokens$Status$202 {
    "application/json": Schemas.access_schemas$empty_response;
}
export interface Response$access$applications$revoke$service$tokens$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$applications$test$access$policies {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface Response$access$applications$test$access$policies$Status$200 {
    "application/json": Schemas.access_policy_check_response;
}
export interface Response$access$applications$test$access$policies$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$200 {
    "application/json": Schemas.access_ca_components$schemas$single_response;
}
export interface Response$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$200 {
    "application/json": Schemas.access_ca_components$schemas$single_response;
}
export interface Response$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$202 {
    "application/json": Schemas.access_schemas$id_response;
}
export interface Response$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$policies$list$access$policies {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$policies$list$access$policies$Status$200 {
    "application/json": Schemas.access_policies_components$schemas$response_collection;
}
export interface Response$access$policies$list$access$policies$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$policies$create$an$access$policy {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$policies$create$an$access$policy {
    "application/json": {
        approval_groups?: Schemas.access_approval_groups;
        approval_required?: Schemas.access_approval_required;
        decision: Schemas.access_decision;
        exclude?: Schemas.access_schemas$exclude;
        include: Schemas.access_include;
        isolation_required?: Schemas.access_isolation_required;
        name: Schemas.access_policies_components$schemas$name;
        precedence?: Schemas.access_precedence;
        purpose_justification_prompt?: Schemas.access_purpose_justification_prompt;
        purpose_justification_required?: Schemas.access_purpose_justification_required;
        require?: Schemas.access_schemas$require;
        session_duration?: Schemas.access_components$schemas$session_duration;
    };
}
export interface Response$access$policies$create$an$access$policy$Status$201 {
    "application/json": Schemas.access_policies_components$schemas$single_response;
}
export interface Response$access$policies$create$an$access$policy$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$policies$get$an$access$policy {
    uuid: Schemas.access_uuid;
    uuid1: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$policies$get$an$access$policy$Status$200 {
    "application/json": Schemas.access_policies_components$schemas$single_response;
}
export interface Response$access$policies$get$an$access$policy$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$policies$update$an$access$policy {
    uuid: Schemas.access_uuid;
    uuid1: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$policies$update$an$access$policy {
    "application/json": {
        approval_groups?: Schemas.access_approval_groups;
        approval_required?: Schemas.access_approval_required;
        decision: Schemas.access_decision;
        exclude?: Schemas.access_schemas$exclude;
        include: Schemas.access_include;
        isolation_required?: Schemas.access_isolation_required;
        name: Schemas.access_policies_components$schemas$name;
        precedence?: Schemas.access_precedence;
        purpose_justification_prompt?: Schemas.access_purpose_justification_prompt;
        purpose_justification_required?: Schemas.access_purpose_justification_required;
        require?: Schemas.access_schemas$require;
        session_duration?: Schemas.access_components$schemas$session_duration;
    };
}
export interface Response$access$policies$update$an$access$policy$Status$200 {
    "application/json": Schemas.access_policies_components$schemas$single_response;
}
export interface Response$access$policies$update$an$access$policy$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$policies$delete$an$access$policy {
    uuid: Schemas.access_uuid;
    uuid1: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$policies$delete$an$access$policy$Status$202 {
    "application/json": Schemas.access_id_response;
}
export interface Response$access$policies$delete$an$access$policy$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as {
    identifier: Schemas.access_identifier;
}
export interface Response$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$200 {
    "application/json": Schemas.access_ca_components$schemas$response_collection;
}
export interface Response$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$bookmark$applications$$$deprecated$$list$bookmark$applications {
    identifier: Schemas.access_schemas$identifier;
}
export interface Response$access$bookmark$applications$$$deprecated$$list$bookmark$applications$Status$200 {
    "application/json": Schemas.access_bookmarks_components$schemas$response_collection;
}
export interface Response$access$bookmark$applications$$$deprecated$$list$bookmark$applications$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$bookmark$applications$$$deprecated$$get$a$bookmark$application {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_schemas$identifier;
}
export interface Response$access$bookmark$applications$$$deprecated$$get$a$bookmark$application$Status$200 {
    "application/json": Schemas.access_bookmarks_components$schemas$single_response;
}
export interface Response$access$bookmark$applications$$$deprecated$$get$a$bookmark$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$bookmark$applications$$$deprecated$$update$a$bookmark$application {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_schemas$identifier;
}
export interface Response$access$bookmark$applications$$$deprecated$$update$a$bookmark$application$Status$200 {
    "application/json": Schemas.access_bookmarks_components$schemas$single_response;
}
export interface Response$access$bookmark$applications$$$deprecated$$update$a$bookmark$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$bookmark$applications$$$deprecated$$create$a$bookmark$application {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_schemas$identifier;
}
export interface Response$access$bookmark$applications$$$deprecated$$create$a$bookmark$application$Status$200 {
    "application/json": Schemas.access_bookmarks_components$schemas$single_response;
}
export interface Response$access$bookmark$applications$$$deprecated$$create$a$bookmark$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_schemas$identifier;
}
export interface Response$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application$Status$200 {
    "application/json": Schemas.access_id_response;
}
export interface Response$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$mtls$authentication$list$mtls$certificates {
    identifier: Schemas.access_identifier;
}
export interface Response$access$mtls$authentication$list$mtls$certificates$Status$200 {
    "application/json": Schemas.access_certificates_components$schemas$response_collection;
}
export interface Response$access$mtls$authentication$list$mtls$certificates$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$mtls$authentication$add$an$mtls$certificate {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$mtls$authentication$add$an$mtls$certificate {
    "application/json": {
        associated_hostnames?: Schemas.access_associated_hostnames;
        /** The certificate content. */
        certificate: string;
        name: Schemas.access_certificates_components$schemas$name;
    };
}
export interface Response$access$mtls$authentication$add$an$mtls$certificate$Status$201 {
    "application/json": Schemas.access_certificates_components$schemas$single_response;
}
export interface Response$access$mtls$authentication$add$an$mtls$certificate$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$mtls$authentication$get$an$mtls$certificate {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$mtls$authentication$get$an$mtls$certificate$Status$200 {
    "application/json": Schemas.access_certificates_components$schemas$single_response;
}
export interface Response$access$mtls$authentication$get$an$mtls$certificate$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$mtls$authentication$update$an$mtls$certificate {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$mtls$authentication$update$an$mtls$certificate {
    "application/json": {
        associated_hostnames: Schemas.access_associated_hostnames;
        name?: Schemas.access_certificates_components$schemas$name;
    };
}
export interface Response$access$mtls$authentication$update$an$mtls$certificate$Status$200 {
    "application/json": Schemas.access_certificates_components$schemas$single_response;
}
export interface Response$access$mtls$authentication$update$an$mtls$certificate$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$mtls$authentication$delete$an$mtls$certificate {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$mtls$authentication$delete$an$mtls$certificate$Status$200 {
    "application/json": Schemas.access_components$schemas$id_response;
}
export interface Response$access$mtls$authentication$delete$an$mtls$certificate$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$mtls$authentication$list$mtls$certificates$hostname$settings {
    identifier: Schemas.access_identifier;
}
export interface Response$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$200 {
    "application/json": Schemas.access_response_collection_hostnames;
}
export interface Response$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$mtls$authentication$update$an$mtls$certificate$settings {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$mtls$authentication$update$an$mtls$certificate$settings {
    "application/json": {
        settings: Schemas.access_settings[];
    };
}
export interface Response$access$mtls$authentication$update$an$mtls$certificate$settings$Status$202 {
    "application/json": Schemas.access_response_collection_hostnames;
}
export interface Response$access$mtls$authentication$update$an$mtls$certificate$settings$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$custom$pages$list$custom$pages {
    identifier: Schemas.access_identifier;
}
export interface Response$access$custom$pages$list$custom$pages$Status$200 {
    "application/json": Schemas.access_custom$pages_components$schemas$response_collection;
}
export interface Response$access$custom$pages$list$custom$pages$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$custom$pages$create$a$custom$page {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$custom$pages$create$a$custom$page {
    "application/json": Schemas.access_custom_page;
}
export interface Response$access$custom$pages$create$a$custom$page$Status$201 {
    "application/json": Schemas.access_single_response_without_html;
}
export interface Response$access$custom$pages$create$a$custom$page$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$custom$pages$get$a$custom$page {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$custom$pages$get$a$custom$page$Status$200 {
    "application/json": Schemas.access_custom$pages_components$schemas$single_response;
}
export interface Response$access$custom$pages$get$a$custom$page$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$custom$pages$update$a$custom$page {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$custom$pages$update$a$custom$page {
    "application/json": Schemas.access_custom_page;
}
export interface Response$access$custom$pages$update$a$custom$page$Status$200 {
    "application/json": Schemas.access_single_response_without_html;
}
export interface Response$access$custom$pages$update$a$custom$page$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$custom$pages$delete$a$custom$page {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$custom$pages$delete$a$custom$page$Status$202 {
    "application/json": Schemas.access_components$schemas$id_response;
}
export interface Response$access$custom$pages$delete$a$custom$page$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$groups$list$access$groups {
    identifier: Schemas.access_identifier;
}
export interface Response$access$groups$list$access$groups$Status$200 {
    "application/json": Schemas.access_schemas$response_collection;
}
export interface Response$access$groups$list$access$groups$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$groups$create$an$access$group {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$groups$create$an$access$group {
    "application/json": {
        exclude?: Schemas.access_exclude;
        include: Schemas.access_include;
        is_default?: Schemas.access_is_default;
        name: Schemas.access_components$schemas$name;
        require?: Schemas.access_require;
    };
}
export interface Response$access$groups$create$an$access$group$Status$201 {
    "application/json": Schemas.access_components$schemas$single_response;
}
export interface Response$access$groups$create$an$access$group$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$groups$get$an$access$group {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$groups$get$an$access$group$Status$200 {
    "application/json": Schemas.access_components$schemas$single_response;
}
export interface Response$access$groups$get$an$access$group$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$groups$update$an$access$group {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$groups$update$an$access$group {
    "application/json": {
        exclude?: Schemas.access_exclude;
        include: Schemas.access_include;
        is_default?: Schemas.access_is_default;
        name: Schemas.access_components$schemas$name;
        require?: Schemas.access_require;
    };
}
export interface Response$access$groups$update$an$access$group$Status$200 {
    "application/json": Schemas.access_components$schemas$single_response;
}
export interface Response$access$groups$update$an$access$group$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$groups$delete$an$access$group {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$groups$delete$an$access$group$Status$202 {
    "application/json": Schemas.access_id_response;
}
export interface Response$access$groups$delete$an$access$group$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$identity$providers$list$access$identity$providers {
    identifier: Schemas.access_identifier;
}
export interface Response$access$identity$providers$list$access$identity$providers$Status$200 {
    "application/json": Schemas.access_response_collection;
}
export interface Response$access$identity$providers$list$access$identity$providers$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$identity$providers$add$an$access$identity$provider {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$identity$providers$add$an$access$identity$provider {
    "application/json": Schemas.access_identity$providers;
}
export interface Response$access$identity$providers$add$an$access$identity$provider$Status$201 {
    "application/json": Schemas.access_schemas$single_response;
}
export interface Response$access$identity$providers$add$an$access$identity$provider$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$identity$providers$get$an$access$identity$provider {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$identity$providers$get$an$access$identity$provider$Status$200 {
    "application/json": Schemas.access_schemas$single_response;
}
export interface Response$access$identity$providers$get$an$access$identity$provider$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$identity$providers$update$an$access$identity$provider {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$identity$providers$update$an$access$identity$provider {
    "application/json": Schemas.access_identity$providers;
}
export interface Response$access$identity$providers$update$an$access$identity$provider$Status$200 {
    "application/json": Schemas.access_schemas$single_response;
}
export interface Response$access$identity$providers$update$an$access$identity$provider$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$identity$providers$delete$an$access$identity$provider {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$identity$providers$delete$an$access$identity$provider$Status$202 {
    "application/json": Schemas.access_id_response;
}
export interface Response$access$identity$providers$delete$an$access$identity$provider$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$key$configuration$get$the$access$key$configuration {
    identifier: Schemas.access_identifier;
}
export interface Response$access$key$configuration$get$the$access$key$configuration$Status$200 {
    "application/json": Schemas.access_keys_components$schemas$single_response;
}
export interface Response$access$key$configuration$get$the$access$key$configuration$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$key$configuration$update$the$access$key$configuration {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$key$configuration$update$the$access$key$configuration {
    "application/json": {
        key_rotation_interval_days: Schemas.access_key_rotation_interval_days;
    };
}
export interface Response$access$key$configuration$update$the$access$key$configuration$Status$200 {
    "application/json": Schemas.access_keys_components$schemas$single_response;
}
export interface Response$access$key$configuration$update$the$access$key$configuration$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$key$configuration$rotate$access$keys {
    identifier: Schemas.access_identifier;
}
export interface Response$access$key$configuration$rotate$access$keys$Status$200 {
    "application/json": Schemas.access_keys_components$schemas$single_response;
}
export interface Response$access$key$configuration$rotate$access$keys$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$authentication$logs$get$access$authentication$logs {
    identifier: Schemas.access_identifier;
}
export interface Response$access$authentication$logs$get$access$authentication$logs$Status$200 {
    "application/json": Schemas.access_access$requests_components$schemas$response_collection;
}
export interface Response$access$authentication$logs$get$access$authentication$logs$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$organization$get$your$zero$trust$organization {
    identifier: Schemas.access_identifier;
}
export interface Response$zero$trust$organization$get$your$zero$trust$organization$Status$200 {
    "application/json": Schemas.access_single_response;
}
export interface Response$zero$trust$organization$get$your$zero$trust$organization$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$organization$update$your$zero$trust$organization {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zero$trust$organization$update$your$zero$trust$organization {
    "application/json": {
        allow_authenticate_via_warp?: Schemas.access_allow_authenticate_via_warp;
        auth_domain?: Schemas.access_auth_domain;
        auto_redirect_to_identity?: Schemas.access_auto_redirect_to_identity;
        custom_pages?: Schemas.access_custom_pages;
        is_ui_read_only?: Schemas.access_is_ui_read_only;
        login_design?: Schemas.access_login_design;
        name?: Schemas.access_name;
        session_duration?: Schemas.access_session_duration;
        ui_read_only_toggle_reason?: Schemas.access_ui_read_only_toggle_reason;
        user_seat_expiration_inactive_time?: Schemas.access_user_seat_expiration_inactive_time;
        warp_auth_session_duration?: Schemas.access_warp_auth_session_duration;
    };
}
export interface Response$zero$trust$organization$update$your$zero$trust$organization$Status$200 {
    "application/json": Schemas.access_single_response;
}
export interface Response$zero$trust$organization$update$your$zero$trust$organization$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$organization$create$your$zero$trust$organization {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zero$trust$organization$create$your$zero$trust$organization {
    "application/json": {
        allow_authenticate_via_warp?: Schemas.access_allow_authenticate_via_warp;
        auth_domain: Schemas.access_auth_domain;
        auto_redirect_to_identity?: Schemas.access_auto_redirect_to_identity;
        is_ui_read_only?: Schemas.access_is_ui_read_only;
        login_design?: Schemas.access_login_design;
        name: Schemas.access_name;
        session_duration?: Schemas.access_session_duration;
        ui_read_only_toggle_reason?: Schemas.access_ui_read_only_toggle_reason;
        user_seat_expiration_inactive_time?: Schemas.access_user_seat_expiration_inactive_time;
        warp_auth_session_duration?: Schemas.access_warp_auth_session_duration;
    };
}
export interface Response$zero$trust$organization$create$your$zero$trust$organization$Status$201 {
    "application/json": Schemas.access_single_response;
}
export interface Response$zero$trust$organization$create$your$zero$trust$organization$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$organization$revoke$all$access$tokens$for$a$user {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zero$trust$organization$revoke$all$access$tokens$for$a$user {
    "application/json": {
        /** The email of the user to revoke. */
        email: string;
    };
}
export interface Response$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$200 {
    "application/json": Schemas.access_empty_response;
}
export interface Response$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$4xx {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$seats$update$a$user$seat {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zero$trust$seats$update$a$user$seat {
    "application/json": Schemas.access_seats_definition;
}
export interface Response$zero$trust$seats$update$a$user$seat$Status$200 {
    "application/json": Schemas.access_seats_components$schemas$response_collection;
}
export interface Response$zero$trust$seats$update$a$user$seat$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$service$tokens$list$service$tokens {
    identifier: Schemas.access_identifier;
}
export interface Response$access$service$tokens$list$service$tokens$Status$200 {
    "application/json": Schemas.access_components$schemas$response_collection;
}
export interface Response$access$service$tokens$list$service$tokens$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$service$tokens$create$a$service$token {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$service$tokens$create$a$service$token {
    "application/json": {
        duration?: Schemas.access_duration;
        name: Schemas.access_service$tokens_components$schemas$name;
    };
}
export interface Response$access$service$tokens$create$a$service$token$Status$201 {
    "application/json": Schemas.access_create_response;
}
export interface Response$access$service$tokens$create$a$service$token$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$service$tokens$update$a$service$token {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$service$tokens$update$a$service$token {
    "application/json": {
        duration?: Schemas.access_duration;
        name?: Schemas.access_service$tokens_components$schemas$name;
    };
}
export interface Response$access$service$tokens$update$a$service$token$Status$200 {
    "application/json": Schemas.access_service$tokens_components$schemas$single_response;
}
export interface Response$access$service$tokens$update$a$service$token$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$service$tokens$delete$a$service$token {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$service$tokens$delete$a$service$token$Status$200 {
    "application/json": Schemas.access_service$tokens_components$schemas$single_response;
}
export interface Response$access$service$tokens$delete$a$service$token$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$service$tokens$refresh$a$service$token {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$service$tokens$refresh$a$service$token$Status$200 {
    "application/json": Schemas.access_service$tokens_components$schemas$single_response;
}
export interface Response$access$service$tokens$refresh$a$service$token$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$service$tokens$rotate$a$service$token {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$access$service$tokens$rotate$a$service$token$Status$200 {
    "application/json": Schemas.access_create_response;
}
export interface Response$access$service$tokens$rotate$a$service$token$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$tags$list$tags {
    identifier: Schemas.access_identifier;
}
export interface Response$access$tags$list$tags$Status$200 {
    "application/json": Schemas.access_tags_components$schemas$response_collection;
}
export interface Response$access$tags$list$tags$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$tags$create$tag {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$access$tags$create$tag {
    "application/json": Schemas.access_tag_without_app_count;
}
export interface Response$access$tags$create$tag$Status$201 {
    "application/json": Schemas.access_tags_components$schemas$single_response;
}
export interface Response$access$tags$create$tag$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$tags$get$a$tag {
    identifier: Schemas.access_identifier;
    name: Schemas.access_tags_components$schemas$name;
}
export interface Response$access$tags$get$a$tag$Status$200 {
    "application/json": Schemas.access_tags_components$schemas$single_response;
}
export interface Response$access$tags$get$a$tag$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$tags$update$a$tag {
    identifier: Schemas.access_identifier;
    name: Schemas.access_tags_components$schemas$name;
}
export interface RequestBody$access$tags$update$a$tag {
    "application/json": Schemas.access_tag_without_app_count;
}
export interface Response$access$tags$update$a$tag$Status$200 {
    "application/json": Schemas.access_tags_components$schemas$single_response;
}
export interface Response$access$tags$update$a$tag$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$access$tags$delete$a$tag {
    identifier: Schemas.access_identifier;
    name: Schemas.access_tags_components$schemas$name;
}
export interface Response$access$tags$delete$a$tag$Status$202 {
    "application/json": Schemas.access_name_response;
}
export interface Response$access$tags$delete$a$tag$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$users$get$users {
    identifier: Schemas.access_identifier;
}
export interface Response$zero$trust$users$get$users$Status$200 {
    "application/json": Schemas.access_users_components$schemas$response_collection;
}
export interface Response$zero$trust$users$get$users$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$users$get$active$sessions {
    id: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zero$trust$users$get$active$sessions$Status$200 {
    "application/json": Schemas.access_active_sessions_response;
}
export interface Response$zero$trust$users$get$active$sessions$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$users$get$active$session {
    id: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
    nonce: Schemas.access_nonce;
}
export interface Response$zero$trust$users$get$active$session$Status$200 {
    "application/json": Schemas.access_active_session_response;
}
export interface Response$zero$trust$users$get$active$session$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$users$get$failed$logins {
    id: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zero$trust$users$get$failed$logins$Status$200 {
    "application/json": Schemas.access_failed_login_response;
}
export interface Response$zero$trust$users$get$failed$logins$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zero$trust$users$get$last$seen$identity {
    id: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zero$trust$users$get$last$seen$identity$Status$200 {
    "application/json": Schemas.access_last_seen_identity_response;
}
export interface Response$zero$trust$users$get$last$seen$identity$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$devices$list$devices {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$list$devices$Status$200 {
    "application/json": Schemas.teams$devices_devices_response;
}
export interface Response$devices$list$devices$Status$4XX {
    "application/json": Schemas.teams$devices_devices_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$device$details {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$device$details$Status$200 {
    "application/json": Schemas.teams$devices_device_response;
}
export interface Response$devices$device$details$Status$4XX {
    "application/json": Schemas.teams$devices_device_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$list$admin$override$code$for$device {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$list$admin$override$code$for$device$Status$200 {
    "application/json": Schemas.teams$devices_override_codes_response;
}
export interface Response$devices$list$admin$override$code$for$device$Status$4XX {
    "application/json": Schemas.teams$devices_override_codes_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$dex$test$details {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$dex$test$details$Status$200 {
    "application/json": Schemas.teams$devices_dex$response_collection;
}
export interface Response$device$dex$test$details$Status$4XX {
    "application/json": Schemas.teams$devices_dex$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$dex$test$create$device$dex$test {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$device$dex$test$create$device$dex$test {
    "application/json": Schemas.teams$devices_device$dex$test$schemas$http;
}
export interface Response$device$dex$test$create$device$dex$test$Status$200 {
    "application/json": Schemas.teams$devices_dex$single_response;
}
export interface Response$device$dex$test$create$device$dex$test$Status$4XX {
    "application/json": Schemas.teams$devices_dex$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$dex$test$get$device$dex$test {
    identifier: Schemas.teams$devices_identifier;
    uuid: Schemas.teams$devices_uuid;
}
export interface Response$device$dex$test$get$device$dex$test$Status$200 {
    "application/json": Schemas.teams$devices_dex$single_response;
}
export interface Response$device$dex$test$get$device$dex$test$Status$4XX {
    "application/json": Schemas.teams$devices_dex$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$dex$test$update$device$dex$test {
    identifier: Schemas.teams$devices_identifier;
    uuid: Schemas.teams$devices_uuid;
}
export interface RequestBody$device$dex$test$update$device$dex$test {
    "application/json": Schemas.teams$devices_device$dex$test$schemas$http;
}
export interface Response$device$dex$test$update$device$dex$test$Status$200 {
    "application/json": Schemas.teams$devices_dex$single_response;
}
export interface Response$device$dex$test$update$device$dex$test$Status$4XX {
    "application/json": Schemas.teams$devices_dex$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$dex$test$delete$device$dex$test {
    identifier: Schemas.teams$devices_identifier;
    uuid: Schemas.teams$devices_uuid;
}
export interface Response$device$dex$test$delete$device$dex$test$Status$200 {
    "application/json": Schemas.teams$devices_dex$response_collection;
}
export interface Response$device$dex$test$delete$device$dex$test$Status$4XX {
    "application/json": Schemas.teams$devices_dex$response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$managed$networks$list$device$managed$networks {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$managed$networks$list$device$managed$networks$Status$200 {
    "application/json": Schemas.teams$devices_components$schemas$response_collection;
}
export interface Response$device$managed$networks$list$device$managed$networks$Status$4XX {
    "application/json": Schemas.teams$devices_components$schemas$response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$managed$networks$create$device$managed$network {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$device$managed$networks$create$device$managed$network {
    "application/json": {
        config: Schemas.teams$devices_schemas$config_request;
        name: Schemas.teams$devices_device$managed$networks_components$schemas$name;
        type: Schemas.teams$devices_components$schemas$type;
    };
}
export interface Response$device$managed$networks$create$device$managed$network$Status$200 {
    "application/json": Schemas.teams$devices_components$schemas$single_response;
}
export interface Response$device$managed$networks$create$device$managed$network$Status$4XX {
    "application/json": Schemas.teams$devices_components$schemas$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$managed$networks$device$managed$network$details {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$managed$networks$device$managed$network$details$Status$200 {
    "application/json": Schemas.teams$devices_components$schemas$single_response;
}
export interface Response$device$managed$networks$device$managed$network$details$Status$4XX {
    "application/json": Schemas.teams$devices_components$schemas$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$managed$networks$update$device$managed$network {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$device$managed$networks$update$device$managed$network {
    "application/json": {
        config?: Schemas.teams$devices_schemas$config_request;
        name?: Schemas.teams$devices_device$managed$networks_components$schemas$name;
        type?: Schemas.teams$devices_components$schemas$type;
    };
}
export interface Response$device$managed$networks$update$device$managed$network$Status$200 {
    "application/json": Schemas.teams$devices_components$schemas$single_response;
}
export interface Response$device$managed$networks$update$device$managed$network$Status$4XX {
    "application/json": Schemas.teams$devices_components$schemas$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$managed$networks$delete$device$managed$network {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$managed$networks$delete$device$managed$network$Status$200 {
    "application/json": Schemas.teams$devices_components$schemas$response_collection;
}
export interface Response$device$managed$networks$delete$device$managed$network$Status$4XX {
    "application/json": Schemas.teams$devices_components$schemas$response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$list$device$settings$policies {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$list$device$settings$policies$Status$200 {
    "application/json": Schemas.teams$devices_device_settings_response_collection;
}
export interface Response$devices$list$device$settings$policies$Status$4XX {
    "application/json": Schemas.teams$devices_device_settings_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$get$default$device$settings$policy {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$get$default$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_default_device_settings_response;
}
export interface Response$devices$get$default$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_default_device_settings_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$create$device$settings$policy {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$create$device$settings$policy {
    "application/json": {
        allow_mode_switch?: Schemas.teams$devices_allow_mode_switch;
        allow_updates?: Schemas.teams$devices_allow_updates;
        allowed_to_leave?: Schemas.teams$devices_allowed_to_leave;
        auto_connect?: Schemas.teams$devices_auto_connect;
        captive_portal?: Schemas.teams$devices_captive_portal;
        description?: Schemas.teams$devices_schemas$description;
        disable_auto_fallback?: Schemas.teams$devices_disable_auto_fallback;
        /** Whether the policy will be applied to matching devices. */
        enabled?: boolean;
        exclude_office_ips?: Schemas.teams$devices_exclude_office_ips;
        lan_allow_minutes?: Schemas.teams$devices_lan_allow_minutes;
        lan_allow_subnet_size?: Schemas.teams$devices_lan_allow_subnet_size;
        match: Schemas.teams$devices_schemas$match;
        /** The name of the device settings profile. */
        name: string;
        precedence: Schemas.teams$devices_precedence;
        service_mode_v2?: Schemas.teams$devices_service_mode_v2;
        support_url?: Schemas.teams$devices_support_url;
        switch_locked?: Schemas.teams$devices_switch_locked;
    };
}
export interface Response$devices$create$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_device_settings_response;
}
export interface Response$devices$create$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_device_settings_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$update$default$device$settings$policy {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$update$default$device$settings$policy {
    "application/json": {
        allow_mode_switch?: Schemas.teams$devices_allow_mode_switch;
        allow_updates?: Schemas.teams$devices_allow_updates;
        allowed_to_leave?: Schemas.teams$devices_allowed_to_leave;
        auto_connect?: Schemas.teams$devices_auto_connect;
        captive_portal?: Schemas.teams$devices_captive_portal;
        disable_auto_fallback?: Schemas.teams$devices_disable_auto_fallback;
        exclude_office_ips?: Schemas.teams$devices_exclude_office_ips;
        service_mode_v2?: Schemas.teams$devices_service_mode_v2;
        support_url?: Schemas.teams$devices_support_url;
        switch_locked?: Schemas.teams$devices_switch_locked;
    };
}
export interface Response$devices$update$default$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_default_device_settings_response;
}
export interface Response$devices$update$default$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_default_device_settings_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$get$device$settings$policy$by$id {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$get$device$settings$policy$by$id$Status$200 {
    "application/json": Schemas.teams$devices_device_settings_response;
}
export interface Response$devices$get$device$settings$policy$by$id$Status$4XX {
    "application/json": Schemas.teams$devices_device_settings_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$delete$device$settings$policy {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$delete$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_device_settings_response_collection;
}
export interface Response$devices$delete$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_device_settings_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$update$device$settings$policy {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$update$device$settings$policy {
    "application/json": {
        allow_mode_switch?: Schemas.teams$devices_allow_mode_switch;
        allow_updates?: Schemas.teams$devices_allow_updates;
        allowed_to_leave?: Schemas.teams$devices_allowed_to_leave;
        auto_connect?: Schemas.teams$devices_auto_connect;
        captive_portal?: Schemas.teams$devices_captive_portal;
        description?: Schemas.teams$devices_schemas$description;
        disable_auto_fallback?: Schemas.teams$devices_disable_auto_fallback;
        /** Whether the policy will be applied to matching devices. */
        enabled?: boolean;
        exclude_office_ips?: Schemas.teams$devices_exclude_office_ips;
        match?: Schemas.teams$devices_schemas$match;
        /** The name of the device settings profile. */
        name?: string;
        precedence?: Schemas.teams$devices_precedence;
        service_mode_v2?: Schemas.teams$devices_service_mode_v2;
        support_url?: Schemas.teams$devices_support_url;
        switch_locked?: Schemas.teams$devices_switch_locked;
    };
}
export interface Response$devices$update$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_device_settings_response;
}
export interface Response$devices$update$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_device_settings_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_split_tunnel_response_collection;
}
export interface Response$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_split_tunnel_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy {
    "application/json": Schemas.teams$devices_split_tunnel[];
}
export interface Response$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_split_tunnel_response_collection;
}
export interface Response$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy$Status$4xx {
    "application/json": Schemas.teams$devices_split_tunnel_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$get$local$domain$fallback$list$for$a$device$settings$policy {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$get$local$domain$fallback$list$for$a$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_fallback_domain_response_collection;
}
export interface Response$devices$get$local$domain$fallback$list$for$a$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_fallback_domain_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$set$local$domain$fallback$list$for$a$device$settings$policy {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$set$local$domain$fallback$list$for$a$device$settings$policy {
    "application/json": Schemas.teams$devices_fallback_domain[];
}
export interface Response$devices$set$local$domain$fallback$list$for$a$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_fallback_domain_response_collection;
}
export interface Response$devices$set$local$domain$fallback$list$for$a$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_fallback_domain_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$get$split$tunnel$include$list$for$a$device$settings$policy {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$get$split$tunnel$include$list$for$a$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_split_tunnel_include_response_collection;
}
export interface Response$devices$get$split$tunnel$include$list$for$a$device$settings$policy$Status$4XX {
    "application/json": Schemas.teams$devices_split_tunnel_include_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$set$split$tunnel$include$list$for$a$device$settings$policy {
    uuid: Schemas.teams$devices_schemas$uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$set$split$tunnel$include$list$for$a$device$settings$policy {
    "application/json": Schemas.teams$devices_split_tunnel_include[];
}
export interface Response$devices$set$split$tunnel$include$list$for$a$device$settings$policy$Status$200 {
    "application/json": Schemas.teams$devices_split_tunnel_include_response_collection;
}
export interface Response$devices$set$split$tunnel$include$list$for$a$device$settings$policy$Status$4xx {
    "application/json": Schemas.teams$devices_split_tunnel_include_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$get$split$tunnel$exclude$list {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$get$split$tunnel$exclude$list$Status$200 {
    "application/json": Schemas.teams$devices_split_tunnel_response_collection;
}
export interface Response$devices$get$split$tunnel$exclude$list$Status$4XX {
    "application/json": Schemas.teams$devices_split_tunnel_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$set$split$tunnel$exclude$list {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$set$split$tunnel$exclude$list {
    "application/json": Schemas.teams$devices_split_tunnel[];
}
export interface Response$devices$set$split$tunnel$exclude$list$Status$200 {
    "application/json": Schemas.teams$devices_split_tunnel_response_collection;
}
export interface Response$devices$set$split$tunnel$exclude$list$Status$4xx {
    "application/json": Schemas.teams$devices_split_tunnel_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$get$local$domain$fallback$list {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$get$local$domain$fallback$list$Status$200 {
    "application/json": Schemas.teams$devices_fallback_domain_response_collection;
}
export interface Response$devices$get$local$domain$fallback$list$Status$4XX {
    "application/json": Schemas.teams$devices_fallback_domain_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$set$local$domain$fallback$list {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$set$local$domain$fallback$list {
    "application/json": Schemas.teams$devices_fallback_domain[];
}
export interface Response$devices$set$local$domain$fallback$list$Status$200 {
    "application/json": Schemas.teams$devices_fallback_domain_response_collection;
}
export interface Response$devices$set$local$domain$fallback$list$Status$4XX {
    "application/json": Schemas.teams$devices_fallback_domain_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$get$split$tunnel$include$list {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$devices$get$split$tunnel$include$list$Status$200 {
    "application/json": Schemas.teams$devices_split_tunnel_include_response_collection;
}
export interface Response$devices$get$split$tunnel$include$list$Status$4XX {
    "application/json": Schemas.teams$devices_split_tunnel_include_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$set$split$tunnel$include$list {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$set$split$tunnel$include$list {
    "application/json": Schemas.teams$devices_split_tunnel_include[];
}
export interface Response$devices$set$split$tunnel$include$list$Status$200 {
    "application/json": Schemas.teams$devices_split_tunnel_include_response_collection;
}
export interface Response$devices$set$split$tunnel$include$list$Status$4xx {
    "application/json": Schemas.teams$devices_split_tunnel_include_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$rules$list$device$posture$rules {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$posture$rules$list$device$posture$rules$Status$200 {
    "application/json": Schemas.teams$devices_response_collection;
}
export interface Response$device$posture$rules$list$device$posture$rules$Status$4XX {
    "application/json": Schemas.teams$devices_response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$rules$create$device$posture$rule {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$device$posture$rules$create$device$posture$rule {
    "application/json": {
        description?: Schemas.teams$devices_description;
        expiration?: Schemas.teams$devices_expiration;
        input?: Schemas.teams$devices_input;
        match?: Schemas.teams$devices_match;
        name: Schemas.teams$devices_name;
        schedule?: Schemas.teams$devices_schedule;
        type: Schemas.teams$devices_type;
    };
}
export interface Response$device$posture$rules$create$device$posture$rule$Status$200 {
    "application/json": Schemas.teams$devices_single_response;
}
export interface Response$device$posture$rules$create$device$posture$rule$Status$4XX {
    "application/json": Schemas.teams$devices_single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$rules$device$posture$rules$details {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$posture$rules$device$posture$rules$details$Status$200 {
    "application/json": Schemas.teams$devices_single_response;
}
export interface Response$device$posture$rules$device$posture$rules$details$Status$4XX {
    "application/json": Schemas.teams$devices_single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$rules$update$device$posture$rule {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$device$posture$rules$update$device$posture$rule {
    "application/json": {
        description?: Schemas.teams$devices_description;
        expiration?: Schemas.teams$devices_expiration;
        input?: Schemas.teams$devices_input;
        match?: Schemas.teams$devices_match;
        name: Schemas.teams$devices_name;
        schedule?: Schemas.teams$devices_schedule;
        type: Schemas.teams$devices_type;
    };
}
export interface Response$device$posture$rules$update$device$posture$rule$Status$200 {
    "application/json": Schemas.teams$devices_single_response;
}
export interface Response$device$posture$rules$update$device$posture$rule$Status$4XX {
    "application/json": Schemas.teams$devices_single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$rules$delete$device$posture$rule {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$posture$rules$delete$device$posture$rule$Status$200 {
    "application/json": Schemas.teams$devices_id_response;
}
export interface Response$device$posture$rules$delete$device$posture$rule$Status$4XX {
    "application/json": Schemas.teams$devices_id_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$integrations$list$device$posture$integrations {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$posture$integrations$list$device$posture$integrations$Status$200 {
    "application/json": Schemas.teams$devices_schemas$response_collection;
}
export interface Response$device$posture$integrations$list$device$posture$integrations$Status$4XX {
    "application/json": Schemas.teams$devices_schemas$response_collection & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$integrations$create$device$posture$integration {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$device$posture$integrations$create$device$posture$integration {
    "application/json": {
        config: Schemas.teams$devices_config_request;
        interval: Schemas.teams$devices_interval;
        name: Schemas.teams$devices_components$schemas$name;
        type: Schemas.teams$devices_schemas$type;
    };
}
export interface Response$device$posture$integrations$create$device$posture$integration$Status$200 {
    "application/json": Schemas.teams$devices_schemas$single_response;
}
export interface Response$device$posture$integrations$create$device$posture$integration$Status$4XX {
    "application/json": Schemas.teams$devices_schemas$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$integrations$device$posture$integration$details {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$posture$integrations$device$posture$integration$details$Status$200 {
    "application/json": Schemas.teams$devices_schemas$single_response;
}
export interface Response$device$posture$integrations$device$posture$integration$details$Status$4XX {
    "application/json": Schemas.teams$devices_schemas$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$integrations$delete$device$posture$integration {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$device$posture$integrations$delete$device$posture$integration$Status$200 {
    "application/json": Schemas.teams$devices_schemas$id_response;
}
export interface Response$device$posture$integrations$delete$device$posture$integration$Status$4XX {
    "application/json": Schemas.teams$devices_schemas$id_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$device$posture$integrations$update$device$posture$integration {
    uuid: Schemas.teams$devices_uuid;
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$device$posture$integrations$update$device$posture$integration {
    "application/json": {
        config?: Schemas.teams$devices_config_request;
        interval?: Schemas.teams$devices_interval;
        name?: Schemas.teams$devices_components$schemas$name;
        type?: Schemas.teams$devices_schemas$type;
    };
}
export interface Response$device$posture$integrations$update$device$posture$integration$Status$200 {
    "application/json": Schemas.teams$devices_schemas$single_response;
}
export interface Response$device$posture$integrations$update$device$posture$integration$Status$4XX {
    "application/json": Schemas.teams$devices_schemas$single_response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$revoke$devices {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$revoke$devices {
    "application/json": Schemas.teams$devices_revoke_devices_request;
}
export interface Response$devices$revoke$devices$Status$200 {
    "application/json": Schemas.teams$devices_api$response$single;
}
export interface Response$devices$revoke$devices$Status$4XX {
    "application/json": Schemas.teams$devices_api$response$single & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$get$device$settings$for$zero$trust$account {
    identifier: Schemas.teams$devices_identifier;
}
export interface Response$zero$trust$accounts$get$device$settings$for$zero$trust$account$Status$200 {
    "application/json": Schemas.teams$devices_zero$trust$account$device$settings$response;
}
export interface Response$zero$trust$accounts$get$device$settings$for$zero$trust$account$Status$4XX {
    "application/json": Schemas.teams$devices_zero$trust$account$device$settings$response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$zero$trust$accounts$update$device$settings$for$the$zero$trust$account {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$zero$trust$accounts$update$device$settings$for$the$zero$trust$account {
    "application/json": Schemas.teams$devices_zero$trust$account$device$settings;
}
export interface Response$zero$trust$accounts$update$device$settings$for$the$zero$trust$account$Status$200 {
    "application/json": Schemas.teams$devices_zero$trust$account$device$settings$response;
}
export interface Response$zero$trust$accounts$update$device$settings$for$the$zero$trust$account$Status$4XX {
    "application/json": Schemas.teams$devices_zero$trust$account$device$settings$response & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$devices$unrevoke$devices {
    identifier: Schemas.teams$devices_identifier;
}
export interface RequestBody$devices$unrevoke$devices {
    "application/json": Schemas.teams$devices_unrevoke_devices_request;
}
export interface Response$devices$unrevoke$devices$Status$200 {
    "application/json": Schemas.teams$devices_api$response$single;
}
export interface Response$devices$unrevoke$devices$Status$4XX {
    "application/json": Schemas.teams$devices_api$response$single & Schemas.teams$devices_api$response$common$failure;
}
export interface Parameter$origin$ca$list$certificates {
    identifier?: Schemas.ApQU2qAj_identifier;
}
export interface Response$origin$ca$list$certificates$Status$200 {
    "application/json": Schemas.ApQU2qAj_schemas$certificate_response_collection;
}
export interface Response$origin$ca$list$certificates$Status$4XX {
    "application/json": Schemas.ApQU2qAj_schemas$certificate_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface RequestBody$origin$ca$create$certificate {
    "application/json": {
        csr?: Schemas.ApQU2qAj_csr;
        hostnames?: Schemas.ApQU2qAj_hostnames;
        request_type?: Schemas.ApQU2qAj_request_type;
        requested_validity?: Schemas.ApQU2qAj_requested_validity;
    };
}
export interface Response$origin$ca$create$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_schemas$certificate_response_single;
}
export interface Response$origin$ca$create$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_schemas$certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$origin$ca$get$certificate {
    identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$origin$ca$get$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_schemas$certificate_response_single;
}
export interface Response$origin$ca$get$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_schemas$certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$origin$ca$revoke$certificate {
    identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$origin$ca$revoke$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_single_id;
}
export interface Response$origin$ca$revoke$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_response_single_id & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$cloudflare$i$ps$cloudflare$ip$details {
    /** Specified as \`jdcloud\` to list IPs used by JD Cloud data centers. */
    networks?: string;
}
export interface Response$cloudflare$i$ps$cloudflare$ip$details$Status$200 {
    "application/json": Schemas.addressing_api$response$single & {
        result?: Schemas.addressing_ips | Schemas.addressing_ips_jdcloud;
    };
}
export interface Response$cloudflare$i$ps$cloudflare$ip$details$Status$4XX {
    "application/json": (Schemas.addressing_api$response$single & {
        result?: Schemas.addressing_ips | Schemas.addressing_ips_jdcloud;
    }) & Schemas.addressing_api$response$common$failure;
}
export interface Parameter$user$$s$account$memberships$list$memberships {
    "account.name"?: Schemas.mrUXABdt_properties$name;
    page?: number;
    per_page?: number;
    order?: "id" | "account.name" | "status";
    direction?: "asc" | "desc";
    name?: Schemas.mrUXABdt_properties$name;
    status?: "accepted" | "pending" | "rejected";
}
export interface Response$user$$s$account$memberships$list$memberships$Status$200 {
    "application/json": Schemas.mrUXABdt_collection_membership_response;
}
export interface Response$user$$s$account$memberships$list$memberships$Status$4XX {
    "application/json": Schemas.mrUXABdt_collection_membership_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$$s$account$memberships$membership$details {
    identifier: Schemas.mrUXABdt_membership_components$schemas$identifier;
}
export interface Response$user$$s$account$memberships$membership$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_membership_response;
}
export interface Response$user$$s$account$memberships$membership$details$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_membership_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$$s$account$memberships$update$membership {
    identifier: Schemas.mrUXABdt_membership_components$schemas$identifier;
}
export interface RequestBody$user$$s$account$memberships$update$membership {
    "application/json": {
        /** Whether to accept or reject this account invitation. */
        status: "accepted" | "rejected";
    };
}
export interface Response$user$$s$account$memberships$update$membership$Status$200 {
    "application/json": Schemas.mrUXABdt_single_membership_response;
}
export interface Response$user$$s$account$memberships$update$membership$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_membership_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$$s$account$memberships$delete$membership {
    identifier: Schemas.mrUXABdt_membership_components$schemas$identifier;
}
export interface Response$user$$s$account$memberships$delete$membership$Status$200 {
    "application/json": Schemas.mrUXABdt_api$response$single & {
        result?: {
            id?: Schemas.mrUXABdt_membership_components$schemas$identifier;
        };
    };
}
export interface Response$user$$s$account$memberships$delete$membership$Status$4XX {
    "application/json": (Schemas.mrUXABdt_api$response$single & {
        result?: {
            id?: Schemas.mrUXABdt_membership_components$schemas$identifier;
        };
    }) & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organizations$$$deprecated$$organization$details {
    identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface Response$organizations$$$deprecated$$organization$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_organization_response;
}
export interface Response$organizations$$$deprecated$$organization$details$Status$4xx {
    "application/json": Schemas.mrUXABdt_single_organization_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organizations$$$deprecated$$edit$organization {
    identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface RequestBody$organizations$$$deprecated$$edit$organization {
    "application/json": {
        name?: Schemas.mrUXABdt_schemas$name;
    };
}
export interface Response$organizations$$$deprecated$$edit$organization$Status$200 {
    "application/json": Schemas.mrUXABdt_single_organization_response;
}
export interface Response$organizations$$$deprecated$$edit$organization$Status$4xx {
    "application/json": Schemas.mrUXABdt_single_organization_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$audit$logs$get$organization$audit$logs {
    organization_identifier: Schemas.w2PBr26F_identifier;
    id?: string;
    export?: boolean;
    "action.type"?: string;
    "actor.ip"?: string;
    "actor.email"?: string;
    since?: Date;
    before?: Date;
    "zone.name"?: string;
    direction?: "desc" | "asc";
    per_page?: number;
    page?: number;
    hide_user_logs?: boolean;
}
export interface Response$audit$logs$get$organization$audit$logs$Status$200 {
    "application/json": Schemas.w2PBr26F_audit_logs_response_collection;
}
export interface Response$audit$logs$get$organization$audit$logs$Status$4XX {
    "application/json": Schemas.w2PBr26F_audit_logs_response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$organization$invites$list$invitations {
    organization_identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface Response$organization$invites$list$invitations$Status$200 {
    "application/json": Schemas.mrUXABdt_collection_invite_response;
}
export interface Response$organization$invites$list$invitations$Status$4xx {
    "application/json": Schemas.mrUXABdt_collection_invite_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$invites$create$invitation {
    organization_identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface RequestBody$organization$invites$create$invitation {
    "application/json": {
        /** When present and set to true, allows for the invited user to be automatically accepted to the organization. No invitation is sent. */
        auto_accept?: boolean;
        invited_member_email: Schemas.mrUXABdt_invited_member_email;
        /** Array of Roles associated with the invited user. */
        roles: {
            description?: Schemas.mrUXABdt_description;
            id: Schemas.mrUXABdt_role_components$schemas$identifier;
            name?: Schemas.mrUXABdt_components$schemas$name;
            permissions?: Schemas.mrUXABdt_schemas$permissions;
        }[];
    };
}
export interface Response$organization$invites$create$invitation$Status$200 {
    "application/json": Schemas.mrUXABdt_single_invite_response;
}
export interface Response$organization$invites$create$invitation$Status$4xx {
    "application/json": Schemas.mrUXABdt_single_invite_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$invites$invitation$details {
    identifier: Schemas.mrUXABdt_invite_components$schemas$identifier;
    organization_identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface Response$organization$invites$invitation$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_invite_response;
}
export interface Response$organization$invites$invitation$details$Status$4xx {
    "application/json": Schemas.mrUXABdt_single_invite_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$invites$cancel$invitation {
    identifier: Schemas.mrUXABdt_invite_components$schemas$identifier;
    organization_identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface Response$organization$invites$cancel$invitation$Status$200 {
    "application/json": {
        id?: Schemas.mrUXABdt_invite_components$schemas$identifier;
    };
}
export interface Response$organization$invites$cancel$invitation$Status$4xx {
    "application/json": {
        id?: Schemas.mrUXABdt_invite_components$schemas$identifier;
    } & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$invites$edit$invitation$roles {
    identifier: Schemas.mrUXABdt_invite_components$schemas$identifier;
    organization_identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface RequestBody$organization$invites$edit$invitation$roles {
    "application/json": {
        /** Array of Roles associated with the invited user. */
        roles?: Schemas.mrUXABdt_role_components$schemas$identifier[];
    };
}
export interface Response$organization$invites$edit$invitation$roles$Status$200 {
    "application/json": Schemas.mrUXABdt_single_invite_response;
}
export interface Response$organization$invites$edit$invitation$roles$Status$4xx {
    "application/json": Schemas.mrUXABdt_single_invite_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$members$list$members {
    organization_identifier: Schemas.mrUXABdt_organization_components$schemas$identifier;
}
export interface Response$organization$members$list$members$Status$200 {
    "application/json": Schemas.mrUXABdt_collection_member_response;
}
export interface Response$organization$members$list$members$Status$4xx {
    "application/json": Schemas.mrUXABdt_collection_member_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$members$member$details {
    identifier: Schemas.mrUXABdt_membership_components$schemas$identifier;
    organization_identifier: Schemas.mrUXABdt_organization_components$schemas$identifier;
}
export interface Response$organization$members$member$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_member_response;
}
export interface Response$organization$members$member$details$Status$4xx {
    "application/json": Schemas.mrUXABdt_single_member_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$members$remove$member {
    identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
    organization_identifier: Schemas.mrUXABdt_organization_components$schemas$identifier;
}
export interface Response$organization$members$remove$member$Status$200 {
    "application/json": {
        id?: Schemas.mrUXABdt_common_components$schemas$identifier;
    };
}
export interface Response$organization$members$remove$member$Status$4XX {
    "application/json": {
        id?: Schemas.mrUXABdt_common_components$schemas$identifier;
    } & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$members$edit$member$roles {
    identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
    organization_identifier: Schemas.mrUXABdt_organization_components$schemas$identifier;
}
export interface RequestBody$organization$members$edit$member$roles {
    "application/json": {
        /** Array of Roles associated with this Member. */
        roles?: Schemas.mrUXABdt_role_components$schemas$identifier[];
    };
}
export interface Response$organization$members$edit$member$roles$Status$200 {
    "application/json": Schemas.mrUXABdt_single_member_response;
}
export interface Response$organization$members$edit$member$roles$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_member_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$roles$list$roles {
    organization_identifier: Schemas.mrUXABdt_organization_components$schemas$identifier;
}
export interface Response$organization$roles$list$roles$Status$200 {
    "application/json": Schemas.mrUXABdt_collection_role_response;
}
export interface Response$organization$roles$list$roles$Status$4XX {
    "application/json": Schemas.mrUXABdt_collection_role_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$organization$roles$role$details {
    identifier: Schemas.mrUXABdt_role_components$schemas$identifier;
    organization_identifier: Schemas.mrUXABdt_organization_components$schemas$identifier;
}
export interface Response$organization$roles$role$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_role_response;
}
export interface Response$organization$roles$role$details$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_role_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$radar$get$annotations$outages {
    limit?: number;
    offset?: number;
    dateRange?: "1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl";
    dateStart?: Date;
    dateEnd?: Date;
    asn?: number;
    location?: string;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$annotations$outages$Status$200 {
    "application/json": {
        result: {
            annotations: {
                asns: number[];
                asnsDetails: {
                    asn: string;
                    locations?: {
                        code: string;
                        name: string;
                    };
                    name: string;
                }[];
                dataSource: string;
                description?: string;
                endDate?: string;
                eventType: string;
                id: string;
                linkedUrl?: string;
                locations: string[];
                locationsDetails: {
                    code: string;
                    name: string;
                }[];
                outage: {
                    outageCause: string;
                    outageType: string;
                };
                scope?: string;
                startDate: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$annotations$outages$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$annotations$outages$top {
    limit?: number;
    dateRange?: "1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl";
    dateStart?: Date;
    dateEnd?: Date;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$annotations$outages$top$Status$200 {
    "application/json": {
        result: {
            annotations: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$annotations$outages$top$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$by$dnssec {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$by$dnssec$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                NOT_SUPPORTED: string;
                SUPPORTED: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$by$dnssec$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$by$edns {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$by$edns$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                NOT_SUPPORTED: string;
                SUPPORTED: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$by$edns$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$by$ip$version {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                IPv4: string;
                IPv6: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$by$ip$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$by$protocol {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$by$protocol$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                tcp: string;
                udp: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$by$protocol$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$by$query$type {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$by$query$type$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                A: string;
                AAAA: string;
                PTR: string;
                SOA: string;
                SRV: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$by$query$type$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$by$response$codes {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$by$response$codes$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                NOERROR: string;
                NXDOMAIN: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$by$response$codes$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$Status$200 {
    "application/json": {
        result: {
            meta: {
                aggInterval: string;
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: Date;
            };
            serie_0: {
                timestamps: (Date)[];
                values: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$group$by$dnssec {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$group$by$dnssec$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                NOT_SUPPORTED: string[];
                SUPPORTED: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$group$by$dnssec$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$group$by$edns {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$group$by$edns$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                NOT_SUPPORTED: string[];
                SUPPORTED: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$group$by$edns$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$group$by$ip$version {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$group$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                IPv4: string[];
                IPv6: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$group$by$ip$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$group$by$protocol {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$group$by$protocol$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                tcp: string[];
                udp: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$group$by$protocol$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$group$by$query$type {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$group$by$query$type$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                A: string[];
                AAAA: string[];
                PTR: string[];
                SOA: string[];
                SRV: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$group$by$query$type$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$timeseries$group$by$response$codes {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$timeseries$group$by$response$codes$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                NOERROR: string[];
                NXDOMAIN: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$timeseries$group$by$response$codes$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$as112$top$locations {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$top$locations$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$top$locations$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$dns$as112$top$locations$by$dnssec {
    dnssec: "SUPPORTED" | "NOT_SUPPORTED";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$top$locations$by$dnssec$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$top$locations$by$dnssec$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$dns$as112$top$locations$by$edns {
    edns: "SUPPORTED" | "NOT_SUPPORTED";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$top$locations$by$edns$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$top$locations$by$edns$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$dns$as112$top$locations$by$ip$version {
    ip_version: "IPv4" | "IPv6";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$as112$top$locations$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$as112$top$locations$by$ip$version$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer3$summary {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$summary$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            summary_0: {
                gre: string;
                icmp: string;
                tcp: string;
                udp: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$summary$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$summary$by$bitrate {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$summary$by$bitrate$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                "_1_GBPS_TO_10_GBPS": string;
                "_10_GBPS_TO_100_GBPS": string;
                "_500_MBPS_TO_1_GBPS": string;
                OVER_100_GBPS: string;
                UNDER_500_MBPS: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$summary$by$bitrate$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$summary$by$duration {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$summary$by$duration$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                "_1_HOUR_TO_3_HOURS": string;
                "_10_MINS_TO_20_MINS": string;
                "_20_MINS_TO_40_MINS": string;
                "_40_MINS_TO_1_HOUR": string;
                OVER_3_HOURS: string;
                UNDER_10_MINS: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$summary$by$duration$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$summary$by$ip$version {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$summary$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                IPv4: string;
                IPv6: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$summary$by$ip$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$summary$by$protocol {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$summary$by$protocol$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                GRE: string;
                ICMP: string;
                TCP: string;
                UDP: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$summary$by$protocol$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$summary$by$vector {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$summary$by$vector$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {};
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$summary$by$vector$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$by$bytes {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
    metric?: "BYTES" | "BYTES_OLD";
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$by$bytes$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
                values: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$by$bytes$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$groups {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$groups$Status$200 {
    "application/json": {
        result: {
            meta: {
                aggInterval: string;
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: Date;
            };
            serie_0: {
                gre: string[];
                icmp: string[];
                tcp: string[];
                timestamps: string[];
                udp: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$groups$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$group$by$bitrate {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$bitrate$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                "_1_GBPS_TO_10_GBPS": string[];
                "_10_GBPS_TO_100_GBPS": string[];
                "_500_MBPS_TO_1_GBPS": string[];
                OVER_100_GBPS: string[];
                UNDER_500_MBPS: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$bitrate$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$group$by$duration {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$duration$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                "_1_HOUR_TO_3_HOURS": string[];
                "_10_MINS_TO_20_MINS": string[];
                "_20_MINS_TO_40_MINS": string[];
                "_40_MINS_TO_1_HOUR": string[];
                OVER_3_HOURS: string[];
                UNDER_10_MINS: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$duration$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$group$by$industry {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    direction?: "ORIGIN" | "TARGET";
    limitPerGroup?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$industry$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$industry$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$group$by$ip$version {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                IPv4: string[];
                IPv6: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$ip$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$group$by$protocol {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    direction?: "ORIGIN" | "TARGET";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$protocol$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                GRE: string[];
                ICMP: string[];
                TCP: string[];
                UDP: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$protocol$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$group$by$vector {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    direction?: "ORIGIN" | "TARGET";
    limitPerGroup?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$vector$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$vector$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$timeseries$group$by$vertical {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    direction?: "ORIGIN" | "TARGET";
    limitPerGroup?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$vertical$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$timeseries$group$by$vertical$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer3$top$attacks {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    limitDirection?: "ORIGIN" | "TARGET";
    limitPerLocation?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$top$attacks$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                originCountryAlpha2: string;
                originCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$top$attacks$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer3$top$industries {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$top$industries$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                name: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$top$industries$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer3$top$origin$locations {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$top$origin$locations$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                originCountryAlpha2: string;
                originCountryName: string;
                rank: number;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$top$origin$locations$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer3$top$target$locations {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$top$target$locations$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                rank: number;
                targetCountryAlpha2: string;
                targetCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$top$target$locations$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer3$top$verticals {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    protocol?: ("UDP" | "TCP" | "ICMP" | "GRE")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer3$top$verticals$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                name: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer3$top$verticals$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer7$summary {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$summary$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            summary_0: {
                ACCESS_RULES: string;
                API_SHIELD: string;
                BOT_MANAGEMENT: string;
                DATA_LOSS_PREVENTION: string;
                DDOS: string;
                IP_REPUTATION: string;
                WAF: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$summary$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$summary$by$http$method {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$summary$by$http$method$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                GET: string;
                POST: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$summary$by$http$method$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$summary$by$http$version {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$summary$by$http$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                "HTTP/1.x": string;
                "HTTP/2": string;
                "HTTP/3": string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$summary$by$http$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$summary$by$ip$version {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$summary$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                IPv4: string;
                IPv6: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$summary$by$ip$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$summary$by$managed$rules {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$summary$by$managed$rules$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                Bot: string;
                "HTTP Anomaly": string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$summary$by$managed$rules$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$summary$by$mitigation$product {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$summary$by$mitigation$product$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                DDOS: string;
                WAF: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$summary$by$mitigation$product$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    attack?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    asn?: string[];
    location?: string[];
    normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$Status$200 {
    "application/json": {
        result: {
            meta: {
                aggInterval: string;
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: Date;
            };
            serie_0: {
                timestamps: (Date)[];
                values: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries$group {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$group$Status$200 {
    "application/json": {
        result: {
            meta: {
                aggInterval: string;
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: Date;
            };
            serie_0: {
                ACCESS_RULES: string[];
                API_SHIELD: string[];
                BOT_MANAGEMENT: string[];
                DATA_LOSS_PREVENTION: string[];
                DDOS: string[];
                IP_REPUTATION: string[];
                WAF: string[];
                timestamps: (Date)[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$group$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries$group$by$http$method {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$http$method$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                GET: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$http$method$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries$group$by$http$version {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$http$version$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                "HTTP/1.x": string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$http$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries$group$by$industry {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    limitPerGroup?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$industry$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$industry$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries$group$by$ip$version {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                IPv4: string[];
                IPv6: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$ip$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries$group$by$managed$rules {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$managed$rules$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                Bot: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$managed$rules$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries$group$by$mitigation$product {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$mitigation$product$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                DDOS: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$mitigation$product$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$timeseries$group$by$vertical {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    ipVersion?: ("IPv4" | "IPv6")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    httpMethod?: ("GET" | "POST" | "DELETE" | "PUT" | "HEAD" | "PURGE" | "OPTIONS" | "PROPFIND" | "MKCOL" | "PATCH" | "ACL" | "BCOPY" | "BDELETE" | "BMOVE" | "BPROPFIND" | "BPROPPATCH" | "CHECKIN" | "CHECKOUT" | "CONNECT" | "COPY" | "LABEL" | "LOCK" | "MERGE" | "MKACTIVITY" | "MKWORKSPACE" | "MOVE" | "NOTIFY" | "ORDERPATCH" | "POLL" | "PROPPATCH" | "REPORT" | "SEARCH" | "SUBSCRIBE" | "TRACE" | "UNCHECKOUT" | "UNLOCK" | "UNSUBSCRIBE" | "UPDATE" | "VERSIONCONTROL" | "BASELINECONTROL" | "XMSENUMATTS" | "RPC_OUT_DATA" | "RPC_IN_DATA" | "JSON" | "COOK" | "TRACK")[];
    mitigationProduct?: ("DDOS" | "WAF" | "BOT_MANAGEMENT" | "ACCESS_RULES" | "IP_REPUTATION" | "API_SHIELD" | "DATA_LOSS_PREVENTION")[];
    normalization?: "PERCENTAGE" | "MIN0_MAX";
    limitPerGroup?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$vertical$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$timeseries$group$by$vertical$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$attacks$layer7$top$origin$as {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$top$origin$as$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                originAsn: string;
                originAsnName: string;
                rank: number;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$top$origin$as$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer7$top$attacks {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    limitDirection?: "ORIGIN" | "TARGET";
    limitPerLocation?: number;
    magnitude?: "AFFECTED_ZONES" | "MITIGATED_REQUESTS";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$top$attacks$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                originCountryAlpha2: string;
                originCountryName: string;
                targetCountryAlpha2: string;
                targetCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$top$attacks$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer7$top$industries {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$top$industries$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                name: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$top$industries$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer7$top$origin$location {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$top$origin$location$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                originCountryAlpha2: string;
                originCountryName: string;
                rank: number;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$top$origin$location$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer7$top$target$location {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$top$target$location$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                rank: number;
                targetCountryAlpha2: string;
                targetCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$top$target$location$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$attacks$layer7$top$verticals {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$attacks$layer7$top$verticals$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                name: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$attacks$layer7$top$verticals$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$bgp$hijacks$events {
    page?: number;
    per_page?: number;
    eventId?: number;
    hijackerAsn?: number;
    victimAsn?: number;
    involvedAsn?: number;
    involvedCountry?: string;
    prefix?: string;
    minConfidence?: number;
    maxConfidence?: number;
    dateRange?: "1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl";
    dateStart?: Date;
    dateEnd?: Date;
    sortBy?: "ID" | "TIME" | "CONFIDENCE";
    sortOrder?: "ASC" | "DESC";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$hijacks$events$Status$200 {
    "application/json": {
        result: {
            asn_info: {
                asn: number;
                country_code: string;
                org_name: string;
            }[];
            events: {
                confidence_score: number;
                duration: number;
                event_type: number;
                hijack_msgs_count: number;
                hijacker_asn: number;
                hijacker_country: string;
                id: number;
                is_stale: boolean;
                max_hijack_ts: string;
                max_msg_ts: string;
                min_hijack_ts: string;
                on_going_count: number;
                peer_asns: number[];
                peer_ip_count: number;
                prefixes: string[];
                tags: {
                    name: string;
                    score: number;
                }[];
                victim_asns: number[];
                victim_countries: string[];
            }[];
            total_monitors: number;
        };
        result_info: {
            count: number;
            page: number;
            per_page: number;
            total_count: number;
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$hijacks$events$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$bgp$route$leak$events {
    page?: number;
    per_page?: number;
    eventId?: number;
    leakAsn?: number;
    involvedAsn?: number;
    involvedCountry?: string;
    dateRange?: "1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl";
    dateStart?: Date;
    dateEnd?: Date;
    sortBy?: "ID" | "LEAKS" | "PEERS" | "PREFIXES" | "ORIGINS" | "TIME";
    sortOrder?: "ASC" | "DESC";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$route$leak$events$Status$200 {
    "application/json": {
        result: {
            asn_info: {
                asn: number;
                country_code: string;
                org_name: string;
            }[];
            events: {
                countries: string[];
                detected_ts: string;
                finished: boolean;
                id: number;
                leak_asn: number;
                leak_count: number;
                leak_seg: number[];
                leak_type: number;
                max_ts: string;
                min_ts: string;
                origin_count: number;
                peer_count: number;
                prefix_count: number;
            }[];
        };
        result_info: {
            count: number;
            page: number;
            per_page: number;
            total_count: number;
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$route$leak$events$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$bgp$pfx2as$moas {
    origin?: number;
    prefix?: string;
    invalid_only?: boolean;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$pfx2as$moas$Status$200 {
    "application/json": {
        result: {
            meta: {
                data_time: string;
                query_time: string;
                total_peers: number;
            };
            moas: {
                origins: {
                    origin: number;
                    peer_count: number;
                    rpki_validation: string;
                }[];
                prefix: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$pfx2as$moas$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$bgp$pfx2as {
    origin?: number;
    prefix?: string;
    rpkiStatus?: "VALID" | "INVALID" | "UNKNOWN";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$pfx2as$Status$200 {
    "application/json": {
        result: {
            meta: {
                data_time: string;
                query_time: string;
                total_peers: number;
            };
            prefix_origins: {
                origin: number;
                peer_count: number;
                prefix: string;
                rpki_validation: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$pfx2as$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$bgp$routes$stats {
    asn?: number;
    location?: string;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$routes$stats$Status$200 {
    "application/json": {
        result: {
            meta: {
                data_time: string;
                query_time: string;
                total_peers: number;
            };
            stats: {
                distinct_origins: number;
                distinct_origins_ipv4: number;
                distinct_origins_ipv6: number;
                distinct_prefixes: number;
                distinct_prefixes_ipv4: number;
                distinct_prefixes_ipv6: number;
                routes_invalid: number;
                routes_invalid_ipv4: number;
                routes_invalid_ipv6: number;
                routes_total: number;
                routes_total_ipv4: number;
                routes_total_ipv6: number;
                routes_unknown: number;
                routes_unknown_ipv4: number;
                routes_unknown_ipv6: number;
                routes_valid: number;
                routes_valid_ipv4: number;
                routes_valid_ipv6: number;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$routes$stats$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$bgp$timeseries {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    prefix?: string[];
    updateType?: ("ANNOUNCEMENT" | "WITHDRAWAL")[];
    asn?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$timeseries$Status$200 {
    "application/json": {
        result: {
            meta: {
                aggInterval: string;
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: Date;
            };
            serie_0: {
                timestamps: (Date)[];
                values: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$timeseries$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$bgp$top$ases {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    prefix?: string[];
    updateType?: ("ANNOUNCEMENT" | "WITHDRAWAL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$top$ases$Status$200 {
    "application/json": {
        result: {
            meta: {
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            top_0: {
                ASName: string;
                asn: number;
                /** Percentage of updates by this AS out of the total updates by all autonomous systems. */
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$top$ases$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$bgp$top$asns$by$prefixes {
    country?: string;
    limit?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$top$asns$by$prefixes$Status$200 {
    "application/json": {
        result: {
            asns: {
                asn: number;
                country: string;
                name: string;
                pfxs_count: number;
            }[];
            meta: {
                data_time: string;
                query_time: string;
                total_peers: number;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$top$asns$by$prefixes$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$bgp$top$prefixes {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    updateType?: ("ANNOUNCEMENT" | "WITHDRAWAL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$bgp$top$prefixes$Status$200 {
    "application/json": {
        result: {
            meta: {
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            top_0: {
                prefix: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$bgp$top$prefixes$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$connection$tampering$summary {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$connection$tampering$summary$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            summary_0: {
                /** Connections matching signatures for tampering later in the connection, after the transfer of multiple data packets. */
                later_in_flow: string;
                /** Connections that do not match any tampering signatures. */
                no_match: string;
                /** Connections matching signatures for tampering after the receipt of a SYN packet and ACK packet, meaning the TCP connection was successfully established but the server did not receive any subsequent packets. */
                post_ack: string;
                /** Connections matching signatures for tampering after the receipt of a packet with PSH flag set, following connection establishment. */
                post_psh: string;
                /** Connections matching signatures for tampering after the receipt of only a single SYN packet, and before the handshake completes. */
                post_syn: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$connection$tampering$summary$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$connection$tampering$timeseries$group {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$connection$tampering$timeseries$group$Status$200 {
    "application/json": {
        result: {
            meta: {
                aggInterval: string;
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: Date;
            };
            serie_0: {
                /** Connections matching signatures for tampering later in the connection, after the transfer of multiple data packets. */
                later_in_flow: string[];
                /** Connections that do not match any tampering signatures. */
                no_match: string[];
                /** Connections matching signatures for tampering after the receipt of a SYN packet and ACK packet, meaning the TCP connection was successfully established but the server did not receive any subsequent packets. */
                post_ack: string[];
                /** Connections matching signatures for tampering after the receipt of a packet with PSH flag set, following connection establishment. */
                post_psh: string[];
                /** Connections matching signatures for tampering after the receipt of only a single SYN packet, and before the handshake completes. */
                post_syn: string[];
                timestamps: (Date)[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$connection$tampering$timeseries$group$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$reports$datasets {
    limit?: number;
    offset?: number;
    datasetType?: "RANKING_BUCKET" | "REPORT";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$reports$datasets$Status$200 {
    "application/json": {
        result: {
            datasets: {
                description: string;
                id: number;
                meta: {};
                tags: string[];
                title: string;
                type: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$reports$datasets$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$reports$dataset$download {
    alias: string;
    date?: string | null;
}
export interface Response$radar$get$reports$dataset$download$Status$200 {
    "text/csv": string;
}
export interface Response$radar$get$reports$dataset$download$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$post$reports$dataset$download$url {
    format?: "JSON" | "CSV";
}
export interface RequestBody$radar$post$reports$dataset$download$url {
    "application/json": {
        datasetId: number;
    };
}
export interface Response$radar$post$reports$dataset$download$url$Status$200 {
    "application/json": {
        result: {
            dataset: {
                url: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$post$reports$dataset$download$url$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$dns$top$ases {
    limit?: number;
    name?: string[];
    domain: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$top$ases$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$top$ases$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$dns$top$locations {
    limit?: number;
    name?: string[];
    domain: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$dns$top$locations$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$dns$top$locations$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$summary$by$arc {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$summary$by$arc$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                FAIL: string;
                NONE: string;
                PASS: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$summary$by$arc$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$summary$by$dkim {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$summary$by$dkim$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                FAIL: string;
                NONE: string;
                PASS: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$summary$by$dkim$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$summary$by$dmarc {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$summary$by$dmarc$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                FAIL: string;
                NONE: string;
                PASS: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$summary$by$dmarc$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$summary$by$malicious {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$summary$by$malicious$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                MALICIOUS: string;
                NOT_MALICIOUS: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$summary$by$malicious$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$summary$by$spam {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$summary$by$spam$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                NOT_SPAM: string;
                SPAM: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$summary$by$spam$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$summary$by$spf {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$summary$by$spf$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                FAIL: string;
                NONE: string;
                PASS: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$summary$by$spf$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$summary$by$threat$category {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$summary$by$threat$category$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                BrandImpersonation: string;
                CredentialHarvester: string;
                IdentityDeception: string;
                Link: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$summary$by$threat$category$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$timeseries$group$by$arc {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$timeseries$group$by$arc$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                FAIL: string[];
                NONE: string[];
                PASS: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$timeseries$group$by$arc$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$timeseries$group$by$dkim {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$timeseries$group$by$dkim$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                FAIL: string[];
                NONE: string[];
                PASS: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$timeseries$group$by$dkim$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$timeseries$group$by$dmarc {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$timeseries$group$by$dmarc$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                FAIL: string[];
                NONE: string[];
                PASS: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$timeseries$group$by$dmarc$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$timeseries$group$by$malicious {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$timeseries$group$by$malicious$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                MALICIOUS: string[];
                NOT_MALICIOUS: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$timeseries$group$by$malicious$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$timeseries$group$by$spam {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$timeseries$group$by$spam$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                NOT_SPAM: string[];
                SPAM: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$timeseries$group$by$spam$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$timeseries$group$by$spf {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$timeseries$group$by$spf$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                FAIL: string[];
                NONE: string[];
                PASS: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$timeseries$group$by$spf$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$timeseries$group$by$threat$category {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$timeseries$group$by$threat$category$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                BrandImpersonation: string[];
                CredentialHarvester: string[];
                IdentityDeception: string[];
                Link: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$timeseries$group$by$threat$category$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$email$security$top$ases$by$messages {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$ases$by$messages$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$ases$by$messages$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$ases$by$arc {
    arc: "PASS" | "NONE" | "FAIL";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$ases$by$arc$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$ases$by$arc$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$ases$by$dkim {
    dkim: "PASS" | "NONE" | "FAIL";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$ases$by$dkim$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$ases$by$dkim$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$ases$by$dmarc {
    dmarc: "PASS" | "NONE" | "FAIL";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$ases$by$dmarc$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$ases$by$dmarc$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$ases$by$malicious {
    malicious: "MALICIOUS" | "NOT_MALICIOUS";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$ases$by$malicious$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$ases$by$malicious$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$ases$by$spam {
    spam: "SPAM" | "NOT_SPAM";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$ases$by$spam$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$ases$by$spam$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$ases$by$spf {
    spf: "PASS" | "NONE" | "FAIL";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$ases$by$spf$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$ases$by$spf$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$locations$by$messages {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$locations$by$messages$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$locations$by$messages$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$locations$by$arc {
    arc: "PASS" | "NONE" | "FAIL";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$locations$by$arc$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$locations$by$arc$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$locations$by$dkim {
    dkim: "PASS" | "NONE" | "FAIL";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$locations$by$dkim$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$locations$by$dkim$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$locations$by$dmarc {
    dmarc: "PASS" | "NONE" | "FAIL";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$locations$by$dmarc$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$locations$by$dmarc$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$locations$by$malicious {
    malicious: "MALICIOUS" | "NOT_MALICIOUS";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$locations$by$malicious$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$locations$by$malicious$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$locations$by$spam {
    spam: "SPAM" | "NOT_SPAM";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    spf?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$locations$by$spam$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$locations$by$spam$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$email$security$top$locations$by$spf {
    spf: "PASS" | "NONE" | "FAIL";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    arc?: ("PASS" | "NONE" | "FAIL")[];
    dkim?: ("PASS" | "NONE" | "FAIL")[];
    dmarc?: ("PASS" | "NONE" | "FAIL")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$email$security$top$locations$by$spf$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$email$security$top$locations$by$spf$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$entities$asn$list {
    limit?: number;
    offset?: number;
    asn?: string;
    location?: string;
    orderBy?: "ASN" | "POPULATION";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$entities$asn$list$Status$200 {
    "application/json": {
        result: {
            asns: {
                aka?: string;
                asn: number;
                country: string;
                countryName: string;
                name: string;
                /** Deprecated field. Please use 'aka'. */
                nameLong?: string;
                orgName?: string;
                website?: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$entities$asn$list$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$entities$asn$by$id {
    asn: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$entities$asn$by$id$Status$200 {
    "application/json": {
        result: {
            asn: {
                aka?: string;
                asn: number;
                confidenceLevel: number;
                country: string;
                countryName: string;
                estimatedUsers: {
                    /** Total estimated users */
                    estimatedUsers?: number;
                    locations: {
                        /** Estimated users per location */
                        estimatedUsers?: number;
                        locationAlpha2: string;
                        locationName: string;
                    }[];
                };
                name: string;
                /** Deprecated field. Please use 'aka'. */
                nameLong?: string;
                orgName: string;
                related: {
                    aka?: string;
                    asn: number;
                    /** Total estimated users */
                    estimatedUsers?: number;
                    name: string;
                }[];
                /** Regional Internet Registry */
                source: string;
                website: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$entities$asn$by$id$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$asns$rel {
    asn: number;
    asn2?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$asns$rel$Status$200 {
    "application/json": {
        result: {
            meta: {
                data_time: string;
                query_time: string;
                total_peers: number;
            };
            rels: {
                asn1: number;
                asn1_country: string;
                asn1_name: string;
                asn2: number;
                asn2_country: string;
                asn2_name: string;
                rel: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$asns$rel$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$entities$asn$by$ip {
    ip: string;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$entities$asn$by$ip$Status$200 {
    "application/json": {
        result: {
            asn: {
                aka?: string;
                asn: number;
                country: string;
                countryName: string;
                estimatedUsers: {
                    /** Total estimated users */
                    estimatedUsers?: number;
                    locations: {
                        /** Estimated users per location */
                        estimatedUsers?: number;
                        locationAlpha2: string;
                        locationName: string;
                    }[];
                };
                name: string;
                /** Deprecated field. Please use 'aka'. */
                nameLong?: string;
                orgName: string;
                related: {
                    aka?: string;
                    asn: number;
                    /** Total estimated users */
                    estimatedUsers?: number;
                    name: string;
                }[];
                /** Regional Internet Registry */
                source: string;
                website: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$entities$asn$by$ip$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$entities$ip {
    ip: string;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$entities$ip$Status$200 {
    "application/json": {
        result: {
            ip: {
                asn: string;
                asnLocation: string;
                asnName: string;
                asnOrgName: string;
                ip: string;
                ipVersion: string;
                location: string;
                locationName: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$entities$ip$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$entities$locations {
    limit?: number;
    offset?: number;
    location?: string;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$entities$locations$Status$200 {
    "application/json": {
        result: {
            locations: {
                alpha2: string;
                latitude: string;
                longitude: string;
                name: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$entities$locations$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$entities$location$by$alpha2 {
    location: string;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$entities$location$by$alpha2$Status$200 {
    "application/json": {
        result: {
            location: {
                alpha2: string;
                confidenceLevel: number;
                latitude: string;
                longitude: string;
                name: string;
                region: string;
                subregion: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$entities$location$by$alpha2$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$summary$by$bot$class {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$summary$by$bot$class$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                bot: string;
                human: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$summary$by$bot$class$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$summary$by$device$type {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$summary$by$device$type$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                desktop: string;
                mobile: string;
                other: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$summary$by$device$type$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$summary$by$http$protocol {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$summary$by$http$protocol$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                http: string;
                https: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$summary$by$http$protocol$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$summary$by$http$version {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$summary$by$http$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                "HTTP/1.x": string;
                "HTTP/2": string;
                "HTTP/3": string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$summary$by$http$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$summary$by$ip$version {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$summary$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                IPv4: string;
                IPv6: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$summary$by$ip$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$summary$by$operating$system {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$summary$by$operating$system$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                ANDROID: string;
                IOS: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$summary$by$operating$system$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$summary$by$tls$version {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$summary$by$tls$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                "TLS 1.0": string;
                "TLS 1.1": string;
                "TLS 1.2": string;
                "TLS 1.3": string;
                "TLS QUIC": string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$summary$by$tls$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$bot$class {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$bot$class$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                bot: string[];
                human: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$bot$class$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$browsers {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    limitPerGroup?: number;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$browsers$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$browsers$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$browser$families {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$browser$families$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$browser$families$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$device$type {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$device$type$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                desktop: string[];
                mobile: string[];
                other: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$device$type$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$http$protocol {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$http$protocol$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                http: string[];
                https: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$http$protocol$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$http$version {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$http$version$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                "HTTP/1.x": string[];
                "HTTP/2": string[];
                "HTTP/3": string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$http$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$ip$version {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                IPv4: string[];
                IPv6: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$ip$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$operating$system {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$operating$system$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$operating$system$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$timeseries$group$by$tls$version {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$timeseries$group$by$tls$version$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                "TLS 1.0": string[];
                "TLS 1.1": string[];
                "TLS 1.2": string[];
                "TLS 1.3": string[];
                "TLS QUIC": string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$timeseries$group$by$tls$version$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$http$top$ases$by$http$requests {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$ases$by$http$requests$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$ases$by$http$requests$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$ases$by$bot$class {
    bot_class: "LIKELY_AUTOMATED" | "LIKELY_HUMAN";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$ases$by$bot$class$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$ases$by$bot$class$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$ases$by$device$type {
    device_type: "DESKTOP" | "MOBILE" | "OTHER";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$ases$by$device$type$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$ases$by$device$type$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$ases$by$http$protocol {
    http_protocol: "HTTP" | "HTTPS";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$ases$by$http$protocol$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$ases$by$http$protocol$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$ases$by$http$version {
    http_version: "HTTPv1" | "HTTPv2" | "HTTPv3";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$ases$by$http$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$ases$by$http$version$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$ases$by$ip$version {
    ip_version: "IPv4" | "IPv6";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$ases$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$ases$by$ip$version$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$ases$by$operating$system {
    os: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$ases$by$operating$system$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$ases$by$operating$system$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$ases$by$tls$version {
    tls_version: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$ases$by$tls$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$ases$by$tls$version$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$browser$families {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$browser$families$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                name: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$browser$families$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$browsers {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$browsers$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                name: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$browsers$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$locations$by$http$requests {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$locations$by$http$requests$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$locations$by$http$requests$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$locations$by$bot$class {
    bot_class: "LIKELY_AUTOMATED" | "LIKELY_HUMAN";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$locations$by$bot$class$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$locations$by$bot$class$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$locations$by$device$type {
    device_type: "DESKTOP" | "MOBILE" | "OTHER";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$locations$by$device$type$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$locations$by$device$type$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$locations$by$http$protocol {
    http_protocol: "HTTP" | "HTTPS";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$locations$by$http$protocol$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$locations$by$http$protocol$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$locations$by$http$version {
    http_version: "HTTPv1" | "HTTPv2" | "HTTPv3";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$locations$by$http$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$locations$by$http$version$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$locations$by$ip$version {
    ip_version: "IPv4" | "IPv6";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$locations$by$ip$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$locations$by$ip$version$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$locations$by$operating$system {
    os: "WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    tlsVersion?: ("TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$locations$by$operating$system$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$locations$by$operating$system$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$http$top$locations$by$tls$version {
    tls_version: "TLSv1_0" | "TLSv1_1" | "TLSv1_2" | "TLSv1_3" | "TLSvQUIC";
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    botClass?: ("LIKELY_AUTOMATED" | "LIKELY_HUMAN")[];
    deviceType?: ("DESKTOP" | "MOBILE" | "OTHER")[];
    httpProtocol?: ("HTTP" | "HTTPS")[];
    httpVersion?: ("HTTPv1" | "HTTPv2" | "HTTPv3")[];
    ipVersion?: ("IPv4" | "IPv6")[];
    os?: ("WINDOWS" | "MACOSX" | "IOS" | "ANDROID" | "CHROMEOS" | "LINUX" | "SMART_TV")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$http$top$locations$by$tls$version$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$http$top$locations$by$tls$version$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$netflows$timeseries {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    product?: ("HTTP" | "ALL")[];
    asn?: string[];
    location?: string[];
    normalization?: "PERCENTAGE_CHANGE" | "MIN0_MAX";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$netflows$timeseries$Status$200 {
    "application/json": {
        result: {
            meta: {
                aggInterval: string;
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: Date;
            };
            serie_0: {
                timestamps: (Date)[];
                values: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$netflows$timeseries$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$netflows$top$ases {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$netflows$top$ases$Status$200 {
    "application/json": {
        result: {
            top_0: {
                clientASN: number;
                clientASName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$netflows$top$ases$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$netflows$top$locations {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$netflows$top$locations$Status$200 {
    "application/json": {
        result: {
            top_0: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$netflows$top$locations$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$quality$index$summary {
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    continent?: string[];
    metric: "BANDWIDTH" | "DNS" | "LATENCY";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$quality$index$summary$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                p25: string;
                p50: string;
                p75: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$quality$index$summary$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$quality$index$timeseries$group {
    aggInterval?: "15m" | "1h" | "1d" | "1w";
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    continent?: string[];
    interpolation?: boolean;
    metric: "BANDWIDTH" | "DNS" | "LATENCY";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$quality$index$timeseries$group$Status$200 {
    "application/json": {
        result: {
            meta: {};
            serie_0: {
                p25: string[];
                p50: string[];
                p75: string[];
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$quality$index$timeseries$group$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$quality$speed$histogram {
    name?: string[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    bucketSize?: number;
    metricGroup?: "BANDWIDTH" | "LATENCY" | "JITTER";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$quality$speed$histogram$Status$200 {
    "application/json": {
        result: {
            histogram_0: {
                bandwidthDownload: string[];
                bandwidthUpload: string[];
                bucketMin: string[];
            };
            meta: {};
        };
        success: boolean;
    };
}
export interface Response$radar$get$quality$speed$histogram$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$quality$speed$summary {
    name?: string[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$quality$speed$summary$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
                normalization: string;
            };
            summary_0: {
                bandwidthDownload: string;
                bandwidthUpload: string;
                jitterIdle: string;
                jitterLoaded: string;
                latencyIdle: string;
                latencyLoaded: string;
                packetLoss: string;
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$quality$speed$summary$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$quality$speed$top$ases {
    limit?: number;
    name?: string[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    orderBy?: "BANDWIDTH_DOWNLOAD" | "BANDWIDTH_UPLOAD" | "LATENCY_IDLE" | "LATENCY_LOADED" | "JITTER_IDLE" | "JITTER_LOADED";
    reverse?: boolean;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$quality$speed$top$ases$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                bandwidthDownload: string;
                bandwidthUpload: string;
                clientASN: number;
                clientASName: string;
                jitterIdle: string;
                jitterLoaded: string;
                latencyIdle: string;
                latencyLoaded: string;
                numTests: number;
                rankPower: number;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$quality$speed$top$ases$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$quality$speed$top$locations {
    limit?: number;
    name?: string[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    orderBy?: "BANDWIDTH_DOWNLOAD" | "BANDWIDTH_UPLOAD" | "LATENCY_IDLE" | "LATENCY_LOADED" | "JITTER_IDLE" | "JITTER_LOADED";
    reverse?: boolean;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$quality$speed$top$locations$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
                lastUpdated: string;
            };
            top_0: {
                bandwidthDownload: string;
                bandwidthUpload: string;
                clientCountryAlpha2: string;
                clientCountryName: string;
                jitterIdle: string;
                jitterLoaded: string;
                latencyIdle: string;
                latencyLoaded: string;
                numTests: number;
                rankPower: number;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$quality$speed$top$locations$Status$404 {
    "application/json": {
        error: string;
    };
}
export interface Parameter$radar$get$ranking$domain$details {
    domain: string;
    limit?: number;
    rankingType?: "POPULAR" | "TRENDING_RISE" | "TRENDING_STEADY";
    name?: string[];
    date?: (string | null)[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$ranking$domain$details$Status$200 {
    "application/json": {
        result: {
            details_0: {
                /** Only available in POPULAR ranking for the most recent ranking. */
                bucket?: string;
                categories: {
                    id: number;
                    name: string;
                    superCategoryId: number;
                }[];
                rank?: number;
                top_locations: {
                    locationCode: string;
                    locationName: string;
                    rank: number;
                }[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$ranking$domain$details$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$ranking$domain$timeseries {
    limit?: number;
    rankingType?: "POPULAR" | "TRENDING_RISE" | "TRENDING_STEADY";
    name?: string[];
    location?: string[];
    domains?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$ranking$domain$timeseries$Status$200 {
    "application/json": {
        result: {
            meta: {
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            serie_0: {
                timestamps: string[];
            };
        };
        success: boolean;
    };
}
export interface Response$radar$get$ranking$domain$timeseries$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$ranking$top$domains {
    limit?: number;
    name?: string[];
    location?: string[];
    date?: (string | null)[];
    rankingType?: "POPULAR" | "TRENDING_RISE" | "TRENDING_STEADY";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$ranking$top$domains$Status$200 {
    "application/json": {
        result: {
            meta: {
                top_0: {
                    date: string;
                };
            };
            top_0: {
                categories: {
                    id: number;
                    name: string;
                    superCategoryId: number;
                }[];
                domain: string;
                /** Only available in TRENDING rankings. */
                pctRankChange?: number;
                rank: number;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$ranking$top$domains$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$search$global {
    limit?: number;
    limitPerGroup?: number;
    query: string;
    include?: ("SPECIAL_EVENTS" | "NOTEBOOKS" | "LOCATIONS" | "ASNS")[];
    exclude?: ("SPECIAL_EVENTS" | "NOTEBOOKS" | "LOCATIONS" | "ASNS")[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$search$global$Status$200 {
    "application/json": {
        result: {
            search: {
                code: string;
                name: string;
                type: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$search$global$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$traffic$anomalies {
    limit?: number;
    offset?: number;
    dateRange?: "1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl";
    dateStart?: Date;
    dateEnd?: Date;
    status?: "VERIFIED" | "UNVERIFIED";
    asn?: number;
    location?: string;
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$traffic$anomalies$Status$200 {
    "application/json": {
        result: {
            trafficAnomalies: {
                asnDetails?: {
                    asn: string;
                    locations?: {
                        code: string;
                        name: string;
                    };
                    name: string;
                };
                endDate?: string;
                locationDetails?: {
                    code: string;
                    name: string;
                };
                startDate: string;
                status: string;
                type: string;
                uuid: string;
                visibleInDataSources?: string[];
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$traffic$anomalies$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$traffic$anomalies$top {
    limit?: number;
    dateRange?: "1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl";
    dateStart?: Date;
    dateEnd?: Date;
    status?: "VERIFIED" | "UNVERIFIED";
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$traffic$anomalies$top$Status$200 {
    "application/json": {
        result: {
            trafficAnomalies: {
                clientCountryAlpha2: string;
                clientCountryName: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$traffic$anomalies$top$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$verified$bots$top$by$http$requests {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$verified$bots$top$by$http$requests$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            top_0: {
                botCategory: string;
                botName: string;
                botOwner: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$verified$bots$top$by$http$requests$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Parameter$radar$get$verified$bots$top$categories$by$http$requests {
    limit?: number;
    name?: string[];
    dateRange?: ("1d" | "2d" | "7d" | "14d" | "28d" | "12w" | "24w" | "52w" | "1dControl" | "2dControl" | "7dControl" | "14dControl" | "28dControl" | "12wControl" | "24wControl")[];
    dateStart?: (Date)[];
    dateEnd?: (Date)[];
    asn?: string[];
    location?: string[];
    format?: "JSON" | "CSV";
}
export interface Response$radar$get$verified$bots$top$categories$by$http$requests$Status$200 {
    "application/json": {
        result: {
            meta: {
                confidenceInfo?: {
                    annotations?: {
                        dataSource: string;
                        description: string;
                        endTime?: Date;
                        eventType: string;
                        isInstantaneous: {};
                        linkedUrl?: string;
                        startTime?: Date;
                    }[];
                    level?: number;
                };
                dateRange: {
                    /** Adjusted end of date range. */
                    endTime: Date;
                    /** Adjusted start of date range. */
                    startTime: Date;
                }[];
            };
            top_0: {
                botCategory: string;
                value: string;
            }[];
        };
        success: boolean;
    };
}
export interface Response$radar$get$verified$bots$top$categories$by$http$requests$Status$400 {
    "application/json": {
        errors: {
            message: string;
        }[];
        result: {};
        success: boolean;
    };
}
export interface Response$user$user$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_user_response;
}
export interface Response$user$user$details$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_user_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface RequestBody$user$edit$user {
    "application/json": {
        country?: Schemas.mrUXABdt_country;
        first_name?: Schemas.mrUXABdt_first_name;
        last_name?: Schemas.mrUXABdt_last_name;
        telephone?: Schemas.mrUXABdt_telephone;
        zipcode?: Schemas.mrUXABdt_zipcode;
    };
}
export interface Response$user$edit$user$Status$200 {
    "application/json": Schemas.mrUXABdt_single_user_response;
}
export interface Response$user$edit$user$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_user_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$audit$logs$get$user$audit$logs {
    id?: string;
    export?: boolean;
    "action.type"?: string;
    "actor.ip"?: string;
    "actor.email"?: string;
    since?: Date;
    before?: Date;
    "zone.name"?: string;
    direction?: "desc" | "asc";
    per_page?: number;
    page?: number;
    hide_user_logs?: boolean;
}
export interface Response$audit$logs$get$user$audit$logs$Status$200 {
    "application/json": Schemas.w2PBr26F_audit_logs_response_collection;
}
export interface Response$audit$logs$get$user$audit$logs$Status$4XX {
    "application/json": Schemas.w2PBr26F_audit_logs_response_collection & Schemas.w2PBr26F_api$response$common$failure;
}
export interface Parameter$user$billing$history$$$deprecated$$billing$history$details {
    page?: number;
    per_page?: number;
    order?: "type" | "occured_at" | "action";
    occured_at?: Schemas.bill$subs$api_occurred_at;
    occurred_at?: Schemas.bill$subs$api_occurred_at;
    type?: string;
    action?: string;
}
export interface Response$user$billing$history$$$deprecated$$billing$history$details$Status$200 {
    "application/json": Schemas.bill$subs$api_billing_history_collection;
}
export interface Response$user$billing$history$$$deprecated$$billing$history$details$Status$4XX {
    "application/json": Schemas.bill$subs$api_billing_history_collection & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Response$user$billing$profile$$$deprecated$$billing$profile$details$Status$200 {
    "application/json": Schemas.bill$subs$api_billing_response_single;
}
export interface Response$user$billing$profile$$$deprecated$$billing$profile$details$Status$4XX {
    "application/json": Schemas.bill$subs$api_billing_response_single & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$a$user$list$ip$access$rules {
    filters?: Schemas.legacy$jhs_schemas$filters;
    "egs-pagination.json"?: Schemas.legacy$jhs_egs$pagination;
    page?: number;
    per_page?: number;
    order?: "configuration.target" | "configuration.value" | "mode";
    direction?: "asc" | "desc";
}
export interface Response$ip$access$rules$for$a$user$list$ip$access$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_rule_collection_response;
}
export interface Response$ip$access$rules$for$a$user$list$ip$access$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_rule_collection_response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface RequestBody$ip$access$rules$for$a$user$create$an$ip$access$rule {
    "application/json": {
        configuration: Schemas.legacy$jhs_schemas$configuration;
        mode: Schemas.legacy$jhs_schemas$mode;
        notes?: Schemas.legacy$jhs_notes;
    };
}
export interface Response$ip$access$rules$for$a$user$create$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_rule_single_response;
}
export interface Response$ip$access$rules$for$a$user$create$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_rule_single_response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$a$user$delete$an$ip$access$rule {
    identifier: Schemas.legacy$jhs_rule_components$schemas$identifier;
}
export interface Response$ip$access$rules$for$a$user$delete$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_rule_single_id_response;
}
export interface Response$ip$access$rules$for$a$user$delete$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_rule_single_id_response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$a$user$update$an$ip$access$rule {
    identifier: Schemas.legacy$jhs_rule_components$schemas$identifier;
}
export interface RequestBody$ip$access$rules$for$a$user$update$an$ip$access$rule {
    "application/json": {
        mode?: Schemas.legacy$jhs_schemas$mode;
        notes?: Schemas.legacy$jhs_notes;
    };
}
export interface Response$ip$access$rules$for$a$user$update$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_rule_single_response;
}
export interface Response$ip$access$rules$for$a$user$update$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_rule_single_response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Response$user$$s$invites$list$invitations$Status$200 {
    "application/json": Schemas.mrUXABdt_schemas$collection_invite_response;
}
export interface Response$user$$s$invites$list$invitations$Status$4XX {
    "application/json": Schemas.mrUXABdt_schemas$collection_invite_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$$s$invites$invitation$details {
    identifier: Schemas.mrUXABdt_invite_components$schemas$identifier;
}
export interface Response$user$$s$invites$invitation$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_invite_response;
}
export interface Response$user$$s$invites$invitation$details$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_invite_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$$s$invites$respond$to$invitation {
    identifier: Schemas.mrUXABdt_invite_components$schemas$identifier;
}
export interface RequestBody$user$$s$invites$respond$to$invitation {
    "application/json": {
        /** Status of your response to the invitation (rejected or accepted). */
        status: "accepted" | "rejected";
    };
}
export interface Response$user$$s$invites$respond$to$invitation$Status$200 {
    "application/json": Schemas.mrUXABdt_single_invite_response;
}
export interface Response$user$$s$invites$respond$to$invitation$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_invite_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Response$load$balancer$monitors$list$monitors$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$collection;
}
export interface Response$load$balancer$monitors$list$monitors$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$collection & Schemas.load$balancing_api$response$common$failure;
}
export interface RequestBody$load$balancer$monitors$create$monitor {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$load$balancer$monitors$create$monitor$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$single;
}
export interface Response$load$balancer$monitors$create$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$single & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$monitors$monitor$details {
    identifier: Schemas.load$balancing_identifier;
}
export interface Response$load$balancer$monitors$monitor$details$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$single;
}
export interface Response$load$balancer$monitors$monitor$details$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$single & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$monitors$update$monitor {
    identifier: Schemas.load$balancing_identifier;
}
export interface RequestBody$load$balancer$monitors$update$monitor {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$load$balancer$monitors$update$monitor$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$single;
}
export interface Response$load$balancer$monitors$update$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$single & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$monitors$delete$monitor {
    identifier: Schemas.load$balancing_identifier;
}
export interface Response$load$balancer$monitors$delete$monitor$Status$200 {
    "application/json": Schemas.load$balancing_id_response;
}
export interface Response$load$balancer$monitors$delete$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_id_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$monitors$patch$monitor {
    identifier: Schemas.load$balancing_identifier;
}
export interface RequestBody$load$balancer$monitors$patch$monitor {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$load$balancer$monitors$patch$monitor$Status$200 {
    "application/json": Schemas.load$balancing_monitor$response$single;
}
export interface Response$load$balancer$monitors$patch$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_monitor$response$single & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$monitors$preview$monitor {
    identifier: Schemas.load$balancing_identifier;
}
export interface RequestBody$load$balancer$monitors$preview$monitor {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$load$balancer$monitors$preview$monitor$Status$200 {
    "application/json": Schemas.load$balancing_preview_response;
}
export interface Response$load$balancer$monitors$preview$monitor$Status$4XX {
    "application/json": Schemas.load$balancing_preview_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$monitors$list$monitor$references {
    identifier: Schemas.load$balancing_identifier;
}
export interface Response$load$balancer$monitors$list$monitor$references$Status$200 {
    "application/json": Schemas.load$balancing_references_response;
}
export interface Response$load$balancer$monitors$list$monitor$references$Status$4XX {
    "application/json": Schemas.load$balancing_references_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$pools$list$pools {
    monitor?: any;
}
export interface Response$load$balancer$pools$list$pools$Status$200 {
    "application/json": Schemas.load$balancing_schemas$response_collection;
}
export interface Response$load$balancer$pools$list$pools$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$response_collection & Schemas.load$balancing_api$response$common$failure;
}
export interface RequestBody$load$balancer$pools$create$pool {
    "application/json": {
        check_regions?: Schemas.load$balancing_check_regions;
        description?: Schemas.load$balancing_schemas$description;
        enabled?: Schemas.load$balancing_enabled;
        latitude?: Schemas.load$balancing_latitude;
        load_shedding?: Schemas.load$balancing_load_shedding;
        longitude?: Schemas.load$balancing_longitude;
        minimum_origins?: Schemas.load$balancing_minimum_origins;
        monitor?: Schemas.load$balancing_monitor_id;
        name: Schemas.load$balancing_name;
        notification_email?: Schemas.load$balancing_notification_email;
        notification_filter?: Schemas.load$balancing_notification_filter;
        origin_steering?: Schemas.load$balancing_origin_steering;
        origins: Schemas.load$balancing_origins;
    };
}
export interface Response$load$balancer$pools$create$pool$Status$200 {
    "application/json": Schemas.load$balancing_schemas$single_response;
}
export interface Response$load$balancer$pools$create$pool$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface RequestBody$load$balancer$pools$patch$pools {
    "application/json": {
        notification_email?: Schemas.load$balancing_patch_pools_notification_email;
    };
}
export interface Response$load$balancer$pools$patch$pools$Status$200 {
    "application/json": Schemas.load$balancing_schemas$response_collection;
}
export interface Response$load$balancer$pools$patch$pools$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$response_collection & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$pools$pool$details {
    identifier: Schemas.load$balancing_schemas$identifier;
}
export interface Response$load$balancer$pools$pool$details$Status$200 {
    "application/json": Schemas.load$balancing_schemas$single_response;
}
export interface Response$load$balancer$pools$pool$details$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$pools$update$pool {
    identifier: Schemas.load$balancing_schemas$identifier;
}
export interface RequestBody$load$balancer$pools$update$pool {
    "application/json": {
        check_regions?: Schemas.load$balancing_check_regions;
        description?: Schemas.load$balancing_schemas$description;
        disabled_at?: Schemas.load$balancing_schemas$disabled_at;
        enabled?: Schemas.load$balancing_enabled;
        latitude?: Schemas.load$balancing_latitude;
        load_shedding?: Schemas.load$balancing_load_shedding;
        longitude?: Schemas.load$balancing_longitude;
        minimum_origins?: Schemas.load$balancing_minimum_origins;
        monitor?: Schemas.load$balancing_monitor_id;
        name: Schemas.load$balancing_name;
        notification_email?: Schemas.load$balancing_notification_email;
        notification_filter?: Schemas.load$balancing_notification_filter;
        origin_steering?: Schemas.load$balancing_origin_steering;
        origins: Schemas.load$balancing_origins;
    };
}
export interface Response$load$balancer$pools$update$pool$Status$200 {
    "application/json": Schemas.load$balancing_schemas$single_response;
}
export interface Response$load$balancer$pools$update$pool$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$pools$delete$pool {
    identifier: Schemas.load$balancing_schemas$identifier;
}
export interface Response$load$balancer$pools$delete$pool$Status$200 {
    "application/json": Schemas.load$balancing_schemas$id_response;
}
export interface Response$load$balancer$pools$delete$pool$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$id_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$pools$patch$pool {
    identifier: Schemas.load$balancing_schemas$identifier;
}
export interface RequestBody$load$balancer$pools$patch$pool {
    "application/json": {
        check_regions?: Schemas.load$balancing_check_regions;
        description?: Schemas.load$balancing_schemas$description;
        disabled_at?: Schemas.load$balancing_schemas$disabled_at;
        enabled?: Schemas.load$balancing_enabled;
        latitude?: Schemas.load$balancing_latitude;
        load_shedding?: Schemas.load$balancing_load_shedding;
        longitude?: Schemas.load$balancing_longitude;
        minimum_origins?: Schemas.load$balancing_minimum_origins;
        monitor?: Schemas.load$balancing_monitor_id;
        name?: Schemas.load$balancing_name;
        notification_email?: Schemas.load$balancing_notification_email;
        notification_filter?: Schemas.load$balancing_notification_filter;
        origin_steering?: Schemas.load$balancing_origin_steering;
        origins?: Schemas.load$balancing_origins;
    };
}
export interface Response$load$balancer$pools$patch$pool$Status$200 {
    "application/json": Schemas.load$balancing_schemas$single_response;
}
export interface Response$load$balancer$pools$patch$pool$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$pools$pool$health$details {
    identifier: Schemas.load$balancing_schemas$identifier;
}
export interface Response$load$balancer$pools$pool$health$details$Status$200 {
    "application/json": Schemas.load$balancing_health_details;
}
export interface Response$load$balancer$pools$pool$health$details$Status$4XX {
    "application/json": Schemas.load$balancing_health_details & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$pools$preview$pool {
    identifier: Schemas.load$balancing_schemas$identifier;
}
export interface RequestBody$load$balancer$pools$preview$pool {
    "application/json": Schemas.load$balancing_monitor$editable & {
        expected_codes: any;
    };
}
export interface Response$load$balancer$pools$preview$pool$Status$200 {
    "application/json": Schemas.load$balancing_preview_response;
}
export interface Response$load$balancer$pools$preview$pool$Status$4XX {
    "application/json": Schemas.load$balancing_preview_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$pools$list$pool$references {
    identifier: Schemas.load$balancing_schemas$identifier;
}
export interface Response$load$balancer$pools$list$pool$references$Status$200 {
    "application/json": Schemas.load$balancing_schemas$references_response;
}
export interface Response$load$balancer$pools$list$pool$references$Status$4XX {
    "application/json": Schemas.load$balancing_schemas$references_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$monitors$preview$result {
    preview_id: Schemas.load$balancing_preview_id;
}
export interface Response$load$balancer$monitors$preview$result$Status$200 {
    "application/json": Schemas.load$balancing_preview_result_response;
}
export interface Response$load$balancer$monitors$preview$result$Status$4XX {
    "application/json": Schemas.load$balancing_preview_result_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancer$healthcheck$events$list$healthcheck$events {
    until?: Schemas.load$balancing_until;
    pool_name?: Schemas.load$balancing_pool_name;
    origin_healthy?: Schemas.load$balancing_origin_healthy;
    identifier?: Schemas.load$balancing_schemas$identifier;
    since?: Date;
    origin_name?: string;
    pool_healthy?: boolean;
}
export interface Response$load$balancer$healthcheck$events$list$healthcheck$events$Status$200 {
    "application/json": Schemas.load$balancing_components$schemas$response_collection;
}
export interface Response$load$balancer$healthcheck$events$list$healthcheck$events$Status$4XX {
    "application/json": Schemas.load$balancing_components$schemas$response_collection & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$user$$s$organizations$list$organizations {
    name?: Schemas.mrUXABdt_schemas$name;
    page?: number;
    per_page?: number;
    order?: "id" | "name" | "status";
    direction?: "asc" | "desc";
    match?: "any" | "all";
    status?: "member" | "invited";
}
export interface Response$user$$s$organizations$list$organizations$Status$200 {
    "application/json": Schemas.mrUXABdt_collection_organization_response;
}
export interface Response$user$$s$organizations$list$organizations$Status$4XX {
    "application/json": Schemas.mrUXABdt_collection_organization_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$$s$organizations$organization$details {
    identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface Response$user$$s$organizations$organization$details$Status$200 {
    "application/json": Schemas.mrUXABdt_single_organization_response;
}
export interface Response$user$$s$organizations$organization$details$Status$4XX {
    "application/json": Schemas.mrUXABdt_single_organization_response & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$$s$organizations$leave$organization {
    identifier: Schemas.mrUXABdt_common_components$schemas$identifier;
}
export interface Response$user$$s$organizations$leave$organization$Status$200 {
    "application/json": {
        id?: Schemas.mrUXABdt_common_components$schemas$identifier;
    };
}
export interface Response$user$$s$organizations$leave$organization$Status$4XX {
    "application/json": {
        id?: Schemas.mrUXABdt_common_components$schemas$identifier;
    } & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Response$user$subscription$get$user$subscriptions$Status$200 {
    "application/json": Schemas.bill$subs$api_user_subscription_response_collection;
}
export interface Response$user$subscription$get$user$subscriptions$Status$4XX {
    "application/json": Schemas.bill$subs$api_user_subscription_response_collection & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$user$subscription$update$user$subscription {
    identifier: Schemas.bill$subs$api_schemas$identifier;
}
export interface RequestBody$user$subscription$update$user$subscription {
    "application/json": Schemas.bill$subs$api_subscription$v2;
}
export interface Response$user$subscription$update$user$subscription$Status$200 {
    "application/json": Schemas.bill$subs$api_user_subscription_response_single;
}
export interface Response$user$subscription$update$user$subscription$Status$4XX {
    "application/json": Schemas.bill$subs$api_user_subscription_response_single & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$user$subscription$delete$user$subscription {
    identifier: Schemas.bill$subs$api_schemas$identifier;
}
export interface Response$user$subscription$delete$user$subscription$Status$200 {
    "application/json": {
        subscription_id?: Schemas.bill$subs$api_schemas$identifier;
    };
}
export interface Response$user$subscription$delete$user$subscription$Status$4XX {
    "application/json": {
        subscription_id?: Schemas.bill$subs$api_schemas$identifier;
    } & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$user$api$tokens$list$tokens {
    page?: number;
    per_page?: number;
    direction?: "asc" | "desc";
}
export interface Response$user$api$tokens$list$tokens$Status$200 {
    "application/json": Schemas.mrUXABdt_response_collection;
}
export interface Response$user$api$tokens$list$tokens$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_collection & Schemas.mrUXABdt_api$response$common$failure;
}
export interface RequestBody$user$api$tokens$create$token {
    "application/json": Schemas.mrUXABdt_create_payload;
}
export interface Response$user$api$tokens$create$token$Status$200 {
    "application/json": Schemas.mrUXABdt_response_create;
}
export interface Response$user$api$tokens$create$token$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_create & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$api$tokens$token$details {
    identifier: Schemas.mrUXABdt_schemas$identifier;
}
export interface Response$user$api$tokens$token$details$Status$200 {
    "application/json": Schemas.mrUXABdt_response_single;
}
export interface Response$user$api$tokens$token$details$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_single & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$api$tokens$update$token {
    identifier: Schemas.mrUXABdt_schemas$identifier;
}
export interface RequestBody$user$api$tokens$update$token {
    "application/json": Schemas.mrUXABdt_schemas$token;
}
export interface Response$user$api$tokens$update$token$Status$200 {
    "application/json": Schemas.mrUXABdt_response_single;
}
export interface Response$user$api$tokens$update$token$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_single & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$api$tokens$delete$token {
    identifier: Schemas.mrUXABdt_schemas$identifier;
}
export interface Response$user$api$tokens$delete$token$Status$200 {
    "application/json": Schemas.mrUXABdt_api$response$single$id;
}
export interface Response$user$api$tokens$delete$token$Status$4XX {
    "application/json": Schemas.mrUXABdt_api$response$single$id & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$user$api$tokens$roll$token {
    identifier: Schemas.mrUXABdt_schemas$identifier;
}
export interface RequestBody$user$api$tokens$roll$token {
    "application/json": {};
}
export interface Response$user$api$tokens$roll$token$Status$200 {
    "application/json": Schemas.mrUXABdt_response_single_value;
}
export interface Response$user$api$tokens$roll$token$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_single_value & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Response$permission$groups$list$permission$groups$Status$200 {
    "application/json": Schemas.mrUXABdt_schemas$response_collection;
}
export interface Response$permission$groups$list$permission$groups$Status$4XX {
    "application/json": Schemas.mrUXABdt_schemas$response_collection & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Response$user$api$tokens$verify$token$Status$200 {
    "application/json": Schemas.mrUXABdt_response_single_segment;
}
export interface Response$user$api$tokens$verify$token$Status$4XX {
    "application/json": Schemas.mrUXABdt_response_single_segment & Schemas.mrUXABdt_api$response$common$failure;
}
export interface Parameter$zones$get {
    name?: string;
    status?: "initializing" | "pending" | "active" | "moved";
    "account.id"?: string;
    "account.name"?: string;
    page?: number;
    per_page?: number;
    order?: "name" | "status" | "account.id" | "account.name";
    direction?: "asc" | "desc";
    match?: "any" | "all";
}
export interface Response$zones$get$Status$200 {
    "application/json": Schemas.zones_api$response$common & {
        result_info?: Schemas.zones_result_info;
    } & {
        result?: Schemas.zones_zone[];
    };
}
export interface Response$zones$get$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface RequestBody$zones$post {
    "application/json": {
        account: {
            id?: Schemas.zones_identifier;
        };
        name: Schemas.zones_name;
        type?: Schemas.zones_type;
    };
}
export interface Response$zones$post$Status$200 {
    "application/json": Schemas.zones_api$response$common & {
        result?: Schemas.zones_zone;
    };
}
export interface Response$zones$post$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$level$access$applications$list$access$applications {
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$applications$list$access$applications$Status$200 {
    "application/json": Schemas.access_apps_components$schemas$response_collection$2;
}
export interface Response$zone$level$access$applications$list$access$applications$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$applications$add$a$bookmark$application {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$applications$add$a$bookmark$application {
    "application/json": Schemas.access_schemas$apps;
}
export interface Response$zone$level$access$applications$add$a$bookmark$application$Status$201 {
    "application/json": Schemas.access_apps_components$schemas$single_response$2 & {
        result?: Schemas.access_schemas$apps;
    };
}
export interface Response$zone$level$access$applications$add$a$bookmark$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$applications$get$an$access$application {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$applications$get$an$access$application$Status$200 {
    "application/json": Schemas.access_apps_components$schemas$single_response$2;
}
export interface Response$zone$level$access$applications$get$an$access$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$applications$update$a$bookmark$application {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$applications$update$a$bookmark$application {
    "application/json": Schemas.access_schemas$apps;
}
export interface Response$zone$level$access$applications$update$a$bookmark$application$Status$200 {
    "application/json": Schemas.access_apps_components$schemas$single_response$2 & {
        result?: Schemas.access_schemas$apps;
    };
}
export interface Response$zone$level$access$applications$update$a$bookmark$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$applications$delete$an$access$application {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$applications$delete$an$access$application$Status$202 {
    "application/json": Schemas.access_id_response;
}
export interface Response$zone$level$access$applications$delete$an$access$application$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$applications$revoke$service$tokens {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$applications$revoke$service$tokens$Status$202 {
    "application/json": Schemas.access_schemas$empty_response;
}
export interface Response$zone$level$access$applications$revoke$service$tokens$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$applications$test$access$policies {
    app_id: Schemas.access_app_id;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$applications$test$access$policies$Status$200 {
    "application/json": Schemas.access_policy_check_response;
}
export interface Response$zone$level$access$applications$test$access$policies$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$200 {
    "application/json": Schemas.access_ca_components$schemas$single_response;
}
export interface Response$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$200 {
    "application/json": Schemas.access_ca_components$schemas$single_response;
}
export interface Response$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$202 {
    "application/json": Schemas.access_schemas$id_response;
}
export interface Response$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$policies$list$access$policies {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$policies$list$access$policies$Status$200 {
    "application/json": Schemas.access_policies_components$schemas$response_collection$2;
}
export interface Response$zone$level$access$policies$list$access$policies$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$policies$create$an$access$policy {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$policies$create$an$access$policy {
    "application/json": {
        approval_groups?: Schemas.access_approval_groups;
        approval_required?: Schemas.access_approval_required;
        decision: Schemas.access_decision;
        exclude?: Schemas.access_schemas$exclude;
        include: Schemas.access_include;
        isolation_required?: Schemas.access_schemas$isolation_required;
        name: Schemas.access_policies_components$schemas$name;
        precedence?: Schemas.access_precedence;
        purpose_justification_prompt?: Schemas.access_purpose_justification_prompt;
        purpose_justification_required?: Schemas.access_purpose_justification_required;
        require?: Schemas.access_schemas$require;
    };
}
export interface Response$zone$level$access$policies$create$an$access$policy$Status$201 {
    "application/json": Schemas.access_policies_components$schemas$single_response$2;
}
export interface Response$zone$level$access$policies$create$an$access$policy$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$policies$get$an$access$policy {
    uuid: Schemas.access_uuid;
    uuid1: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$policies$get$an$access$policy$Status$200 {
    "application/json": Schemas.access_policies_components$schemas$single_response$2;
}
export interface Response$zone$level$access$policies$get$an$access$policy$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$policies$update$an$access$policy {
    uuid: Schemas.access_uuid;
    uuid1: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$policies$update$an$access$policy {
    "application/json": {
        approval_groups?: Schemas.access_approval_groups;
        approval_required?: Schemas.access_approval_required;
        decision: Schemas.access_decision;
        exclude?: Schemas.access_schemas$exclude;
        include: Schemas.access_include;
        isolation_required?: Schemas.access_schemas$isolation_required;
        name: Schemas.access_policies_components$schemas$name;
        precedence?: Schemas.access_precedence;
        purpose_justification_prompt?: Schemas.access_purpose_justification_prompt;
        purpose_justification_required?: Schemas.access_purpose_justification_required;
        require?: Schemas.access_schemas$require;
    };
}
export interface Response$zone$level$access$policies$update$an$access$policy$Status$200 {
    "application/json": Schemas.access_policies_components$schemas$single_response$2;
}
export interface Response$zone$level$access$policies$update$an$access$policy$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$policies$delete$an$access$policy {
    uuid: Schemas.access_uuid;
    uuid1: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$policies$delete$an$access$policy$Status$202 {
    "application/json": Schemas.access_id_response;
}
export interface Response$zone$level$access$policies$delete$an$access$policy$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as {
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$200 {
    "application/json": Schemas.access_ca_components$schemas$response_collection;
}
export interface Response$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$mtls$authentication$list$mtls$certificates {
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$mtls$authentication$list$mtls$certificates$Status$200 {
    "application/json": Schemas.access_certificates_components$schemas$response_collection;
}
export interface Response$zone$level$access$mtls$authentication$list$mtls$certificates$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$mtls$authentication$add$an$mtls$certificate {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$mtls$authentication$add$an$mtls$certificate {
    "application/json": {
        associated_hostnames?: Schemas.access_associated_hostnames;
        /** The certificate content. */
        certificate: string;
        name: Schemas.access_certificates_components$schemas$name;
    };
}
export interface Response$zone$level$access$mtls$authentication$add$an$mtls$certificate$Status$201 {
    "application/json": Schemas.access_certificates_components$schemas$single_response;
}
export interface Response$zone$level$access$mtls$authentication$add$an$mtls$certificate$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$mtls$authentication$get$an$mtls$certificate {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$mtls$authentication$get$an$mtls$certificate$Status$200 {
    "application/json": Schemas.access_certificates_components$schemas$single_response;
}
export interface Response$zone$level$access$mtls$authentication$get$an$mtls$certificate$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$mtls$authentication$update$an$mtls$certificate {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$mtls$authentication$update$an$mtls$certificate {
    "application/json": {
        associated_hostnames: Schemas.access_associated_hostnames;
        name?: Schemas.access_certificates_components$schemas$name;
    };
}
export interface Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$Status$200 {
    "application/json": Schemas.access_certificates_components$schemas$single_response;
}
export interface Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$mtls$authentication$delete$an$mtls$certificate {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$mtls$authentication$delete$an$mtls$certificate$Status$200 {
    "application/json": Schemas.access_components$schemas$id_response;
}
export interface Response$zone$level$access$mtls$authentication$delete$an$mtls$certificate$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings {
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$200 {
    "application/json": Schemas.access_response_collection_hostnames;
}
export interface Response$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings {
    "application/json": {
        settings: Schemas.access_settings[];
    };
}
export interface Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings$Status$202 {
    "application/json": Schemas.access_response_collection_hostnames;
}
export interface Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$groups$list$access$groups {
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$groups$list$access$groups$Status$200 {
    "application/json": Schemas.access_groups_components$schemas$response_collection;
}
export interface Response$zone$level$access$groups$list$access$groups$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$groups$create$an$access$group {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$groups$create$an$access$group {
    "application/json": {
        exclude?: Schemas.access_exclude;
        include: Schemas.access_include;
        name: Schemas.access_components$schemas$name;
        require?: Schemas.access_require;
    };
}
export interface Response$zone$level$access$groups$create$an$access$group$Status$201 {
    "application/json": Schemas.access_groups_components$schemas$single_response;
}
export interface Response$zone$level$access$groups$create$an$access$group$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$groups$get$an$access$group {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$groups$get$an$access$group$Status$200 {
    "application/json": Schemas.access_groups_components$schemas$single_response;
}
export interface Response$zone$level$access$groups$get$an$access$group$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$groups$update$an$access$group {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$groups$update$an$access$group {
    "application/json": {
        exclude?: Schemas.access_exclude;
        include: Schemas.access_include;
        name: Schemas.access_components$schemas$name;
        require?: Schemas.access_require;
    };
}
export interface Response$zone$level$access$groups$update$an$access$group$Status$200 {
    "application/json": Schemas.access_groups_components$schemas$single_response;
}
export interface Response$zone$level$access$groups$update$an$access$group$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$groups$delete$an$access$group {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$groups$delete$an$access$group$Status$202 {
    "application/json": Schemas.access_id_response;
}
export interface Response$zone$level$access$groups$delete$an$access$group$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$identity$providers$list$access$identity$providers {
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$identity$providers$list$access$identity$providers$Status$200 {
    "application/json": Schemas.access_identity$providers_components$schemas$response_collection;
}
export interface Response$zone$level$access$identity$providers$list$access$identity$providers$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$identity$providers$add$an$access$identity$provider {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$identity$providers$add$an$access$identity$provider {
    "application/json": Schemas.access_schemas$identity$providers;
}
export interface Response$zone$level$access$identity$providers$add$an$access$identity$provider$Status$201 {
    "application/json": Schemas.access_identity$providers_components$schemas$single_response;
}
export interface Response$zone$level$access$identity$providers$add$an$access$identity$provider$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$identity$providers$get$an$access$identity$provider {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$identity$providers$get$an$access$identity$provider$Status$200 {
    "application/json": Schemas.access_identity$providers_components$schemas$single_response;
}
export interface Response$zone$level$access$identity$providers$get$an$access$identity$provider$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$identity$providers$update$an$access$identity$provider {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$identity$providers$update$an$access$identity$provider {
    "application/json": Schemas.access_schemas$identity$providers;
}
export interface Response$zone$level$access$identity$providers$update$an$access$identity$provider$Status$200 {
    "application/json": Schemas.access_identity$providers_components$schemas$single_response;
}
export interface Response$zone$level$access$identity$providers$update$an$access$identity$provider$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$identity$providers$delete$an$access$identity$provider {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$identity$providers$delete$an$access$identity$provider$Status$202 {
    "application/json": Schemas.access_id_response;
}
export interface Response$zone$level$access$identity$providers$delete$an$access$identity$provider$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$zero$trust$organization$get$your$zero$trust$organization {
    identifier: Schemas.access_schemas$identifier;
}
export interface Response$zone$level$zero$trust$organization$get$your$zero$trust$organization$Status$200 {
    "application/json": Schemas.access_organizations_components$schemas$single_response;
}
export interface Response$zone$level$zero$trust$organization$get$your$zero$trust$organization$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$zero$trust$organization$update$your$zero$trust$organization {
    identifier: Schemas.access_schemas$identifier;
}
export interface RequestBody$zone$level$zero$trust$organization$update$your$zero$trust$organization {
    "application/json": {
        auth_domain?: Schemas.access_auth_domain;
        is_ui_read_only?: Schemas.access_is_ui_read_only;
        login_design?: Schemas.access_login_design;
        name?: Schemas.access_name;
        ui_read_only_toggle_reason?: Schemas.access_ui_read_only_toggle_reason;
        user_seat_expiration_inactive_time?: Schemas.access_user_seat_expiration_inactive_time;
    };
}
export interface Response$zone$level$zero$trust$organization$update$your$zero$trust$organization$Status$200 {
    "application/json": Schemas.access_organizations_components$schemas$single_response;
}
export interface Response$zone$level$zero$trust$organization$update$your$zero$trust$organization$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$zero$trust$organization$create$your$zero$trust$organization {
    identifier: Schemas.access_schemas$identifier;
}
export interface RequestBody$zone$level$zero$trust$organization$create$your$zero$trust$organization {
    "application/json": {
        auth_domain: Schemas.access_auth_domain;
        is_ui_read_only?: Schemas.access_is_ui_read_only;
        login_design?: Schemas.access_login_design;
        name: Schemas.access_name;
        ui_read_only_toggle_reason?: Schemas.access_ui_read_only_toggle_reason;
        user_seat_expiration_inactive_time?: Schemas.access_user_seat_expiration_inactive_time;
    };
}
export interface Response$zone$level$zero$trust$organization$create$your$zero$trust$organization$Status$201 {
    "application/json": Schemas.access_organizations_components$schemas$single_response;
}
export interface Response$zone$level$zero$trust$organization$create$your$zero$trust$organization$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user {
    identifier: Schemas.access_schemas$identifier;
}
export interface RequestBody$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user {
    "application/json": {
        /** The email of the user to revoke. */
        email: string;
    };
}
export interface Response$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$200 {
    "application/json": Schemas.access_empty_response;
}
export interface Response$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$4xx {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$service$tokens$list$service$tokens {
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$service$tokens$list$service$tokens$Status$200 {
    "application/json": Schemas.access_components$schemas$response_collection;
}
export interface Response$zone$level$access$service$tokens$list$service$tokens$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$service$tokens$create$a$service$token {
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$service$tokens$create$a$service$token {
    "application/json": {
        duration?: Schemas.access_duration;
        name: Schemas.access_service$tokens_components$schemas$name;
    };
}
export interface Response$zone$level$access$service$tokens$create$a$service$token$Status$201 {
    "application/json": Schemas.access_create_response;
}
export interface Response$zone$level$access$service$tokens$create$a$service$token$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$service$tokens$update$a$service$token {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface RequestBody$zone$level$access$service$tokens$update$a$service$token {
    "application/json": {
        duration?: Schemas.access_duration;
        name?: Schemas.access_service$tokens_components$schemas$name;
    };
}
export interface Response$zone$level$access$service$tokens$update$a$service$token$Status$200 {
    "application/json": Schemas.access_service$tokens_components$schemas$single_response;
}
export interface Response$zone$level$access$service$tokens$update$a$service$token$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$zone$level$access$service$tokens$delete$a$service$token {
    uuid: Schemas.access_uuid;
    identifier: Schemas.access_identifier;
}
export interface Response$zone$level$access$service$tokens$delete$a$service$token$Status$200 {
    "application/json": Schemas.access_service$tokens_components$schemas$single_response;
}
export interface Response$zone$level$access$service$tokens$delete$a$service$token$Status$4XX {
    "application/json": Schemas.access_api$response$common$failure;
}
export interface Parameter$dns$analytics$table {
    identifier: Schemas.erIwb89A_identifier;
    metrics?: Schemas.erIwb89A_metrics;
    dimensions?: Schemas.erIwb89A_dimensions;
    since?: Schemas.erIwb89A_since;
    until?: Schemas.erIwb89A_until;
    limit?: Schemas.erIwb89A_limit;
    sort?: Schemas.erIwb89A_sort;
    filters?: Schemas.erIwb89A_filters;
}
export interface Response$dns$analytics$table$Status$200 {
    "application/json": Schemas.erIwb89A_api$response$single & {
        result?: Schemas.erIwb89A_report;
    };
}
export interface Response$dns$analytics$table$Status$4XX {
    "application/json": (Schemas.erIwb89A_api$response$single & {
        result?: Schemas.erIwb89A_report;
    }) & Schemas.erIwb89A_api$response$common$failure;
}
export interface Parameter$dns$analytics$by$time {
    identifier: Schemas.erIwb89A_identifier;
    metrics?: Schemas.erIwb89A_metrics;
    dimensions?: Schemas.erIwb89A_dimensions;
    since?: Schemas.erIwb89A_since;
    until?: Schemas.erIwb89A_until;
    limit?: Schemas.erIwb89A_limit;
    sort?: Schemas.erIwb89A_sort;
    filters?: Schemas.erIwb89A_filters;
    time_delta?: Schemas.erIwb89A_time_delta;
}
export interface Response$dns$analytics$by$time$Status$200 {
    "application/json": Schemas.erIwb89A_api$response$single & {
        result?: Schemas.erIwb89A_report_bytime;
    };
}
export interface Response$dns$analytics$by$time$Status$4XX {
    "application/json": (Schemas.erIwb89A_api$response$single & {
        result?: Schemas.erIwb89A_report_bytime;
    }) & Schemas.erIwb89A_api$response$common$failure;
}
export interface Parameter$load$balancers$list$load$balancers {
    identifier: Schemas.load$balancing_load$balancer_components$schemas$identifier;
}
export interface Response$load$balancers$list$load$balancers$Status$200 {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$response_collection;
}
export interface Response$load$balancers$list$load$balancers$Status$4XX {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$response_collection & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancers$create$load$balancer {
    identifier: Schemas.load$balancing_load$balancer_components$schemas$identifier;
}
export interface RequestBody$load$balancers$create$load$balancer {
    "application/json": {
        adaptive_routing?: Schemas.load$balancing_adaptive_routing;
        country_pools?: Schemas.load$balancing_country_pools;
        default_pools: Schemas.load$balancing_default_pools;
        description?: Schemas.load$balancing_components$schemas$description;
        fallback_pool: Schemas.load$balancing_fallback_pool;
        location_strategy?: Schemas.load$balancing_location_strategy;
        name: Schemas.load$balancing_components$schemas$name;
        pop_pools?: Schemas.load$balancing_pop_pools;
        proxied?: Schemas.load$balancing_proxied;
        random_steering?: Schemas.load$balancing_random_steering;
        region_pools?: Schemas.load$balancing_region_pools;
        rules?: Schemas.load$balancing_rules;
        session_affinity?: Schemas.load$balancing_session_affinity;
        session_affinity_attributes?: Schemas.load$balancing_session_affinity_attributes;
        session_affinity_ttl?: Schemas.load$balancing_session_affinity_ttl;
        steering_policy?: Schemas.load$balancing_steering_policy;
        ttl?: Schemas.load$balancing_ttl;
    };
}
export interface Response$load$balancers$create$load$balancer$Status$200 {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$single_response;
}
export interface Response$load$balancers$create$load$balancer$Status$4XX {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$zone$purge {
    identifier: Schemas.GRP4pb9k_identifier;
}
export interface RequestBody$zone$purge {
    "application/json": Schemas.GRP4pb9k_Flex | Schemas.GRP4pb9k_Everything | Schemas.GRP4pb9k_Files;
}
export interface Response$zone$purge$Status$200 {
    "application/json": Schemas.GRP4pb9k_api$response$single$id;
}
export interface Response$zone$purge$Status$4xx {
    "application/json": Schemas.GRP4pb9k_api$response$single$id & Schemas.GRP4pb9k_api$response$common$failure;
}
export interface Parameter$analyze$certificate$analyze$certificate {
    identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$analyze$certificate$analyze$certificate {
    "application/json": {
        bundle_method?: Schemas.ApQU2qAj_bundle_method;
        certificate?: Schemas.ApQU2qAj_certificate;
    };
}
export interface Response$analyze$certificate$analyze$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_analyze_response;
}
export interface Response$analyze$certificate$analyze$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_analyze_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$zone$subscription$zone$subscription$details {
    identifier: Schemas.bill$subs$api_schemas$identifier;
}
export interface Response$zone$subscription$zone$subscription$details$Status$200 {
    "application/json": Schemas.bill$subs$api_zone_subscription_response_single;
}
export interface Response$zone$subscription$zone$subscription$details$Status$4XX {
    "application/json": Schemas.bill$subs$api_zone_subscription_response_single & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$zone$subscription$update$zone$subscription {
    identifier: Schemas.bill$subs$api_schemas$identifier;
}
export interface RequestBody$zone$subscription$update$zone$subscription {
    "application/json": Schemas.bill$subs$api_subscription$v2;
}
export interface Response$zone$subscription$update$zone$subscription$Status$200 {
    "application/json": Schemas.bill$subs$api_zone_subscription_response_single;
}
export interface Response$zone$subscription$update$zone$subscription$Status$4XX {
    "application/json": Schemas.bill$subs$api_zone_subscription_response_single & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$zone$subscription$create$zone$subscription {
    identifier: Schemas.bill$subs$api_schemas$identifier;
}
export interface RequestBody$zone$subscription$create$zone$subscription {
    "application/json": Schemas.bill$subs$api_subscription$v2;
}
export interface Response$zone$subscription$create$zone$subscription$Status$200 {
    "application/json": Schemas.bill$subs$api_zone_subscription_response_single;
}
export interface Response$zone$subscription$create$zone$subscription$Status$4XX {
    "application/json": Schemas.bill$subs$api_zone_subscription_response_single & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$load$balancers$load$balancer$details {
    identifier: Schemas.load$balancing_load$balancer_components$schemas$identifier;
    identifier1: Schemas.load$balancing_load$balancer_components$schemas$identifier;
}
export interface Response$load$balancers$load$balancer$details$Status$200 {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$single_response;
}
export interface Response$load$balancers$load$balancer$details$Status$4XX {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancers$update$load$balancer {
    identifier: Schemas.load$balancing_load$balancer_components$schemas$identifier;
    identifier1: Schemas.load$balancing_load$balancer_components$schemas$identifier;
}
export interface RequestBody$load$balancers$update$load$balancer {
    "application/json": {
        adaptive_routing?: Schemas.load$balancing_adaptive_routing;
        country_pools?: Schemas.load$balancing_country_pools;
        default_pools: Schemas.load$balancing_default_pools;
        description?: Schemas.load$balancing_components$schemas$description;
        enabled?: Schemas.load$balancing_components$schemas$enabled;
        fallback_pool: Schemas.load$balancing_fallback_pool;
        location_strategy?: Schemas.load$balancing_location_strategy;
        name: Schemas.load$balancing_components$schemas$name;
        pop_pools?: Schemas.load$balancing_pop_pools;
        proxied?: Schemas.load$balancing_proxied;
        random_steering?: Schemas.load$balancing_random_steering;
        region_pools?: Schemas.load$balancing_region_pools;
        rules?: Schemas.load$balancing_rules;
        session_affinity?: Schemas.load$balancing_session_affinity;
        session_affinity_attributes?: Schemas.load$balancing_session_affinity_attributes;
        session_affinity_ttl?: Schemas.load$balancing_session_affinity_ttl;
        steering_policy?: Schemas.load$balancing_steering_policy;
        ttl?: Schemas.load$balancing_ttl;
    };
}
export interface Response$load$balancers$update$load$balancer$Status$200 {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$single_response;
}
export interface Response$load$balancers$update$load$balancer$Status$4XX {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancers$delete$load$balancer {
    identifier: Schemas.load$balancing_load$balancer_components$schemas$identifier;
    identifier1: Schemas.load$balancing_load$balancer_components$schemas$identifier;
}
export interface Response$load$balancers$delete$load$balancer$Status$200 {
    "application/json": Schemas.load$balancing_components$schemas$id_response;
}
export interface Response$load$balancers$delete$load$balancer$Status$4XX {
    "application/json": Schemas.load$balancing_components$schemas$id_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$load$balancers$patch$load$balancer {
    identifier: Schemas.load$balancing_load$balancer_components$schemas$identifier;
    identifier1: Schemas.load$balancing_load$balancer_components$schemas$identifier;
}
export interface RequestBody$load$balancers$patch$load$balancer {
    "application/json": {
        adaptive_routing?: Schemas.load$balancing_adaptive_routing;
        country_pools?: Schemas.load$balancing_country_pools;
        default_pools?: Schemas.load$balancing_default_pools;
        description?: Schemas.load$balancing_components$schemas$description;
        enabled?: Schemas.load$balancing_components$schemas$enabled;
        fallback_pool?: Schemas.load$balancing_fallback_pool;
        location_strategy?: Schemas.load$balancing_location_strategy;
        name?: Schemas.load$balancing_components$schemas$name;
        pop_pools?: Schemas.load$balancing_pop_pools;
        proxied?: Schemas.load$balancing_proxied;
        random_steering?: Schemas.load$balancing_random_steering;
        region_pools?: Schemas.load$balancing_region_pools;
        rules?: Schemas.load$balancing_rules;
        session_affinity?: Schemas.load$balancing_session_affinity;
        session_affinity_attributes?: Schemas.load$balancing_session_affinity_attributes;
        session_affinity_ttl?: Schemas.load$balancing_session_affinity_ttl;
        steering_policy?: Schemas.load$balancing_steering_policy;
        ttl?: Schemas.load$balancing_ttl;
    };
}
export interface Response$load$balancers$patch$load$balancer$Status$200 {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$single_response;
}
export interface Response$load$balancers$patch$load$balancer$Status$4XX {
    "application/json": Schemas.load$balancing_load$balancer_components$schemas$single_response & Schemas.load$balancing_api$response$common$failure;
}
export interface Parameter$zones$0$get {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zones$0$get$Status$200 {
    "application/json": Schemas.zones_api$response$common & {
        result?: Schemas.zones_zone;
    };
}
export interface Response$zones$0$get$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zones$0$delete {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zones$0$delete$Status$200 {
    "application/json": Schemas.zones_api$response$single$id;
}
export interface Response$zones$0$delete$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zones$0$patch {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zones$0$patch {
    "application/json": {
        paused?: Schemas.zones_paused;
        /**
         * (Deprecated) Please use the \`/zones/{zone_id}/subscription\` API
         * to update a zone's plan. Changing this value will create/cancel
         * associated subscriptions. To view available plans for this zone,
         * see Zone Plans.
         */
        plan?: {
            id?: Schemas.zones_identifier;
        };
        /**
         * A full zone implies that DNS is hosted with Cloudflare. A partial
         * zone is typically a partner-hosted zone or a CNAME setup. This
         * parameter is only available to Enterprise customers or if it has
         * been explicitly enabled on a zone.
         */
        type?: "full" | "partial" | "secondary";
        vanity_name_servers?: Schemas.zones_vanity_name_servers;
    };
}
export interface Response$zones$0$patch$Status$200 {
    "application/json": Schemas.zones_api$response$common & {
        result?: Schemas.zones_zone;
    };
}
export interface Response$zones$0$patch$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$put$zones$zone_id$activation_check {
    /** Zone ID */
    zone_id: Schemas.tt1FM6Ha_identifier;
}
export interface Response$put$zones$zone_id$activation_check$Status$200 {
    "application/json": Schemas.tt1FM6Ha_api$response$single & {
        result?: {
            id?: Schemas.tt1FM6Ha_identifier;
        };
    };
}
export interface Response$put$zones$zone_id$activation_check$Status$4XX {
    "application/json": Schemas.tt1FM6Ha_api$response$common$failure;
}
export interface Parameter$argo$analytics$for$zone$argo$analytics$for$a$zone {
    zone_id: Schemas.argo$analytics_identifier;
    bins?: string;
}
export interface Response$argo$analytics$for$zone$argo$analytics$for$a$zone$Status$200 {
    "application/json": Schemas.argo$analytics_response_single;
}
export interface Response$argo$analytics$for$zone$argo$analytics$for$a$zone$Status$4XX {
    "application/json": Schemas.argo$analytics_response_single & Schemas.argo$analytics_api$response$common$failure;
}
export interface Parameter$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps {
    zone_id: Schemas.argo$analytics_identifier;
}
export interface Response$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps$Status$200 {
    "application/json": Schemas.argo$analytics_response_single;
}
export interface Response$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps$Status$4XX {
    "application/json": Schemas.argo$analytics_response_single & Schemas.argo$analytics_api$response$common$failure;
}
export interface Parameter$api$shield$settings$retrieve$information$about$specific$configuration$properties {
    zone_id: Parameters.api$shield_zone_id;
    properties?: Schemas.api$shield_properties;
}
export interface Response$api$shield$settings$retrieve$information$about$specific$configuration$properties$Status$200 {
    "application/json": Schemas.api$shield_single_response;
}
export interface Response$api$shield$settings$retrieve$information$about$specific$configuration$properties$Status$4XX {
    "application/json": Schemas.api$shield_single_response & Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$settings$set$configuration$properties {
    zone_id: Parameters.api$shield_zone_id;
}
export interface RequestBody$api$shield$settings$set$configuration$properties {
    "application/json": Schemas.api$shield_configuration;
}
export interface Response$api$shield$settings$set$configuration$properties$Status$200 {
    "application/json": Schemas.api$shield_default_response;
}
export interface Response$api$shield$settings$set$configuration$properties$Status$4XX {
    "application/json": Schemas.api$shield_default_response & Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi {
    zone_id: Parameters.api$shield_zone_id;
}
export interface Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi$Status$200 {
    "application/json": Schemas.api$shield_schema_response_discovery;
}
export interface Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi$Status$4XX {
    "application/json": Schemas.api$shield_schema_response_discovery & Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone {
    zone_id: Parameters.api$shield_zone_id;
    /** Page number of paginated results. */
    page?: Parameters.api$shield_page;
    /** Maximum number of results per page. */
    per_page?: Parameters.api$shield_per_page;
    host?: Parameters.api$shield_host_parameter;
    method?: Parameters.api$shield_method_parameter;
    endpoint?: Parameters.api$shield_endpoint_parameter;
    direction?: Parameters.api$shield_direction_parameter;
    order?: Parameters.api$shield_order_parameter;
    diff?: Parameters.api$shield_diff_parameter;
    /**
     * Filter results to only include discovery results sourced from a particular discovery engine
     *   * \`ML\` - Discovered operations that were sourced using ML API Discovery
     *   * \`SessionIdentifier\` - Discovered operations that were sourced using Session Identifier API Discovery
     */
    origin?: Parameters.api$shield_api_discovery_origin_parameter;
    /**
     * Filter results to only include discovery results in a particular state. States are as follows
     *   * \`review\` - Discovered operations that are not saved into API Shield Endpoint Management
     *   * \`saved\` - Discovered operations that are already saved into API Shield Endpoint Management
     *   * \`ignored\` - Discovered operations that have been marked as ignored
     */
    state?: Parameters.api$shield_api_discovery_state_parameter;
}
export interface Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$Status$200 {
    "application/json": Schemas.api$shield_api$response$collection & {
        result?: (Schemas.api$shield_discovery_operation)[];
    };
}
export interface Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$api$patch$discovered$operations {
    zone_id: Parameters.api$shield_zone_id;
}
export interface RequestBody$api$shield$api$patch$discovered$operations {
    "application/json": Schemas.api$shield_api_discovery_patch_multiple_request;
}
export interface Response$api$shield$api$patch$discovered$operations$Status$200 {
    "application/json": Schemas.api$shield_patch_discoveries_response;
}
export interface Response$api$shield$api$patch$discovered$operations$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$api$patch$discovered$operation {
    zone_id: Parameters.api$shield_zone_id;
    /** Identifier for the discovered operation */
    operation_id: Parameters.api$shield_parameters$operation_id;
}
export interface RequestBody$api$shield$api$patch$discovered$operation {
    "application/json": {
        state?: Schemas.api$shield_api_discovery_state_patch;
    };
}
export interface Response$api$shield$api$patch$discovered$operation$Status$200 {
    "application/json": Schemas.api$shield_patch_discovery_response;
}
export interface Response$api$shield$api$patch$discovered$operation$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone {
    zone_id: Parameters.api$shield_zone_id;
    /** Page number of paginated results. */
    page?: Parameters.api$shield_page;
    /** Number of results to return per page */
    per_page?: number;
    order?: "method" | "host" | "endpoint" | "thresholds.$key";
    direction?: Parameters.api$shield_direction_parameter;
    host?: Parameters.api$shield_host_parameter;
    method?: Parameters.api$shield_method_parameter;
    endpoint?: Parameters.api$shield_endpoint_parameter;
    /** Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning. */
    feature?: Parameters.api$shield_operation_feature_parameter;
}
export interface Response$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone$Status$200 {
    "application/json": Schemas.api$shield_collection_response_paginated;
}
export interface Response$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$endpoint$management$add$operations$to$a$zone {
    zone_id: Parameters.api$shield_zone_id;
}
export interface RequestBody$api$shield$endpoint$management$add$operations$to$a$zone {
    "application/json": Schemas.api$shield_basic_operation[];
}
export interface Response$api$shield$endpoint$management$add$operations$to$a$zone$Status$200 {
    "application/json": Schemas.api$shield_collection_response;
}
export interface Response$api$shield$endpoint$management$add$operations$to$a$zone$Status$4XX {
    "application/json": Schemas.api$shield_collection_response & Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$endpoint$management$retrieve$information$about$an$operation {
    zone_id: Parameters.api$shield_zone_id;
    /** Identifier for the operation */
    operation_id: Parameters.api$shield_operation_id;
    /** Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning. */
    feature?: Parameters.api$shield_operation_feature_parameter;
}
export interface Response$api$shield$endpoint$management$retrieve$information$about$an$operation$Status$200 {
    "application/json": Schemas.api$shield_schemas$single_response;
}
export interface Response$api$shield$endpoint$management$retrieve$information$about$an$operation$Status$4XX {
    "application/json": Schemas.api$shield_schemas$single_response & Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$endpoint$management$delete$an$operation {
    zone_id: Parameters.api$shield_zone_id;
    /** Identifier for the operation */
    operation_id: Parameters.api$shield_operation_id;
}
export interface Response$api$shield$endpoint$management$delete$an$operation$Status$200 {
    "application/json": Schemas.api$shield_default_response;
}
export interface Response$api$shield$endpoint$management$delete$an$operation$Status$4XX {
    "application/json": Schemas.api$shield_default_response & Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$retrieve$operation$level$settings {
    zone_id: Parameters.api$shield_zone_id;
    /** Identifier for the operation */
    operation_id: Parameters.api$shield_operation_id;
}
export interface Response$api$shield$schema$validation$retrieve$operation$level$settings$Status$200 {
    "application/json": Schemas.api$shield_operation_schema_validation_settings;
}
export interface Response$api$shield$schema$validation$retrieve$operation$level$settings$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$update$operation$level$settings {
    zone_id: Parameters.api$shield_zone_id;
    /** Identifier for the operation */
    operation_id: Parameters.api$shield_operation_id;
}
export interface RequestBody$api$shield$schema$validation$update$operation$level$settings {
    "application/json": Schemas.api$shield_operation_schema_validation_settings;
}
export interface Response$api$shield$schema$validation$update$operation$level$settings$Status$200 {
    "application/json": Schemas.api$shield_operation_schema_validation_settings;
}
export interface Response$api$shield$schema$validation$update$operation$level$settings$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$update$multiple$operation$level$settings {
    zone_id: Parameters.api$shield_zone_id;
}
export interface RequestBody$api$shield$schema$validation$update$multiple$operation$level$settings {
    "application/json": Schemas.api$shield_operation_schema_validation_settings_multiple_request;
}
export interface Response$api$shield$schema$validation$update$multiple$operation$level$settings$Status$200 {
    "application/json": Schemas.api$shield_api$response$single & {
        result?: Schemas.api$shield_operation_schema_validation_settings_multiple_request;
    };
}
export interface Response$api$shield$schema$validation$update$multiple$operation$level$settings$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas {
    zone_id: Parameters.api$shield_zone_id;
    host?: string[];
    /** Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning. */
    feature?: Parameters.api$shield_operation_feature_parameter;
}
export interface Response$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas$Status$200 {
    "application/json": Schemas.api$shield_schema_response_with_thresholds;
}
export interface Response$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas$Status$4XX {
    "application/json": Schemas.api$shield_schema_response_with_thresholds & Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$retrieve$zone$level$settings {
    zone_id: Parameters.api$shield_zone_id;
}
export interface Response$api$shield$schema$validation$retrieve$zone$level$settings$Status$200 {
    "application/json": Schemas.api$shield_zone_schema_validation_settings;
}
export interface Response$api$shield$schema$validation$retrieve$zone$level$settings$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$update$zone$level$settings {
    zone_id: Parameters.api$shield_zone_id;
}
export interface RequestBody$api$shield$schema$validation$update$zone$level$settings {
    "application/json": Schemas.api$shield_zone_schema_validation_settings_put;
}
export interface Response$api$shield$schema$validation$update$zone$level$settings$Status$200 {
    "application/json": Schemas.api$shield_zone_schema_validation_settings;
}
export interface Response$api$shield$schema$validation$update$zone$level$settings$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$patch$zone$level$settings {
    zone_id: Parameters.api$shield_zone_id;
}
export interface RequestBody$api$shield$schema$validation$patch$zone$level$settings {
    "application/json": Schemas.api$shield_zone_schema_validation_settings_patch;
}
export interface Response$api$shield$schema$validation$patch$zone$level$settings$Status$200 {
    "application/json": Schemas.api$shield_zone_schema_validation_settings;
}
export interface Response$api$shield$schema$validation$patch$zone$level$settings$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$retrieve$information$about$all$schemas {
    zone_id: Parameters.api$shield_zone_id;
    /** Page number of paginated results. */
    page?: Parameters.api$shield_page;
    /** Maximum number of results per page. */
    per_page?: Parameters.api$shield_per_page;
    /** Omit the source-files of schemas and only retrieve their meta-data. */
    omit_source?: Parameters.api$shield_omit_source;
    validation_enabled?: Schemas.api$shield_validation_enabled;
}
export interface Response$api$shield$schema$validation$retrieve$information$about$all$schemas$Status$200 {
    "application/json": Schemas.api$shield_api$response$collection & {
        result?: Schemas.api$shield_public_schema[];
    };
}
export interface Response$api$shield$schema$validation$retrieve$information$about$all$schemas$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$post$schema {
    zone_id: Parameters.api$shield_zone_id;
}
export interface RequestBody$api$shield$schema$validation$post$schema {
    "multipart/form-data": {
        /** Schema file bytes */
        file: Blob;
        kind: Schemas.api$shield_kind;
        /** Name of the schema */
        name?: string;
        /** Flag whether schema is enabled for validation. */
        validation_enabled?: "true" | "false";
    };
}
export interface Response$api$shield$schema$validation$post$schema$Status$200 {
    "application/json": Schemas.api$shield_api$response$single & {
        result?: Schemas.api$shield_schema_upload_response;
    };
}
export interface Response$api$shield$schema$validation$post$schema$Status$4XX {
    "application/json": Schemas.api$shield_schema_upload_failure;
}
export interface Parameter$api$shield$schema$validation$retrieve$information$about$specific$schema {
    zone_id: Parameters.api$shield_zone_id;
    /** Identifier for the schema-ID */
    schema_id: Parameters.api$shield_schema_id;
    /** Omit the source-files of schemas and only retrieve their meta-data. */
    omit_source?: Parameters.api$shield_omit_source;
}
export interface Response$api$shield$schema$validation$retrieve$information$about$specific$schema$Status$200 {
    "application/json": Schemas.api$shield_api$response$single & {
        result?: Schemas.api$shield_public_schema;
    };
}
export interface Response$api$shield$schema$validation$retrieve$information$about$specific$schema$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$delete$a$schema {
    zone_id: Parameters.api$shield_zone_id;
    /** Identifier for the schema-ID */
    schema_id: Parameters.api$shield_schema_id;
}
export interface Response$api$shield$schema$delete$a$schema$Status$200 {
    "application/json": Schemas.api$shield_api$response$single;
}
export interface Response$api$shield$schema$delete$a$schema$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$enable$validation$for$a$schema {
    zone_id: Parameters.api$shield_zone_id;
    /** Identifier for the schema-ID */
    schema_id: Parameters.api$shield_schema_id;
}
export interface RequestBody$api$shield$schema$validation$enable$validation$for$a$schema {
    "application/json": {
        validation_enabled?: Schemas.api$shield_validation_enabled & string;
    };
}
export interface Response$api$shield$schema$validation$enable$validation$for$a$schema$Status$200 {
    "application/json": Schemas.api$shield_api$response$single & {
        result?: Schemas.api$shield_public_schema;
    };
}
export interface Response$api$shield$schema$validation$enable$validation$for$a$schema$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$api$shield$schema$validation$extract$operations$from$schema {
    /** Identifier for the schema-ID */
    schema_id: Parameters.api$shield_schema_id;
    zone_id: Parameters.api$shield_zone_id;
    /** Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning. */
    feature?: Parameters.api$shield_operation_feature_parameter;
    host?: Parameters.api$shield_host_parameter;
    method?: Parameters.api$shield_method_parameter;
    endpoint?: Parameters.api$shield_endpoint_parameter;
    /** Page number of paginated results. */
    page?: Parameters.api$shield_page;
    /** Maximum number of results per page. */
    per_page?: Parameters.api$shield_per_page;
    /** Filter results by whether operations exist in API Shield Endpoint Management or not. \`new\` will just return operations from the schema that do not exist in API Shield Endpoint Management. \`existing\` will just return operations from the schema that already exist in API Shield Endpoint Management. */
    operation_status?: "new" | "existing";
}
export interface Response$api$shield$schema$validation$extract$operations$from$schema$Status$200 {
    "application/json": Schemas.api$shield_api$response$collection & {
        result?: (Schemas.api$shield_operation | Schemas.api$shield_basic_operation)[];
    };
}
export interface Response$api$shield$schema$validation$extract$operations$from$schema$Status$4XX {
    "application/json": Schemas.api$shield_api$response$common$failure;
}
export interface Parameter$argo$smart$routing$get$argo$smart$routing$setting {
    zone_id: Schemas.argo$config_identifier;
}
export interface Response$argo$smart$routing$get$argo$smart$routing$setting$Status$200 {
    "application/json": Schemas.argo$config_response_single;
}
export interface Response$argo$smart$routing$get$argo$smart$routing$setting$Status$4XX {
    "application/json": Schemas.argo$config_response_single & Schemas.argo$config_api$response$common$failure;
}
export interface Parameter$argo$smart$routing$patch$argo$smart$routing$setting {
    zone_id: Schemas.argo$config_identifier;
}
export interface RequestBody$argo$smart$routing$patch$argo$smart$routing$setting {
    "application/json": Schemas.argo$config_patch;
}
export interface Response$argo$smart$routing$patch$argo$smart$routing$setting$Status$200 {
    "application/json": Schemas.argo$config_response_single;
}
export interface Response$argo$smart$routing$patch$argo$smart$routing$setting$Status$4XX {
    "application/json": Schemas.argo$config_response_single & Schemas.argo$config_api$response$common$failure;
}
export interface Parameter$tiered$caching$get$tiered$caching$setting {
    zone_id: Schemas.cache_identifier;
}
export interface Response$tiered$caching$get$tiered$caching$setting$Status$200 {
    "application/json": Schemas.cache_response_single;
}
export interface Response$tiered$caching$get$tiered$caching$setting$Status$4XX {
    "application/json": Schemas.cache_response_single & Schemas.cache_api$response$common$failure;
}
export interface Parameter$tiered$caching$patch$tiered$caching$setting {
    zone_id: Schemas.cache_identifier;
}
export interface RequestBody$tiered$caching$patch$tiered$caching$setting {
    "application/json": Schemas.cache_patch;
}
export interface Response$tiered$caching$patch$tiered$caching$setting$Status$200 {
    "application/json": Schemas.cache_response_single;
}
export interface Response$tiered$caching$patch$tiered$caching$setting$Status$4XX {
    "application/json": Schemas.cache_response_single & Schemas.cache_api$response$common$failure;
}
export interface Parameter$bot$management$for$a$zone$get$config {
    zone_id: Schemas.bot$management_identifier;
}
export interface Response$bot$management$for$a$zone$get$config$Status$200 {
    "application/json": Schemas.bot$management_bot_management_response_body;
}
export interface Response$bot$management$for$a$zone$get$config$Status$4XX {
    "application/json": Schemas.bot$management_bot_management_response_body & Schemas.bot$management_api$response$common$failure;
}
export interface Parameter$bot$management$for$a$zone$update$config {
    zone_id: Schemas.bot$management_identifier;
}
export interface RequestBody$bot$management$for$a$zone$update$config {
    "application/json": Schemas.bot$management_config_single;
}
export interface Response$bot$management$for$a$zone$update$config$Status$200 {
    "application/json": Schemas.bot$management_bot_management_response_body;
}
export interface Response$bot$management$for$a$zone$update$config$Status$4XX {
    "application/json": Schemas.bot$management_bot_management_response_body & Schemas.bot$management_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$get$cache$reserve$setting {
    zone_id: Schemas.cache_identifier;
}
export interface Response$zone$cache$settings$get$cache$reserve$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_cache_reserve_response_value;
}
export interface Response$zone$cache$settings$get$cache$reserve$setting$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & Schemas.cache_cache_reserve_response_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$change$cache$reserve$setting {
    zone_id: Schemas.cache_identifier;
}
export interface RequestBody$zone$cache$settings$change$cache$reserve$setting {
    "application/json": {
        value: Schemas.cache_cache_reserve_value;
    };
}
export interface Response$zone$cache$settings$change$cache$reserve$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_cache_reserve_response_value;
}
export interface Response$zone$cache$settings$change$cache$reserve$setting$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & Schemas.cache_cache_reserve_response_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$get$cache$reserve$clear {
    zone_id: Schemas.cache_identifier;
}
export interface Response$zone$cache$settings$get$cache$reserve$clear$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_cache_reserve_clear_response_value;
}
export interface Response$zone$cache$settings$get$cache$reserve$clear$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & Schemas.cache_cache_reserve_clear_response_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$start$cache$reserve$clear {
    zone_id: Schemas.cache_identifier;
}
export interface RequestBody$zone$cache$settings$start$cache$reserve$clear {
}
export interface Response$zone$cache$settings$start$cache$reserve$clear$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_cache_reserve_clear_response_value;
}
export interface Response$zone$cache$settings$start$cache$reserve$clear$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & Schemas.cache_cache_reserve_clear_response_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$get$origin$post$quantum$encryption$setting {
    zone_id: Schemas.cache_identifier;
}
export interface Response$zone$cache$settings$get$origin$post$quantum$encryption$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_origin_post_quantum_encryption_value;
}
export interface Response$zone$cache$settings$get$origin$post$quantum$encryption$setting$Status$4XX {
    "application/json": (Schemas.cache_origin_post_quantum_encryption_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$change$origin$post$quantum$encryption$setting {
    zone_id: Schemas.cache_identifier;
}
export interface RequestBody$zone$cache$settings$change$origin$post$quantum$encryption$setting {
    "application/json": {
        value: Schemas.cache_origin_post_quantum_encryption_value;
    };
}
export interface Response$zone$cache$settings$change$origin$post$quantum$encryption$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_origin_post_quantum_encryption_value;
}
export interface Response$zone$cache$settings$change$origin$post$quantum$encryption$setting$Status$4XX {
    "application/json": (Schemas.cache_origin_post_quantum_encryption_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$get$regional$tiered$cache$setting {
    zone_id: Schemas.cache_identifier;
}
export interface Response$zone$cache$settings$get$regional$tiered$cache$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_regional_tiered_cache_response_value;
}
export interface Response$zone$cache$settings$get$regional$tiered$cache$setting$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & Schemas.cache_regional_tiered_cache_response_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$change$regional$tiered$cache$setting {
    zone_id: Schemas.cache_identifier;
}
export interface RequestBody$zone$cache$settings$change$regional$tiered$cache$setting {
    "application/json": {
        value: Schemas.cache_regional_tiered_cache_value;
    };
}
export interface Response$zone$cache$settings$change$regional$tiered$cache$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_regional_tiered_cache_response_value;
}
export interface Response$zone$cache$settings$change$regional$tiered$cache$setting$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & Schemas.cache_regional_tiered_cache_response_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$smart$tiered$cache$get$smart$tiered$cache$setting {
    zone_id: Schemas.cache_identifier;
}
export interface Response$smart$tiered$cache$get$smart$tiered$cache$setting$Status$200 {
    "application/json": Schemas.cache_response_single;
}
export interface Response$smart$tiered$cache$get$smart$tiered$cache$setting$Status$4XX {
    "application/json": Schemas.cache_response_single & Schemas.cache_api$response$common$failure;
}
export interface Parameter$smart$tiered$cache$delete$smart$tiered$cache$setting {
    zone_id: Schemas.cache_identifier;
}
export interface Response$smart$tiered$cache$delete$smart$tiered$cache$setting$Status$200 {
    "application/json": Schemas.cache_response_single;
}
export interface Response$smart$tiered$cache$delete$smart$tiered$cache$setting$Status$4XX {
    "application/json": Schemas.cache_response_single & Schemas.cache_api$response$common$failure;
}
export interface Parameter$smart$tiered$cache$patch$smart$tiered$cache$setting {
    zone_id: Schemas.cache_identifier;
}
export interface RequestBody$smart$tiered$cache$patch$smart$tiered$cache$setting {
    "application/json": Schemas.cache_schemas$patch;
}
export interface Response$smart$tiered$cache$patch$smart$tiered$cache$setting$Status$200 {
    "application/json": Schemas.cache_response_single;
}
export interface Response$smart$tiered$cache$patch$smart$tiered$cache$setting$Status$4XX {
    "application/json": Schemas.cache_response_single & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$get$variants$setting {
    zone_id: Schemas.cache_identifier;
}
export interface Response$zone$cache$settings$get$variants$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_variants_response_value;
}
export interface Response$zone$cache$settings$get$variants$setting$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & Schemas.cache_variants_response_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$delete$variants$setting {
    zone_id: Schemas.cache_identifier;
}
export interface Response$zone$cache$settings$delete$variants$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & {
        result?: Schemas.cache_variants;
    };
}
export interface Response$zone$cache$settings$delete$variants$setting$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & {
        result?: Schemas.cache_variants;
    }) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$zone$cache$settings$change$variants$setting {
    zone_id: Schemas.cache_identifier;
}
export interface RequestBody$zone$cache$settings$change$variants$setting {
    "application/json": {
        value: Schemas.cache_variants_value;
    };
}
export interface Response$zone$cache$settings$change$variants$setting$Status$200 {
    "application/json": Schemas.cache_zone_cache_settings_response_single & Schemas.cache_variants_response_value;
}
export interface Response$zone$cache$settings$change$variants$setting$Status$4XX {
    "application/json": (Schemas.cache_zone_cache_settings_response_single & Schemas.cache_variants_response_value) & Schemas.cache_api$response$common$failure;
}
export interface Parameter$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata {
    zone_id: Schemas.dns$custom$nameservers_schemas$identifier;
}
export interface Response$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata$Status$200 {
    "application/json": Schemas.dns$custom$nameservers_get_response;
}
export interface Response$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata$Status$4XX {
    "application/json": Schemas.dns$custom$nameservers_get_response & Schemas.dns$custom$nameservers_api$response$common$failure;
}
export interface Parameter$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata {
    zone_id: Schemas.dns$custom$nameservers_schemas$identifier;
}
export interface RequestBody$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata {
    "application/json": Schemas.dns$custom$nameservers_zone_metadata;
}
export interface Response$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata$Status$200 {
    "application/json": Schemas.dns$custom$nameservers_schemas$empty_response;
}
export interface Response$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata$Status$4XX {
    "application/json": Schemas.dns$custom$nameservers_schemas$empty_response & Schemas.dns$custom$nameservers_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$list$dns$records {
    zone_id: Schemas.dns$records_identifier;
    name?: Schemas.dns$records_name;
    type?: Schemas.dns$records_type;
    content?: Schemas.dns$records_content;
    proxied?: Schemas.dns$records_proxied;
    match?: Schemas.dns$records_match;
    comment?: string;
    "comment.present"?: string;
    "comment.absent"?: string;
    "comment.exact"?: string;
    "comment.contains"?: string;
    "comment.startswith"?: string;
    "comment.endswith"?: string;
    tag?: string;
    "tag.present"?: string;
    "tag.absent"?: string;
    "tag.exact"?: string;
    "tag.contains"?: string;
    "tag.startswith"?: string;
    "tag.endswith"?: string;
    search?: Schemas.dns$records_search;
    tag_match?: Schemas.dns$records_tag_match;
    page?: Schemas.dns$records_page;
    per_page?: Schemas.dns$records_per_page;
    order?: Schemas.dns$records_order;
    direction?: Schemas.dns$records_direction;
}
export interface Response$dns$records$for$a$zone$list$dns$records$Status$200 {
    "application/json": Schemas.dns$records_dns_response_collection;
}
export interface Response$dns$records$for$a$zone$list$dns$records$Status$4xx {
    "application/json": Schemas.dns$records_dns_response_collection & Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$create$dns$record {
    zone_id: Schemas.dns$records_identifier;
}
export interface RequestBody$dns$records$for$a$zone$create$dns$record {
    "application/json": Schemas.dns$records_dns$record;
}
export interface Response$dns$records$for$a$zone$create$dns$record$Status$200 {
    "application/json": Schemas.dns$records_dns_response_single;
}
export interface Response$dns$records$for$a$zone$create$dns$record$Status$4xx {
    "application/json": Schemas.dns$records_dns_response_single & Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$dns$record$details {
    dns_record_id: Schemas.dns$records_identifier;
    zone_id: Schemas.dns$records_identifier;
}
export interface Response$dns$records$for$a$zone$dns$record$details$Status$200 {
    "application/json": Schemas.dns$records_dns_response_single;
}
export interface Response$dns$records$for$a$zone$dns$record$details$Status$4xx {
    "application/json": Schemas.dns$records_dns_response_single & Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$update$dns$record {
    dns_record_id: Schemas.dns$records_identifier;
    zone_id: Schemas.dns$records_identifier;
}
export interface RequestBody$dns$records$for$a$zone$update$dns$record {
    "application/json": Schemas.dns$records_dns$record;
}
export interface Response$dns$records$for$a$zone$update$dns$record$Status$200 {
    "application/json": Schemas.dns$records_dns_response_single;
}
export interface Response$dns$records$for$a$zone$update$dns$record$Status$4xx {
    "application/json": Schemas.dns$records_dns_response_single & Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$delete$dns$record {
    dns_record_id: Schemas.dns$records_identifier;
    zone_id: Schemas.dns$records_identifier;
}
export interface Response$dns$records$for$a$zone$delete$dns$record$Status$200 {
    "application/json": {
        result?: {
            id?: Schemas.dns$records_identifier;
        };
    };
}
export interface Response$dns$records$for$a$zone$delete$dns$record$Status$4xx {
    "application/json": {
        result?: {
            id?: Schemas.dns$records_identifier;
        };
    } & Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$patch$dns$record {
    dns_record_id: Schemas.dns$records_identifier;
    zone_id: Schemas.dns$records_identifier;
}
export interface RequestBody$dns$records$for$a$zone$patch$dns$record {
    "application/json": Schemas.dns$records_dns$record;
}
export interface Response$dns$records$for$a$zone$patch$dns$record$Status$200 {
    "application/json": Schemas.dns$records_dns_response_single;
}
export interface Response$dns$records$for$a$zone$patch$dns$record$Status$4xx {
    "application/json": Schemas.dns$records_dns_response_single & Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$export$dns$records {
    zone_id: Schemas.dns$records_identifier;
}
export interface Response$dns$records$for$a$zone$export$dns$records$Status$200 {
    /** Exported BIND zone file. */
    "text/plain": string;
}
export interface Response$dns$records$for$a$zone$export$dns$records$Status$4XX {
    "application/json": Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$import$dns$records {
    zone_id: Schemas.dns$records_identifier;
}
export interface RequestBody$dns$records$for$a$zone$import$dns$records {
    "multipart/form-data": {
        /**
         * BIND config to import.
         *
         * **Tip:** When using cURL, a file can be uploaded using \`--form 'file=@bind_config.txt'\`.
         */
        file: string;
        /**
         * Whether or not proxiable records should receive the performance and security benefits of Cloudflare.
         *
         * The value should be either \`true\` or \`false\`.
         */
        proxied?: string;
    };
}
export interface Response$dns$records$for$a$zone$import$dns$records$Status$200 {
    "application/json": Schemas.dns$records_dns_response_import_scan;
}
export interface Response$dns$records$for$a$zone$import$dns$records$Status$4XX {
    "application/json": Schemas.dns$records_dns_response_import_scan & Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dns$records$for$a$zone$scan$dns$records {
    zone_id: Schemas.dns$records_identifier;
}
export interface Response$dns$records$for$a$zone$scan$dns$records$Status$200 {
    "application/json": Schemas.dns$records_dns_response_import_scan;
}
export interface Response$dns$records$for$a$zone$scan$dns$records$Status$4XX {
    "application/json": Schemas.dns$records_dns_response_import_scan & Schemas.dns$records_api$response$common$failure;
}
export interface Parameter$dnssec$dnssec$details {
    zone_id: Schemas.dnssec_identifier;
}
export interface Response$dnssec$dnssec$details$Status$200 {
    "application/json": Schemas.dnssec_dnssec_response_single;
}
export interface Response$dnssec$dnssec$details$Status$4XX {
    "application/json": Schemas.dnssec_dnssec_response_single & Schemas.dnssec_api$response$common$failure;
}
export interface Parameter$dnssec$delete$dnssec$records {
    zone_id: Schemas.dnssec_identifier;
}
export interface Response$dnssec$delete$dnssec$records$Status$200 {
    "application/json": Schemas.dnssec_delete_dnssec_response_single;
}
export interface Response$dnssec$delete$dnssec$records$Status$4XX {
    "application/json": Schemas.dnssec_delete_dnssec_response_single & Schemas.dnssec_api$response$common$failure;
}
export interface Parameter$dnssec$edit$dnssec$status {
    zone_id: Schemas.dnssec_identifier;
}
export interface RequestBody$dnssec$edit$dnssec$status {
    "application/json": {
        dnssec_multi_signer?: Schemas.dnssec_dnssec_multi_signer;
        dnssec_presigned?: Schemas.dnssec_dnssec_presigned;
        /** Status of DNSSEC, based on user-desired state and presence of necessary records. */
        status?: "active" | "disabled";
    };
}
export interface Response$dnssec$edit$dnssec$status$Status$200 {
    "application/json": Schemas.dnssec_dnssec_response_single;
}
export interface Response$dnssec$edit$dnssec$status$Status$4XX {
    "application/json": Schemas.dnssec_dnssec_response_single & Schemas.dnssec_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$a$zone$list$ip$access$rules {
    zone_id: Schemas.legacy$jhs_common_components$schemas$identifier;
    filters?: Schemas.legacy$jhs_schemas$filters;
    "egs-pagination.json"?: Schemas.legacy$jhs_egs$pagination;
    page?: number;
    per_page?: number;
    order?: "configuration.target" | "configuration.value" | "mode";
    direction?: "asc" | "desc";
}
export interface Response$ip$access$rules$for$a$zone$list$ip$access$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_rule_collection_response;
}
export interface Response$ip$access$rules$for$a$zone$list$ip$access$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_rule_collection_response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$a$zone$create$an$ip$access$rule {
    zone_id: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$ip$access$rules$for$a$zone$create$an$ip$access$rule {
    "application/json": {
        configuration: Schemas.legacy$jhs_schemas$configuration;
        mode: Schemas.legacy$jhs_schemas$mode;
        notes: Schemas.legacy$jhs_notes;
    };
}
export interface Response$ip$access$rules$for$a$zone$create$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_rule_single_response;
}
export interface Response$ip$access$rules$for$a$zone$create$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_rule_single_response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$a$zone$delete$an$ip$access$rule {
    identifier: Schemas.legacy$jhs_rule_components$schemas$identifier;
    zone_id: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$ip$access$rules$for$a$zone$delete$an$ip$access$rule {
    "application/json": {
        /** The level to attempt to delete similar rules defined for other zones with the same owner. The default value is \`none\`, which will only delete the current rule. Using \`basic\` will delete rules that match the same action (mode) and configuration, while using \`aggressive\` will delete rules that match the same configuration. */
        cascade?: "none" | "basic" | "aggressive";
    };
}
export interface Response$ip$access$rules$for$a$zone$delete$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_rule_single_id_response;
}
export interface Response$ip$access$rules$for$a$zone$delete$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_rule_single_id_response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$ip$access$rules$for$a$zone$update$an$ip$access$rule {
    identifier: Schemas.legacy$jhs_rule_components$schemas$identifier;
    zone_id: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$ip$access$rules$for$a$zone$update$an$ip$access$rule {
    "application/json": {
        mode?: Schemas.legacy$jhs_schemas$mode;
        notes?: Schemas.legacy$jhs_notes;
    };
}
export interface Response$ip$access$rules$for$a$zone$update$an$ip$access$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_rule_single_response;
}
export interface Response$ip$access$rules$for$a$zone$update$an$ip$access$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_rule_single_response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$rule$groups$list$waf$rule$groups {
    package_id: Schemas.waf$managed$rules_identifier;
    zone_id: Schemas.waf$managed$rules_schemas$identifier;
    mode?: Schemas.waf$managed$rules_mode;
    page?: number;
    per_page?: number;
    order?: "mode" | "rules_count";
    direction?: "asc" | "desc";
    match?: "any" | "all";
    name?: string;
    rules_count?: number;
}
export interface Response$waf$rule$groups$list$waf$rule$groups$Status$200 {
    "application/json": Schemas.waf$managed$rules_rule_group_response_collection;
}
export interface Response$waf$rule$groups$list$waf$rule$groups$Status$4XX {
    "application/json": Schemas.waf$managed$rules_rule_group_response_collection & Schemas.waf$managed$rules_api$response$common$failure;
}
export interface Parameter$waf$rule$groups$get$a$waf$rule$group {
    group_id: Schemas.waf$managed$rules_identifier;
    package_id: Schemas.waf$managed$rules_identifier;
    zone_id: Schemas.waf$managed$rules_schemas$identifier;
}
export interface Response$waf$rule$groups$get$a$waf$rule$group$Status$200 {
    "application/json": Schemas.waf$managed$rules_rule_group_response_single;
}
export interface Response$waf$rule$groups$get$a$waf$rule$group$Status$4XX {
    "application/json": Schemas.waf$managed$rules_rule_group_response_single & Schemas.waf$managed$rules_api$response$common$failure;
}
export interface Parameter$waf$rule$groups$update$a$waf$rule$group {
    group_id: Schemas.waf$managed$rules_identifier;
    package_id: Schemas.waf$managed$rules_identifier;
    zone_id: Schemas.waf$managed$rules_schemas$identifier;
}
export interface RequestBody$waf$rule$groups$update$a$waf$rule$group {
    "application/json": {
        mode?: Schemas.waf$managed$rules_mode;
    };
}
export interface Response$waf$rule$groups$update$a$waf$rule$group$Status$200 {
    "application/json": Schemas.waf$managed$rules_rule_group_response_single;
}
export interface Response$waf$rule$groups$update$a$waf$rule$group$Status$4XX {
    "application/json": Schemas.waf$managed$rules_rule_group_response_single & Schemas.waf$managed$rules_api$response$common$failure;
}
export interface Parameter$waf$rules$list$waf$rules {
    package_id: Schemas.waf$managed$rules_identifier;
    zone_id: Schemas.waf$managed$rules_schemas$identifier;
    mode?: "DIS" | "CHL" | "BLK" | "SIM";
    group_id?: Schemas.waf$managed$rules_components$schemas$identifier;
    page?: number;
    per_page?: number;
    order?: "priority" | "group_id" | "description";
    direction?: "asc" | "desc";
    match?: "any" | "all";
    description?: string;
    priority?: string;
}
export interface Response$waf$rules$list$waf$rules$Status$200 {
    "application/json": Schemas.waf$managed$rules_rule_response_collection;
}
export interface Response$waf$rules$list$waf$rules$Status$4XX {
    "application/json": Schemas.waf$managed$rules_rule_response_collection & Schemas.waf$managed$rules_api$response$common$failure;
}
export interface Parameter$waf$rules$get$a$waf$rule {
    rule_id: Schemas.waf$managed$rules_identifier;
    package_id: Schemas.waf$managed$rules_identifier;
    zone_id: Schemas.waf$managed$rules_schemas$identifier;
}
export interface Response$waf$rules$get$a$waf$rule$Status$200 {
    "application/json": Schemas.waf$managed$rules_rule_response_single;
}
export interface Response$waf$rules$get$a$waf$rule$Status$4XX {
    "application/json": Schemas.waf$managed$rules_rule_response_single & Schemas.waf$managed$rules_api$response$common$failure;
}
export interface Parameter$waf$rules$update$a$waf$rule {
    rule_id: Schemas.waf$managed$rules_identifier;
    package_id: Schemas.waf$managed$rules_identifier;
    zone_id: Schemas.waf$managed$rules_schemas$identifier;
}
export interface RequestBody$waf$rules$update$a$waf$rule {
    "application/json": {
        /** The mode/action of the rule when triggered. You must use a value from the \`allowed_modes\` array of the current rule. */
        mode?: "default" | "disable" | "simulate" | "block" | "challenge" | "on" | "off";
    };
}
export interface Response$waf$rules$update$a$waf$rule$Status$200 {
    "application/json": Schemas.waf$managed$rules_rule_response_single & {
        result?: Schemas.waf$managed$rules_anomaly_rule | Schemas.waf$managed$rules_traditional_deny_rule | Schemas.waf$managed$rules_traditional_allow_rule;
    };
}
export interface Response$waf$rules$update$a$waf$rule$Status$4XX {
    "application/json": (Schemas.waf$managed$rules_rule_response_single & {
        result?: Schemas.waf$managed$rules_anomaly_rule | Schemas.waf$managed$rules_traditional_deny_rule | Schemas.waf$managed$rules_traditional_allow_rule;
    }) & Schemas.waf$managed$rules_api$response$common$failure;
}
export interface Parameter$zones$0$hold$get {
    /** Zone ID */
    zone_id: Schemas.zones_schemas$identifier;
}
export interface Response$zones$0$hold$get$Status$200 {
    "application/json": Schemas.zones_api$response$single & {
        result?: {
            hold?: boolean;
            hold_after?: string;
            include_subdomains?: string;
        };
    };
}
export interface Response$zones$0$hold$get$Status$4XX {
    "application/json": Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$zones$0$hold$post {
    /** Zone ID */
    zone_id: Schemas.zones_schemas$identifier;
    /**
     * If provided, the zone hold will extend to block any subdomain of the given zone, as well
     * as SSL4SaaS Custom Hostnames. For example, a zone hold on a zone with the hostname
     * 'example.com' and include_subdomains=true will block 'example.com',
     * 'staging.example.com', 'api.staging.example.com', etc.
     */
    include_subdomains?: boolean;
}
export interface Response$zones$0$hold$post$Status$200 {
    "application/json": Schemas.zones_api$response$single & {
        result?: {
            hold?: boolean;
            hold_after?: string;
            include_subdomains?: string;
        };
    };
}
export interface Response$zones$0$hold$post$Status$4XX {
    "application/json": Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$zones$0$hold$delete {
    /** Zone ID */
    zone_id: Schemas.zones_schemas$identifier;
    /**
     * If \`hold_after\` is provided, the hold will be temporarily disabled,
     * then automatically re-enabled by the system at the time specified
     * in this RFC3339-formatted timestamp. Otherwise, the hold will be
     * disabled indefinitely.
     */
    hold_after?: string;
}
export interface Response$zones$0$hold$delete$Status$200 {
    "application/json": {
        result?: {
            hold?: boolean;
            hold_after?: string;
            include_subdomains?: string;
        };
    };
}
export interface Response$zones$0$hold$delete$Status$4XX {
    "application/json": Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$logpush$datasets$dataset$fields {
    dataset_id: Schemas.logpush_dataset;
    zone_id: Schemas.logpush_identifier;
}
export interface Response$get$zones$zone_identifier$logpush$datasets$dataset$fields$Status$200 {
    "application/json": Schemas.logpush_logpush_field_response_collection;
}
export interface Response$get$zones$zone_identifier$logpush$datasets$dataset$fields$Status$4XX {
    "application/json": Schemas.logpush_logpush_field_response_collection & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$logpush$datasets$dataset$jobs {
    dataset_id: Schemas.logpush_dataset;
    zone_id: Schemas.logpush_identifier;
}
export interface Response$get$zones$zone_identifier$logpush$datasets$dataset$jobs$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_collection;
}
export interface Response$get$zones$zone_identifier$logpush$datasets$dataset$jobs$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_collection & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$logpush$edge$jobs {
    zone_id: Schemas.logpush_identifier;
}
export interface Response$get$zones$zone_identifier$logpush$edge$jobs$Status$200 {
    "application/json": Schemas.logpush_instant_logs_job_response_collection;
}
export interface Response$get$zones$zone_identifier$logpush$edge$jobs$Status$4XX {
    "application/json": Schemas.logpush_instant_logs_job_response_collection & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$zones$zone_identifier$logpush$edge$jobs {
    zone_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$zones$zone_identifier$logpush$edge$jobs {
    "application/json": {
        fields?: Schemas.logpush_fields;
        filter?: Schemas.logpush_filter;
        sample?: Schemas.logpush_sample;
    };
}
export interface Response$post$zones$zone_identifier$logpush$edge$jobs$Status$200 {
    "application/json": Schemas.logpush_instant_logs_job_response_single;
}
export interface Response$post$zones$zone_identifier$logpush$edge$jobs$Status$4XX {
    "application/json": Schemas.logpush_instant_logs_job_response_single & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$logpush$jobs {
    zone_id: Schemas.logpush_identifier;
}
export interface Response$get$zones$zone_identifier$logpush$jobs$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_collection;
}
export interface Response$get$zones$zone_identifier$logpush$jobs$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_collection & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$zones$zone_identifier$logpush$jobs {
    zone_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$zones$zone_identifier$logpush$jobs {
    "application/json": {
        dataset?: Schemas.logpush_dataset;
        destination_conf: Schemas.logpush_destination_conf;
        enabled?: Schemas.logpush_enabled;
        frequency?: Schemas.logpush_frequency;
        logpull_options?: Schemas.logpush_logpull_options;
        name?: Schemas.logpush_name;
        output_options?: Schemas.logpush_output_options;
        ownership_challenge?: Schemas.logpush_ownership_challenge;
    };
}
export interface Response$post$zones$zone_identifier$logpush$jobs$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_single;
}
export interface Response$post$zones$zone_identifier$logpush$jobs$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_single & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$logpush$jobs$job_identifier {
    job_id: Schemas.logpush_id;
    zone_id: Schemas.logpush_identifier;
}
export interface Response$get$zones$zone_identifier$logpush$jobs$job_identifier$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_single;
}
export interface Response$get$zones$zone_identifier$logpush$jobs$job_identifier$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_single & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$put$zones$zone_identifier$logpush$jobs$job_identifier {
    job_id: Schemas.logpush_id;
    zone_id: Schemas.logpush_identifier;
}
export interface RequestBody$put$zones$zone_identifier$logpush$jobs$job_identifier {
    "application/json": {
        destination_conf?: Schemas.logpush_destination_conf;
        enabled?: Schemas.logpush_enabled;
        frequency?: Schemas.logpush_frequency;
        logpull_options?: Schemas.logpush_logpull_options;
        output_options?: Schemas.logpush_output_options;
        ownership_challenge?: Schemas.logpush_ownership_challenge;
    };
}
export interface Response$put$zones$zone_identifier$logpush$jobs$job_identifier$Status$200 {
    "application/json": Schemas.logpush_logpush_job_response_single;
}
export interface Response$put$zones$zone_identifier$logpush$jobs$job_identifier$Status$4XX {
    "application/json": Schemas.logpush_logpush_job_response_single & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$delete$zones$zone_identifier$logpush$jobs$job_identifier {
    job_id: Schemas.logpush_id;
    zone_id: Schemas.logpush_identifier;
}
export interface Response$delete$zones$zone_identifier$logpush$jobs$job_identifier$Status$200 {
    "application/json": Schemas.logpush_api$response$common & {
        result?: {} | null;
    };
}
export interface Response$delete$zones$zone_identifier$logpush$jobs$job_identifier$Status$4XX {
    "application/json": (Schemas.logpush_api$response$common & {
        result?: {} | null;
    }) & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$zones$zone_identifier$logpush$ownership {
    zone_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$zones$zone_identifier$logpush$ownership {
    "application/json": {
        destination_conf: Schemas.logpush_destination_conf;
    };
}
export interface Response$post$zones$zone_identifier$logpush$ownership$Status$200 {
    "application/json": Schemas.logpush_get_ownership_response;
}
export interface Response$post$zones$zone_identifier$logpush$ownership$Status$4XX {
    "application/json": Schemas.logpush_get_ownership_response & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$zones$zone_identifier$logpush$ownership$validate {
    zone_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$zones$zone_identifier$logpush$ownership$validate {
    "application/json": {
        destination_conf: Schemas.logpush_destination_conf;
        ownership_challenge: Schemas.logpush_ownership_challenge;
    };
}
export interface Response$post$zones$zone_identifier$logpush$ownership$validate$Status$200 {
    "application/json": Schemas.logpush_validate_ownership_response;
}
export interface Response$post$zones$zone_identifier$logpush$ownership$validate$Status$4XX {
    "application/json": Schemas.logpush_validate_ownership_response & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$zones$zone_identifier$logpush$validate$destination$exists {
    zone_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$zones$zone_identifier$logpush$validate$destination$exists {
    "application/json": {
        destination_conf: Schemas.logpush_destination_conf;
    };
}
export interface Response$post$zones$zone_identifier$logpush$validate$destination$exists$Status$200 {
    "application/json": Schemas.logpush_destination_exists_response;
}
export interface Response$post$zones$zone_identifier$logpush$validate$destination$exists$Status$4XX {
    "application/json": Schemas.logpush_destination_exists_response & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$post$zones$zone_identifier$logpush$validate$origin {
    zone_id: Schemas.logpush_identifier;
}
export interface RequestBody$post$zones$zone_identifier$logpush$validate$origin {
    "application/json": {
        logpull_options: Schemas.logpush_logpull_options;
    };
}
export interface Response$post$zones$zone_identifier$logpush$validate$origin$Status$200 {
    "application/json": Schemas.logpush_validate_response;
}
export interface Response$post$zones$zone_identifier$logpush$validate$origin$Status$4XX {
    "application/json": Schemas.logpush_validate_response & Schemas.logpush_api$response$common$failure;
}
export interface Parameter$managed$transforms$list$managed$transforms {
    zone_id: Schemas.rulesets_identifier;
}
export interface Response$managed$transforms$list$managed$transforms$Status$200 {
    "application/json": {
        managed_request_headers?: Schemas.rulesets_request_list;
        managed_response_headers?: Schemas.rulesets_request_list;
    };
}
export interface Response$managed$transforms$list$managed$transforms$Status$4XX {
    "application/json": {
        managed_request_headers?: Schemas.rulesets_request_list;
        managed_response_headers?: Schemas.rulesets_request_list;
    } & Schemas.rulesets_api$response$common$failure;
}
export interface Parameter$managed$transforms$update$status$of$managed$transforms {
    zone_id: Schemas.rulesets_identifier;
}
export interface RequestBody$managed$transforms$update$status$of$managed$transforms {
    "application/json": {
        managed_request_headers: Schemas.rulesets_request_list;
        managed_response_headers: Schemas.rulesets_request_list;
    };
}
export interface Response$managed$transforms$update$status$of$managed$transforms$Status$200 {
    "application/json": {
        managed_request_headers?: Schemas.rulesets_response_list;
        managed_response_headers?: Schemas.rulesets_response_list;
    };
}
export interface Response$managed$transforms$update$status$of$managed$transforms$Status$4XX {
    "application/json": {
        managed_request_headers?: Schemas.rulesets_response_list;
        managed_response_headers?: Schemas.rulesets_response_list;
    } & Schemas.rulesets_api$response$common$failure;
}
export interface Parameter$page$shield$get$page$shield$settings {
    zone_id: Schemas.page$shield_identifier;
}
export interface Response$page$shield$get$page$shield$settings$Status$200 {
    "application/json": Schemas.page$shield_zone_settings_response_single & {
        result?: Schemas.page$shield_get$zone$settings$response;
    };
}
export interface Response$page$shield$get$page$shield$settings$Status$4XX {
    "application/json": (Schemas.page$shield_zone_settings_response_single & {
        result?: Schemas.page$shield_get$zone$settings$response;
    }) & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$update$page$shield$settings {
    zone_id: Schemas.page$shield_identifier;
}
export interface RequestBody$page$shield$update$page$shield$settings {
    "application/json": {
        enabled?: Schemas.page$shield_enabled;
        use_cloudflare_reporting_endpoint?: Schemas.page$shield_use_cloudflare_reporting_endpoint;
        use_connection_url_path?: Schemas.page$shield_use_connection_url_path;
    };
}
export interface Response$page$shield$update$page$shield$settings$Status$200 {
    "application/json": Schemas.page$shield_zone_settings_response_single & {
        result?: Schemas.page$shield_update$zone$settings$response;
    };
}
export interface Response$page$shield$update$page$shield$settings$Status$4XX {
    "application/json": (Schemas.page$shield_zone_settings_response_single & {
        result?: Schemas.page$shield_update$zone$settings$response;
    }) & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$list$page$shield$connections {
    zone_id: Schemas.page$shield_identifier;
    exclude_urls?: string;
    urls?: string;
    hosts?: string;
    page?: string;
    per_page?: number;
    order_by?: "first_seen_at" | "last_seen_at";
    direction?: "asc" | "desc";
    prioritize_malicious?: boolean;
    exclude_cdn_cgi?: boolean;
    status?: string;
    page_url?: string;
    export?: "csv";
}
export interface Response$page$shield$list$page$shield$connections$Status$200 {
    "application/json": Schemas.page$shield_list$zone$connections$response;
}
export interface Response$page$shield$list$page$shield$connections$Status$4XX {
    "application/json": Schemas.page$shield_list$zone$connections$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$get$a$page$shield$connection {
    zone_id: Schemas.page$shield_identifier;
    connection_id: Schemas.page$shield_resource_id;
}
export interface Response$page$shield$get$a$page$shield$connection$Status$200 {
    "application/json": Schemas.page$shield_get$zone$connection$response;
}
export interface Response$page$shield$get$a$page$shield$connection$Status$4XX {
    "application/json": Schemas.page$shield_get$zone$connection$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$list$page$shield$policies {
    zone_id: Schemas.page$shield_identifier;
}
export interface Response$page$shield$list$page$shield$policies$Status$200 {
    "application/json": Schemas.page$shield_list$zone$policies$response;
}
export interface Response$page$shield$list$page$shield$policies$Status$4XX {
    "application/json": Schemas.page$shield_list$zone$policies$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$create$a$page$shield$policy {
    zone_id: Schemas.page$shield_identifier;
}
export interface RequestBody$page$shield$create$a$page$shield$policy {
    "application/json": {
        action?: Schemas.page$shield_pageshield$policy$action;
        description?: Schemas.page$shield_pageshield$policy$description;
        enabled?: Schemas.page$shield_pageshield$policy$enabled;
        expression?: Schemas.page$shield_pageshield$policy$expression;
        value?: Schemas.page$shield_pageshield$policy$value;
    };
}
export interface Response$page$shield$create$a$page$shield$policy$Status$200 {
    "application/json": Schemas.page$shield_get$zone$policy$response;
}
export interface Response$page$shield$create$a$page$shield$policy$Status$4XX {
    "application/json": Schemas.page$shield_get$zone$policy$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$get$a$page$shield$policy {
    zone_id: Schemas.page$shield_identifier;
    policy_id: Schemas.page$shield_policy_id;
}
export interface Response$page$shield$get$a$page$shield$policy$Status$200 {
    "application/json": Schemas.page$shield_get$zone$policy$response;
}
export interface Response$page$shield$get$a$page$shield$policy$Status$4XX {
    "application/json": Schemas.page$shield_get$zone$policy$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$update$a$page$shield$policy {
    zone_id: Schemas.page$shield_identifier;
    policy_id: Schemas.page$shield_policy_id;
}
export interface RequestBody$page$shield$update$a$page$shield$policy {
    "application/json": {
        action?: Schemas.page$shield_pageshield$policy$action;
        description?: Schemas.page$shield_pageshield$policy$description;
        enabled?: Schemas.page$shield_pageshield$policy$enabled;
        expression?: Schemas.page$shield_pageshield$policy$expression;
        value?: Schemas.page$shield_pageshield$policy$value;
    };
}
export interface Response$page$shield$update$a$page$shield$policy$Status$200 {
    "application/json": Schemas.page$shield_get$zone$policy$response;
}
export interface Response$page$shield$update$a$page$shield$policy$Status$4XX {
    "application/json": Schemas.page$shield_get$zone$policy$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$delete$a$page$shield$policy {
    zone_id: Schemas.page$shield_identifier;
    policy_id: Schemas.page$shield_policy_id;
}
export interface Response$page$shield$delete$a$page$shield$policy$Status$4XX {
    "application/json": Schemas.page$shield_get$zone$policy$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$list$page$shield$scripts {
    zone_id: Schemas.page$shield_identifier;
    exclude_urls?: string;
    urls?: string;
    hosts?: string;
    page?: string;
    per_page?: number;
    order_by?: "first_seen_at" | "last_seen_at";
    direction?: "asc" | "desc";
    prioritize_malicious?: boolean;
    exclude_cdn_cgi?: boolean;
    exclude_duplicates?: boolean;
    status?: string;
    page_url?: string;
    export?: "csv";
}
export interface Response$page$shield$list$page$shield$scripts$Status$200 {
    "application/json": Schemas.page$shield_list$zone$scripts$response;
}
export interface Response$page$shield$list$page$shield$scripts$Status$4XX {
    "application/json": Schemas.page$shield_list$zone$scripts$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$shield$get$a$page$shield$script {
    zone_id: Schemas.page$shield_identifier;
    script_id: Schemas.page$shield_resource_id;
}
export interface Response$page$shield$get$a$page$shield$script$Status$200 {
    "application/json": Schemas.page$shield_get$zone$script$response;
}
export interface Response$page$shield$get$a$page$shield$script$Status$4XX {
    "application/json": Schemas.page$shield_get$zone$script$response & Schemas.page$shield_api$response$common$failure;
}
export interface Parameter$page$rules$list$page$rules {
    zone_id: Schemas.zones_schemas$identifier;
    order?: "status" | "priority";
    direction?: "asc" | "desc";
    match?: "any" | "all";
    status?: "active" | "disabled";
}
export interface Response$page$rules$list$page$rules$Status$200 {
    "application/json": Schemas.zones_pagerule_response_collection;
}
export interface Response$page$rules$list$page$rules$Status$4XX {
    "application/json": Schemas.zones_pagerule_response_collection & Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$page$rules$create$a$page$rule {
    zone_id: Schemas.zones_schemas$identifier;
}
export interface RequestBody$page$rules$create$a$page$rule {
    "application/json": {
        actions: Schemas.zones_actions;
        priority?: Schemas.zones_priority;
        status?: Schemas.zones_status;
        targets: Schemas.zones_targets;
    };
}
export interface Response$page$rules$create$a$page$rule$Status$200 {
    "application/json": Schemas.zones_pagerule_response_single;
}
export interface Response$page$rules$create$a$page$rule$Status$4XX {
    "application/json": Schemas.zones_pagerule_response_single & Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$page$rules$get$a$page$rule {
    pagerule_id: Schemas.zones_schemas$identifier;
    zone_id: Schemas.zones_schemas$identifier;
}
export interface Response$page$rules$get$a$page$rule$Status$200 {
    "application/json": Schemas.zones_pagerule_response_single;
}
export interface Response$page$rules$get$a$page$rule$Status$4XX {
    "application/json": Schemas.zones_pagerule_response_single & Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$page$rules$update$a$page$rule {
    pagerule_id: Schemas.zones_schemas$identifier;
    zone_id: Schemas.zones_schemas$identifier;
}
export interface RequestBody$page$rules$update$a$page$rule {
    "application/json": {
        actions: Schemas.zones_actions;
        priority?: Schemas.zones_priority;
        status?: Schemas.zones_status;
        targets: Schemas.zones_targets;
    };
}
export interface Response$page$rules$update$a$page$rule$Status$200 {
    "application/json": Schemas.zones_pagerule_response_single;
}
export interface Response$page$rules$update$a$page$rule$Status$4XX {
    "application/json": Schemas.zones_pagerule_response_single & Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$page$rules$delete$a$page$rule {
    pagerule_id: Schemas.zones_schemas$identifier;
    zone_id: Schemas.zones_schemas$identifier;
}
export interface Response$page$rules$delete$a$page$rule$Status$200 {
    "application/json": Schemas.zones_schemas$api$response$single$id;
}
export interface Response$page$rules$delete$a$page$rule$Status$4XX {
    "application/json": Schemas.zones_schemas$api$response$single$id & Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$page$rules$edit$a$page$rule {
    pagerule_id: Schemas.zones_schemas$identifier;
    zone_id: Schemas.zones_schemas$identifier;
}
export interface RequestBody$page$rules$edit$a$page$rule {
    "application/json": {
        actions?: Schemas.zones_actions;
        priority?: Schemas.zones_priority;
        status?: Schemas.zones_status;
        targets?: Schemas.zones_targets;
    };
}
export interface Response$page$rules$edit$a$page$rule$Status$200 {
    "application/json": Schemas.zones_pagerule_response_single;
}
export interface Response$page$rules$edit$a$page$rule$Status$4XX {
    "application/json": Schemas.zones_pagerule_response_single & Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$available$page$rules$settings$list$available$page$rules$settings {
    zone_id: Schemas.zones_schemas$identifier;
}
export interface Response$available$page$rules$settings$list$available$page$rules$settings$Status$200 {
    "application/json": Schemas.zones_pagerule_settings_response_collection;
}
export interface Response$available$page$rules$settings$list$available$page$rules$settings$Status$4XX {
    "application/json": Schemas.zones_pagerule_settings_response_collection & Schemas.zones_schemas$api$response$common$failure;
}
export interface Parameter$listZoneRulesets {
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$listZoneRulesets$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetsResponse;
    };
}
export interface Response$listZoneRulesets$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$createZoneRuleset {
    zone_id: Schemas.rulesets_ZoneId;
}
export interface RequestBody$createZoneRuleset {
    "application/json": Schemas.rulesets_CreateRulesetRequest;
}
export interface Response$createZoneRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$createZoneRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$getZoneRuleset {
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$getZoneRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$getZoneRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$updateZoneRuleset {
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface RequestBody$updateZoneRuleset {
    "application/json": Schemas.rulesets_UpdateRulesetRequest;
}
export interface Response$updateZoneRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$updateZoneRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$deleteZoneRuleset {
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$deleteZoneRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$createZoneRulesetRule {
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface RequestBody$createZoneRulesetRule {
    "application/json": Schemas.rulesets_CreateOrUpdateRuleRequest;
}
export interface Response$createZoneRulesetRule$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$createZoneRulesetRule$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$deleteZoneRulesetRule {
    rule_id: Schemas.rulesets_RuleId;
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$deleteZoneRulesetRule$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$deleteZoneRulesetRule$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$updateZoneRulesetRule {
    rule_id: Schemas.rulesets_RuleId;
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface RequestBody$updateZoneRulesetRule {
    "application/json": Schemas.rulesets_CreateOrUpdateRuleRequest;
}
export interface Response$updateZoneRulesetRule$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$updateZoneRulesetRule$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$listZoneRulesetVersions {
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$listZoneRulesetVersions$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetsResponse;
    };
}
export interface Response$listZoneRulesetVersions$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$getZoneRulesetVersion {
    ruleset_version: Schemas.rulesets_RulesetVersion;
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$getZoneRulesetVersion$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$getZoneRulesetVersion$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$deleteZoneRulesetVersion {
    ruleset_version: Schemas.rulesets_RulesetVersion;
    ruleset_id: Schemas.rulesets_RulesetId;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$deleteZoneRulesetVersion$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$getZoneEntrypointRuleset {
    ruleset_phase: Schemas.rulesets_RulesetPhase;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$getZoneEntrypointRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$getZoneEntrypointRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$updateZoneEntrypointRuleset {
    ruleset_phase: Schemas.rulesets_RulesetPhase;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface RequestBody$updateZoneEntrypointRuleset {
    "application/json": Schemas.rulesets_UpdateRulesetRequest;
}
export interface Response$updateZoneEntrypointRuleset$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$updateZoneEntrypointRuleset$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$listZoneEntrypointRulesetVersions {
    ruleset_phase: Schemas.rulesets_RulesetPhase;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$listZoneEntrypointRulesetVersions$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetsResponse;
    };
}
export interface Response$listZoneEntrypointRulesetVersions$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$getZoneEntrypointRulesetVersion {
    ruleset_version: Schemas.rulesets_RulesetVersion;
    ruleset_phase: Schemas.rulesets_RulesetPhase;
    zone_id: Schemas.rulesets_ZoneId;
}
export interface Response$getZoneEntrypointRulesetVersion$Status$200 {
    "application/json": Schemas.rulesets_Response & {
        result?: Schemas.rulesets_RulesetResponse;
    };
}
export interface Response$getZoneEntrypointRulesetVersion$Status$4XX {
    "application/json": Schemas.rulesets_FailureResponse;
}
export interface Parameter$zone$settings$get$all$zone$settings {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$all$zone$settings$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_collection;
}
export interface Response$zone$settings$get$all$zone$settings$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$edit$zone$settings$info {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$edit$zone$settings$info {
    "application/json": {
        /** One or more zone setting objects. Must contain an ID and a value. */
        items: Schemas.zones_setting[];
    };
}
export interface Response$zone$settings$edit$zone$settings$info$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_collection;
}
export interface Response$zone$settings$edit$zone$settings$info$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$0$rtt$session$resumption$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$0$rtt$session$resumption$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_0rtt;
    };
}
export interface Response$zone$settings$get$0$rtt$session$resumption$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$0$rtt$session$resumption$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$0$rtt$session$resumption$setting {
    "application/json": {
        value: Schemas.zones_0rtt_value;
    };
}
export interface Response$zone$settings$change$0$rtt$session$resumption$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_0rtt;
    };
}
export interface Response$zone$settings$change$0$rtt$session$resumption$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$advanced$ddos$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$advanced$ddos$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_advanced_ddos;
    };
}
export interface Response$zone$settings$get$advanced$ddos$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$always$online$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$always$online$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_always_online;
    };
}
export interface Response$zone$settings$get$always$online$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$always$online$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$always$online$setting {
    "application/json": {
        value: Schemas.zones_always_online_value;
    };
}
export interface Response$zone$settings$change$always$online$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_always_online;
    };
}
export interface Response$zone$settings$change$always$online$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$always$use$https$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$always$use$https$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_always_use_https;
    };
}
export interface Response$zone$settings$get$always$use$https$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$always$use$https$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$always$use$https$setting {
    "application/json": {
        value: Schemas.zones_always_use_https_value;
    };
}
export interface Response$zone$settings$change$always$use$https$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_always_use_https;
    };
}
export interface Response$zone$settings$change$always$use$https$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$automatic$https$rewrites$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$automatic$https$rewrites$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_automatic_https_rewrites;
    };
}
export interface Response$zone$settings$get$automatic$https$rewrites$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$automatic$https$rewrites$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$automatic$https$rewrites$setting {
    "application/json": {
        value: Schemas.zones_automatic_https_rewrites_value;
    };
}
export interface Response$zone$settings$change$automatic$https$rewrites$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_automatic_https_rewrites;
    };
}
export interface Response$zone$settings$change$automatic$https$rewrites$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$automatic_platform_optimization$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$automatic_platform_optimization$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_automatic_platform_optimization;
    };
}
export interface Response$zone$settings$get$automatic_platform_optimization$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$automatic_platform_optimization$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$automatic_platform_optimization$setting {
    "application/json": {
        value: Schemas.zones_automatic_platform_optimization;
    };
}
export interface Response$zone$settings$change$automatic_platform_optimization$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_automatic_platform_optimization;
    };
}
export interface Response$zone$settings$change$automatic_platform_optimization$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$brotli$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$brotli$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_brotli;
    };
}
export interface Response$zone$settings$get$brotli$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$brotli$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$brotli$setting {
    "application/json": {
        value: Schemas.zones_brotli_value;
    };
}
export interface Response$zone$settings$change$brotli$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_brotli;
    };
}
export interface Response$zone$settings$change$brotli$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$browser$cache$ttl$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$browser$cache$ttl$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_browser_cache_ttl;
    };
}
export interface Response$zone$settings$get$browser$cache$ttl$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$browser$cache$ttl$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$browser$cache$ttl$setting {
    "application/json": {
        value: Schemas.zones_browser_cache_ttl_value;
    };
}
export interface Response$zone$settings$change$browser$cache$ttl$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_browser_cache_ttl;
    };
}
export interface Response$zone$settings$change$browser$cache$ttl$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$browser$check$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$browser$check$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_browser_check;
    };
}
export interface Response$zone$settings$get$browser$check$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$browser$check$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$browser$check$setting {
    "application/json": {
        value: Schemas.zones_browser_check_value;
    };
}
export interface Response$zone$settings$change$browser$check$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_browser_check;
    };
}
export interface Response$zone$settings$change$browser$check$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$cache$level$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$cache$level$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_cache_level;
    };
}
export interface Response$zone$settings$get$cache$level$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$cache$level$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$cache$level$setting {
    "application/json": {
        value: Schemas.zones_cache_level_value;
    };
}
export interface Response$zone$settings$change$cache$level$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_cache_level;
    };
}
export interface Response$zone$settings$change$cache$level$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$challenge$ttl$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$challenge$ttl$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_challenge_ttl;
    };
}
export interface Response$zone$settings$get$challenge$ttl$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$challenge$ttl$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$challenge$ttl$setting {
    "application/json": {
        value: Schemas.zones_challenge_ttl_value;
    };
}
export interface Response$zone$settings$change$challenge$ttl$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_challenge_ttl;
    };
}
export interface Response$zone$settings$change$challenge$ttl$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$ciphers$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$ciphers$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ciphers;
    };
}
export interface Response$zone$settings$get$ciphers$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$ciphers$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$ciphers$setting {
    "application/json": {
        value: Schemas.zones_ciphers_value;
    };
}
export interface Response$zone$settings$change$ciphers$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ciphers;
    };
}
export interface Response$zone$settings$change$ciphers$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$development$mode$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$development$mode$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_development_mode;
    };
}
export interface Response$zone$settings$get$development$mode$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$development$mode$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$development$mode$setting {
    "application/json": {
        value: Schemas.zones_development_mode_value;
    };
}
export interface Response$zone$settings$change$development$mode$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_development_mode;
    };
}
export interface Response$zone$settings$change$development$mode$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$early$hints$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$early$hints$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_early_hints;
    };
}
export interface Response$zone$settings$get$early$hints$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$early$hints$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$early$hints$setting {
    "application/json": {
        value: Schemas.zones_early_hints_value;
    };
}
export interface Response$zone$settings$change$early$hints$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_early_hints;
    };
}
export interface Response$zone$settings$change$early$hints$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$email$obfuscation$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$email$obfuscation$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_email_obfuscation;
    };
}
export interface Response$zone$settings$get$email$obfuscation$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$email$obfuscation$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$email$obfuscation$setting {
    "application/json": {
        value: Schemas.zones_email_obfuscation_value;
    };
}
export interface Response$zone$settings$change$email$obfuscation$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_email_obfuscation;
    };
}
export interface Response$zone$settings$change$email$obfuscation$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$fonts$setting {
    zone_id: Schemas.speed_identifier;
}
export interface Response$zone$settings$get$fonts$setting$Status$200 {
    "application/json": Schemas.speed_api$response$common & {
        result?: Schemas.speed_cloudflare_fonts;
    };
}
export interface Response$zone$settings$get$fonts$setting$Status$4XX {
    "application/json": Schemas.speed_api$response$common$failure;
}
export interface Parameter$zone$settings$change$fonts$setting {
    zone_id: Schemas.speed_identifier;
}
export interface RequestBody$zone$settings$change$fonts$setting {
    "application/json": {
        value: Schemas.speed_cloudflare_fonts_value;
    };
}
export interface Response$zone$settings$change$fonts$setting$Status$200 {
    "application/json": Schemas.speed_api$response$common & {
        result?: Schemas.speed_cloudflare_fonts;
    };
}
export interface Response$zone$settings$change$fonts$setting$Status$4XX {
    "application/json": Schemas.speed_api$response$common$failure;
}
export interface Parameter$zone$settings$get$h2_prioritization$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$h2_prioritization$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_h2_prioritization;
    };
}
export interface Response$zone$settings$get$h2_prioritization$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$h2_prioritization$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$h2_prioritization$setting {
    "application/json": {
        value: Schemas.zones_h2_prioritization;
    };
}
export interface Response$zone$settings$change$h2_prioritization$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_h2_prioritization;
    };
}
export interface Response$zone$settings$change$h2_prioritization$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$hotlink$protection$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$hotlink$protection$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_hotlink_protection;
    };
}
export interface Response$zone$settings$get$hotlink$protection$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$hotlink$protection$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$hotlink$protection$setting {
    "application/json": {
        value: Schemas.zones_hotlink_protection_value;
    };
}
export interface Response$zone$settings$change$hotlink$protection$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_hotlink_protection;
    };
}
export interface Response$zone$settings$change$hotlink$protection$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$h$t$t$p$2$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$h$t$t$p$2$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_http2;
    };
}
export interface Response$zone$settings$get$h$t$t$p$2$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$h$t$t$p$2$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$h$t$t$p$2$setting {
    "application/json": {
        value: Schemas.zones_http2_value;
    };
}
export interface Response$zone$settings$change$h$t$t$p$2$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_http2;
    };
}
export interface Response$zone$settings$change$h$t$t$p$2$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$h$t$t$p$3$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$h$t$t$p$3$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_http3;
    };
}
export interface Response$zone$settings$get$h$t$t$p$3$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$h$t$t$p$3$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$h$t$t$p$3$setting {
    "application/json": {
        value: Schemas.zones_http3_value;
    };
}
export interface Response$zone$settings$change$h$t$t$p$3$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_http3;
    };
}
export interface Response$zone$settings$change$h$t$t$p$3$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$image_resizing$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$image_resizing$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_image_resizing;
    };
}
export interface Response$zone$settings$get$image_resizing$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$image_resizing$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$image_resizing$setting {
    "application/json": {
        value: Schemas.zones_image_resizing;
    };
}
export interface Response$zone$settings$change$image_resizing$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_image_resizing;
    };
}
export interface Response$zone$settings$change$image_resizing$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$ip$geolocation$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$ip$geolocation$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ip_geolocation;
    };
}
export interface Response$zone$settings$get$ip$geolocation$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$ip$geolocation$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$ip$geolocation$setting {
    "application/json": {
        value: Schemas.zones_ip_geolocation_value;
    };
}
export interface Response$zone$settings$change$ip$geolocation$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ip_geolocation;
    };
}
export interface Response$zone$settings$change$ip$geolocation$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$i$pv6$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$i$pv6$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ipv6;
    };
}
export interface Response$zone$settings$get$i$pv6$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$i$pv6$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$i$pv6$setting {
    "application/json": {
        value: Schemas.zones_ipv6_value;
    };
}
export interface Response$zone$settings$change$i$pv6$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ipv6;
    };
}
export interface Response$zone$settings$change$i$pv6$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$minimum$tls$version$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$minimum$tls$version$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_min_tls_version;
    };
}
export interface Response$zone$settings$get$minimum$tls$version$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$minimum$tls$version$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$minimum$tls$version$setting {
    "application/json": {
        value: Schemas.zones_min_tls_version_value;
    };
}
export interface Response$zone$settings$change$minimum$tls$version$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_min_tls_version;
    };
}
export interface Response$zone$settings$change$minimum$tls$version$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$minify$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$minify$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_minify;
    };
}
export interface Response$zone$settings$get$minify$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$minify$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$minify$setting {
    "application/json": {
        value: Schemas.zones_minify_value;
    };
}
export interface Response$zone$settings$change$minify$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_minify;
    };
}
export interface Response$zone$settings$change$minify$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$mirage$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$mirage$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_mirage;
    };
}
export interface Response$zone$settings$get$mirage$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$web$mirage$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$web$mirage$setting {
    "application/json": {
        value: Schemas.zones_mirage_value;
    };
}
export interface Response$zone$settings$change$web$mirage$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_mirage;
    };
}
export interface Response$zone$settings$change$web$mirage$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$mobile$redirect$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$mobile$redirect$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_mobile_redirect;
    };
}
export interface Response$zone$settings$get$mobile$redirect$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$mobile$redirect$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$mobile$redirect$setting {
    "application/json": {
        value: Schemas.zones_mobile_redirect_value;
    };
}
export interface Response$zone$settings$change$mobile$redirect$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_mobile_redirect;
    };
}
export interface Response$zone$settings$change$mobile$redirect$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$nel$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$nel$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_nel;
    };
}
export interface Response$zone$settings$get$nel$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$nel$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$nel$setting {
    "application/json": {
        value: Schemas.zones_nel;
    };
}
export interface Response$zone$settings$change$nel$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_nel;
    };
}
export interface Response$zone$settings$change$nel$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$opportunistic$encryption$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$opportunistic$encryption$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_opportunistic_encryption;
    };
}
export interface Response$zone$settings$get$opportunistic$encryption$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$opportunistic$encryption$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$opportunistic$encryption$setting {
    "application/json": {
        value: Schemas.zones_opportunistic_encryption_value;
    };
}
export interface Response$zone$settings$change$opportunistic$encryption$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_opportunistic_encryption;
    };
}
export interface Response$zone$settings$change$opportunistic$encryption$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$opportunistic$onion$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$opportunistic$onion$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_opportunistic_onion;
    };
}
export interface Response$zone$settings$get$opportunistic$onion$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$opportunistic$onion$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$opportunistic$onion$setting {
    "application/json": {
        value: Schemas.zones_opportunistic_onion_value;
    };
}
export interface Response$zone$settings$change$opportunistic$onion$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_opportunistic_onion;
    };
}
export interface Response$zone$settings$change$opportunistic$onion$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$orange_to_orange$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$orange_to_orange$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_orange_to_orange;
    };
}
export interface Response$zone$settings$get$orange_to_orange$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$orange_to_orange$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$orange_to_orange$setting {
    "application/json": {
        value: Schemas.zones_orange_to_orange;
    };
}
export interface Response$zone$settings$change$orange_to_orange$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_orange_to_orange;
    };
}
export interface Response$zone$settings$change$orange_to_orange$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$enable$error$pages$on$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$enable$error$pages$on$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_origin_error_page_pass_thru;
    };
}
export interface Response$zone$settings$get$enable$error$pages$on$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$enable$error$pages$on$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$enable$error$pages$on$setting {
    "application/json": {
        value: Schemas.zones_origin_error_page_pass_thru_value;
    };
}
export interface Response$zone$settings$change$enable$error$pages$on$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_origin_error_page_pass_thru;
    };
}
export interface Response$zone$settings$change$enable$error$pages$on$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$polish$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$polish$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_polish;
    };
}
export interface Response$zone$settings$get$polish$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$polish$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$polish$setting {
    "application/json": {
        value: Schemas.zones_polish;
    };
}
export interface Response$zone$settings$change$polish$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_polish;
    };
}
export interface Response$zone$settings$change$polish$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$prefetch$preload$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$prefetch$preload$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_prefetch_preload;
    };
}
export interface Response$zone$settings$get$prefetch$preload$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$prefetch$preload$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$prefetch$preload$setting {
    "application/json": {
        value: Schemas.zones_prefetch_preload_value;
    };
}
export interface Response$zone$settings$change$prefetch$preload$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_prefetch_preload;
    };
}
export interface Response$zone$settings$change$prefetch$preload$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$proxy_read_timeout$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$proxy_read_timeout$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_proxy_read_timeout;
    };
}
export interface Response$zone$settings$get$proxy_read_timeout$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$proxy_read_timeout$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$proxy_read_timeout$setting {
    "application/json": {
        value: Schemas.zones_proxy_read_timeout;
    };
}
export interface Response$zone$settings$change$proxy_read_timeout$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_proxy_read_timeout;
    };
}
export interface Response$zone$settings$change$proxy_read_timeout$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$pseudo$i$pv4$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$pseudo$i$pv4$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_pseudo_ipv4;
    };
}
export interface Response$zone$settings$get$pseudo$i$pv4$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$pseudo$i$pv4$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$pseudo$i$pv4$setting {
    "application/json": {
        value: Schemas.zones_pseudo_ipv4_value;
    };
}
export interface Response$zone$settings$change$pseudo$i$pv4$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_pseudo_ipv4;
    };
}
export interface Response$zone$settings$change$pseudo$i$pv4$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$response$buffering$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$response$buffering$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_response_buffering;
    };
}
export interface Response$zone$settings$get$response$buffering$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$response$buffering$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$response$buffering$setting {
    "application/json": {
        value: Schemas.zones_response_buffering_value;
    };
}
export interface Response$zone$settings$change$response$buffering$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_response_buffering;
    };
}
export interface Response$zone$settings$change$response$buffering$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$rocket_loader$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$rocket_loader$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_rocket_loader;
    };
}
export interface Response$zone$settings$get$rocket_loader$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$rocket_loader$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$rocket_loader$setting {
    "application/json": {
        value: Schemas.zones_rocket_loader;
    };
}
export interface Response$zone$settings$change$rocket_loader$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_rocket_loader;
    };
}
export interface Response$zone$settings$change$rocket_loader$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$security$header$$$hsts$$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$security$header$$$hsts$$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_security_header;
    };
}
export interface Response$zone$settings$get$security$header$$$hsts$$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$security$header$$$hsts$$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$security$header$$$hsts$$setting {
    "application/json": {
        value: Schemas.zones_security_header_value;
    };
}
export interface Response$zone$settings$change$security$header$$$hsts$$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_security_header;
    };
}
export interface Response$zone$settings$change$security$header$$$hsts$$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$security$level$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$security$level$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_security_level;
    };
}
export interface Response$zone$settings$get$security$level$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$security$level$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$security$level$setting {
    "application/json": {
        value: Schemas.zones_security_level_value;
    };
}
export interface Response$zone$settings$change$security$level$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_security_level;
    };
}
export interface Response$zone$settings$change$security$level$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$server$side$exclude$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$server$side$exclude$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_server_side_exclude;
    };
}
export interface Response$zone$settings$get$server$side$exclude$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$server$side$exclude$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$server$side$exclude$setting {
    "application/json": {
        value: Schemas.zones_server_side_exclude_value;
    };
}
export interface Response$zone$settings$change$server$side$exclude$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_server_side_exclude;
    };
}
export interface Response$zone$settings$change$server$side$exclude$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$enable$query$string$sort$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$enable$query$string$sort$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_sort_query_string_for_cache;
    };
}
export interface Response$zone$settings$get$enable$query$string$sort$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$enable$query$string$sort$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$enable$query$string$sort$setting {
    "application/json": {
        value: Schemas.zones_sort_query_string_for_cache_value;
    };
}
export interface Response$zone$settings$change$enable$query$string$sort$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_sort_query_string_for_cache;
    };
}
export interface Response$zone$settings$change$enable$query$string$sort$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$ssl$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$ssl$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ssl;
    };
}
export interface Response$zone$settings$get$ssl$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$ssl$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$ssl$setting {
    "application/json": {
        value: Schemas.zones_ssl_value;
    };
}
export interface Response$zone$settings$change$ssl$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ssl;
    };
}
export interface Response$zone$settings$change$ssl$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$ssl_recommender$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$ssl_recommender$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ssl_recommender;
    };
}
export interface Response$zone$settings$get$ssl_recommender$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$ssl_recommender$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$ssl_recommender$setting {
    "application/json": {
        value: Schemas.zones_ssl_recommender;
    };
}
export interface Response$zone$settings$change$ssl_recommender$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_ssl_recommender;
    };
}
export interface Response$zone$settings$change$ssl_recommender$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_tls_1_3;
    };
}
export interface Response$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$tls$1$$3$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$tls$1$$3$setting {
    "application/json": {
        value: Schemas.zones_tls_1_3_value;
    };
}
export interface Response$zone$settings$change$tls$1$$3$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_tls_1_3;
    };
}
export interface Response$zone$settings$change$tls$1$$3$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$tls$client$auth$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$tls$client$auth$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_tls_client_auth;
    };
}
export interface Response$zone$settings$get$tls$client$auth$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$tls$client$auth$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$tls$client$auth$setting {
    "application/json": {
        value: Schemas.zones_tls_client_auth_value;
    };
}
export interface Response$zone$settings$change$tls$client$auth$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_tls_client_auth;
    };
}
export interface Response$zone$settings$change$tls$client$auth$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$true$client$ip$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$true$client$ip$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_true_client_ip_header;
    };
}
export interface Response$zone$settings$get$true$client$ip$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$true$client$ip$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$true$client$ip$setting {
    "application/json": {
        value: Schemas.zones_true_client_ip_header_value;
    };
}
export interface Response$zone$settings$change$true$client$ip$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_true_client_ip_header;
    };
}
export interface Response$zone$settings$change$true$client$ip$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$web$application$firewall$$$waf$$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$web$application$firewall$$$waf$$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_waf;
    };
}
export interface Response$zone$settings$get$web$application$firewall$$$waf$$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$web$application$firewall$$$waf$$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$web$application$firewall$$$waf$$setting {
    "application/json": {
        value: Schemas.zones_waf_value;
    };
}
export interface Response$zone$settings$change$web$application$firewall$$$waf$$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_waf;
    };
}
export interface Response$zone$settings$change$web$application$firewall$$$waf$$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$web$p$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$web$p$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_webp;
    };
}
export interface Response$zone$settings$get$web$p$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$web$p$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$web$p$setting {
    "application/json": {
        value: Schemas.zones_webp_value;
    };
}
export interface Response$zone$settings$change$web$p$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_webp;
    };
}
export interface Response$zone$settings$change$web$p$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$get$web$sockets$setting {
    zone_id: Schemas.zones_identifier;
}
export interface Response$zone$settings$get$web$sockets$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_websockets;
    };
}
export interface Response$zone$settings$get$web$sockets$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$zone$settings$change$web$sockets$setting {
    zone_id: Schemas.zones_identifier;
}
export interface RequestBody$zone$settings$change$web$sockets$setting {
    "application/json": {
        value: Schemas.zones_websockets_value;
    };
}
export interface Response$zone$settings$change$web$sockets$setting$Status$200 {
    "application/json": Schemas.zones_zone_settings_response_single & {
        result?: Schemas.zones_websockets;
    };
}
export interface Response$zone$settings$change$web$sockets$setting$Status$4XX {
    "application/json": Schemas.zones_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$zaraz$config {
    zone_id: Schemas.zaraz_identifier;
}
export interface Response$get$zones$zone_identifier$zaraz$config$Status$200 {
    "application/json": Schemas.zaraz_zaraz$config$response;
}
export interface Response$get$zones$zone_identifier$zaraz$config$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$put$zones$zone_identifier$zaraz$config {
    zone_id: Schemas.zaraz_identifier;
}
export interface RequestBody$put$zones$zone_identifier$zaraz$config {
    "application/json": Schemas.zaraz_zaraz$config$body;
}
export interface Response$put$zones$zone_identifier$zaraz$config$Status$200 {
    "application/json": Schemas.zaraz_zaraz$config$response;
}
export interface Response$put$zones$zone_identifier$zaraz$config$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$zaraz$default {
    zone_id: Schemas.zaraz_identifier;
}
export interface Response$get$zones$zone_identifier$zaraz$default$Status$200 {
    "application/json": Schemas.zaraz_zaraz$config$response;
}
export interface Response$get$zones$zone_identifier$zaraz$default$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$zaraz$export {
    zone_id: Schemas.zaraz_identifier;
}
export interface Response$get$zones$zone_identifier$zaraz$export$Status$200 {
    "application/json": Schemas.zaraz_zaraz$config$return;
}
export interface Response$get$zones$zone_identifier$zaraz$export$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$zaraz$history {
    zone_id: Schemas.zaraz_identifier;
    /** Ordinal number to start listing the results with. Default value is 0. */
    offset?: number;
    /** Maximum amount of results to list. Default value is 10. */
    limit?: number;
    /** The field to sort by. Default is updated_at. */
    sortField?: "id" | "user_id" | "description" | "created_at" | "updated_at";
    /** Sorting order. Default is DESC. */
    sortOrder?: "DESC" | "ASC";
}
export interface Response$get$zones$zone_identifier$zaraz$history$Status$200 {
    "application/json": Schemas.zaraz_zaraz$history$response;
}
export interface Response$get$zones$zone_identifier$zaraz$history$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$put$zones$zone_identifier$zaraz$history {
    zone_id: Schemas.zaraz_identifier;
}
export interface RequestBody$put$zones$zone_identifier$zaraz$history {
    /** ID of the Zaraz configuration to restore. */
    "application/json": number;
}
export interface Response$put$zones$zone_identifier$zaraz$history$Status$200 {
    "application/json": Schemas.zaraz_zaraz$config$response;
}
export interface Response$put$zones$zone_identifier$zaraz$history$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$zaraz$config$history {
    zone_id: Schemas.zaraz_identifier;
    /** Comma separated list of Zaraz configuration IDs */
    ids: number[];
}
export interface Response$get$zones$zone_identifier$zaraz$config$history$Status$200 {
    "application/json": Schemas.zaraz_zaraz$config$history$response;
}
export interface Response$get$zones$zone_identifier$zaraz$config$history$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$post$zones$zone_identifier$zaraz$publish {
    zone_id: Schemas.zaraz_identifier;
}
export interface RequestBody$post$zones$zone_identifier$zaraz$publish {
    /** Zaraz configuration description. */
    "application/json": string;
}
export interface Response$post$zones$zone_identifier$zaraz$publish$Status$200 {
    "application/json": Schemas.zaraz_api$response$common & {
        result?: string;
    };
}
export interface Response$post$zones$zone_identifier$zaraz$publish$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$get$zones$zone_identifier$zaraz$workflow {
    zone_id: Schemas.zaraz_identifier;
}
export interface Response$get$zones$zone_identifier$zaraz$workflow$Status$200 {
    "application/json": Schemas.zaraz_zaraz$workflow$response;
}
export interface Response$get$zones$zone_identifier$zaraz$workflow$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$put$zones$zone_identifier$zaraz$workflow {
    zone_id: Schemas.zaraz_identifier;
}
export interface RequestBody$put$zones$zone_identifier$zaraz$workflow {
    "application/json": Schemas.zaraz_zaraz$workflow;
}
export interface Response$put$zones$zone_identifier$zaraz$workflow$Status$200 {
    "application/json": Schemas.zaraz_zaraz$workflow$response;
}
export interface Response$put$zones$zone_identifier$zaraz$workflow$Status$4XX {
    "application/json": Schemas.zaraz_api$response$common$failure;
}
export interface Parameter$speed$get$availabilities {
    zone_id: Schemas.observatory_identifier;
}
export interface Response$speed$get$availabilities$Status$200 {
    "application/json": Schemas.observatory_availabilities$response;
}
export interface Response$speed$get$availabilities$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$list$pages {
    zone_id: Schemas.observatory_identifier;
}
export interface Response$speed$list$pages$Status$200 {
    "application/json": Schemas.observatory_pages$response$collection;
}
export interface Response$speed$list$pages$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$list$test$history {
    zone_id: Schemas.observatory_identifier;
    url: Schemas.observatory_url;
    page?: number;
    per_page?: number;
    region?: Schemas.observatory_region;
}
export interface Response$speed$list$test$history$Status$200 {
    "application/json": Schemas.observatory_page$test$response$collection;
}
export interface Response$speed$list$test$history$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$create$test {
    zone_id: Schemas.observatory_identifier;
    url: Schemas.observatory_url;
}
export interface RequestBody$speed$create$test {
    "application/json": {
        region?: Schemas.observatory_region;
    };
}
export interface Response$speed$create$test$Status$200 {
    "application/json": Schemas.observatory_page$test$response$single;
}
export interface Response$speed$create$test$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$delete$tests {
    zone_id: Schemas.observatory_identifier;
    url: Schemas.observatory_url;
    region?: Schemas.observatory_region;
}
export interface Response$speed$delete$tests$Status$200 {
    "application/json": Schemas.observatory_count$response;
}
export interface Response$speed$delete$tests$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$get$test {
    zone_id: Schemas.observatory_identifier;
    url: Schemas.observatory_url;
    test_id: string;
}
export interface Response$speed$get$test$Status$200 {
    "application/json": Schemas.observatory_page$test$response$single;
}
export interface Response$speed$get$test$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$list$page$trend {
    zone_id: Schemas.observatory_identifier;
    url: Schemas.observatory_url;
    region: Schemas.observatory_region;
    deviceType: Schemas.observatory_device_type;
    start: Schemas.observatory_timestamp;
    end?: Schemas.observatory_timestamp;
    /** The timezone of the start and end timestamps. */
    tz: string;
    /** A comma-separated list of metrics to include in the results. */
    metrics: string;
}
export interface Response$speed$list$page$trend$Status$200 {
    "application/json": Schemas.observatory_trend$response;
}
export interface Response$speed$list$page$trend$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$get$scheduled$test {
    zone_id: Schemas.observatory_identifier;
    url: Schemas.observatory_url;
    region?: Schemas.observatory_region;
}
export interface Response$speed$get$scheduled$test$Status$200 {
    "application/json": Schemas.observatory_schedule$response$single;
}
export interface Response$speed$get$scheduled$test$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$create$scheduled$test {
    zone_id: Schemas.observatory_identifier;
    url: Schemas.observatory_url;
    region?: Schemas.observatory_region;
}
export interface Response$speed$create$scheduled$test$Status$200 {
    "application/json": Schemas.observatory_create$schedule$response;
}
export interface Response$speed$create$scheduled$test$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$speed$delete$test$schedule {
    zone_id: Schemas.observatory_identifier;
    url: Schemas.observatory_url;
    region?: Schemas.observatory_region;
}
export interface Response$speed$delete$test$schedule$Status$200 {
    "application/json": Schemas.observatory_count$response;
}
export interface Response$speed$delete$test$schedule$Status$4XX {
    "application/json": Schemas.observatory_api$response$common$failure;
}
export interface Parameter$url$normalization$get$url$normalization$settings {
    zone_id: Schemas.rulesets_identifier;
}
export interface Response$url$normalization$get$url$normalization$settings$Status$200 {
    "application/json": Schemas.rulesets_schemas$response_model;
}
export interface Response$url$normalization$get$url$normalization$settings$Status$4XX {
    "application/json": Schemas.rulesets_schemas$response_model & Schemas.rulesets_api$response$common$failure;
}
export interface Parameter$url$normalization$update$url$normalization$settings {
    zone_id: Schemas.rulesets_identifier;
}
export interface RequestBody$url$normalization$update$url$normalization$settings {
    "application/json": Schemas.rulesets_schemas$request_model;
}
export interface Response$url$normalization$update$url$normalization$settings$Status$200 {
    "application/json": Schemas.rulesets_schemas$response_model;
}
export interface Response$url$normalization$update$url$normalization$settings$Status$4XX {
    "application/json": Schemas.rulesets_schemas$response_model & Schemas.rulesets_api$response$common$failure;
}
export interface Parameter$worker$filters$$$deprecated$$list$filters {
    zone_id: Schemas.workers_identifier;
}
export interface Response$worker$filters$$$deprecated$$list$filters$Status$200 {
    "application/json": Schemas.workers_filter$response$collection;
}
export interface Response$worker$filters$$$deprecated$$list$filters$Status$4XX {
    "application/json": Schemas.workers_filter$response$collection & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$filters$$$deprecated$$create$filter {
    zone_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$filters$$$deprecated$$create$filter {
    "application/json": Schemas.workers_filter$no$id;
}
export interface Response$worker$filters$$$deprecated$$create$filter$Status$200 {
    "application/json": Schemas.workers_api$response$single$id;
}
export interface Response$worker$filters$$$deprecated$$create$filter$Status$4XX {
    "application/json": Schemas.workers_api$response$single$id & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$filters$$$deprecated$$update$filter {
    filter_id: Schemas.workers_identifier;
    zone_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$filters$$$deprecated$$update$filter {
    "application/json": Schemas.workers_filter$no$id;
}
export interface Response$worker$filters$$$deprecated$$update$filter$Status$200 {
    "application/json": Schemas.workers_filter$response$single;
}
export interface Response$worker$filters$$$deprecated$$update$filter$Status$4XX {
    "application/json": Schemas.workers_filter$response$single & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$filters$$$deprecated$$delete$filter {
    filter_id: Schemas.workers_identifier;
    zone_id: Schemas.workers_identifier;
}
export interface Response$worker$filters$$$deprecated$$delete$filter$Status$200 {
    "application/json": Schemas.workers_api$response$single$id;
}
export interface Response$worker$filters$$$deprecated$$delete$filter$Status$4XX {
    "application/json": Schemas.workers_api$response$single$id & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$routes$list$routes {
    zone_id: Schemas.workers_identifier;
}
export interface Response$worker$routes$list$routes$Status$200 {
    "application/json": Schemas.workers_route$response$collection;
}
export interface Response$worker$routes$list$routes$Status$4XX {
    "application/json": Schemas.workers_route$response$collection & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$routes$create$route {
    zone_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$routes$create$route {
    "application/json": Schemas.workers_route$no$id;
}
export interface Response$worker$routes$create$route$Status$200 {
    "application/json": Schemas.workers_api$response$single;
}
export interface Response$worker$routes$create$route$Status$4XX {
    "application/json": Schemas.workers_api$response$single & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$routes$get$route {
    route_id: Schemas.workers_identifier;
    zone_id: Schemas.workers_identifier;
}
export interface Response$worker$routes$get$route$Status$200 {
    "application/json": Schemas.workers_route$response$single;
}
export interface Response$worker$routes$get$route$Status$4XX {
    "application/json": Schemas.workers_route$response$single & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$routes$update$route {
    route_id: Schemas.workers_identifier;
    zone_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$routes$update$route {
    "application/json": Schemas.workers_route$no$id;
}
export interface Response$worker$routes$update$route$Status$200 {
    "application/json": Schemas.workers_route$response$single;
}
export interface Response$worker$routes$update$route$Status$4XX {
    "application/json": Schemas.workers_route$response$single & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$routes$delete$route {
    route_id: Schemas.workers_identifier;
    zone_id: Schemas.workers_identifier;
}
export interface Response$worker$routes$delete$route$Status$200 {
    "application/json": Schemas.workers_api$response$single;
}
export interface Response$worker$routes$delete$route$Status$4XX {
    "application/json": Schemas.workers_api$response$single & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$$$deprecated$$download$worker {
    zone_id: Schemas.workers_identifier;
}
export interface Response$worker$script$$$deprecated$$download$worker$Status$200 {
    undefined: any;
}
export interface Response$worker$script$$$deprecated$$download$worker$Status$4XX {
    undefined: any;
}
export interface Parameter$worker$script$$$deprecated$$upload$worker {
    zone_id: Schemas.workers_identifier;
}
export interface RequestBody$worker$script$$$deprecated$$upload$worker {
    "application/javascript": any;
}
export interface Response$worker$script$$$deprecated$$upload$worker$Status$200 {
    "application/json": Schemas.workers_schemas$script$response$single;
}
export interface Response$worker$script$$$deprecated$$upload$worker$Status$4XX {
    "application/json": Schemas.workers_schemas$script$response$single & Schemas.workers_api$response$common$failure;
}
export interface Parameter$worker$script$$$deprecated$$delete$worker {
    zone_id: Schemas.workers_identifier;
}
export interface Response$worker$script$$$deprecated$$delete$worker$Status$200 {
}
export interface Response$worker$script$$$deprecated$$delete$worker$Status$4XX {
}
export interface Parameter$worker$binding$$$deprecated$$list$bindings {
    zone_id: Schemas.workers_identifier;
}
export interface Response$worker$binding$$$deprecated$$list$bindings$Status$200 {
    "application/json": Schemas.workers_api$response$common & {
        result?: Schemas.workers_schemas$binding[];
    };
}
export interface Response$worker$binding$$$deprecated$$list$bindings$Status$4XX {
    "application/json": (Schemas.workers_api$response$common & {
        result?: Schemas.workers_schemas$binding[];
    }) & Schemas.workers_api$response$common$failure;
}
export interface Parameter$total$tls$total$tls$settings$details {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$total$tls$total$tls$settings$details$Status$200 {
    "application/json": Schemas.ApQU2qAj_total_tls_settings_response;
}
export interface Response$total$tls$total$tls$settings$details$Status$4XX {
    "application/json": Schemas.ApQU2qAj_total_tls_settings_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$total$tls$enable$or$disable$total$tls {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$total$tls$enable$or$disable$total$tls {
    "application/json": {
        certificate_authority?: Schemas.ApQU2qAj_components$schemas$certificate_authority;
        enabled: Schemas.ApQU2qAj_components$schemas$enabled;
    };
}
export interface Response$total$tls$enable$or$disable$total$tls$Status$200 {
    "application/json": Schemas.ApQU2qAj_total_tls_settings_response;
}
export interface Response$total$tls$enable$or$disable$total$tls$Status$4XX {
    "application/json": Schemas.ApQU2qAj_total_tls_settings_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$zone$analytics$$$deprecated$$get$analytics$by$co$locations {
    zone_identifier: Schemas.dFBpZBFx_identifier;
    until?: Schemas.dFBpZBFx_until;
    since?: string | number;
    continuous?: boolean;
}
export interface Response$zone$analytics$$$deprecated$$get$analytics$by$co$locations$Status$200 {
    "application/json": Schemas.dFBpZBFx_colo_response;
}
export interface Response$zone$analytics$$$deprecated$$get$analytics$by$co$locations$Status$4XX {
    "application/json": Schemas.dFBpZBFx_colo_response & Schemas.dFBpZBFx_api$response$common$failure;
}
export interface Parameter$zone$analytics$$$deprecated$$get$dashboard {
    zone_identifier: Schemas.dFBpZBFx_identifier;
    until?: Schemas.dFBpZBFx_until;
    since?: string | number;
    continuous?: boolean;
}
export interface Response$zone$analytics$$$deprecated$$get$dashboard$Status$200 {
    "application/json": Schemas.dFBpZBFx_dashboard_response;
}
export interface Response$zone$analytics$$$deprecated$$get$dashboard$Status$4XX {
    "application/json": Schemas.dFBpZBFx_dashboard_response & Schemas.dFBpZBFx_api$response$common$failure;
}
export interface Parameter$zone$rate$plan$list$available$plans {
    zone_identifier: Schemas.bill$subs$api_identifier;
}
export interface Response$zone$rate$plan$list$available$plans$Status$200 {
    "application/json": Schemas.bill$subs$api_api$response$collection & {
        result?: Schemas.bill$subs$api_available$rate$plan[];
    };
}
export interface Response$zone$rate$plan$list$available$plans$Status$4XX {
    "application/json": (Schemas.bill$subs$api_api$response$collection & {
        result?: Schemas.bill$subs$api_available$rate$plan[];
    }) & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$zone$rate$plan$available$plan$details {
    plan_identifier: Schemas.bill$subs$api_identifier;
    zone_identifier: Schemas.bill$subs$api_identifier;
}
export interface Response$zone$rate$plan$available$plan$details$Status$200 {
    "application/json": Schemas.bill$subs$api_api$response$single & {
        result?: Schemas.bill$subs$api_available$rate$plan;
    };
}
export interface Response$zone$rate$plan$available$plan$details$Status$4XX {
    "application/json": (Schemas.bill$subs$api_api$response$single & {
        result?: Schemas.bill$subs$api_available$rate$plan;
    }) & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$zone$rate$plan$list$available$rate$plans {
    zone_identifier: Schemas.bill$subs$api_identifier;
}
export interface Response$zone$rate$plan$list$available$rate$plans$Status$200 {
    "application/json": Schemas.bill$subs$api_plan_response_collection;
}
export interface Response$zone$rate$plan$list$available$rate$plans$Status$4XX {
    "application/json": Schemas.bill$subs$api_plan_response_collection & Schemas.bill$subs$api_api$response$common$failure;
}
export interface Parameter$client$certificate$for$a$zone$list$hostname$associations {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    mtls_certificate_id?: string;
}
export interface Response$client$certificate$for$a$zone$list$hostname$associations$Status$200 {
    "application/json": Schemas.ApQU2qAj_hostname_associations_response;
}
export interface Response$client$certificate$for$a$zone$list$hostname$associations$Status$4xx {
    "application/json": Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$client$certificate$for$a$zone$put$hostname$associations {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$client$certificate$for$a$zone$put$hostname$associations {
    "application/json": Schemas.ApQU2qAj_hostname_association;
}
export interface Response$client$certificate$for$a$zone$put$hostname$associations$Status$200 {
    "application/json": Schemas.ApQU2qAj_hostname_associations_response;
}
export interface Response$client$certificate$for$a$zone$put$hostname$associations$Status$4xx {
    "application/json": Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$client$certificate$for$a$zone$list$client$certificates {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    status?: "all" | "active" | "pending_reactivation" | "pending_revocation" | "revoked";
    page?: number;
    per_page?: number;
    limit?: number;
    offset?: number;
}
export interface Response$client$certificate$for$a$zone$list$client$certificates$Status$200 {
    "application/json": Schemas.ApQU2qAj_client_certificate_response_collection;
}
export interface Response$client$certificate$for$a$zone$list$client$certificates$Status$4xx {
    "application/json": Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$client$certificate$for$a$zone$create$client$certificate {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$client$certificate$for$a$zone$create$client$certificate {
    "application/json": {
        csr: Schemas.ApQU2qAj_schemas$csr;
        validity_days: Schemas.ApQU2qAj_components$schemas$validity_days;
    };
}
export interface Response$client$certificate$for$a$zone$create$client$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_client_certificate_response_single;
}
export interface Response$client$certificate$for$a$zone$create$client$certificate$Status$4xx {
    "application/json": Schemas.ApQU2qAj_client_certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$client$certificate$for$a$zone$client$certificate$details {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    client_certificate_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$client$certificate$for$a$zone$client$certificate$details$Status$200 {
    "application/json": Schemas.ApQU2qAj_client_certificate_response_single;
}
export interface Response$client$certificate$for$a$zone$client$certificate$details$Status$4xx {
    "application/json": Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$client$certificate$for$a$zone$delete$client$certificate {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    client_certificate_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$client$certificate$for$a$zone$delete$client$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_client_certificate_response_single;
}
export interface Response$client$certificate$for$a$zone$delete$client$certificate$Status$4xx {
    "application/json": Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$client$certificate$for$a$zone$edit$client$certificate {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    client_certificate_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$client$certificate$for$a$zone$edit$client$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_client_certificate_response_single;
}
export interface Response$client$certificate$for$a$zone$edit$client$certificate$Status$4xx {
    "application/json": Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$ssl$for$a$zone$list$ssl$configurations {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    page?: number;
    per_page?: number;
    match?: "any" | "all";
    status?: "active" | "expired" | "deleted" | "pending" | "initializing";
}
export interface Response$custom$ssl$for$a$zone$list$ssl$configurations$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_collection;
}
export interface Response$custom$ssl$for$a$zone$list$ssl$configurations$Status$4xx {
    "application/json": Schemas.ApQU2qAj_certificate_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$ssl$for$a$zone$create$ssl$configuration {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$custom$ssl$for$a$zone$create$ssl$configuration {
    "application/json": {
        bundle_method?: Schemas.ApQU2qAj_bundle_method;
        certificate: Schemas.ApQU2qAj_certificate;
        geo_restrictions?: Schemas.ApQU2qAj_geo_restrictions;
        policy?: Schemas.ApQU2qAj_policy;
        private_key: Schemas.ApQU2qAj_private_key;
        type?: Schemas.ApQU2qAj_type;
    };
}
export interface Response$custom$ssl$for$a$zone$create$ssl$configuration$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_single;
}
export interface Response$custom$ssl$for$a$zone$create$ssl$configuration$Status$4xx {
    "application/json": Schemas.ApQU2qAj_certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$ssl$for$a$zone$ssl$configuration$details {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$custom$ssl$for$a$zone$ssl$configuration$details$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_single;
}
export interface Response$custom$ssl$for$a$zone$ssl$configuration$details$Status$4xx {
    "application/json": Schemas.ApQU2qAj_certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$ssl$for$a$zone$delete$ssl$configuration {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$custom$ssl$for$a$zone$delete$ssl$configuration$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_id_only;
}
export interface Response$custom$ssl$for$a$zone$delete$ssl$configuration$Status$4xx {
    "application/json": Schemas.ApQU2qAj_certificate_response_id_only & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$ssl$for$a$zone$edit$ssl$configuration {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$custom$ssl$for$a$zone$edit$ssl$configuration {
    "application/json": {
        bundle_method?: Schemas.ApQU2qAj_bundle_method;
        certificate?: Schemas.ApQU2qAj_certificate;
        geo_restrictions?: Schemas.ApQU2qAj_geo_restrictions;
        policy?: Schemas.ApQU2qAj_policy;
        private_key?: Schemas.ApQU2qAj_private_key;
    };
}
export interface Response$custom$ssl$for$a$zone$edit$ssl$configuration$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_single;
}
export interface Response$custom$ssl$for$a$zone$edit$ssl$configuration$Status$4xx {
    "application/json": Schemas.ApQU2qAj_certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$ssl$for$a$zone$re$prioritize$ssl$certificates {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$custom$ssl$for$a$zone$re$prioritize$ssl$certificates {
    "application/json": {
        /** Array of ordered certificates. */
        certificates: {
            id?: Schemas.ApQU2qAj_identifier;
            priority?: Schemas.ApQU2qAj_priority;
        }[];
    };
}
export interface Response$custom$ssl$for$a$zone$re$prioritize$ssl$certificates$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_collection;
}
export interface Response$custom$ssl$for$a$zone$re$prioritize$ssl$certificates$Status$4xx {
    "application/json": Schemas.ApQU2qAj_certificate_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$hostname$for$a$zone$list$custom$hostnames {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    hostname?: string;
    id?: string;
    page?: number;
    per_page?: number;
    order?: "ssl" | "ssl_status";
    direction?: "asc" | "desc";
    ssl?: string;
}
export interface Response$custom$hostname$for$a$zone$list$custom$hostnames$Status$200 {
    "application/json": Schemas.ApQU2qAj_custom_hostname_response_collection;
}
export interface Response$custom$hostname$for$a$zone$list$custom$hostnames$Status$4XX {
    "application/json": Schemas.ApQU2qAj_custom_hostname_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$hostname$for$a$zone$create$custom$hostname {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$custom$hostname$for$a$zone$create$custom$hostname {
    "application/json": {
        custom_metadata?: Schemas.ApQU2qAj_custom_metadata;
        hostname: Schemas.ApQU2qAj_hostname_post;
        ssl: Schemas.ApQU2qAj_sslpost;
    };
}
export interface Response$custom$hostname$for$a$zone$create$custom$hostname$Status$200 {
    "application/json": Schemas.ApQU2qAj_custom_hostname_response_single;
}
export interface Response$custom$hostname$for$a$zone$create$custom$hostname$Status$4XX {
    "application/json": Schemas.ApQU2qAj_custom_hostname_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$hostname$for$a$zone$custom$hostname$details {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$custom$hostname$for$a$zone$custom$hostname$details$Status$200 {
    "application/json": Schemas.ApQU2qAj_custom_hostname_response_single;
}
export interface Response$custom$hostname$for$a$zone$custom$hostname$details$Status$4XX {
    "application/json": Schemas.ApQU2qAj_custom_hostname_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$ {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$$Status$200 {
    "application/json": {
        id?: Schemas.ApQU2qAj_identifier;
    };
}
export interface Response$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$$Status$4XX {
    "application/json": {
        id?: Schemas.ApQU2qAj_identifier;
    } & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$hostname$for$a$zone$edit$custom$hostname {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$custom$hostname$for$a$zone$edit$custom$hostname {
    "application/json": {
        custom_metadata?: Schemas.ApQU2qAj_custom_metadata;
        custom_origin_server?: Schemas.ApQU2qAj_custom_origin_server;
        custom_origin_sni?: Schemas.ApQU2qAj_custom_origin_sni;
        ssl?: Schemas.ApQU2qAj_sslpost;
    };
}
export interface Response$custom$hostname$for$a$zone$edit$custom$hostname$Status$200 {
    "application/json": Schemas.ApQU2qAj_custom_hostname_response_single;
}
export interface Response$custom$hostname$for$a$zone$edit$custom$hostname$Status$4XX {
    "application/json": Schemas.ApQU2qAj_custom_hostname_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames$Status$200 {
    "application/json": Schemas.ApQU2qAj_fallback_origin_response;
}
export interface Response$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames$Status$4XX {
    "application/json": Schemas.ApQU2qAj_fallback_origin_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames {
    "application/json": {
        origin: Schemas.ApQU2qAj_origin;
    };
}
export interface Response$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames$Status$200 {
    "application/json": Schemas.ApQU2qAj_fallback_origin_response;
}
export interface Response$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames$Status$4XX {
    "application/json": Schemas.ApQU2qAj_fallback_origin_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames$Status$200 {
    "application/json": Schemas.ApQU2qAj_fallback_origin_response;
}
export interface Response$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames$Status$4XX {
    "application/json": Schemas.ApQU2qAj_fallback_origin_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$custom$pages$for$a$zone$list$custom$pages {
    zone_identifier: Schemas.NQKiZdJe_identifier;
}
export interface Response$custom$pages$for$a$zone$list$custom$pages$Status$200 {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_collection;
}
export interface Response$custom$pages$for$a$zone$list$custom$pages$Status$4xx {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_collection & Schemas.NQKiZdJe_api$response$common$failure;
}
export interface Parameter$custom$pages$for$a$zone$get$a$custom$page {
    identifier: Schemas.NQKiZdJe_identifier;
    zone_identifier: Schemas.NQKiZdJe_identifier;
}
export interface Response$custom$pages$for$a$zone$get$a$custom$page$Status$200 {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_single;
}
export interface Response$custom$pages$for$a$zone$get$a$custom$page$Status$4xx {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_single & Schemas.NQKiZdJe_api$response$common$failure;
}
export interface Parameter$custom$pages$for$a$zone$update$a$custom$page {
    identifier: Schemas.NQKiZdJe_identifier;
    zone_identifier: Schemas.NQKiZdJe_identifier;
}
export interface RequestBody$custom$pages$for$a$zone$update$a$custom$page {
    "application/json": {
        state: Schemas.NQKiZdJe_state;
        url: Schemas.NQKiZdJe_url;
    };
}
export interface Response$custom$pages$for$a$zone$update$a$custom$page$Status$200 {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_single;
}
export interface Response$custom$pages$for$a$zone$update$a$custom$page$Status$4xx {
    "application/json": Schemas.NQKiZdJe_custom_pages_response_single & Schemas.NQKiZdJe_api$response$common$failure;
}
export interface Parameter$dcv$delegation$uuid$get {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$dcv$delegation$uuid$get$Status$200 {
    "application/json": Schemas.ApQU2qAj_dcv_delegation_response;
}
export interface Response$dcv$delegation$uuid$get$Status$4XX {
    "application/json": Schemas.ApQU2qAj_dcv_delegation_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$email$routing$settings$get$email$routing$settings {
    zone_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$settings$get$email$routing$settings$Status$200 {
    "application/json": Schemas.email_email_settings_response_single;
}
export interface Parameter$email$routing$settings$disable$email$routing {
    zone_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$settings$disable$email$routing$Status$200 {
    "application/json": Schemas.email_email_settings_response_single;
}
export interface Parameter$email$routing$settings$email$routing$dns$settings {
    zone_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$settings$email$routing$dns$settings$Status$200 {
    "application/json": Schemas.email_dns_settings_response_collection;
}
export interface Parameter$email$routing$settings$enable$email$routing {
    zone_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$settings$enable$email$routing$Status$200 {
    "application/json": Schemas.email_email_settings_response_single;
}
export interface Parameter$email$routing$routing$rules$list$routing$rules {
    zone_identifier: Schemas.email_identifier;
    page?: number;
    per_page?: number;
    enabled?: true | false;
}
export interface Response$email$routing$routing$rules$list$routing$rules$Status$200 {
    "application/json": Schemas.email_rules_response_collection;
}
export interface Parameter$email$routing$routing$rules$create$routing$rule {
    zone_identifier: Schemas.email_identifier;
}
export interface RequestBody$email$routing$routing$rules$create$routing$rule {
    "application/json": Schemas.email_create_rule_properties;
}
export interface Response$email$routing$routing$rules$create$routing$rule$Status$200 {
    "application/json": Schemas.email_rule_response_single;
}
export interface Parameter$email$routing$routing$rules$get$routing$rule {
    rule_identifier: Schemas.email_rule_identifier;
    zone_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$routing$rules$get$routing$rule$Status$200 {
    "application/json": Schemas.email_rule_response_single;
}
export interface Parameter$email$routing$routing$rules$update$routing$rule {
    rule_identifier: Schemas.email_rule_identifier;
    zone_identifier: Schemas.email_identifier;
}
export interface RequestBody$email$routing$routing$rules$update$routing$rule {
    "application/json": Schemas.email_update_rule_properties;
}
export interface Response$email$routing$routing$rules$update$routing$rule$Status$200 {
    "application/json": Schemas.email_rule_response_single;
}
export interface Parameter$email$routing$routing$rules$delete$routing$rule {
    rule_identifier: Schemas.email_rule_identifier;
    zone_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$routing$rules$delete$routing$rule$Status$200 {
    "application/json": Schemas.email_rule_response_single;
}
export interface Parameter$email$routing$routing$rules$get$catch$all$rule {
    zone_identifier: Schemas.email_identifier;
}
export interface Response$email$routing$routing$rules$get$catch$all$rule$Status$200 {
    "application/json": Schemas.email_catch_all_rule_response_single;
}
export interface Parameter$email$routing$routing$rules$update$catch$all$rule {
    zone_identifier: Schemas.email_identifier;
}
export interface RequestBody$email$routing$routing$rules$update$catch$all$rule {
    "application/json": Schemas.email_update_catch_all_rule_properties;
}
export interface Response$email$routing$routing$rules$update$catch$all$rule$Status$200 {
    "application/json": Schemas.email_catch_all_rule_response_single;
}
export interface Parameter$filters$list$filters {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
    paused?: Schemas.legacy$jhs_filters_components$schemas$paused;
    expression?: string;
    description?: string;
    ref?: string;
    page?: number;
    per_page?: number;
    id?: string;
}
export interface Response$filters$list$filters$Status$200 {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$collection;
}
export interface Response$filters$list$filters$Status$4xx {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$filters$update$filters {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$filters$update$filters {
    "application/json": {
        id: any;
    };
}
export interface Response$filters$update$filters$Status$200 {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$collection;
}
export interface Response$filters$update$filters$Status$4xx {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$filters$create$filters {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$filters$create$filters {
    "application/json": {
        expression: any;
    };
}
export interface Response$filters$create$filters$Status$200 {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$collection;
}
export interface Response$filters$create$filters$Status$4xx {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$filters$delete$filters {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$filters$delete$filters {
    "application/json": {
        id: Schemas.legacy$jhs_filters_components$schemas$id;
    };
}
export interface Response$filters$delete$filters$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$delete$response$collection;
}
export interface Response$filters$delete$filters$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$delete$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$filters$get$a$filter {
    id: Schemas.legacy$jhs_filters_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$filters$get$a$filter$Status$200 {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$single;
}
export interface Response$filters$get$a$filter$Status$4xx {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$filters$update$a$filter {
    id: Schemas.legacy$jhs_filters_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$filters$update$a$filter {
    "application/json": {
        id: any;
    };
}
export interface Response$filters$update$a$filter$Status$200 {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$single;
}
export interface Response$filters$update$a$filter$Status$4xx {
    "application/json": Schemas.legacy$jhs_schemas$filter$response$single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$filters$delete$a$filter {
    id: Schemas.legacy$jhs_filters_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$filters$delete$a$filter$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$delete$response$single;
}
export interface Response$filters$delete$a$filter$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$delete$response$single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$zone$lockdown$list$zone$lockdown$rules {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
    page?: number;
    description?: Schemas.legacy$jhs_schemas$description_search;
    modified_on?: Schemas.legacy$jhs_components$schemas$modified_on;
    ip?: Schemas.legacy$jhs_ip_search;
    priority?: Schemas.legacy$jhs_lockdowns_components$schemas$priority;
    uri_search?: Schemas.legacy$jhs_uri_search;
    ip_range_search?: Schemas.legacy$jhs_ip_range_search;
    per_page?: number;
    created_on?: Date;
    description_search?: string;
    ip_search?: string;
}
export interface Response$zone$lockdown$list$zone$lockdown$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_zonelockdown_response_collection;
}
export interface Response$zone$lockdown$list$zone$lockdown$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_zonelockdown_response_collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$zone$lockdown$create$a$zone$lockdown$rule {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$zone$lockdown$create$a$zone$lockdown$rule {
    "application/json": {
        urls: any;
        configurations: any;
    };
}
export interface Response$zone$lockdown$create$a$zone$lockdown$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_zonelockdown_response_single;
}
export interface Response$zone$lockdown$create$a$zone$lockdown$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_zonelockdown_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$zone$lockdown$get$a$zone$lockdown$rule {
    id: Schemas.legacy$jhs_lockdowns_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$zone$lockdown$get$a$zone$lockdown$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_zonelockdown_response_single;
}
export interface Response$zone$lockdown$get$a$zone$lockdown$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_zonelockdown_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$zone$lockdown$update$a$zone$lockdown$rule {
    id: Schemas.legacy$jhs_lockdowns_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$zone$lockdown$update$a$zone$lockdown$rule {
    "application/json": {
        urls: any;
        configurations: any;
    };
}
export interface Response$zone$lockdown$update$a$zone$lockdown$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_zonelockdown_response_single;
}
export interface Response$zone$lockdown$update$a$zone$lockdown$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_zonelockdown_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$zone$lockdown$delete$a$zone$lockdown$rule {
    id: Schemas.legacy$jhs_lockdowns_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$zone$lockdown$delete$a$zone$lockdown$rule$Status$200 {
    "application/json": {
        result?: {
            id?: Schemas.legacy$jhs_lockdowns_components$schemas$id;
        };
    };
}
export interface Response$zone$lockdown$delete$a$zone$lockdown$rule$Status$4xx {
    "application/json": {
        result?: {
            id?: Schemas.legacy$jhs_lockdowns_components$schemas$id;
        };
    } & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$list$firewall$rules {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
    description?: string;
    action?: string;
    page?: number;
    per_page?: number;
    id?: string;
    paused?: boolean;
}
export interface Response$firewall$rules$list$firewall$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection;
}
export interface Response$firewall$rules$list$firewall$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$update$firewall$rules {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$firewall$rules$update$firewall$rules {
    "application/json": {
        id: any;
    };
}
export interface Response$firewall$rules$update$firewall$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection;
}
export interface Response$firewall$rules$update$firewall$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$create$firewall$rules {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$firewall$rules$create$firewall$rules {
    "application/json": {
        filter: any;
        action: any;
    };
}
export interface Response$firewall$rules$create$firewall$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection;
}
export interface Response$firewall$rules$create$firewall$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$delete$firewall$rules {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$firewall$rules$delete$firewall$rules {
    "application/json": {
        id: Schemas.legacy$jhs_firewall$rules_components$schemas$id;
    };
}
export interface Response$firewall$rules$delete$firewall$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection$delete;
}
export interface Response$firewall$rules$delete$firewall$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection$delete & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$update$priority$of$firewall$rules {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$firewall$rules$update$priority$of$firewall$rules {
    "application/json": {
        id: any;
    };
}
export interface Response$firewall$rules$update$priority$of$firewall$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection;
}
export interface Response$firewall$rules$update$priority$of$firewall$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$get$a$firewall$rule {
    id?: Schemas.legacy$jhs_firewall$rules_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$firewall$rules$get$a$firewall$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$single$response;
}
export interface Response$firewall$rules$get$a$firewall$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$single$response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$update$a$firewall$rule {
    id: Schemas.legacy$jhs_firewall$rules_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$firewall$rules$update$a$firewall$rule {
    "application/json": {
        id: any;
        filter: any;
        action: any;
    };
}
export interface Response$firewall$rules$update$a$firewall$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$single$response;
}
export interface Response$firewall$rules$update$a$firewall$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$single$response & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$delete$a$firewall$rule {
    id: Schemas.legacy$jhs_firewall$rules_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$firewall$rules$delete$a$firewall$rule {
    "application/json": {
        delete_filter_if_unused?: Schemas.legacy$jhs_delete_filter_if_unused;
    };
}
export interface Response$firewall$rules$delete$a$firewall$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$single$response$delete;
}
export interface Response$firewall$rules$delete$a$firewall$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$single$response$delete & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$firewall$rules$update$priority$of$a$firewall$rule {
    id: Schemas.legacy$jhs_firewall$rules_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$firewall$rules$update$priority$of$a$firewall$rule {
    "application/json": {
        id: any;
    };
}
export interface Response$firewall$rules$update$priority$of$a$firewall$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection;
}
export interface Response$firewall$rules$update$priority$of$a$firewall$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_filter$rules$response$collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$user$agent$blocking$rules$list$user$agent$blocking$rules {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
    page?: number;
    description?: Schemas.legacy$jhs_description_search;
    description_search?: Schemas.legacy$jhs_description_search;
    per_page?: number;
    ua_search?: string;
}
export interface Response$user$agent$blocking$rules$list$user$agent$blocking$rules$Status$200 {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_collection;
}
export interface Response$user$agent$blocking$rules$list$user$agent$blocking$rules$Status$4xx {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$user$agent$blocking$rules$create$a$user$agent$blocking$rule {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$user$agent$blocking$rules$create$a$user$agent$blocking$rule {
    "application/json": {
        mode: any;
        configuration: any;
    };
}
export interface Response$user$agent$blocking$rules$create$a$user$agent$blocking$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_single;
}
export interface Response$user$agent$blocking$rules$create$a$user$agent$blocking$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$user$agent$blocking$rules$get$a$user$agent$blocking$rule {
    id: Schemas.legacy$jhs_ua$rules_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$user$agent$blocking$rules$get$a$user$agent$blocking$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_single;
}
export interface Response$user$agent$blocking$rules$get$a$user$agent$blocking$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$user$agent$blocking$rules$update$a$user$agent$blocking$rule {
    id: Schemas.legacy$jhs_ua$rules_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$user$agent$blocking$rules$update$a$user$agent$blocking$rule {
    "application/json": {
        id: any;
        mode: any;
        configuration: any;
    };
}
export interface Response$user$agent$blocking$rules$update$a$user$agent$blocking$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_single;
}
export interface Response$user$agent$blocking$rules$update$a$user$agent$blocking$rule$Status$4xx {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$user$agent$blocking$rules$delete$a$user$agent$blocking$rule {
    id: Schemas.legacy$jhs_ua$rules_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$user$agent$blocking$rules$delete$a$user$agent$blocking$rule$Status$200 {
    "application/json": Schemas.legacy$jhs_firewalluablock_response_single & {
        result?: {
            id?: Schemas.legacy$jhs_ua$rules_components$schemas$id;
        };
    };
}
export interface Response$user$agent$blocking$rules$delete$a$user$agent$blocking$rule$Status$4xx {
    "application/json": (Schemas.legacy$jhs_firewalluablock_response_single & {
        result?: {
            id?: Schemas.legacy$jhs_ua$rules_components$schemas$id;
        };
    }) & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$overrides$list$waf$overrides {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
    page?: number;
    per_page?: number;
}
export interface Response$waf$overrides$list$waf$overrides$Status$200 {
    "application/json": Schemas.legacy$jhs_override_response_collection;
}
export interface Response$waf$overrides$list$waf$overrides$Status$4xx {
    "application/json": Schemas.legacy$jhs_override_response_collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$overrides$create$a$waf$override {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$waf$overrides$create$a$waf$override {
    "application/json": {
        urls: any;
    };
}
export interface Response$waf$overrides$create$a$waf$override$Status$200 {
    "application/json": Schemas.legacy$jhs_override_response_single;
}
export interface Response$waf$overrides$create$a$waf$override$Status$4xx {
    "application/json": Schemas.legacy$jhs_override_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$overrides$get$a$waf$override {
    id: Schemas.legacy$jhs_overrides_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$waf$overrides$get$a$waf$override$Status$200 {
    "application/json": Schemas.legacy$jhs_override_response_single;
}
export interface Response$waf$overrides$get$a$waf$override$Status$4xx {
    "application/json": Schemas.legacy$jhs_override_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$overrides$update$waf$override {
    id: Schemas.legacy$jhs_overrides_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$waf$overrides$update$waf$override {
    "application/json": {
        id: any;
        urls: any;
        rules: any;
        rewrite_action: any;
    };
}
export interface Response$waf$overrides$update$waf$override$Status$200 {
    "application/json": Schemas.legacy$jhs_override_response_single;
}
export interface Response$waf$overrides$update$waf$override$Status$4xx {
    "application/json": Schemas.legacy$jhs_override_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$overrides$delete$a$waf$override {
    id: Schemas.legacy$jhs_overrides_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$waf$overrides$delete$a$waf$override$Status$200 {
    "application/json": {
        result?: {
            id?: Schemas.legacy$jhs_overrides_components$schemas$id;
        };
    };
}
export interface Response$waf$overrides$delete$a$waf$override$Status$4xx {
    "application/json": {
        result?: {
            id?: Schemas.legacy$jhs_overrides_components$schemas$id;
        };
    } & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$packages$list$waf$packages {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
    page?: number;
    per_page?: number;
    order?: "name";
    direction?: "asc" | "desc";
    match?: "any" | "all";
    name?: string;
}
export interface Response$waf$packages$list$waf$packages$Status$200 {
    "application/json": Schemas.legacy$jhs_package_response_collection;
}
export interface Response$waf$packages$list$waf$packages$Status$4xx {
    "application/json": Schemas.legacy$jhs_package_response_collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$packages$get$a$waf$package {
    identifier: Schemas.legacy$jhs_package_components$schemas$identifier;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$waf$packages$get$a$waf$package$Status$200 {
    "application/json": Schemas.legacy$jhs_package_response_single;
}
export interface Response$waf$packages$get$a$waf$package$Status$4xx {
    "application/json": Schemas.legacy$jhs_package_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$waf$packages$update$a$waf$package {
    identifier: Schemas.legacy$jhs_package_components$schemas$identifier;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$waf$packages$update$a$waf$package {
    "application/json": {
        action_mode?: Schemas.legacy$jhs_action_mode;
        sensitivity?: Schemas.legacy$jhs_sensitivity;
    };
}
export interface Response$waf$packages$update$a$waf$package$Status$200 {
    "application/json": Schemas.legacy$jhs_package_response_single & {
        result?: Schemas.legacy$jhs_anomaly_package;
    };
}
export interface Response$waf$packages$update$a$waf$package$Status$4xx {
    "application/json": (Schemas.legacy$jhs_package_response_single & {
        result?: Schemas.legacy$jhs_anomaly_package;
    }) & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$health$checks$list$health$checks {
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface Response$health$checks$list$health$checks$Status$200 {
    "application/json": Schemas.healthchecks_response_collection;
}
export interface Response$health$checks$list$health$checks$Status$4XX {
    "application/json": Schemas.healthchecks_response_collection & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$health$checks$create$health$check {
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface RequestBody$health$checks$create$health$check {
    "application/json": Schemas.healthchecks_query_healthcheck;
}
export interface Response$health$checks$create$health$check$Status$200 {
    "application/json": Schemas.healthchecks_single_response;
}
export interface Response$health$checks$create$health$check$Status$4XX {
    "application/json": Schemas.healthchecks_single_response & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$health$checks$health$check$details {
    identifier: Schemas.healthchecks_identifier;
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface Response$health$checks$health$check$details$Status$200 {
    "application/json": Schemas.healthchecks_single_response;
}
export interface Response$health$checks$health$check$details$Status$4XX {
    "application/json": Schemas.healthchecks_single_response & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$health$checks$update$health$check {
    identifier: Schemas.healthchecks_identifier;
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface RequestBody$health$checks$update$health$check {
    "application/json": Schemas.healthchecks_query_healthcheck;
}
export interface Response$health$checks$update$health$check$Status$200 {
    "application/json": Schemas.healthchecks_single_response;
}
export interface Response$health$checks$update$health$check$Status$4XX {
    "application/json": Schemas.healthchecks_single_response & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$health$checks$delete$health$check {
    identifier: Schemas.healthchecks_identifier;
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface Response$health$checks$delete$health$check$Status$200 {
    "application/json": Schemas.healthchecks_id_response;
}
export interface Response$health$checks$delete$health$check$Status$4XX {
    "application/json": Schemas.healthchecks_id_response & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$health$checks$patch$health$check {
    identifier: Schemas.healthchecks_identifier;
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface RequestBody$health$checks$patch$health$check {
    "application/json": Schemas.healthchecks_query_healthcheck;
}
export interface Response$health$checks$patch$health$check$Status$200 {
    "application/json": Schemas.healthchecks_single_response;
}
export interface Response$health$checks$patch$health$check$Status$4XX {
    "application/json": Schemas.healthchecks_single_response & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$health$checks$create$preview$health$check {
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface RequestBody$health$checks$create$preview$health$check {
    "application/json": Schemas.healthchecks_query_healthcheck;
}
export interface Response$health$checks$create$preview$health$check$Status$200 {
    "application/json": Schemas.healthchecks_single_response;
}
export interface Response$health$checks$create$preview$health$check$Status$4XX {
    "application/json": Schemas.healthchecks_single_response & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$health$checks$health$check$preview$details {
    identifier: Schemas.healthchecks_identifier;
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface Response$health$checks$health$check$preview$details$Status$200 {
    "application/json": Schemas.healthchecks_single_response;
}
export interface Response$health$checks$health$check$preview$details$Status$4XX {
    "application/json": Schemas.healthchecks_single_response & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$health$checks$delete$preview$health$check {
    identifier: Schemas.healthchecks_identifier;
    zone_identifier: Schemas.healthchecks_identifier;
}
export interface Response$health$checks$delete$preview$health$check$Status$200 {
    "application/json": Schemas.healthchecks_id_response;
}
export interface Response$health$checks$delete$preview$health$check$Status$4XX {
    "application/json": Schemas.healthchecks_id_response & Schemas.healthchecks_api$response$common$failure;
}
export interface Parameter$per$hostname$tls$settings$list {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    tls_setting: Schemas.ApQU2qAj_tls_setting;
}
export interface Response$per$hostname$tls$settings$list$Status$200 {
    "application/json": Schemas.ApQU2qAj_per_hostname_settings_response_collection;
}
export interface Response$per$hostname$tls$settings$list$Status$4XX {
    "application/json": Schemas.ApQU2qAj_per_hostname_settings_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$per$hostname$tls$settings$put {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    tls_setting: Schemas.ApQU2qAj_tls_setting;
    hostname: Schemas.ApQU2qAj_components$schemas$hostname;
}
export interface RequestBody$per$hostname$tls$settings$put {
    "application/json": {
        value: Schemas.ApQU2qAj_value;
    };
}
export interface Response$per$hostname$tls$settings$put$Status$200 {
    "application/json": Schemas.ApQU2qAj_per_hostname_settings_response;
}
export interface Response$per$hostname$tls$settings$put$Status$4XX {
    "application/json": Schemas.ApQU2qAj_per_hostname_settings_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$per$hostname$tls$settings$delete {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    tls_setting: Schemas.ApQU2qAj_tls_setting;
    hostname: Schemas.ApQU2qAj_components$schemas$hostname;
}
export interface Response$per$hostname$tls$settings$delete$Status$200 {
    "application/json": Schemas.ApQU2qAj_per_hostname_settings_response_delete;
}
export interface Response$per$hostname$tls$settings$delete$Status$4XX {
    "application/json": Schemas.ApQU2qAj_per_hostname_settings_response_delete & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$keyless$ssl$for$a$zone$list$keyless$ssl$configurations {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$keyless$ssl$for$a$zone$list$keyless$ssl$configurations$Status$200 {
    "application/json": Schemas.ApQU2qAj_keyless_response_collection;
}
export interface Response$keyless$ssl$for$a$zone$list$keyless$ssl$configurations$Status$4XX {
    "application/json": Schemas.ApQU2qAj_keyless_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$keyless$ssl$for$a$zone$create$keyless$ssl$configuration {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$keyless$ssl$for$a$zone$create$keyless$ssl$configuration {
    "application/json": {
        bundle_method?: Schemas.ApQU2qAj_bundle_method;
        certificate: Schemas.ApQU2qAj_schemas$certificate;
        host: Schemas.ApQU2qAj_host;
        name?: Schemas.ApQU2qAj_name_write;
        port: Schemas.ApQU2qAj_port;
        tunnel?: Schemas.ApQU2qAj_keyless_tunnel;
    };
}
export interface Response$keyless$ssl$for$a$zone$create$keyless$ssl$configuration$Status$200 {
    "application/json": Schemas.ApQU2qAj_keyless_response_single;
}
export interface Response$keyless$ssl$for$a$zone$create$keyless$ssl$configuration$Status$4XX {
    "application/json": Schemas.ApQU2qAj_keyless_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$keyless$ssl$for$a$zone$get$keyless$ssl$configuration {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$keyless$ssl$for$a$zone$get$keyless$ssl$configuration$Status$200 {
    "application/json": Schemas.ApQU2qAj_keyless_response_single;
}
export interface Response$keyless$ssl$for$a$zone$get$keyless$ssl$configuration$Status$4XX {
    "application/json": Schemas.ApQU2qAj_keyless_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration$Status$200 {
    "application/json": Schemas.ApQU2qAj_keyless_response_single_id;
}
export interface Response$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration$Status$4XX {
    "application/json": Schemas.ApQU2qAj_keyless_response_single_id & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration {
    "application/json": {
        enabled?: Schemas.ApQU2qAj_enabled_write;
        host?: Schemas.ApQU2qAj_host;
        name?: Schemas.ApQU2qAj_name_write;
        port?: Schemas.ApQU2qAj_port;
        tunnel?: Schemas.ApQU2qAj_keyless_tunnel;
    };
}
export interface Response$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration$Status$200 {
    "application/json": Schemas.ApQU2qAj_keyless_response_single;
}
export interface Response$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration$Status$4XX {
    "application/json": Schemas.ApQU2qAj_keyless_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$logs$received$get$log$retention$flag {
    zone_identifier: Schemas.dFBpZBFx_identifier;
}
export interface Response$logs$received$get$log$retention$flag$Status$200 {
    "application/json": Schemas.dFBpZBFx_flag_response;
}
export interface Response$logs$received$get$log$retention$flag$Status$4XX {
    "application/json": Schemas.dFBpZBFx_flag_response & Schemas.dFBpZBFx_api$response$common$failure;
}
export interface Parameter$logs$received$update$log$retention$flag {
    zone_identifier: Schemas.dFBpZBFx_identifier;
}
export interface RequestBody$logs$received$update$log$retention$flag {
    "application/json": {
        flag: Schemas.dFBpZBFx_flag;
    };
}
export interface Response$logs$received$update$log$retention$flag$Status$200 {
    "application/json": Schemas.dFBpZBFx_flag_response;
}
export interface Response$logs$received$update$log$retention$flag$Status$4XX {
    "application/json": Schemas.dFBpZBFx_flag_response & Schemas.dFBpZBFx_api$response$common$failure;
}
export interface Parameter$logs$received$get$logs$ray$i$ds {
    ray_identifier: Schemas.dFBpZBFx_ray_identifier;
    zone_identifier: Schemas.dFBpZBFx_identifier;
    timestamps?: Schemas.dFBpZBFx_timestamps;
    fields?: string;
}
export interface Response$logs$received$get$logs$ray$i$ds$Status$200 {
    "application/json": Schemas.dFBpZBFx_logs;
}
export interface Response$logs$received$get$logs$ray$i$ds$Status$4XX {
    "application/json": Schemas.dFBpZBFx_logs & Schemas.dFBpZBFx_api$response$common$failure;
}
export interface Parameter$logs$received$get$logs$received {
    zone_identifier: Schemas.dFBpZBFx_identifier;
    end: Schemas.dFBpZBFx_end;
    sample?: Schemas.dFBpZBFx_sample;
    timestamps?: Schemas.dFBpZBFx_timestamps;
    count?: number;
    fields?: string;
    start?: string | number;
}
export interface Response$logs$received$get$logs$received$Status$200 {
    "application/json": Schemas.dFBpZBFx_logs;
}
export interface Response$logs$received$get$logs$received$Status$4XX {
    "application/json": Schemas.dFBpZBFx_logs & Schemas.dFBpZBFx_api$response$common$failure;
}
export interface Parameter$logs$received$list$fields {
    zone_identifier: Schemas.dFBpZBFx_identifier;
}
export interface Response$logs$received$list$fields$Status$200 {
    "application/json": Schemas.dFBpZBFx_fields_response;
}
export interface Response$logs$received$list$fields$Status$4XX {
    "application/json": Schemas.dFBpZBFx_fields_response & Schemas.dFBpZBFx_api$response$common$failure;
}
export interface Parameter$zone$level$authenticated$origin$pulls$list$certificates {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$zone$level$authenticated$origin$pulls$list$certificates$Status$200 {
    "application/json": Schemas.ApQU2qAj_components$schemas$certificate_response_collection;
}
export interface Response$zone$level$authenticated$origin$pulls$list$certificates$Status$4XX {
    "application/json": Schemas.ApQU2qAj_components$schemas$certificate_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$zone$level$authenticated$origin$pulls$upload$certificate {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$zone$level$authenticated$origin$pulls$upload$certificate {
    "application/json": {
        certificate: Schemas.ApQU2qAj_zone$authenticated$origin$pull_components$schemas$certificate;
        private_key: Schemas.ApQU2qAj_private_key;
    };
}
export interface Response$zone$level$authenticated$origin$pulls$upload$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_single;
}
export interface Response$zone$level$authenticated$origin$pulls$upload$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$zone$level$authenticated$origin$pulls$get$certificate$details {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$zone$level$authenticated$origin$pulls$get$certificate$details$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_single;
}
export interface Response$zone$level$authenticated$origin$pulls$get$certificate$details$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$zone$level$authenticated$origin$pulls$delete$certificate {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$zone$level$authenticated$origin$pulls$delete$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_response_single;
}
export interface Response$zone$level$authenticated$origin$pulls$delete$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication {
    "application/json": {
        config: Schemas.ApQU2qAj_config;
    };
}
export interface Response$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication$Status$200 {
    "application/json": Schemas.ApQU2qAj_hostname_aop_response_collection;
}
export interface Response$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication$Status$4XX {
    "application/json": Schemas.ApQU2qAj_hostname_aop_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication {
    hostname: Schemas.ApQU2qAj_schemas$hostname;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication$Status$200 {
    "application/json": Schemas.ApQU2qAj_hostname_aop_single_response;
}
export interface Response$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication$Status$4XX {
    "application/json": Schemas.ApQU2qAj_hostname_aop_single_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$per$hostname$authenticated$origin$pull$list$certificates {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$per$hostname$authenticated$origin$pull$list$certificates$Status$200 {
    "application/json": Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$certificate_response_collection;
}
export interface Response$per$hostname$authenticated$origin$pull$list$certificates$Status$4XX {
    "application/json": Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$certificate_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate {
    "application/json": {
        certificate: Schemas.ApQU2qAj_hostname$authenticated$origin$pull_components$schemas$certificate;
        private_key: Schemas.ApQU2qAj_schemas$private_key;
    };
}
export interface Response$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_components$schemas$certificate_response_single;
}
export interface Response$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_components$schemas$certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_components$schemas$certificate_response_single;
}
export interface Response$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_components$schemas$certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate$Status$200 {
    "application/json": Schemas.ApQU2qAj_components$schemas$certificate_response_single;
}
export interface Response$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate$Status$4XX {
    "application/json": Schemas.ApQU2qAj_components$schemas$certificate_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone$Status$200 {
    "application/json": Schemas.ApQU2qAj_enabled_response;
}
export interface Response$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone$Status$4XX {
    "application/json": Schemas.ApQU2qAj_enabled_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$zone$level$authenticated$origin$pulls$set$enablement$for$zone {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$zone$level$authenticated$origin$pulls$set$enablement$for$zone {
    "application/json": {
        enabled: Schemas.ApQU2qAj_zone$authenticated$origin$pull_components$schemas$enabled;
    };
}
export interface Response$zone$level$authenticated$origin$pulls$set$enablement$for$zone$Status$200 {
    "application/json": Schemas.ApQU2qAj_enabled_response;
}
export interface Response$zone$level$authenticated$origin$pulls$set$enablement$for$zone$Status$4XX {
    "application/json": Schemas.ApQU2qAj_enabled_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$rate$limits$for$a$zone$list$rate$limits {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
    page?: number;
    per_page?: number;
}
export interface Response$rate$limits$for$a$zone$list$rate$limits$Status$200 {
    "application/json": Schemas.legacy$jhs_ratelimit_response_collection;
}
export interface Response$rate$limits$for$a$zone$list$rate$limits$Status$4xx {
    "application/json": Schemas.legacy$jhs_ratelimit_response_collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$rate$limits$for$a$zone$create$a$rate$limit {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$rate$limits$for$a$zone$create$a$rate$limit {
    "application/json": {
        match: any;
        threshold: any;
        period: any;
        action: any;
    };
}
export interface Response$rate$limits$for$a$zone$create$a$rate$limit$Status$200 {
    "application/json": Schemas.legacy$jhs_ratelimit_response_single;
}
export interface Response$rate$limits$for$a$zone$create$a$rate$limit$Status$4xx {
    "application/json": Schemas.legacy$jhs_ratelimit_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$rate$limits$for$a$zone$get$a$rate$limit {
    id: Schemas.legacy$jhs_rate$limits_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$rate$limits$for$a$zone$get$a$rate$limit$Status$200 {
    "application/json": Schemas.legacy$jhs_ratelimit_response_single;
}
export interface Response$rate$limits$for$a$zone$get$a$rate$limit$Status$4xx {
    "application/json": Schemas.legacy$jhs_ratelimit_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$rate$limits$for$a$zone$update$a$rate$limit {
    id: Schemas.legacy$jhs_rate$limits_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$rate$limits$for$a$zone$update$a$rate$limit {
    "application/json": {
        id: any;
        match: any;
        threshold: any;
        period: any;
        action: any;
    };
}
export interface Response$rate$limits$for$a$zone$update$a$rate$limit$Status$200 {
    "application/json": Schemas.legacy$jhs_ratelimit_response_single;
}
export interface Response$rate$limits$for$a$zone$update$a$rate$limit$Status$4xx {
    "application/json": Schemas.legacy$jhs_ratelimit_response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$rate$limits$for$a$zone$delete$a$rate$limit {
    id: Schemas.legacy$jhs_rate$limits_components$schemas$id;
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$rate$limits$for$a$zone$delete$a$rate$limit$Status$200 {
    "application/json": Schemas.legacy$jhs_ratelimit_response_single & {
        result?: {
            id?: Schemas.legacy$jhs_rate$limits_components$schemas$id;
        };
    };
}
export interface Response$rate$limits$for$a$zone$delete$a$rate$limit$Status$4xx {
    "application/json": (Schemas.legacy$jhs_ratelimit_response_single & {
        result?: {
            id?: Schemas.legacy$jhs_rate$limits_components$schemas$id;
        };
    }) & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$secondary$zone$$force$axfr {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$secondary$zone$$force$axfr$Status$200 {
    "application/json": Schemas.vusJxt3o_force_response;
}
export interface Response$secondary$dns$$$secondary$zone$$force$axfr$Status$4XX {
    "application/json": Schemas.vusJxt3o_force_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response_incoming;
}
export interface Response$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response_incoming & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface RequestBody$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration {
    "application/json": Schemas.vusJxt3o_dns$secondary$secondary$zone;
}
export interface Response$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response_incoming;
}
export interface Response$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response_incoming & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface RequestBody$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration {
    "application/json": Schemas.vusJxt3o_dns$secondary$secondary$zone;
}
export interface Response$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response_incoming;
}
export interface Response$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response_incoming & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration$Status$200 {
    "application/json": Schemas.vusJxt3o_id_response;
}
export interface Response$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration$Status$4XX {
    "application/json": Schemas.vusJxt3o_id_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$primary$zone$$primary$zone$configuration$details {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$primary$zone$$primary$zone$configuration$details$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response_outgoing;
}
export interface Response$secondary$dns$$$primary$zone$$primary$zone$configuration$details$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response_outgoing & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$primary$zone$$update$primary$zone$configuration {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface RequestBody$secondary$dns$$$primary$zone$$update$primary$zone$configuration {
    "application/json": Schemas.vusJxt3o_single_request_outgoing;
}
export interface Response$secondary$dns$$$primary$zone$$update$primary$zone$configuration$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response_outgoing;
}
export interface Response$secondary$dns$$$primary$zone$$update$primary$zone$configuration$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response_outgoing & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$primary$zone$$create$primary$zone$configuration {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface RequestBody$secondary$dns$$$primary$zone$$create$primary$zone$configuration {
    "application/json": Schemas.vusJxt3o_single_request_outgoing;
}
export interface Response$secondary$dns$$$primary$zone$$create$primary$zone$configuration$Status$200 {
    "application/json": Schemas.vusJxt3o_single_response_outgoing;
}
export interface Response$secondary$dns$$$primary$zone$$create$primary$zone$configuration$Status$4XX {
    "application/json": Schemas.vusJxt3o_single_response_outgoing & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$primary$zone$$delete$primary$zone$configuration {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$primary$zone$$delete$primary$zone$configuration$Status$200 {
    "application/json": Schemas.vusJxt3o_id_response;
}
export interface Response$secondary$dns$$$primary$zone$$delete$primary$zone$configuration$Status$4XX {
    "application/json": Schemas.vusJxt3o_id_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers$Status$200 {
    "application/json": Schemas.vusJxt3o_disable_transfer_response;
}
export interface Response$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers$Status$4XX {
    "application/json": Schemas.vusJxt3o_disable_transfer_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers$Status$200 {
    "application/json": Schemas.vusJxt3o_enable_transfer_response;
}
export interface Response$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers$Status$4XX {
    "application/json": Schemas.vusJxt3o_enable_transfer_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$primary$zone$$force$dns$notify {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$primary$zone$$force$dns$notify$Status$200 {
    "application/json": Schemas.vusJxt3o_schemas$force_response;
}
export interface Response$secondary$dns$$$primary$zone$$force$dns$notify$Status$4XX {
    "application/json": Schemas.vusJxt3o_schemas$force_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status {
    zone_identifier: Schemas.vusJxt3o_identifier;
}
export interface Response$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status$Status$200 {
    "application/json": Schemas.vusJxt3o_enable_transfer_response;
}
export interface Response$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status$Status$4XX {
    "application/json": Schemas.vusJxt3o_enable_transfer_response & Schemas.vusJxt3o_api$response$common$failure;
}
export interface Parameter$zone$snippets {
    zone_identifier: Schemas.ajfne3Yc_identifier;
}
export interface Response$zone$snippets$Status$200 {
    "application/json": Schemas.ajfne3Yc_api$response$common & {
        /** List of all zone snippets */
        result?: Schemas.ajfne3Yc_snippet[];
    };
}
export interface Response$zone$snippets$Status$4XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Response$zone$snippets$Status$5XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Parameter$zone$snippets$snippet {
    zone_identifier: Schemas.ajfne3Yc_identifier;
    snippet_name: Schemas.ajfne3Yc_snippet_name;
}
export interface Response$zone$snippets$snippet$Status$200 {
    "application/json": Schemas.ajfne3Yc_api$response$common & {
        result?: Schemas.ajfne3Yc_snippet;
    };
}
export interface Response$zone$snippets$snippet$Status$4XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Response$zone$snippets$snippet$Status$5XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Parameter$zone$snippets$snippet$put {
    zone_identifier: Schemas.ajfne3Yc_identifier;
    snippet_name: Schemas.ajfne3Yc_snippet_name;
}
export interface RequestBody$zone$snippets$snippet$put {
    "multipart/form-data": {
        /** Content files of uploaded snippet */
        files?: string;
        metadata?: {
            /** Main module name of uploaded snippet */
            main_module?: string;
        };
    };
}
export interface Response$zone$snippets$snippet$put$Status$200 {
    "application/json": Schemas.ajfne3Yc_api$response$common & {
        result?: Schemas.ajfne3Yc_snippet;
    };
}
export interface Response$zone$snippets$snippet$put$Status$4XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Response$zone$snippets$snippet$put$Status$5XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Parameter$zone$snippets$snippet$delete {
    zone_identifier: Schemas.ajfne3Yc_identifier;
    snippet_name: Schemas.ajfne3Yc_snippet_name;
}
export interface Response$zone$snippets$snippet$delete$Status$200 {
    "application/json": Schemas.ajfne3Yc_api$response$common;
}
export interface Response$zone$snippets$snippet$delete$Status$4XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Response$zone$snippets$snippet$delete$Status$5XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Parameter$zone$snippets$snippet$content {
    zone_identifier: Schemas.ajfne3Yc_identifier;
    snippet_name: Schemas.ajfne3Yc_snippet_name;
}
export interface Response$zone$snippets$snippet$content$Status$200 {
    "multipart/form-data": {
        /** Content files of uploaded snippet */
        files?: string;
    };
}
export interface Response$zone$snippets$snippet$content$Status$4XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Response$zone$snippets$snippet$content$Status$5XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Parameter$zone$snippets$snippet$rules {
    zone_identifier: Schemas.ajfne3Yc_identifier;
}
export interface Response$zone$snippets$snippet$rules$Status$200 {
    "application/json": Schemas.ajfne3Yc_api$response$common & {
        result?: Schemas.ajfne3Yc_rules;
    };
}
export interface Response$zone$snippets$snippet$rules$Status$4XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Response$zone$snippets$snippet$rules$Status$5XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Parameter$zone$snippets$snippet$rules$put {
    zone_identifier: Schemas.ajfne3Yc_identifier;
}
export interface RequestBody$zone$snippets$snippet$rules$put {
    "application/json": {
        rules?: Schemas.ajfne3Yc_rules;
    };
}
export interface Response$zone$snippets$snippet$rules$put$Status$200 {
    "application/json": Schemas.ajfne3Yc_api$response$common & {
        result?: Schemas.ajfne3Yc_rules;
    };
}
export interface Response$zone$snippets$snippet$rules$put$Status$4XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Response$zone$snippets$snippet$rules$put$Status$5XX {
    "application/json": Schemas.ajfne3Yc_api$response$common$failure;
}
export interface Parameter$certificate$packs$list$certificate$packs {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    status?: "all";
}
export interface Response$certificate$packs$list$certificate$packs$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_pack_response_collection;
}
export interface Response$certificate$packs$list$certificate$packs$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_pack_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$certificate$packs$get$certificate$pack {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$certificate$packs$get$certificate$pack$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_pack_response_single;
}
export interface Response$certificate$packs$get$certificate$pack$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_pack_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$certificate$packs$delete$advanced$certificate$manager$certificate$pack {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$certificate$packs$delete$advanced$certificate$manager$certificate$pack$Status$200 {
    "application/json": Schemas.ApQU2qAj_delete_advanced_certificate_pack_response_single;
}
export interface Response$certificate$packs$delete$advanced$certificate$manager$certificate$pack$Status$4XX {
    "application/json": Schemas.ApQU2qAj_delete_advanced_certificate_pack_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack {
    identifier: Schemas.ApQU2qAj_identifier;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack$Status$200 {
    "application/json": Schemas.ApQU2qAj_advanced_certificate_pack_response_single;
}
export interface Response$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack$Status$4XX {
    "application/json": Schemas.ApQU2qAj_advanced_certificate_pack_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$certificate$packs$order$advanced$certificate$manager$certificate$pack {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$certificate$packs$order$advanced$certificate$manager$certificate$pack {
    "application/json": {
        certificate_authority: Schemas.ApQU2qAj_schemas$certificate_authority;
        cloudflare_branding?: Schemas.ApQU2qAj_cloudflare_branding;
        hosts: Schemas.ApQU2qAj_schemas$hosts;
        type: Schemas.ApQU2qAj_advanced_type;
        validation_method: Schemas.ApQU2qAj_validation_method;
        validity_days: Schemas.ApQU2qAj_validity_days;
    };
}
export interface Response$certificate$packs$order$advanced$certificate$manager$certificate$pack$Status$200 {
    "application/json": Schemas.ApQU2qAj_advanced_certificate_pack_response_single;
}
export interface Response$certificate$packs$order$advanced$certificate$manager$certificate$pack$Status$4XX {
    "application/json": Schemas.ApQU2qAj_advanced_certificate_pack_response_single & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$certificate$packs$get$certificate$pack$quotas {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$certificate$packs$get$certificate$pack$quotas$Status$200 {
    "application/json": Schemas.ApQU2qAj_certificate_pack_quota_response;
}
export interface Response$certificate$packs$get$certificate$pack$quotas$Status$4XX {
    "application/json": Schemas.ApQU2qAj_certificate_pack_quota_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$ssl$$tls$mode$recommendation$ssl$$tls$recommendation {
    zone_identifier: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$ssl$$tls$mode$recommendation$ssl$$tls$recommendation$Status$200 {
    "application/json": Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_id;
            modified_on?: Schemas.legacy$jhs_timestamp;
            value?: Schemas.legacy$jhs_ssl$recommender_components$schemas$value;
        };
    };
}
export interface Response$ssl$$tls$mode$recommendation$ssl$$tls$recommendation$Status$4xx {
    "application/json": (Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_id;
            modified_on?: Schemas.legacy$jhs_timestamp;
            value?: Schemas.legacy$jhs_ssl$recommender_components$schemas$value;
        };
    }) & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$universal$ssl$settings$for$a$zone$universal$ssl$settings$details {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface Response$universal$ssl$settings$for$a$zone$universal$ssl$settings$details$Status$200 {
    "application/json": Schemas.ApQU2qAj_ssl_universal_settings_response;
}
export interface Response$universal$ssl$settings$for$a$zone$universal$ssl$settings$details$Status$4XX {
    "application/json": Schemas.ApQU2qAj_ssl_universal_settings_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings {
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings {
    "application/json": Schemas.ApQU2qAj_universal;
}
export interface Response$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings$Status$200 {
    "application/json": Schemas.ApQU2qAj_ssl_universal_settings_response;
}
export interface Response$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings$Status$4XX {
    "application/json": Schemas.ApQU2qAj_ssl_universal_settings_response & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$ssl$verification$ssl$verification$details {
    zone_identifier: Schemas.ApQU2qAj_identifier;
    retry?: string;
}
export interface Response$ssl$verification$ssl$verification$details$Status$200 {
    "application/json": Schemas.ApQU2qAj_ssl_verification_response_collection;
}
export interface Response$ssl$verification$ssl$verification$details$Status$4XX {
    "application/json": Schemas.ApQU2qAj_ssl_verification_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$ssl$verification$edit$ssl$certificate$pack$validation$method {
    cert_pack_uuid: Schemas.ApQU2qAj_cert_pack_uuid;
    zone_identifier: Schemas.ApQU2qAj_identifier;
}
export interface RequestBody$ssl$verification$edit$ssl$certificate$pack$validation$method {
    "application/json": Schemas.ApQU2qAj_components$schemas$validation_method;
}
export interface Response$ssl$verification$edit$ssl$certificate$pack$validation$method$Status$200 {
    "application/json": Schemas.ApQU2qAj_ssl_validation_method_response_collection;
}
export interface Response$ssl$verification$edit$ssl$certificate$pack$validation$method$Status$4XX {
    "application/json": Schemas.ApQU2qAj_ssl_validation_method_response_collection & Schemas.ApQU2qAj_api$response$common$failure;
}
export interface Parameter$waiting$room$list$waiting$rooms {
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$list$waiting$rooms$Status$200 {
    "application/json": Schemas.waitingroom_response_collection;
}
export interface Response$waiting$room$list$waiting$rooms$Status$4XX {
    "application/json": Schemas.waitingroom_response_collection & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$create$waiting$room {
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$create$waiting$room {
    "application/json": Schemas.waitingroom_query_waitingroom;
}
export interface Response$waiting$room$create$waiting$room$Status$200 {
    "application/json": Schemas.waitingroom_single_response;
}
export interface Response$waiting$room$create$waiting$room$Status$4XX {
    "application/json": Schemas.waitingroom_single_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$waiting$room$details {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$waiting$room$details$Status$200 {
    "application/json": Schemas.waitingroom_single_response;
}
export interface Response$waiting$room$waiting$room$details$Status$4XX {
    "application/json": Schemas.waitingroom_single_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$update$waiting$room {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$update$waiting$room {
    "application/json": Schemas.waitingroom_query_waitingroom;
}
export interface Response$waiting$room$update$waiting$room$Status$200 {
    "application/json": Schemas.waitingroom_single_response;
}
export interface Response$waiting$room$update$waiting$room$Status$4XX {
    "application/json": Schemas.waitingroom_single_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$delete$waiting$room {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$delete$waiting$room$Status$200 {
    "application/json": Schemas.waitingroom_waiting_room_id_response;
}
export interface Response$waiting$room$delete$waiting$room$Status$4XX {
    "application/json": Schemas.waitingroom_waiting_room_id_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$patch$waiting$room {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$patch$waiting$room {
    "application/json": Schemas.waitingroom_query_waitingroom;
}
export interface Response$waiting$room$patch$waiting$room$Status$200 {
    "application/json": Schemas.waitingroom_single_response;
}
export interface Response$waiting$room$patch$waiting$room$Status$4XX {
    "application/json": Schemas.waitingroom_single_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$list$events {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$list$events$Status$200 {
    "application/json": Schemas.waitingroom_event_response_collection;
}
export interface Response$waiting$room$list$events$Status$4XX {
    "application/json": Schemas.waitingroom_event_response_collection & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$create$event {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$create$event {
    "application/json": Schemas.waitingroom_query_event;
}
export interface Response$waiting$room$create$event$Status$200 {
    "application/json": Schemas.waitingroom_event_response;
}
export interface Response$waiting$room$create$event$Status$4XX {
    "application/json": Schemas.waitingroom_event_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$event$details {
    event_id: Schemas.waitingroom_event_id;
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$event$details$Status$200 {
    "application/json": Schemas.waitingroom_event_response;
}
export interface Response$waiting$room$event$details$Status$4XX {
    "application/json": Schemas.waitingroom_event_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$update$event {
    event_id: Schemas.waitingroom_event_id;
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$update$event {
    "application/json": Schemas.waitingroom_query_event;
}
export interface Response$waiting$room$update$event$Status$200 {
    "application/json": Schemas.waitingroom_event_response;
}
export interface Response$waiting$room$update$event$Status$4XX {
    "application/json": Schemas.waitingroom_event_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$delete$event {
    event_id: Schemas.waitingroom_event_id;
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$delete$event$Status$200 {
    "application/json": Schemas.waitingroom_event_id_response;
}
export interface Response$waiting$room$delete$event$Status$4XX {
    "application/json": Schemas.waitingroom_event_id_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$patch$event {
    event_id: Schemas.waitingroom_event_id;
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$patch$event {
    "application/json": Schemas.waitingroom_query_event;
}
export interface Response$waiting$room$patch$event$Status$200 {
    "application/json": Schemas.waitingroom_event_response;
}
export interface Response$waiting$room$patch$event$Status$4XX {
    "application/json": Schemas.waitingroom_event_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$preview$active$event$details {
    event_id: Schemas.waitingroom_event_id;
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$preview$active$event$details$Status$200 {
    "application/json": Schemas.waitingroom_event_details_response;
}
export interface Response$waiting$room$preview$active$event$details$Status$4XX {
    "application/json": Schemas.waitingroom_event_details_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$list$waiting$room$rules {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$list$waiting$room$rules$Status$200 {
    "application/json": Schemas.waitingroom_rules_response_collection;
}
export interface Response$waiting$room$list$waiting$room$rules$Status$4XX {
    "application/json": Schemas.waitingroom_rules_response_collection & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$replace$waiting$room$rules {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$replace$waiting$room$rules {
    "application/json": Schemas.waitingroom_update_rules;
}
export interface Response$waiting$room$replace$waiting$room$rules$Status$200 {
    "application/json": Schemas.waitingroom_rules_response_collection;
}
export interface Response$waiting$room$replace$waiting$room$rules$Status$4XX {
    "application/json": Schemas.waitingroom_rules_response_collection & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$create$waiting$room$rule {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$create$waiting$room$rule {
    "application/json": Schemas.waitingroom_create_rule;
}
export interface Response$waiting$room$create$waiting$room$rule$Status$200 {
    "application/json": Schemas.waitingroom_rules_response_collection;
}
export interface Response$waiting$room$create$waiting$room$rule$Status$4XX {
    "application/json": Schemas.waitingroom_rules_response_collection & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$delete$waiting$room$rule {
    rule_id: Schemas.waitingroom_rule_id;
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$delete$waiting$room$rule$Status$200 {
    "application/json": Schemas.waitingroom_rules_response_collection;
}
export interface Response$waiting$room$delete$waiting$room$rule$Status$4XX {
    "application/json": Schemas.waitingroom_rules_response_collection & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$patch$waiting$room$rule {
    rule_id: Schemas.waitingroom_rule_id;
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$patch$waiting$room$rule {
    "application/json": Schemas.waitingroom_patch_rule;
}
export interface Response$waiting$room$patch$waiting$room$rule$Status$200 {
    "application/json": Schemas.waitingroom_rules_response_collection;
}
export interface Response$waiting$room$patch$waiting$room$rule$Status$4XX {
    "application/json": Schemas.waitingroom_rules_response_collection & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$get$waiting$room$status {
    waiting_room_id: Schemas.waitingroom_waiting_room_id;
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$get$waiting$room$status$Status$200 {
    "application/json": Schemas.waitingroom_status_response;
}
export interface Response$waiting$room$get$waiting$room$status$Status$4XX {
    "application/json": Schemas.waitingroom_status_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$create$a$custom$waiting$room$page$preview {
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$create$a$custom$waiting$room$page$preview {
    "application/json": Schemas.waitingroom_query_preview;
}
export interface Response$waiting$room$create$a$custom$waiting$room$page$preview$Status$200 {
    "application/json": Schemas.waitingroom_preview_response;
}
export interface Response$waiting$room$create$a$custom$waiting$room$page$preview$Status$4XX {
    "application/json": Schemas.waitingroom_preview_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$get$zone$settings {
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface Response$waiting$room$get$zone$settings$Status$200 {
    "application/json": Schemas.waitingroom_zone_settings_response;
}
export interface Response$waiting$room$get$zone$settings$Status$4XX {
    "application/json": Schemas.waitingroom_zone_settings_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$update$zone$settings {
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$update$zone$settings {
    "application/json": Schemas.waitingroom_zone_settings;
}
export interface Response$waiting$room$update$zone$settings$Status$200 {
    "application/json": Schemas.waitingroom_zone_settings_response;
}
export interface Response$waiting$room$update$zone$settings$Status$4XX {
    "application/json": Schemas.waitingroom_zone_settings_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$waiting$room$patch$zone$settings {
    zone_identifier: Schemas.waitingroom_identifier;
}
export interface RequestBody$waiting$room$patch$zone$settings {
    "application/json": Schemas.waitingroom_zone_settings;
}
export interface Response$waiting$room$patch$zone$settings$Status$200 {
    "application/json": Schemas.waitingroom_zone_settings_response;
}
export interface Response$waiting$room$patch$zone$settings$Status$4XX {
    "application/json": Schemas.waitingroom_zone_settings_response & Schemas.waitingroom_api$response$common$failure;
}
export interface Parameter$web3$hostname$list$web3$hostnames {
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface Response$web3$hostname$list$web3$hostnames$Status$200 {
    "application/json": Schemas.YSGOQLq3_collection_response;
}
export interface Response$web3$hostname$list$web3$hostnames$Status$5XX {
    "application/json": Schemas.YSGOQLq3_collection_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$create$web3$hostname {
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface RequestBody$web3$hostname$create$web3$hostname {
    "application/json": Schemas.YSGOQLq3_create_request;
}
export interface Response$web3$hostname$create$web3$hostname$Status$200 {
    "application/json": Schemas.YSGOQLq3_single_response;
}
export interface Response$web3$hostname$create$web3$hostname$Status$5XX {
    "application/json": Schemas.YSGOQLq3_single_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$web3$hostname$details {
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface Response$web3$hostname$web3$hostname$details$Status$200 {
    "application/json": Schemas.YSGOQLq3_single_response;
}
export interface Response$web3$hostname$web3$hostname$details$Status$5XX {
    "application/json": Schemas.YSGOQLq3_single_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$delete$web3$hostname {
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface Response$web3$hostname$delete$web3$hostname$Status$200 {
    "application/json": Schemas.YSGOQLq3_api$response$single$id;
}
export interface Response$web3$hostname$delete$web3$hostname$Status$5XX {
    "application/json": Schemas.YSGOQLq3_api$response$single$id & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$edit$web3$hostname {
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface RequestBody$web3$hostname$edit$web3$hostname {
    "application/json": Schemas.YSGOQLq3_modify_request;
}
export interface Response$web3$hostname$edit$web3$hostname$Status$200 {
    "application/json": Schemas.YSGOQLq3_single_response;
}
export interface Response$web3$hostname$edit$web3$hostname$Status$5XX {
    "application/json": Schemas.YSGOQLq3_single_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$ipfs$universal$path$gateway$content$list$details {
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface Response$web3$hostname$ipfs$universal$path$gateway$content$list$details$Status$200 {
    "application/json": Schemas.YSGOQLq3_content_list_details_response;
}
export interface Response$web3$hostname$ipfs$universal$path$gateway$content$list$details$Status$5XX {
    "application/json": Schemas.YSGOQLq3_content_list_details_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$update$ipfs$universal$path$gateway$content$list {
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface RequestBody$web3$hostname$update$ipfs$universal$path$gateway$content$list {
    "application/json": Schemas.YSGOQLq3_content_list_update_request;
}
export interface Response$web3$hostname$update$ipfs$universal$path$gateway$content$list$Status$200 {
    "application/json": Schemas.YSGOQLq3_content_list_details_response;
}
export interface Response$web3$hostname$update$ipfs$universal$path$gateway$content$list$Status$5XX {
    "application/json": Schemas.YSGOQLq3_content_list_details_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries {
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface Response$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries$Status$200 {
    "application/json": Schemas.YSGOQLq3_content_list_entry_collection_response;
}
export interface Response$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries$Status$5XX {
    "application/json": Schemas.YSGOQLq3_content_list_entry_collection_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry {
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface RequestBody$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry {
    "application/json": Schemas.YSGOQLq3_content_list_entry_create_request;
}
export interface Response$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry$Status$200 {
    "application/json": Schemas.YSGOQLq3_content_list_entry_single_response;
}
export interface Response$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry$Status$5XX {
    "application/json": Schemas.YSGOQLq3_content_list_entry_single_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details {
    content_list_entry_identifier: Schemas.YSGOQLq3_identifier;
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface Response$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details$Status$200 {
    "application/json": Schemas.YSGOQLq3_content_list_entry_single_response;
}
export interface Response$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details$Status$5XX {
    "application/json": Schemas.YSGOQLq3_content_list_entry_single_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry {
    content_list_entry_identifier: Schemas.YSGOQLq3_identifier;
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface RequestBody$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry {
    "application/json": Schemas.YSGOQLq3_content_list_entry_create_request;
}
export interface Response$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry$Status$200 {
    "application/json": Schemas.YSGOQLq3_content_list_entry_single_response;
}
export interface Response$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry$Status$5XX {
    "application/json": Schemas.YSGOQLq3_content_list_entry_single_response & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry {
    content_list_entry_identifier: Schemas.YSGOQLq3_identifier;
    identifier: Schemas.YSGOQLq3_identifier;
    zone_identifier: Schemas.YSGOQLq3_identifier;
}
export interface Response$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry$Status$200 {
    "application/json": Schemas.YSGOQLq3_api$response$single$id;
}
export interface Response$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry$Status$5XX {
    "application/json": Schemas.YSGOQLq3_api$response$single$id & Schemas.YSGOQLq3_api$response$common$failure;
}
export interface Parameter$spectrum$aggregate$analytics$get$current$aggregated$analytics {
    zone: Schemas.legacy$jhs_common_components$schemas$identifier;
    appID?: Schemas.legacy$jhs_app_id_param;
    app_id_param?: Schemas.legacy$jhs_app_id_param;
    colo_name?: string;
}
export interface Response$spectrum$aggregate$analytics$get$current$aggregated$analytics$Status$200 {
    "application/json": Schemas.legacy$jhs_analytics$aggregate_components$schemas$response_collection;
}
export interface Response$spectrum$aggregate$analytics$get$current$aggregated$analytics$Status$4xx {
    "application/json": Schemas.legacy$jhs_analytics$aggregate_components$schemas$response_collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$spectrum$analytics$$$by$time$$get$analytics$by$time {
    zone: Schemas.legacy$jhs_common_components$schemas$identifier;
    dimensions?: Schemas.legacy$jhs_dimensions;
    sort?: Schemas.legacy$jhs_sort;
    until?: Schemas.legacy$jhs_schemas$until;
    metrics?: ("count" | "bytesIngress" | "bytesEgress" | "durationAvg" | "durationMedian" | "duration90th" | "duration99th")[];
    filters?: string;
    since?: Date;
    time_delta?: "year" | "quarter" | "month" | "week" | "day" | "hour" | "dekaminute" | "minute";
}
export interface Response$spectrum$analytics$$$by$time$$get$analytics$by$time$Status$200 {
    "application/json": Schemas.legacy$jhs_api$response$single;
}
export interface Response$spectrum$analytics$$$by$time$$get$analytics$by$time$Status$4xx {
    "application/json": Schemas.legacy$jhs_api$response$single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$spectrum$analytics$$$summary$$get$analytics$summary {
    zone: Schemas.legacy$jhs_common_components$schemas$identifier;
    dimensions?: Schemas.legacy$jhs_dimensions;
    sort?: Schemas.legacy$jhs_sort;
    until?: Schemas.legacy$jhs_schemas$until;
    metrics?: ("count" | "bytesIngress" | "bytesEgress" | "durationAvg" | "durationMedian" | "duration90th" | "duration99th")[];
    filters?: string;
    since?: Date;
}
export interface Response$spectrum$analytics$$$summary$$get$analytics$summary$Status$200 {
    "application/json": Schemas.legacy$jhs_api$response$single;
}
export interface Response$spectrum$analytics$$$summary$$get$analytics$summary$Status$4xx {
    "application/json": Schemas.legacy$jhs_api$response$single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$spectrum$applications$list$spectrum$applications {
    zone: Schemas.legacy$jhs_common_components$schemas$identifier;
    page?: number;
    per_page?: number;
    direction?: "asc" | "desc";
    order?: "protocol" | "app_id" | "created_on" | "modified_on" | "dns";
}
export interface Response$spectrum$applications$list$spectrum$applications$Status$200 {
    "application/json": Schemas.legacy$jhs_components$schemas$response_collection;
}
export interface Response$spectrum$applications$list$spectrum$applications$Status$4xx {
    "application/json": Schemas.legacy$jhs_components$schemas$response_collection & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin {
    zone: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin {
    "application/json": {
        argo_smart_routing?: Schemas.legacy$jhs_argo_smart_routing;
        dns: Schemas.legacy$jhs_dns;
        edge_ips?: Schemas.legacy$jhs_edge_ips;
        ip_firewall?: Schemas.legacy$jhs_ip_firewall;
        origin_dns: Schemas.legacy$jhs_origin_dns;
        origin_port: Schemas.legacy$jhs_origin_port;
        protocol: Schemas.legacy$jhs_protocol;
        proxy_protocol?: Schemas.legacy$jhs_proxy_protocol;
        tls?: Schemas.legacy$jhs_tls;
        traffic_type?: Schemas.legacy$jhs_traffic_type;
    };
}
export interface Response$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin$Status$200 {
    "application/json": Schemas.legacy$jhs_response_single_origin_dns;
}
export interface Response$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin$Status$4xx {
    "application/json": Schemas.legacy$jhs_response_single_origin_dns & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$spectrum$applications$get$spectrum$application$configuration {
    app_id: Schemas.legacy$jhs_app_id;
    zone: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$spectrum$applications$get$spectrum$application$configuration$Status$200 {
    "application/json": Schemas.legacy$jhs_schemas$response_single;
}
export interface Response$spectrum$applications$get$spectrum$application$configuration$Status$4xx {
    "application/json": Schemas.legacy$jhs_schemas$response_single & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin {
    app_id: Schemas.legacy$jhs_app_id;
    zone: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface RequestBody$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin {
    "application/json": {
        argo_smart_routing?: Schemas.legacy$jhs_argo_smart_routing;
        dns: Schemas.legacy$jhs_dns;
        edge_ips?: Schemas.legacy$jhs_edge_ips;
        ip_firewall?: Schemas.legacy$jhs_ip_firewall;
        origin_dns: Schemas.legacy$jhs_origin_dns;
        origin_port: Schemas.legacy$jhs_origin_port;
        protocol: Schemas.legacy$jhs_protocol;
        proxy_protocol?: Schemas.legacy$jhs_proxy_protocol;
        tls?: Schemas.legacy$jhs_tls;
        traffic_type?: Schemas.legacy$jhs_traffic_type;
    };
}
export interface Response$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin$Status$200 {
    "application/json": Schemas.legacy$jhs_response_single_origin_dns;
}
export interface Response$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin$Status$4xx {
    "application/json": Schemas.legacy$jhs_response_single_origin_dns & Schemas.legacy$jhs_api$response$common$failure;
}
export interface Parameter$spectrum$applications$delete$spectrum$application {
    app_id: Schemas.legacy$jhs_app_id;
    zone: Schemas.legacy$jhs_common_components$schemas$identifier;
}
export interface Response$spectrum$applications$delete$spectrum$application$Status$200 {
    "application/json": Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_app_id;
        };
    };
}
export interface Response$spectrum$applications$delete$spectrum$application$Status$4xx {
    "application/json": (Schemas.legacy$jhs_api$response$single & {
        result?: {
            id?: Schemas.legacy$jhs_app_id;
        };
    }) & Schemas.legacy$jhs_api$response$common$failure;
}
export type ResponseContentType$accounts$list$accounts = keyof Response$accounts$list$accounts$Status$200;
export interface Params$accounts$list$accounts {
    parameter: Parameter$accounts$list$accounts;
}
export type ResponseContentType$notification$alert$types$get$alert$types = keyof Response$notification$alert$types$get$alert$types$Status$200;
export interface Params$notification$alert$types$get$alert$types {
    parameter: Parameter$notification$alert$types$get$alert$types;
}
export type ResponseContentType$notification$mechanism$eligibility$get$delivery$mechanism$eligibility = keyof Response$notification$mechanism$eligibility$get$delivery$mechanism$eligibility$Status$200;
export interface Params$notification$mechanism$eligibility$get$delivery$mechanism$eligibility {
    parameter: Parameter$notification$mechanism$eligibility$get$delivery$mechanism$eligibility;
}
export type ResponseContentType$notification$destinations$with$pager$duty$list$pager$duty$services = keyof Response$notification$destinations$with$pager$duty$list$pager$duty$services$Status$200;
export interface Params$notification$destinations$with$pager$duty$list$pager$duty$services {
    parameter: Parameter$notification$destinations$with$pager$duty$list$pager$duty$services;
}
export type ResponseContentType$notification$destinations$with$pager$duty$delete$pager$duty$services = keyof Response$notification$destinations$with$pager$duty$delete$pager$duty$services$Status$200;
export interface Params$notification$destinations$with$pager$duty$delete$pager$duty$services {
    parameter: Parameter$notification$destinations$with$pager$duty$delete$pager$duty$services;
}
export type ResponseContentType$notification$destinations$with$pager$duty$connect$pager$duty = keyof Response$notification$destinations$with$pager$duty$connect$pager$duty$Status$201;
export interface Params$notification$destinations$with$pager$duty$connect$pager$duty {
    parameter: Parameter$notification$destinations$with$pager$duty$connect$pager$duty;
}
export type ResponseContentType$notification$destinations$with$pager$duty$connect$pager$duty$token = keyof Response$notification$destinations$with$pager$duty$connect$pager$duty$token$Status$200;
export interface Params$notification$destinations$with$pager$duty$connect$pager$duty$token {
    parameter: Parameter$notification$destinations$with$pager$duty$connect$pager$duty$token;
}
export type ResponseContentType$notification$webhooks$list$webhooks = keyof Response$notification$webhooks$list$webhooks$Status$200;
export interface Params$notification$webhooks$list$webhooks {
    parameter: Parameter$notification$webhooks$list$webhooks;
}
export type RequestContentType$notification$webhooks$create$a$webhook = keyof RequestBody$notification$webhooks$create$a$webhook;
export type ResponseContentType$notification$webhooks$create$a$webhook = keyof Response$notification$webhooks$create$a$webhook$Status$201;
export interface Params$notification$webhooks$create$a$webhook {
    parameter: Parameter$notification$webhooks$create$a$webhook;
    requestBody: RequestBody$notification$webhooks$create$a$webhook["application/json"];
}
export type ResponseContentType$notification$webhooks$get$a$webhook = keyof Response$notification$webhooks$get$a$webhook$Status$200;
export interface Params$notification$webhooks$get$a$webhook {
    parameter: Parameter$notification$webhooks$get$a$webhook;
}
export type RequestContentType$notification$webhooks$update$a$webhook = keyof RequestBody$notification$webhooks$update$a$webhook;
export type ResponseContentType$notification$webhooks$update$a$webhook = keyof Response$notification$webhooks$update$a$webhook$Status$200;
export interface Params$notification$webhooks$update$a$webhook {
    parameter: Parameter$notification$webhooks$update$a$webhook;
    requestBody: RequestBody$notification$webhooks$update$a$webhook["application/json"];
}
export type ResponseContentType$notification$webhooks$delete$a$webhook = keyof Response$notification$webhooks$delete$a$webhook$Status$200;
export interface Params$notification$webhooks$delete$a$webhook {
    parameter: Parameter$notification$webhooks$delete$a$webhook;
}
export type ResponseContentType$notification$history$list$history = keyof Response$notification$history$list$history$Status$200;
export interface Params$notification$history$list$history {
    parameter: Parameter$notification$history$list$history;
}
export type ResponseContentType$notification$policies$list$notification$policies = keyof Response$notification$policies$list$notification$policies$Status$200;
export interface Params$notification$policies$list$notification$policies {
    parameter: Parameter$notification$policies$list$notification$policies;
}
export type RequestContentType$notification$policies$create$a$notification$policy = keyof RequestBody$notification$policies$create$a$notification$policy;
export type ResponseContentType$notification$policies$create$a$notification$policy = keyof Response$notification$policies$create$a$notification$policy$Status$200;
export interface Params$notification$policies$create$a$notification$policy {
    parameter: Parameter$notification$policies$create$a$notification$policy;
    requestBody: RequestBody$notification$policies$create$a$notification$policy["application/json"];
}
export type ResponseContentType$notification$policies$get$a$notification$policy = keyof Response$notification$policies$get$a$notification$policy$Status$200;
export interface Params$notification$policies$get$a$notification$policy {
    parameter: Parameter$notification$policies$get$a$notification$policy;
}
export type RequestContentType$notification$policies$update$a$notification$policy = keyof RequestBody$notification$policies$update$a$notification$policy;
export type ResponseContentType$notification$policies$update$a$notification$policy = keyof Response$notification$policies$update$a$notification$policy$Status$200;
export interface Params$notification$policies$update$a$notification$policy {
    parameter: Parameter$notification$policies$update$a$notification$policy;
    requestBody: RequestBody$notification$policies$update$a$notification$policy["application/json"];
}
export type ResponseContentType$notification$policies$delete$a$notification$policy = keyof Response$notification$policies$delete$a$notification$policy$Status$200;
export interface Params$notification$policies$delete$a$notification$policy {
    parameter: Parameter$notification$policies$delete$a$notification$policy;
}
export type RequestContentType$phishing$url$scanner$submit$suspicious$url$for$scanning = keyof RequestBody$phishing$url$scanner$submit$suspicious$url$for$scanning;
export type ResponseContentType$phishing$url$scanner$submit$suspicious$url$for$scanning = keyof Response$phishing$url$scanner$submit$suspicious$url$for$scanning$Status$200;
export interface Params$phishing$url$scanner$submit$suspicious$url$for$scanning {
    parameter: Parameter$phishing$url$scanner$submit$suspicious$url$for$scanning;
    requestBody: RequestBody$phishing$url$scanner$submit$suspicious$url$for$scanning["application/json"];
}
export type ResponseContentType$phishing$url$information$get$results$for$a$url$scan = keyof Response$phishing$url$information$get$results$for$a$url$scan$Status$200;
export interface Params$phishing$url$information$get$results$for$a$url$scan {
    parameter: Parameter$phishing$url$information$get$results$for$a$url$scan;
}
export type ResponseContentType$cloudflare$tunnel$list$cloudflare$tunnels = keyof Response$cloudflare$tunnel$list$cloudflare$tunnels$Status$200;
export interface Params$cloudflare$tunnel$list$cloudflare$tunnels {
    parameter: Parameter$cloudflare$tunnel$list$cloudflare$tunnels;
}
export type RequestContentType$cloudflare$tunnel$create$a$cloudflare$tunnel = keyof RequestBody$cloudflare$tunnel$create$a$cloudflare$tunnel;
export type ResponseContentType$cloudflare$tunnel$create$a$cloudflare$tunnel = keyof Response$cloudflare$tunnel$create$a$cloudflare$tunnel$Status$200;
export interface Params$cloudflare$tunnel$create$a$cloudflare$tunnel {
    parameter: Parameter$cloudflare$tunnel$create$a$cloudflare$tunnel;
    requestBody: RequestBody$cloudflare$tunnel$create$a$cloudflare$tunnel["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$get$a$cloudflare$tunnel = keyof Response$cloudflare$tunnel$get$a$cloudflare$tunnel$Status$200;
export interface Params$cloudflare$tunnel$get$a$cloudflare$tunnel {
    parameter: Parameter$cloudflare$tunnel$get$a$cloudflare$tunnel;
}
export type RequestContentType$cloudflare$tunnel$delete$a$cloudflare$tunnel = keyof RequestBody$cloudflare$tunnel$delete$a$cloudflare$tunnel;
export type ResponseContentType$cloudflare$tunnel$delete$a$cloudflare$tunnel = keyof Response$cloudflare$tunnel$delete$a$cloudflare$tunnel$Status$200;
export interface Params$cloudflare$tunnel$delete$a$cloudflare$tunnel {
    parameter: Parameter$cloudflare$tunnel$delete$a$cloudflare$tunnel;
    requestBody: RequestBody$cloudflare$tunnel$delete$a$cloudflare$tunnel["application/json"];
}
export type RequestContentType$cloudflare$tunnel$update$a$cloudflare$tunnel = keyof RequestBody$cloudflare$tunnel$update$a$cloudflare$tunnel;
export type ResponseContentType$cloudflare$tunnel$update$a$cloudflare$tunnel = keyof Response$cloudflare$tunnel$update$a$cloudflare$tunnel$Status$200;
export interface Params$cloudflare$tunnel$update$a$cloudflare$tunnel {
    parameter: Parameter$cloudflare$tunnel$update$a$cloudflare$tunnel;
    requestBody: RequestBody$cloudflare$tunnel$update$a$cloudflare$tunnel["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$configuration$get$configuration = keyof Response$cloudflare$tunnel$configuration$get$configuration$Status$200;
export interface Params$cloudflare$tunnel$configuration$get$configuration {
    parameter: Parameter$cloudflare$tunnel$configuration$get$configuration;
}
export type RequestContentType$cloudflare$tunnel$configuration$put$configuration = keyof RequestBody$cloudflare$tunnel$configuration$put$configuration;
export type ResponseContentType$cloudflare$tunnel$configuration$put$configuration = keyof Response$cloudflare$tunnel$configuration$put$configuration$Status$200;
export interface Params$cloudflare$tunnel$configuration$put$configuration {
    parameter: Parameter$cloudflare$tunnel$configuration$put$configuration;
    requestBody: RequestBody$cloudflare$tunnel$configuration$put$configuration["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$list$cloudflare$tunnel$connections = keyof Response$cloudflare$tunnel$list$cloudflare$tunnel$connections$Status$200;
export interface Params$cloudflare$tunnel$list$cloudflare$tunnel$connections {
    parameter: Parameter$cloudflare$tunnel$list$cloudflare$tunnel$connections;
}
export type RequestContentType$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections = keyof RequestBody$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections;
export type ResponseContentType$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections = keyof Response$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections$Status$200;
export interface Params$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections {
    parameter: Parameter$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections;
    requestBody: RequestBody$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$get$cloudflare$tunnel$connector = keyof Response$cloudflare$tunnel$get$cloudflare$tunnel$connector$Status$200;
export interface Params$cloudflare$tunnel$get$cloudflare$tunnel$connector {
    parameter: Parameter$cloudflare$tunnel$get$cloudflare$tunnel$connector;
}
export type RequestContentType$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token = keyof RequestBody$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token;
export type ResponseContentType$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token = keyof Response$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token$Status$200;
export interface Params$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token {
    parameter: Parameter$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token;
    requestBody: RequestBody$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$get$a$cloudflare$tunnel$token = keyof Response$cloudflare$tunnel$get$a$cloudflare$tunnel$token$Status$200;
export interface Params$cloudflare$tunnel$get$a$cloudflare$tunnel$token {
    parameter: Parameter$cloudflare$tunnel$get$a$cloudflare$tunnel$token;
}
export type ResponseContentType$account$level$custom$nameservers$list$account$custom$nameservers = keyof Response$account$level$custom$nameservers$list$account$custom$nameservers$Status$200;
export interface Params$account$level$custom$nameservers$list$account$custom$nameservers {
    parameter: Parameter$account$level$custom$nameservers$list$account$custom$nameservers;
}
export type RequestContentType$account$level$custom$nameservers$add$account$custom$nameserver = keyof RequestBody$account$level$custom$nameservers$add$account$custom$nameserver;
export type ResponseContentType$account$level$custom$nameservers$add$account$custom$nameserver = keyof Response$account$level$custom$nameservers$add$account$custom$nameserver$Status$200;
export interface Params$account$level$custom$nameservers$add$account$custom$nameserver {
    parameter: Parameter$account$level$custom$nameservers$add$account$custom$nameserver;
    requestBody: RequestBody$account$level$custom$nameservers$add$account$custom$nameserver["application/json"];
}
export type ResponseContentType$account$level$custom$nameservers$delete$account$custom$nameserver = keyof Response$account$level$custom$nameservers$delete$account$custom$nameserver$Status$200;
export interface Params$account$level$custom$nameservers$delete$account$custom$nameserver {
    parameter: Parameter$account$level$custom$nameservers$delete$account$custom$nameserver;
}
export type ResponseContentType$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers = keyof Response$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers$Status$200;
export interface Params$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers {
    parameter: Parameter$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers;
}
export type ResponseContentType$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records = keyof Response$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records$Status$200;
export interface Params$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records {
    parameter: Parameter$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records;
}
export type ResponseContentType$cloudflare$d1$list$databases = keyof Response$cloudflare$d1$list$databases$Status$200;
export interface Params$cloudflare$d1$list$databases {
    parameter: Parameter$cloudflare$d1$list$databases;
}
export type RequestContentType$cloudflare$d1$create$database = keyof RequestBody$cloudflare$d1$create$database;
export type ResponseContentType$cloudflare$d1$create$database = keyof Response$cloudflare$d1$create$database$Status$200;
export interface Params$cloudflare$d1$create$database {
    parameter: Parameter$cloudflare$d1$create$database;
    requestBody: RequestBody$cloudflare$d1$create$database["application/json"];
}
export type ResponseContentType$dex$endpoints$list$colos = keyof Response$dex$endpoints$list$colos$Status$200;
export interface Params$dex$endpoints$list$colos {
    parameter: Parameter$dex$endpoints$list$colos;
}
export type ResponseContentType$dex$fleet$status$devices = keyof Response$dex$fleet$status$devices$Status$200;
export interface Params$dex$fleet$status$devices {
    parameter: Parameter$dex$fleet$status$devices;
}
export type ResponseContentType$dex$fleet$status$live = keyof Response$dex$fleet$status$live$Status$200;
export interface Params$dex$fleet$status$live {
    parameter: Parameter$dex$fleet$status$live;
}
export interface Params$dex$fleet$status$over$time {
    parameter: Parameter$dex$fleet$status$over$time;
}
export type ResponseContentType$dex$endpoints$http$test$details = keyof Response$dex$endpoints$http$test$details$Status$200;
export interface Params$dex$endpoints$http$test$details {
    parameter: Parameter$dex$endpoints$http$test$details;
}
export type ResponseContentType$dex$endpoints$http$test$percentiles = keyof Response$dex$endpoints$http$test$percentiles$Status$200;
export interface Params$dex$endpoints$http$test$percentiles {
    parameter: Parameter$dex$endpoints$http$test$percentiles;
}
export type ResponseContentType$dex$endpoints$list$tests = keyof Response$dex$endpoints$list$tests$Status$200;
export interface Params$dex$endpoints$list$tests {
    parameter: Parameter$dex$endpoints$list$tests;
}
export type ResponseContentType$dex$endpoints$tests$unique$devices = keyof Response$dex$endpoints$tests$unique$devices$Status$200;
export interface Params$dex$endpoints$tests$unique$devices {
    parameter: Parameter$dex$endpoints$tests$unique$devices;
}
export type ResponseContentType$dex$endpoints$traceroute$test$result$network$path = keyof Response$dex$endpoints$traceroute$test$result$network$path$Status$200;
export interface Params$dex$endpoints$traceroute$test$result$network$path {
    parameter: Parameter$dex$endpoints$traceroute$test$result$network$path;
}
export type ResponseContentType$dex$endpoints$traceroute$test$details = keyof Response$dex$endpoints$traceroute$test$details$Status$200;
export interface Params$dex$endpoints$traceroute$test$details {
    parameter: Parameter$dex$endpoints$traceroute$test$details;
}
export type ResponseContentType$dex$endpoints$traceroute$test$network$path = keyof Response$dex$endpoints$traceroute$test$network$path$Status$200;
export interface Params$dex$endpoints$traceroute$test$network$path {
    parameter: Parameter$dex$endpoints$traceroute$test$network$path;
}
export type ResponseContentType$dex$endpoints$traceroute$test$percentiles = keyof Response$dex$endpoints$traceroute$test$percentiles$Status$200;
export interface Params$dex$endpoints$traceroute$test$percentiles {
    parameter: Parameter$dex$endpoints$traceroute$test$percentiles;
}
export type ResponseContentType$dlp$datasets$read$all = keyof Response$dlp$datasets$read$all$Status$200;
export interface Params$dlp$datasets$read$all {
    parameter: Parameter$dlp$datasets$read$all;
}
export type RequestContentType$dlp$datasets$create = keyof RequestBody$dlp$datasets$create;
export type ResponseContentType$dlp$datasets$create = keyof Response$dlp$datasets$create$Status$200;
export interface Params$dlp$datasets$create {
    parameter: Parameter$dlp$datasets$create;
    requestBody: RequestBody$dlp$datasets$create["application/json"];
}
export type ResponseContentType$dlp$datasets$read = keyof Response$dlp$datasets$read$Status$200;
export interface Params$dlp$datasets$read {
    parameter: Parameter$dlp$datasets$read;
}
export type RequestContentType$dlp$datasets$update = keyof RequestBody$dlp$datasets$update;
export type ResponseContentType$dlp$datasets$update = keyof Response$dlp$datasets$update$Status$200;
export interface Params$dlp$datasets$update {
    parameter: Parameter$dlp$datasets$update;
    requestBody: RequestBody$dlp$datasets$update["application/json"];
}
export interface Params$dlp$datasets$delete {
    parameter: Parameter$dlp$datasets$delete;
}
export type ResponseContentType$dlp$datasets$create$version = keyof Response$dlp$datasets$create$version$Status$200;
export interface Params$dlp$datasets$create$version {
    parameter: Parameter$dlp$datasets$create$version;
}
export type RequestContentType$dlp$datasets$upload$version = keyof RequestBody$dlp$datasets$upload$version;
export type ResponseContentType$dlp$datasets$upload$version = keyof Response$dlp$datasets$upload$version$Status$200;
export interface Params$dlp$datasets$upload$version {
    parameter: Parameter$dlp$datasets$upload$version;
    requestBody: RequestBody$dlp$datasets$upload$version["application/octet-stream"];
}
export type RequestContentType$dlp$pattern$validation$validate$pattern = keyof RequestBody$dlp$pattern$validation$validate$pattern;
export type ResponseContentType$dlp$pattern$validation$validate$pattern = keyof Response$dlp$pattern$validation$validate$pattern$Status$200;
export interface Params$dlp$pattern$validation$validate$pattern {
    parameter: Parameter$dlp$pattern$validation$validate$pattern;
    requestBody: RequestBody$dlp$pattern$validation$validate$pattern["application/json"];
}
export type ResponseContentType$dlp$payload$log$settings$get$settings = keyof Response$dlp$payload$log$settings$get$settings$Status$200;
export interface Params$dlp$payload$log$settings$get$settings {
    parameter: Parameter$dlp$payload$log$settings$get$settings;
}
export type RequestContentType$dlp$payload$log$settings$update$settings = keyof RequestBody$dlp$payload$log$settings$update$settings;
export type ResponseContentType$dlp$payload$log$settings$update$settings = keyof Response$dlp$payload$log$settings$update$settings$Status$200;
export interface Params$dlp$payload$log$settings$update$settings {
    parameter: Parameter$dlp$payload$log$settings$update$settings;
    requestBody: RequestBody$dlp$payload$log$settings$update$settings["application/json"];
}
export type ResponseContentType$dlp$profiles$list$all$profiles = keyof Response$dlp$profiles$list$all$profiles$Status$200;
export interface Params$dlp$profiles$list$all$profiles {
    parameter: Parameter$dlp$profiles$list$all$profiles;
}
export type ResponseContentType$dlp$profiles$get$dlp$profile = keyof Response$dlp$profiles$get$dlp$profile$Status$200;
export interface Params$dlp$profiles$get$dlp$profile {
    parameter: Parameter$dlp$profiles$get$dlp$profile;
}
export type RequestContentType$dlp$profiles$create$custom$profiles = keyof RequestBody$dlp$profiles$create$custom$profiles;
export type ResponseContentType$dlp$profiles$create$custom$profiles = keyof Response$dlp$profiles$create$custom$profiles$Status$200;
export interface Params$dlp$profiles$create$custom$profiles {
    parameter: Parameter$dlp$profiles$create$custom$profiles;
    requestBody: RequestBody$dlp$profiles$create$custom$profiles["application/json"];
}
export type ResponseContentType$dlp$profiles$get$custom$profile = keyof Response$dlp$profiles$get$custom$profile$Status$200;
export interface Params$dlp$profiles$get$custom$profile {
    parameter: Parameter$dlp$profiles$get$custom$profile;
}
export type RequestContentType$dlp$profiles$update$custom$profile = keyof RequestBody$dlp$profiles$update$custom$profile;
export type ResponseContentType$dlp$profiles$update$custom$profile = keyof Response$dlp$profiles$update$custom$profile$Status$200;
export interface Params$dlp$profiles$update$custom$profile {
    parameter: Parameter$dlp$profiles$update$custom$profile;
    requestBody: RequestBody$dlp$profiles$update$custom$profile["application/json"];
}
export type ResponseContentType$dlp$profiles$delete$custom$profile = keyof Response$dlp$profiles$delete$custom$profile$Status$200;
export interface Params$dlp$profiles$delete$custom$profile {
    parameter: Parameter$dlp$profiles$delete$custom$profile;
}
export type ResponseContentType$dlp$profiles$get$predefined$profile = keyof Response$dlp$profiles$get$predefined$profile$Status$200;
export interface Params$dlp$profiles$get$predefined$profile {
    parameter: Parameter$dlp$profiles$get$predefined$profile;
}
export type RequestContentType$dlp$profiles$update$predefined$profile = keyof RequestBody$dlp$profiles$update$predefined$profile;
export type ResponseContentType$dlp$profiles$update$predefined$profile = keyof Response$dlp$profiles$update$predefined$profile$Status$200;
export interface Params$dlp$profiles$update$predefined$profile {
    parameter: Parameter$dlp$profiles$update$predefined$profile;
    requestBody: RequestBody$dlp$profiles$update$predefined$profile["application/json"];
}
export type ResponseContentType$dns$firewall$list$dns$firewall$clusters = keyof Response$dns$firewall$list$dns$firewall$clusters$Status$200;
export interface Params$dns$firewall$list$dns$firewall$clusters {
    parameter: Parameter$dns$firewall$list$dns$firewall$clusters;
}
export type RequestContentType$dns$firewall$create$dns$firewall$cluster = keyof RequestBody$dns$firewall$create$dns$firewall$cluster;
export type ResponseContentType$dns$firewall$create$dns$firewall$cluster = keyof Response$dns$firewall$create$dns$firewall$cluster$Status$200;
export interface Params$dns$firewall$create$dns$firewall$cluster {
    parameter: Parameter$dns$firewall$create$dns$firewall$cluster;
    requestBody: RequestBody$dns$firewall$create$dns$firewall$cluster["application/json"];
}
export type ResponseContentType$dns$firewall$dns$firewall$cluster$details = keyof Response$dns$firewall$dns$firewall$cluster$details$Status$200;
export interface Params$dns$firewall$dns$firewall$cluster$details {
    parameter: Parameter$dns$firewall$dns$firewall$cluster$details;
}
export type ResponseContentType$dns$firewall$delete$dns$firewall$cluster = keyof Response$dns$firewall$delete$dns$firewall$cluster$Status$200;
export interface Params$dns$firewall$delete$dns$firewall$cluster {
    parameter: Parameter$dns$firewall$delete$dns$firewall$cluster;
}
export type RequestContentType$dns$firewall$update$dns$firewall$cluster = keyof RequestBody$dns$firewall$update$dns$firewall$cluster;
export type ResponseContentType$dns$firewall$update$dns$firewall$cluster = keyof Response$dns$firewall$update$dns$firewall$cluster$Status$200;
export interface Params$dns$firewall$update$dns$firewall$cluster {
    parameter: Parameter$dns$firewall$update$dns$firewall$cluster;
    requestBody: RequestBody$dns$firewall$update$dns$firewall$cluster["application/json"];
}
export type ResponseContentType$zero$trust$accounts$get$zero$trust$account$information = keyof Response$zero$trust$accounts$get$zero$trust$account$information$Status$200;
export interface Params$zero$trust$accounts$get$zero$trust$account$information {
    parameter: Parameter$zero$trust$accounts$get$zero$trust$account$information;
}
export type ResponseContentType$zero$trust$accounts$create$zero$trust$account = keyof Response$zero$trust$accounts$create$zero$trust$account$Status$200;
export interface Params$zero$trust$accounts$create$zero$trust$account {
    parameter: Parameter$zero$trust$accounts$create$zero$trust$account;
}
export type ResponseContentType$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings = keyof Response$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings$Status$200;
export interface Params$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings {
    parameter: Parameter$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings;
}
export type ResponseContentType$zero$trust$get$audit$ssh$settings = keyof Response$zero$trust$get$audit$ssh$settings$Status$200;
export interface Params$zero$trust$get$audit$ssh$settings {
    parameter: Parameter$zero$trust$get$audit$ssh$settings;
}
export type RequestContentType$zero$trust$update$audit$ssh$settings = keyof RequestBody$zero$trust$update$audit$ssh$settings;
export type ResponseContentType$zero$trust$update$audit$ssh$settings = keyof Response$zero$trust$update$audit$ssh$settings$Status$200;
export interface Params$zero$trust$update$audit$ssh$settings {
    parameter: Parameter$zero$trust$update$audit$ssh$settings;
    requestBody: RequestBody$zero$trust$update$audit$ssh$settings["application/json"];
}
export type ResponseContentType$zero$trust$gateway$categories$list$categories = keyof Response$zero$trust$gateway$categories$list$categories$Status$200;
export interface Params$zero$trust$gateway$categories$list$categories {
    parameter: Parameter$zero$trust$gateway$categories$list$categories;
}
export type ResponseContentType$zero$trust$accounts$get$zero$trust$account$configuration = keyof Response$zero$trust$accounts$get$zero$trust$account$configuration$Status$200;
export interface Params$zero$trust$accounts$get$zero$trust$account$configuration {
    parameter: Parameter$zero$trust$accounts$get$zero$trust$account$configuration;
}
export type RequestContentType$zero$trust$accounts$update$zero$trust$account$configuration = keyof RequestBody$zero$trust$accounts$update$zero$trust$account$configuration;
export type ResponseContentType$zero$trust$accounts$update$zero$trust$account$configuration = keyof Response$zero$trust$accounts$update$zero$trust$account$configuration$Status$200;
export interface Params$zero$trust$accounts$update$zero$trust$account$configuration {
    parameter: Parameter$zero$trust$accounts$update$zero$trust$account$configuration;
    requestBody: RequestBody$zero$trust$accounts$update$zero$trust$account$configuration["application/json"];
}
export type RequestContentType$zero$trust$accounts$patch$zero$trust$account$configuration = keyof RequestBody$zero$trust$accounts$patch$zero$trust$account$configuration;
export type ResponseContentType$zero$trust$accounts$patch$zero$trust$account$configuration = keyof Response$zero$trust$accounts$patch$zero$trust$account$configuration$Status$200;
export interface Params$zero$trust$accounts$patch$zero$trust$account$configuration {
    parameter: Parameter$zero$trust$accounts$patch$zero$trust$account$configuration;
    requestBody: RequestBody$zero$trust$accounts$patch$zero$trust$account$configuration["application/json"];
}
export type ResponseContentType$zero$trust$lists$list$zero$trust$lists = keyof Response$zero$trust$lists$list$zero$trust$lists$Status$200;
export interface Params$zero$trust$lists$list$zero$trust$lists {
    parameter: Parameter$zero$trust$lists$list$zero$trust$lists;
}
export type RequestContentType$zero$trust$lists$create$zero$trust$list = keyof RequestBody$zero$trust$lists$create$zero$trust$list;
export type ResponseContentType$zero$trust$lists$create$zero$trust$list = keyof Response$zero$trust$lists$create$zero$trust$list$Status$200;
export interface Params$zero$trust$lists$create$zero$trust$list {
    parameter: Parameter$zero$trust$lists$create$zero$trust$list;
    requestBody: RequestBody$zero$trust$lists$create$zero$trust$list["application/json"];
}
export type ResponseContentType$zero$trust$lists$zero$trust$list$details = keyof Response$zero$trust$lists$zero$trust$list$details$Status$200;
export interface Params$zero$trust$lists$zero$trust$list$details {
    parameter: Parameter$zero$trust$lists$zero$trust$list$details;
}
export type RequestContentType$zero$trust$lists$update$zero$trust$list = keyof RequestBody$zero$trust$lists$update$zero$trust$list;
export type ResponseContentType$zero$trust$lists$update$zero$trust$list = keyof Response$zero$trust$lists$update$zero$trust$list$Status$200;
export interface Params$zero$trust$lists$update$zero$trust$list {
    parameter: Parameter$zero$trust$lists$update$zero$trust$list;
    requestBody: RequestBody$zero$trust$lists$update$zero$trust$list["application/json"];
}
export type ResponseContentType$zero$trust$lists$delete$zero$trust$list = keyof Response$zero$trust$lists$delete$zero$trust$list$Status$200;
export interface Params$zero$trust$lists$delete$zero$trust$list {
    parameter: Parameter$zero$trust$lists$delete$zero$trust$list;
}
export type RequestContentType$zero$trust$lists$patch$zero$trust$list = keyof RequestBody$zero$trust$lists$patch$zero$trust$list;
export type ResponseContentType$zero$trust$lists$patch$zero$trust$list = keyof Response$zero$trust$lists$patch$zero$trust$list$Status$200;
export interface Params$zero$trust$lists$patch$zero$trust$list {
    parameter: Parameter$zero$trust$lists$patch$zero$trust$list;
    requestBody: RequestBody$zero$trust$lists$patch$zero$trust$list["application/json"];
}
export type ResponseContentType$zero$trust$lists$zero$trust$list$items = keyof Response$zero$trust$lists$zero$trust$list$items$Status$200;
export interface Params$zero$trust$lists$zero$trust$list$items {
    parameter: Parameter$zero$trust$lists$zero$trust$list$items;
}
export type ResponseContentType$zero$trust$gateway$locations$list$zero$trust$gateway$locations = keyof Response$zero$trust$gateway$locations$list$zero$trust$gateway$locations$Status$200;
export interface Params$zero$trust$gateway$locations$list$zero$trust$gateway$locations {
    parameter: Parameter$zero$trust$gateway$locations$list$zero$trust$gateway$locations;
}
export type RequestContentType$zero$trust$gateway$locations$create$zero$trust$gateway$location = keyof RequestBody$zero$trust$gateway$locations$create$zero$trust$gateway$location;
export type ResponseContentType$zero$trust$gateway$locations$create$zero$trust$gateway$location = keyof Response$zero$trust$gateway$locations$create$zero$trust$gateway$location$Status$200;
export interface Params$zero$trust$gateway$locations$create$zero$trust$gateway$location {
    parameter: Parameter$zero$trust$gateway$locations$create$zero$trust$gateway$location;
    requestBody: RequestBody$zero$trust$gateway$locations$create$zero$trust$gateway$location["application/json"];
}
export type ResponseContentType$zero$trust$gateway$locations$zero$trust$gateway$location$details = keyof Response$zero$trust$gateway$locations$zero$trust$gateway$location$details$Status$200;
export interface Params$zero$trust$gateway$locations$zero$trust$gateway$location$details {
    parameter: Parameter$zero$trust$gateway$locations$zero$trust$gateway$location$details;
}
export type RequestContentType$zero$trust$gateway$locations$update$zero$trust$gateway$location = keyof RequestBody$zero$trust$gateway$locations$update$zero$trust$gateway$location;
export type ResponseContentType$zero$trust$gateway$locations$update$zero$trust$gateway$location = keyof Response$zero$trust$gateway$locations$update$zero$trust$gateway$location$Status$200;
export interface Params$zero$trust$gateway$locations$update$zero$trust$gateway$location {
    parameter: Parameter$zero$trust$gateway$locations$update$zero$trust$gateway$location;
    requestBody: RequestBody$zero$trust$gateway$locations$update$zero$trust$gateway$location["application/json"];
}
export type ResponseContentType$zero$trust$gateway$locations$delete$zero$trust$gateway$location = keyof Response$zero$trust$gateway$locations$delete$zero$trust$gateway$location$Status$200;
export interface Params$zero$trust$gateway$locations$delete$zero$trust$gateway$location {
    parameter: Parameter$zero$trust$gateway$locations$delete$zero$trust$gateway$location;
}
export type ResponseContentType$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account = keyof Response$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account$Status$200;
export interface Params$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account {
    parameter: Parameter$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account;
}
export type RequestContentType$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account = keyof RequestBody$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account;
export type ResponseContentType$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account = keyof Response$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account$Status$200;
export interface Params$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account {
    parameter: Parameter$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account;
    requestBody: RequestBody$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account["application/json"];
}
export type ResponseContentType$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints = keyof Response$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints$Status$200;
export interface Params$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints {
    parameter: Parameter$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints;
}
export type RequestContentType$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint = keyof RequestBody$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint;
export type ResponseContentType$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint = keyof Response$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint$Status$200;
export interface Params$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint {
    parameter: Parameter$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint;
    requestBody: RequestBody$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint["application/json"];
}
export type ResponseContentType$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details = keyof Response$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details$Status$200;
export interface Params$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details {
    parameter: Parameter$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details;
}
export type ResponseContentType$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint = keyof Response$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint$Status$200;
export interface Params$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint {
    parameter: Parameter$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint;
}
export type RequestContentType$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint = keyof RequestBody$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint;
export type ResponseContentType$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint = keyof Response$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint$Status$200;
export interface Params$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint {
    parameter: Parameter$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint;
    requestBody: RequestBody$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint["application/json"];
}
export type ResponseContentType$zero$trust$gateway$rules$list$zero$trust$gateway$rules = keyof Response$zero$trust$gateway$rules$list$zero$trust$gateway$rules$Status$200;
export interface Params$zero$trust$gateway$rules$list$zero$trust$gateway$rules {
    parameter: Parameter$zero$trust$gateway$rules$list$zero$trust$gateway$rules;
}
export type RequestContentType$zero$trust$gateway$rules$create$zero$trust$gateway$rule = keyof RequestBody$zero$trust$gateway$rules$create$zero$trust$gateway$rule;
export type ResponseContentType$zero$trust$gateway$rules$create$zero$trust$gateway$rule = keyof Response$zero$trust$gateway$rules$create$zero$trust$gateway$rule$Status$200;
export interface Params$zero$trust$gateway$rules$create$zero$trust$gateway$rule {
    parameter: Parameter$zero$trust$gateway$rules$create$zero$trust$gateway$rule;
    requestBody: RequestBody$zero$trust$gateway$rules$create$zero$trust$gateway$rule["application/json"];
}
export type ResponseContentType$zero$trust$gateway$rules$zero$trust$gateway$rule$details = keyof Response$zero$trust$gateway$rules$zero$trust$gateway$rule$details$Status$200;
export interface Params$zero$trust$gateway$rules$zero$trust$gateway$rule$details {
    parameter: Parameter$zero$trust$gateway$rules$zero$trust$gateway$rule$details;
}
export type RequestContentType$zero$trust$gateway$rules$update$zero$trust$gateway$rule = keyof RequestBody$zero$trust$gateway$rules$update$zero$trust$gateway$rule;
export type ResponseContentType$zero$trust$gateway$rules$update$zero$trust$gateway$rule = keyof Response$zero$trust$gateway$rules$update$zero$trust$gateway$rule$Status$200;
export interface Params$zero$trust$gateway$rules$update$zero$trust$gateway$rule {
    parameter: Parameter$zero$trust$gateway$rules$update$zero$trust$gateway$rule;
    requestBody: RequestBody$zero$trust$gateway$rules$update$zero$trust$gateway$rule["application/json"];
}
export type ResponseContentType$zero$trust$gateway$rules$delete$zero$trust$gateway$rule = keyof Response$zero$trust$gateway$rules$delete$zero$trust$gateway$rule$Status$200;
export interface Params$zero$trust$gateway$rules$delete$zero$trust$gateway$rule {
    parameter: Parameter$zero$trust$gateway$rules$delete$zero$trust$gateway$rule;
}
export type ResponseContentType$list$hyperdrive = keyof Response$list$hyperdrive$Status$200;
export interface Params$list$hyperdrive {
    parameter: Parameter$list$hyperdrive;
}
export type RequestContentType$create$hyperdrive = keyof RequestBody$create$hyperdrive;
export type ResponseContentType$create$hyperdrive = keyof Response$create$hyperdrive$Status$200;
export interface Params$create$hyperdrive {
    parameter: Parameter$create$hyperdrive;
    requestBody: RequestBody$create$hyperdrive["application/json"];
}
export type ResponseContentType$get$hyperdrive = keyof Response$get$hyperdrive$Status$200;
export interface Params$get$hyperdrive {
    parameter: Parameter$get$hyperdrive;
}
export type RequestContentType$update$hyperdrive = keyof RequestBody$update$hyperdrive;
export type ResponseContentType$update$hyperdrive = keyof Response$update$hyperdrive$Status$200;
export interface Params$update$hyperdrive {
    parameter: Parameter$update$hyperdrive;
    requestBody: RequestBody$update$hyperdrive["application/json"];
}
export type ResponseContentType$delete$hyperdrive = keyof Response$delete$hyperdrive$Status$200;
export interface Params$delete$hyperdrive {
    parameter: Parameter$delete$hyperdrive;
}
export type ResponseContentType$cloudflare$images$list$images = keyof Response$cloudflare$images$list$images$Status$200;
export interface Params$cloudflare$images$list$images {
    parameter: Parameter$cloudflare$images$list$images;
}
export type RequestContentType$cloudflare$images$upload$an$image$via$url = keyof RequestBody$cloudflare$images$upload$an$image$via$url;
export type ResponseContentType$cloudflare$images$upload$an$image$via$url = keyof Response$cloudflare$images$upload$an$image$via$url$Status$200;
export interface Params$cloudflare$images$upload$an$image$via$url {
    parameter: Parameter$cloudflare$images$upload$an$image$via$url;
    requestBody: RequestBody$cloudflare$images$upload$an$image$via$url["multipart/form-data"];
}
export type ResponseContentType$cloudflare$images$image$details = keyof Response$cloudflare$images$image$details$Status$200;
export interface Params$cloudflare$images$image$details {
    parameter: Parameter$cloudflare$images$image$details;
}
export type ResponseContentType$cloudflare$images$delete$image = keyof Response$cloudflare$images$delete$image$Status$200;
export interface Params$cloudflare$images$delete$image {
    parameter: Parameter$cloudflare$images$delete$image;
}
export type RequestContentType$cloudflare$images$update$image = keyof RequestBody$cloudflare$images$update$image;
export type ResponseContentType$cloudflare$images$update$image = keyof Response$cloudflare$images$update$image$Status$200;
export interface Params$cloudflare$images$update$image {
    parameter: Parameter$cloudflare$images$update$image;
    requestBody: RequestBody$cloudflare$images$update$image["application/json"];
}
export type ResponseContentType$cloudflare$images$base$image = keyof Response$cloudflare$images$base$image$Status$200;
export interface Params$cloudflare$images$base$image {
    parameter: Parameter$cloudflare$images$base$image;
}
export type ResponseContentType$cloudflare$images$keys$list$signing$keys = keyof Response$cloudflare$images$keys$list$signing$keys$Status$200;
export interface Params$cloudflare$images$keys$list$signing$keys {
    parameter: Parameter$cloudflare$images$keys$list$signing$keys;
}
export type ResponseContentType$cloudflare$images$images$usage$statistics = keyof Response$cloudflare$images$images$usage$statistics$Status$200;
export interface Params$cloudflare$images$images$usage$statistics {
    parameter: Parameter$cloudflare$images$images$usage$statistics;
}
export type ResponseContentType$cloudflare$images$variants$list$variants = keyof Response$cloudflare$images$variants$list$variants$Status$200;
export interface Params$cloudflare$images$variants$list$variants {
    parameter: Parameter$cloudflare$images$variants$list$variants;
}
export type RequestContentType$cloudflare$images$variants$create$a$variant = keyof RequestBody$cloudflare$images$variants$create$a$variant;
export type ResponseContentType$cloudflare$images$variants$create$a$variant = keyof Response$cloudflare$images$variants$create$a$variant$Status$200;
export interface Params$cloudflare$images$variants$create$a$variant {
    parameter: Parameter$cloudflare$images$variants$create$a$variant;
    requestBody: RequestBody$cloudflare$images$variants$create$a$variant["application/json"];
}
export type ResponseContentType$cloudflare$images$variants$variant$details = keyof Response$cloudflare$images$variants$variant$details$Status$200;
export interface Params$cloudflare$images$variants$variant$details {
    parameter: Parameter$cloudflare$images$variants$variant$details;
}
export type ResponseContentType$cloudflare$images$variants$delete$a$variant = keyof Response$cloudflare$images$variants$delete$a$variant$Status$200;
export interface Params$cloudflare$images$variants$delete$a$variant {
    parameter: Parameter$cloudflare$images$variants$delete$a$variant;
}
export type RequestContentType$cloudflare$images$variants$update$a$variant = keyof RequestBody$cloudflare$images$variants$update$a$variant;
export type ResponseContentType$cloudflare$images$variants$update$a$variant = keyof Response$cloudflare$images$variants$update$a$variant$Status$200;
export interface Params$cloudflare$images$variants$update$a$variant {
    parameter: Parameter$cloudflare$images$variants$update$a$variant;
    requestBody: RequestBody$cloudflare$images$variants$update$a$variant["application/json"];
}
export type ResponseContentType$cloudflare$images$list$images$v2 = keyof Response$cloudflare$images$list$images$v2$Status$200;
export interface Params$cloudflare$images$list$images$v2 {
    parameter: Parameter$cloudflare$images$list$images$v2;
}
export type RequestContentType$cloudflare$images$create$authenticated$direct$upload$url$v$2 = keyof RequestBody$cloudflare$images$create$authenticated$direct$upload$url$v$2;
export type ResponseContentType$cloudflare$images$create$authenticated$direct$upload$url$v$2 = keyof Response$cloudflare$images$create$authenticated$direct$upload$url$v$2$Status$200;
export interface Params$cloudflare$images$create$authenticated$direct$upload$url$v$2 {
    parameter: Parameter$cloudflare$images$create$authenticated$direct$upload$url$v$2;
    requestBody: RequestBody$cloudflare$images$create$authenticated$direct$upload$url$v$2["multipart/form-data"];
}
export type ResponseContentType$asn$intelligence$get$asn$overview = keyof Response$asn$intelligence$get$asn$overview$Status$200;
export interface Params$asn$intelligence$get$asn$overview {
    parameter: Parameter$asn$intelligence$get$asn$overview;
}
export type ResponseContentType$asn$intelligence$get$asn$subnets = keyof Response$asn$intelligence$get$asn$subnets$Status$200;
export interface Params$asn$intelligence$get$asn$subnets {
    parameter: Parameter$asn$intelligence$get$asn$subnets;
}
export type ResponseContentType$passive$dns$by$ip$get$passive$dns$by$ip = keyof Response$passive$dns$by$ip$get$passive$dns$by$ip$Status$200;
export interface Params$passive$dns$by$ip$get$passive$dns$by$ip {
    parameter: Parameter$passive$dns$by$ip$get$passive$dns$by$ip;
}
export type ResponseContentType$domain$intelligence$get$domain$details = keyof Response$domain$intelligence$get$domain$details$Status$200;
export interface Params$domain$intelligence$get$domain$details {
    parameter: Parameter$domain$intelligence$get$domain$details;
}
export type ResponseContentType$domain$history$get$domain$history = keyof Response$domain$history$get$domain$history$Status$200;
export interface Params$domain$history$get$domain$history {
    parameter: Parameter$domain$history$get$domain$history;
}
export type ResponseContentType$domain$intelligence$get$multiple$domain$details = keyof Response$domain$intelligence$get$multiple$domain$details$Status$200;
export interface Params$domain$intelligence$get$multiple$domain$details {
    parameter: Parameter$domain$intelligence$get$multiple$domain$details;
}
export type ResponseContentType$ip$intelligence$get$ip$overview = keyof Response$ip$intelligence$get$ip$overview$Status$200;
export interface Params$ip$intelligence$get$ip$overview {
    parameter: Parameter$ip$intelligence$get$ip$overview;
}
export type ResponseContentType$ip$list$get$ip$lists = keyof Response$ip$list$get$ip$lists$Status$200;
export interface Params$ip$list$get$ip$lists {
    parameter: Parameter$ip$list$get$ip$lists;
}
export type RequestContentType$miscategorization$create$miscategorization = keyof RequestBody$miscategorization$create$miscategorization;
export type ResponseContentType$miscategorization$create$miscategorization = keyof Response$miscategorization$create$miscategorization$Status$200;
export interface Params$miscategorization$create$miscategorization {
    parameter: Parameter$miscategorization$create$miscategorization;
    requestBody: RequestBody$miscategorization$create$miscategorization["application/json"];
}
export type ResponseContentType$whois$record$get$whois$record = keyof Response$whois$record$get$whois$record$Status$200;
export interface Params$whois$record$get$whois$record {
    parameter: Parameter$whois$record$get$whois$record;
}
export type ResponseContentType$get$accounts$account_identifier$logpush$datasets$dataset$fields = keyof Response$get$accounts$account_identifier$logpush$datasets$dataset$fields$Status$200;
export interface Params$get$accounts$account_identifier$logpush$datasets$dataset$fields {
    parameter: Parameter$get$accounts$account_identifier$logpush$datasets$dataset$fields;
}
export type ResponseContentType$get$accounts$account_identifier$logpush$datasets$dataset$jobs = keyof Response$get$accounts$account_identifier$logpush$datasets$dataset$jobs$Status$200;
export interface Params$get$accounts$account_identifier$logpush$datasets$dataset$jobs {
    parameter: Parameter$get$accounts$account_identifier$logpush$datasets$dataset$jobs;
}
export type ResponseContentType$get$accounts$account_identifier$logpush$jobs = keyof Response$get$accounts$account_identifier$logpush$jobs$Status$200;
export interface Params$get$accounts$account_identifier$logpush$jobs {
    parameter: Parameter$get$accounts$account_identifier$logpush$jobs;
}
export type RequestContentType$post$accounts$account_identifier$logpush$jobs = keyof RequestBody$post$accounts$account_identifier$logpush$jobs;
export type ResponseContentType$post$accounts$account_identifier$logpush$jobs = keyof Response$post$accounts$account_identifier$logpush$jobs$Status$200;
export interface Params$post$accounts$account_identifier$logpush$jobs {
    parameter: Parameter$post$accounts$account_identifier$logpush$jobs;
    requestBody: RequestBody$post$accounts$account_identifier$logpush$jobs["application/json"];
}
export type ResponseContentType$get$accounts$account_identifier$logpush$jobs$job_identifier = keyof Response$get$accounts$account_identifier$logpush$jobs$job_identifier$Status$200;
export interface Params$get$accounts$account_identifier$logpush$jobs$job_identifier {
    parameter: Parameter$get$accounts$account_identifier$logpush$jobs$job_identifier;
}
export type RequestContentType$put$accounts$account_identifier$logpush$jobs$job_identifier = keyof RequestBody$put$accounts$account_identifier$logpush$jobs$job_identifier;
export type ResponseContentType$put$accounts$account_identifier$logpush$jobs$job_identifier = keyof Response$put$accounts$account_identifier$logpush$jobs$job_identifier$Status$200;
export interface Params$put$accounts$account_identifier$logpush$jobs$job_identifier {
    parameter: Parameter$put$accounts$account_identifier$logpush$jobs$job_identifier;
    requestBody: RequestBody$put$accounts$account_identifier$logpush$jobs$job_identifier["application/json"];
}
export type ResponseContentType$delete$accounts$account_identifier$logpush$jobs$job_identifier = keyof Response$delete$accounts$account_identifier$logpush$jobs$job_identifier$Status$200;
export interface Params$delete$accounts$account_identifier$logpush$jobs$job_identifier {
    parameter: Parameter$delete$accounts$account_identifier$logpush$jobs$job_identifier;
}
export type RequestContentType$post$accounts$account_identifier$logpush$ownership = keyof RequestBody$post$accounts$account_identifier$logpush$ownership;
export type ResponseContentType$post$accounts$account_identifier$logpush$ownership = keyof Response$post$accounts$account_identifier$logpush$ownership$Status$200;
export interface Params$post$accounts$account_identifier$logpush$ownership {
    parameter: Parameter$post$accounts$account_identifier$logpush$ownership;
    requestBody: RequestBody$post$accounts$account_identifier$logpush$ownership["application/json"];
}
export type RequestContentType$post$accounts$account_identifier$logpush$ownership$validate = keyof RequestBody$post$accounts$account_identifier$logpush$ownership$validate;
export type ResponseContentType$post$accounts$account_identifier$logpush$ownership$validate = keyof Response$post$accounts$account_identifier$logpush$ownership$validate$Status$200;
export interface Params$post$accounts$account_identifier$logpush$ownership$validate {
    parameter: Parameter$post$accounts$account_identifier$logpush$ownership$validate;
    requestBody: RequestBody$post$accounts$account_identifier$logpush$ownership$validate["application/json"];
}
export type RequestContentType$delete$accounts$account_identifier$logpush$validate$destination$exists = keyof RequestBody$delete$accounts$account_identifier$logpush$validate$destination$exists;
export type ResponseContentType$delete$accounts$account_identifier$logpush$validate$destination$exists = keyof Response$delete$accounts$account_identifier$logpush$validate$destination$exists$Status$200;
export interface Params$delete$accounts$account_identifier$logpush$validate$destination$exists {
    parameter: Parameter$delete$accounts$account_identifier$logpush$validate$destination$exists;
    requestBody: RequestBody$delete$accounts$account_identifier$logpush$validate$destination$exists["application/json"];
}
export type RequestContentType$post$accounts$account_identifier$logpush$validate$origin = keyof RequestBody$post$accounts$account_identifier$logpush$validate$origin;
export type ResponseContentType$post$accounts$account_identifier$logpush$validate$origin = keyof Response$post$accounts$account_identifier$logpush$validate$origin$Status$200;
export interface Params$post$accounts$account_identifier$logpush$validate$origin {
    parameter: Parameter$post$accounts$account_identifier$logpush$validate$origin;
    requestBody: RequestBody$post$accounts$account_identifier$logpush$validate$origin["application/json"];
}
export type ResponseContentType$get$accounts$account_identifier$logs$control$cmb$config = keyof Response$get$accounts$account_identifier$logs$control$cmb$config$Status$200;
export interface Params$get$accounts$account_identifier$logs$control$cmb$config {
    parameter: Parameter$get$accounts$account_identifier$logs$control$cmb$config;
}
export type RequestContentType$put$accounts$account_identifier$logs$control$cmb$config = keyof RequestBody$put$accounts$account_identifier$logs$control$cmb$config;
export type ResponseContentType$put$accounts$account_identifier$logs$control$cmb$config = keyof Response$put$accounts$account_identifier$logs$control$cmb$config$Status$200;
export interface Params$put$accounts$account_identifier$logs$control$cmb$config {
    parameter: Parameter$put$accounts$account_identifier$logs$control$cmb$config;
    requestBody: RequestBody$put$accounts$account_identifier$logs$control$cmb$config["application/json"];
}
export type ResponseContentType$delete$accounts$account_identifier$logs$control$cmb$config = keyof Response$delete$accounts$account_identifier$logs$control$cmb$config$Status$200;
export interface Params$delete$accounts$account_identifier$logs$control$cmb$config {
    parameter: Parameter$delete$accounts$account_identifier$logs$control$cmb$config;
}
export type ResponseContentType$pages$project$get$projects = keyof Response$pages$project$get$projects$Status$200;
export interface Params$pages$project$get$projects {
    parameter: Parameter$pages$project$get$projects;
}
export type RequestContentType$pages$project$create$project = keyof RequestBody$pages$project$create$project;
export type ResponseContentType$pages$project$create$project = keyof Response$pages$project$create$project$Status$200;
export interface Params$pages$project$create$project {
    parameter: Parameter$pages$project$create$project;
    requestBody: RequestBody$pages$project$create$project["application/json"];
}
export type ResponseContentType$pages$project$get$project = keyof Response$pages$project$get$project$Status$200;
export interface Params$pages$project$get$project {
    parameter: Parameter$pages$project$get$project;
}
export type ResponseContentType$pages$project$delete$project = keyof Response$pages$project$delete$project$Status$200;
export interface Params$pages$project$delete$project {
    parameter: Parameter$pages$project$delete$project;
}
export type RequestContentType$pages$project$update$project = keyof RequestBody$pages$project$update$project;
export type ResponseContentType$pages$project$update$project = keyof Response$pages$project$update$project$Status$200;
export interface Params$pages$project$update$project {
    parameter: Parameter$pages$project$update$project;
    requestBody: RequestBody$pages$project$update$project["application/json"];
}
export type ResponseContentType$pages$deployment$get$deployments = keyof Response$pages$deployment$get$deployments$Status$200;
export interface Params$pages$deployment$get$deployments {
    parameter: Parameter$pages$deployment$get$deployments;
}
export type RequestContentType$pages$deployment$create$deployment = keyof RequestBody$pages$deployment$create$deployment;
export type ResponseContentType$pages$deployment$create$deployment = keyof Response$pages$deployment$create$deployment$Status$200;
export interface Params$pages$deployment$create$deployment {
    parameter: Parameter$pages$deployment$create$deployment;
    requestBody: RequestBody$pages$deployment$create$deployment["multipart/form-data"];
}
export type ResponseContentType$pages$deployment$get$deployment$info = keyof Response$pages$deployment$get$deployment$info$Status$200;
export interface Params$pages$deployment$get$deployment$info {
    parameter: Parameter$pages$deployment$get$deployment$info;
}
export type ResponseContentType$pages$deployment$delete$deployment = keyof Response$pages$deployment$delete$deployment$Status$200;
export interface Params$pages$deployment$delete$deployment {
    parameter: Parameter$pages$deployment$delete$deployment;
}
export type ResponseContentType$pages$deployment$get$deployment$logs = keyof Response$pages$deployment$get$deployment$logs$Status$200;
export interface Params$pages$deployment$get$deployment$logs {
    parameter: Parameter$pages$deployment$get$deployment$logs;
}
export type ResponseContentType$pages$deployment$retry$deployment = keyof Response$pages$deployment$retry$deployment$Status$200;
export interface Params$pages$deployment$retry$deployment {
    parameter: Parameter$pages$deployment$retry$deployment;
}
export type ResponseContentType$pages$deployment$rollback$deployment = keyof Response$pages$deployment$rollback$deployment$Status$200;
export interface Params$pages$deployment$rollback$deployment {
    parameter: Parameter$pages$deployment$rollback$deployment;
}
export type ResponseContentType$pages$domains$get$domains = keyof Response$pages$domains$get$domains$Status$200;
export interface Params$pages$domains$get$domains {
    parameter: Parameter$pages$domains$get$domains;
}
export type RequestContentType$pages$domains$add$domain = keyof RequestBody$pages$domains$add$domain;
export type ResponseContentType$pages$domains$add$domain = keyof Response$pages$domains$add$domain$Status$200;
export interface Params$pages$domains$add$domain {
    parameter: Parameter$pages$domains$add$domain;
    requestBody: RequestBody$pages$domains$add$domain["application/json"];
}
export type ResponseContentType$pages$domains$get$domain = keyof Response$pages$domains$get$domain$Status$200;
export interface Params$pages$domains$get$domain {
    parameter: Parameter$pages$domains$get$domain;
}
export type ResponseContentType$pages$domains$delete$domain = keyof Response$pages$domains$delete$domain$Status$200;
export interface Params$pages$domains$delete$domain {
    parameter: Parameter$pages$domains$delete$domain;
}
export type ResponseContentType$pages$domains$patch$domain = keyof Response$pages$domains$patch$domain$Status$200;
export interface Params$pages$domains$patch$domain {
    parameter: Parameter$pages$domains$patch$domain;
}
export type ResponseContentType$pages$purge$build$cache = keyof Response$pages$purge$build$cache$Status$200;
export interface Params$pages$purge$build$cache {
    parameter: Parameter$pages$purge$build$cache;
}
export type ResponseContentType$r2$list$buckets = keyof Response$r2$list$buckets$Status$200;
export interface Params$r2$list$buckets {
    parameter: Parameter$r2$list$buckets;
}
export type RequestContentType$r2$create$bucket = keyof RequestBody$r2$create$bucket;
export type ResponseContentType$r2$create$bucket = keyof Response$r2$create$bucket$Status$200;
export interface Params$r2$create$bucket {
    parameter: Parameter$r2$create$bucket;
    requestBody: RequestBody$r2$create$bucket["application/json"];
}
export type ResponseContentType$r2$get$bucket = keyof Response$r2$get$bucket$Status$200;
export interface Params$r2$get$bucket {
    parameter: Parameter$r2$get$bucket;
}
export type ResponseContentType$r2$delete$bucket = keyof Response$r2$delete$bucket$Status$200;
export interface Params$r2$delete$bucket {
    parameter: Parameter$r2$delete$bucket;
}
export type ResponseContentType$r2$get$bucket$sippy$config = keyof Response$r2$get$bucket$sippy$config$Status$200;
export interface Params$r2$get$bucket$sippy$config {
    parameter: Parameter$r2$get$bucket$sippy$config;
}
export type RequestContentType$r2$put$bucket$sippy$config = keyof RequestBody$r2$put$bucket$sippy$config;
export type ResponseContentType$r2$put$bucket$sippy$config = keyof Response$r2$put$bucket$sippy$config$Status$200;
export interface Params$r2$put$bucket$sippy$config {
    parameter: Parameter$r2$put$bucket$sippy$config;
    requestBody: RequestBody$r2$put$bucket$sippy$config["application/json"];
}
export type ResponseContentType$r2$delete$bucket$sippy$config = keyof Response$r2$delete$bucket$sippy$config$Status$200;
export interface Params$r2$delete$bucket$sippy$config {
    parameter: Parameter$r2$delete$bucket$sippy$config;
}
export type ResponseContentType$registrar$domains$list$domains = keyof Response$registrar$domains$list$domains$Status$200;
export interface Params$registrar$domains$list$domains {
    parameter: Parameter$registrar$domains$list$domains;
}
export type ResponseContentType$registrar$domains$get$domain = keyof Response$registrar$domains$get$domain$Status$200;
export interface Params$registrar$domains$get$domain {
    parameter: Parameter$registrar$domains$get$domain;
}
export type RequestContentType$registrar$domains$update$domain = keyof RequestBody$registrar$domains$update$domain;
export type ResponseContentType$registrar$domains$update$domain = keyof Response$registrar$domains$update$domain$Status$200;
export interface Params$registrar$domains$update$domain {
    parameter: Parameter$registrar$domains$update$domain;
    requestBody: RequestBody$registrar$domains$update$domain["application/json"];
}
export type ResponseContentType$lists$get$lists = keyof Response$lists$get$lists$Status$200;
export interface Params$lists$get$lists {
    parameter: Parameter$lists$get$lists;
}
export type RequestContentType$lists$create$a$list = keyof RequestBody$lists$create$a$list;
export type ResponseContentType$lists$create$a$list = keyof Response$lists$create$a$list$Status$200;
export interface Params$lists$create$a$list {
    parameter: Parameter$lists$create$a$list;
    requestBody: RequestBody$lists$create$a$list["application/json"];
}
export type ResponseContentType$lists$get$a$list = keyof Response$lists$get$a$list$Status$200;
export interface Params$lists$get$a$list {
    parameter: Parameter$lists$get$a$list;
}
export type RequestContentType$lists$update$a$list = keyof RequestBody$lists$update$a$list;
export type ResponseContentType$lists$update$a$list = keyof Response$lists$update$a$list$Status$200;
export interface Params$lists$update$a$list {
    parameter: Parameter$lists$update$a$list;
    requestBody: RequestBody$lists$update$a$list["application/json"];
}
export type ResponseContentType$lists$delete$a$list = keyof Response$lists$delete$a$list$Status$200;
export interface Params$lists$delete$a$list {
    parameter: Parameter$lists$delete$a$list;
}
export type ResponseContentType$lists$get$list$items = keyof Response$lists$get$list$items$Status$200;
export interface Params$lists$get$list$items {
    parameter: Parameter$lists$get$list$items;
}
export type RequestContentType$lists$update$all$list$items = keyof RequestBody$lists$update$all$list$items;
export type ResponseContentType$lists$update$all$list$items = keyof Response$lists$update$all$list$items$Status$200;
export interface Params$lists$update$all$list$items {
    parameter: Parameter$lists$update$all$list$items;
    requestBody: RequestBody$lists$update$all$list$items["application/json"];
}
export type RequestContentType$lists$create$list$items = keyof RequestBody$lists$create$list$items;
export type ResponseContentType$lists$create$list$items = keyof Response$lists$create$list$items$Status$200;
export interface Params$lists$create$list$items {
    parameter: Parameter$lists$create$list$items;
    requestBody: RequestBody$lists$create$list$items["application/json"];
}
export type RequestContentType$lists$delete$list$items = keyof RequestBody$lists$delete$list$items;
export type ResponseContentType$lists$delete$list$items = keyof Response$lists$delete$list$items$Status$200;
export interface Params$lists$delete$list$items {
    parameter: Parameter$lists$delete$list$items;
    requestBody: RequestBody$lists$delete$list$items["application/json"];
}
export type ResponseContentType$listAccountRulesets = keyof Response$listAccountRulesets$Status$200;
export interface Params$listAccountRulesets {
    parameter: Parameter$listAccountRulesets;
}
export type RequestContentType$createAccountRuleset = keyof RequestBody$createAccountRuleset;
export type ResponseContentType$createAccountRuleset = keyof Response$createAccountRuleset$Status$200;
export interface Params$createAccountRuleset {
    parameter: Parameter$createAccountRuleset;
    requestBody: RequestBody$createAccountRuleset["application/json"];
}
export type ResponseContentType$getAccountRuleset = keyof Response$getAccountRuleset$Status$200;
export interface Params$getAccountRuleset {
    parameter: Parameter$getAccountRuleset;
}
export type RequestContentType$updateAccountRuleset = keyof RequestBody$updateAccountRuleset;
export type ResponseContentType$updateAccountRuleset = keyof Response$updateAccountRuleset$Status$200;
export interface Params$updateAccountRuleset {
    parameter: Parameter$updateAccountRuleset;
    requestBody: RequestBody$updateAccountRuleset["application/json"];
}
export interface Params$deleteAccountRuleset {
    parameter: Parameter$deleteAccountRuleset;
}
export type RequestContentType$createAccountRulesetRule = keyof RequestBody$createAccountRulesetRule;
export type ResponseContentType$createAccountRulesetRule = keyof Response$createAccountRulesetRule$Status$200;
export interface Params$createAccountRulesetRule {
    parameter: Parameter$createAccountRulesetRule;
    requestBody: RequestBody$createAccountRulesetRule["application/json"];
}
export type ResponseContentType$deleteAccountRulesetRule = keyof Response$deleteAccountRulesetRule$Status$200;
export interface Params$deleteAccountRulesetRule {
    parameter: Parameter$deleteAccountRulesetRule;
}
export type RequestContentType$updateAccountRulesetRule = keyof RequestBody$updateAccountRulesetRule;
export type ResponseContentType$updateAccountRulesetRule = keyof Response$updateAccountRulesetRule$Status$200;
export interface Params$updateAccountRulesetRule {
    parameter: Parameter$updateAccountRulesetRule;
    requestBody: RequestBody$updateAccountRulesetRule["application/json"];
}
export type ResponseContentType$listAccountRulesetVersions = keyof Response$listAccountRulesetVersions$Status$200;
export interface Params$listAccountRulesetVersions {
    parameter: Parameter$listAccountRulesetVersions;
}
export type ResponseContentType$getAccountRulesetVersion = keyof Response$getAccountRulesetVersion$Status$200;
export interface Params$getAccountRulesetVersion {
    parameter: Parameter$getAccountRulesetVersion;
}
export interface Params$deleteAccountRulesetVersion {
    parameter: Parameter$deleteAccountRulesetVersion;
}
export type ResponseContentType$listAccountRulesetVersionRulesByTag = keyof Response$listAccountRulesetVersionRulesByTag$Status$200;
export interface Params$listAccountRulesetVersionRulesByTag {
    parameter: Parameter$listAccountRulesetVersionRulesByTag;
}
export type ResponseContentType$getAccountEntrypointRuleset = keyof Response$getAccountEntrypointRuleset$Status$200;
export interface Params$getAccountEntrypointRuleset {
    parameter: Parameter$getAccountEntrypointRuleset;
}
export type RequestContentType$updateAccountEntrypointRuleset = keyof RequestBody$updateAccountEntrypointRuleset;
export type ResponseContentType$updateAccountEntrypointRuleset = keyof Response$updateAccountEntrypointRuleset$Status$200;
export interface Params$updateAccountEntrypointRuleset {
    parameter: Parameter$updateAccountEntrypointRuleset;
    requestBody: RequestBody$updateAccountEntrypointRuleset["application/json"];
}
export type ResponseContentType$listAccountEntrypointRulesetVersions = keyof Response$listAccountEntrypointRulesetVersions$Status$200;
export interface Params$listAccountEntrypointRulesetVersions {
    parameter: Parameter$listAccountEntrypointRulesetVersions;
}
export type ResponseContentType$getAccountEntrypointRulesetVersion = keyof Response$getAccountEntrypointRulesetVersion$Status$200;
export interface Params$getAccountEntrypointRulesetVersion {
    parameter: Parameter$getAccountEntrypointRulesetVersion;
}
export type ResponseContentType$stream$videos$list$videos = keyof Response$stream$videos$list$videos$Status$200;
export interface Params$stream$videos$list$videos {
    parameter: Parameter$stream$videos$list$videos;
}
export interface Params$stream$videos$initiate$video$uploads$using$tus {
    parameter: Parameter$stream$videos$initiate$video$uploads$using$tus;
}
export type ResponseContentType$stream$videos$retrieve$video$details = keyof Response$stream$videos$retrieve$video$details$Status$200;
export interface Params$stream$videos$retrieve$video$details {
    parameter: Parameter$stream$videos$retrieve$video$details;
}
export type RequestContentType$stream$videos$update$video$details = keyof RequestBody$stream$videos$update$video$details;
export type ResponseContentType$stream$videos$update$video$details = keyof Response$stream$videos$update$video$details$Status$200;
export interface Params$stream$videos$update$video$details {
    parameter: Parameter$stream$videos$update$video$details;
    requestBody: RequestBody$stream$videos$update$video$details["application/json"];
}
export interface Params$stream$videos$delete$video {
    parameter: Parameter$stream$videos$delete$video;
}
export type ResponseContentType$list$audio$tracks = keyof Response$list$audio$tracks$Status$200;
export interface Params$list$audio$tracks {
    parameter: Parameter$list$audio$tracks;
}
export type ResponseContentType$delete$audio$tracks = keyof Response$delete$audio$tracks$Status$200;
export interface Params$delete$audio$tracks {
    parameter: Parameter$delete$audio$tracks;
}
export type RequestContentType$edit$audio$tracks = keyof RequestBody$edit$audio$tracks;
export type ResponseContentType$edit$audio$tracks = keyof Response$edit$audio$tracks$Status$200;
export interface Params$edit$audio$tracks {
    parameter: Parameter$edit$audio$tracks;
    requestBody: RequestBody$edit$audio$tracks["application/json"];
}
export type RequestContentType$add$audio$track = keyof RequestBody$add$audio$track;
export type ResponseContentType$add$audio$track = keyof Response$add$audio$track$Status$200;
export interface Params$add$audio$track {
    parameter: Parameter$add$audio$track;
    requestBody: RequestBody$add$audio$track["application/json"];
}
export type ResponseContentType$stream$subtitles$$captions$list$captions$or$subtitles = keyof Response$stream$subtitles$$captions$list$captions$or$subtitles$Status$200;
export interface Params$stream$subtitles$$captions$list$captions$or$subtitles {
    parameter: Parameter$stream$subtitles$$captions$list$captions$or$subtitles;
}
export type RequestContentType$stream$subtitles$$captions$upload$captions$or$subtitles = keyof RequestBody$stream$subtitles$$captions$upload$captions$or$subtitles;
export type ResponseContentType$stream$subtitles$$captions$upload$captions$or$subtitles = keyof Response$stream$subtitles$$captions$upload$captions$or$subtitles$Status$200;
export interface Params$stream$subtitles$$captions$upload$captions$or$subtitles {
    parameter: Parameter$stream$subtitles$$captions$upload$captions$or$subtitles;
    requestBody: RequestBody$stream$subtitles$$captions$upload$captions$or$subtitles["multipart/form-data"];
}
export type ResponseContentType$stream$subtitles$$captions$delete$captions$or$subtitles = keyof Response$stream$subtitles$$captions$delete$captions$or$subtitles$Status$200;
export interface Params$stream$subtitles$$captions$delete$captions$or$subtitles {
    parameter: Parameter$stream$subtitles$$captions$delete$captions$or$subtitles;
}
export type ResponseContentType$stream$m$p$4$downloads$list$downloads = keyof Response$stream$m$p$4$downloads$list$downloads$Status$200;
export interface Params$stream$m$p$4$downloads$list$downloads {
    parameter: Parameter$stream$m$p$4$downloads$list$downloads;
}
export type ResponseContentType$stream$m$p$4$downloads$create$downloads = keyof Response$stream$m$p$4$downloads$create$downloads$Status$200;
export interface Params$stream$m$p$4$downloads$create$downloads {
    parameter: Parameter$stream$m$p$4$downloads$create$downloads;
}
export type ResponseContentType$stream$m$p$4$downloads$delete$downloads = keyof Response$stream$m$p$4$downloads$delete$downloads$Status$200;
export interface Params$stream$m$p$4$downloads$delete$downloads {
    parameter: Parameter$stream$m$p$4$downloads$delete$downloads;
}
export type ResponseContentType$stream$videos$retreieve$embed$code$html = keyof Response$stream$videos$retreieve$embed$code$html$Status$200;
export interface Params$stream$videos$retreieve$embed$code$html {
    parameter: Parameter$stream$videos$retreieve$embed$code$html;
}
export type RequestContentType$stream$videos$create$signed$url$tokens$for$videos = keyof RequestBody$stream$videos$create$signed$url$tokens$for$videos;
export type ResponseContentType$stream$videos$create$signed$url$tokens$for$videos = keyof Response$stream$videos$create$signed$url$tokens$for$videos$Status$200;
export interface Params$stream$videos$create$signed$url$tokens$for$videos {
    parameter: Parameter$stream$videos$create$signed$url$tokens$for$videos;
    requestBody: RequestBody$stream$videos$create$signed$url$tokens$for$videos["application/json"];
}
export type RequestContentType$stream$video$clipping$clip$videos$given$a$start$and$end$time = keyof RequestBody$stream$video$clipping$clip$videos$given$a$start$and$end$time;
export type ResponseContentType$stream$video$clipping$clip$videos$given$a$start$and$end$time = keyof Response$stream$video$clipping$clip$videos$given$a$start$and$end$time$Status$200;
export interface Params$stream$video$clipping$clip$videos$given$a$start$and$end$time {
    parameter: Parameter$stream$video$clipping$clip$videos$given$a$start$and$end$time;
    requestBody: RequestBody$stream$video$clipping$clip$videos$given$a$start$and$end$time["application/json"];
}
export type RequestContentType$stream$videos$upload$videos$from$a$url = keyof RequestBody$stream$videos$upload$videos$from$a$url;
export type ResponseContentType$stream$videos$upload$videos$from$a$url = keyof Response$stream$videos$upload$videos$from$a$url$Status$200;
export interface Params$stream$videos$upload$videos$from$a$url {
    parameter: Parameter$stream$videos$upload$videos$from$a$url;
    requestBody: RequestBody$stream$videos$upload$videos$from$a$url["application/json"];
}
export type RequestContentType$stream$videos$upload$videos$via$direct$upload$ur$ls = keyof RequestBody$stream$videos$upload$videos$via$direct$upload$ur$ls;
export type ResponseContentType$stream$videos$upload$videos$via$direct$upload$ur$ls = keyof Response$stream$videos$upload$videos$via$direct$upload$ur$ls$Status$200;
export interface Params$stream$videos$upload$videos$via$direct$upload$ur$ls {
    parameter: Parameter$stream$videos$upload$videos$via$direct$upload$ur$ls;
    requestBody: RequestBody$stream$videos$upload$videos$via$direct$upload$ur$ls["application/json"];
}
export type ResponseContentType$stream$signing$keys$list$signing$keys = keyof Response$stream$signing$keys$list$signing$keys$Status$200;
export interface Params$stream$signing$keys$list$signing$keys {
    parameter: Parameter$stream$signing$keys$list$signing$keys;
}
export type ResponseContentType$stream$signing$keys$create$signing$keys = keyof Response$stream$signing$keys$create$signing$keys$Status$200;
export interface Params$stream$signing$keys$create$signing$keys {
    parameter: Parameter$stream$signing$keys$create$signing$keys;
}
export type ResponseContentType$stream$signing$keys$delete$signing$keys = keyof Response$stream$signing$keys$delete$signing$keys$Status$200;
export interface Params$stream$signing$keys$delete$signing$keys {
    parameter: Parameter$stream$signing$keys$delete$signing$keys;
}
export type ResponseContentType$stream$live$inputs$list$live$inputs = keyof Response$stream$live$inputs$list$live$inputs$Status$200;
export interface Params$stream$live$inputs$list$live$inputs {
    parameter: Parameter$stream$live$inputs$list$live$inputs;
}
export type RequestContentType$stream$live$inputs$create$a$live$input = keyof RequestBody$stream$live$inputs$create$a$live$input;
export type ResponseContentType$stream$live$inputs$create$a$live$input = keyof Response$stream$live$inputs$create$a$live$input$Status$200;
export interface Params$stream$live$inputs$create$a$live$input {
    parameter: Parameter$stream$live$inputs$create$a$live$input;
    requestBody: RequestBody$stream$live$inputs$create$a$live$input["application/json"];
}
export type ResponseContentType$stream$live$inputs$retrieve$a$live$input = keyof Response$stream$live$inputs$retrieve$a$live$input$Status$200;
export interface Params$stream$live$inputs$retrieve$a$live$input {
    parameter: Parameter$stream$live$inputs$retrieve$a$live$input;
}
export type RequestContentType$stream$live$inputs$update$a$live$input = keyof RequestBody$stream$live$inputs$update$a$live$input;
export type ResponseContentType$stream$live$inputs$update$a$live$input = keyof Response$stream$live$inputs$update$a$live$input$Status$200;
export interface Params$stream$live$inputs$update$a$live$input {
    parameter: Parameter$stream$live$inputs$update$a$live$input;
    requestBody: RequestBody$stream$live$inputs$update$a$live$input["application/json"];
}
export interface Params$stream$live$inputs$delete$a$live$input {
    parameter: Parameter$stream$live$inputs$delete$a$live$input;
}
export type ResponseContentType$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input = keyof Response$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input$Status$200;
export interface Params$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input {
    parameter: Parameter$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input;
}
export type RequestContentType$stream$live$inputs$create$a$new$output$$connected$to$a$live$input = keyof RequestBody$stream$live$inputs$create$a$new$output$$connected$to$a$live$input;
export type ResponseContentType$stream$live$inputs$create$a$new$output$$connected$to$a$live$input = keyof Response$stream$live$inputs$create$a$new$output$$connected$to$a$live$input$Status$200;
export interface Params$stream$live$inputs$create$a$new$output$$connected$to$a$live$input {
    parameter: Parameter$stream$live$inputs$create$a$new$output$$connected$to$a$live$input;
    requestBody: RequestBody$stream$live$inputs$create$a$new$output$$connected$to$a$live$input["application/json"];
}
export type RequestContentType$stream$live$inputs$update$an$output = keyof RequestBody$stream$live$inputs$update$an$output;
export type ResponseContentType$stream$live$inputs$update$an$output = keyof Response$stream$live$inputs$update$an$output$Status$200;
export interface Params$stream$live$inputs$update$an$output {
    parameter: Parameter$stream$live$inputs$update$an$output;
    requestBody: RequestBody$stream$live$inputs$update$an$output["application/json"];
}
export interface Params$stream$live$inputs$delete$an$output {
    parameter: Parameter$stream$live$inputs$delete$an$output;
}
export type ResponseContentType$stream$videos$storage$usage = keyof Response$stream$videos$storage$usage$Status$200;
export interface Params$stream$videos$storage$usage {
    parameter: Parameter$stream$videos$storage$usage;
}
export type ResponseContentType$stream$watermark$profile$list$watermark$profiles = keyof Response$stream$watermark$profile$list$watermark$profiles$Status$200;
export interface Params$stream$watermark$profile$list$watermark$profiles {
    parameter: Parameter$stream$watermark$profile$list$watermark$profiles;
}
export type RequestContentType$stream$watermark$profile$create$watermark$profiles$via$basic$upload = keyof RequestBody$stream$watermark$profile$create$watermark$profiles$via$basic$upload;
export type ResponseContentType$stream$watermark$profile$create$watermark$profiles$via$basic$upload = keyof Response$stream$watermark$profile$create$watermark$profiles$via$basic$upload$Status$200;
export interface Params$stream$watermark$profile$create$watermark$profiles$via$basic$upload {
    parameter: Parameter$stream$watermark$profile$create$watermark$profiles$via$basic$upload;
    requestBody: RequestBody$stream$watermark$profile$create$watermark$profiles$via$basic$upload["multipart/form-data"];
}
export type ResponseContentType$stream$watermark$profile$watermark$profile$details = keyof Response$stream$watermark$profile$watermark$profile$details$Status$200;
export interface Params$stream$watermark$profile$watermark$profile$details {
    parameter: Parameter$stream$watermark$profile$watermark$profile$details;
}
export type ResponseContentType$stream$watermark$profile$delete$watermark$profiles = keyof Response$stream$watermark$profile$delete$watermark$profiles$Status$200;
export interface Params$stream$watermark$profile$delete$watermark$profiles {
    parameter: Parameter$stream$watermark$profile$delete$watermark$profiles;
}
export type ResponseContentType$stream$webhook$view$webhooks = keyof Response$stream$webhook$view$webhooks$Status$200;
export interface Params$stream$webhook$view$webhooks {
    parameter: Parameter$stream$webhook$view$webhooks;
}
export type RequestContentType$stream$webhook$create$webhooks = keyof RequestBody$stream$webhook$create$webhooks;
export type ResponseContentType$stream$webhook$create$webhooks = keyof Response$stream$webhook$create$webhooks$Status$200;
export interface Params$stream$webhook$create$webhooks {
    parameter: Parameter$stream$webhook$create$webhooks;
    requestBody: RequestBody$stream$webhook$create$webhooks["application/json"];
}
export type ResponseContentType$stream$webhook$delete$webhooks = keyof Response$stream$webhook$delete$webhooks$Status$200;
export interface Params$stream$webhook$delete$webhooks {
    parameter: Parameter$stream$webhook$delete$webhooks;
}
export type ResponseContentType$tunnel$route$list$tunnel$routes = keyof Response$tunnel$route$list$tunnel$routes$Status$200;
export interface Params$tunnel$route$list$tunnel$routes {
    parameter: Parameter$tunnel$route$list$tunnel$routes;
}
export type RequestContentType$tunnel$route$create$a$tunnel$route = keyof RequestBody$tunnel$route$create$a$tunnel$route;
export type ResponseContentType$tunnel$route$create$a$tunnel$route = keyof Response$tunnel$route$create$a$tunnel$route$Status$200;
export interface Params$tunnel$route$create$a$tunnel$route {
    parameter: Parameter$tunnel$route$create$a$tunnel$route;
    requestBody: RequestBody$tunnel$route$create$a$tunnel$route["application/json"];
}
export type ResponseContentType$tunnel$route$delete$a$tunnel$route = keyof Response$tunnel$route$delete$a$tunnel$route$Status$200;
export interface Params$tunnel$route$delete$a$tunnel$route {
    parameter: Parameter$tunnel$route$delete$a$tunnel$route;
}
export type RequestContentType$tunnel$route$update$a$tunnel$route = keyof RequestBody$tunnel$route$update$a$tunnel$route;
export type ResponseContentType$tunnel$route$update$a$tunnel$route = keyof Response$tunnel$route$update$a$tunnel$route$Status$200;
export interface Params$tunnel$route$update$a$tunnel$route {
    parameter: Parameter$tunnel$route$update$a$tunnel$route;
    requestBody: RequestBody$tunnel$route$update$a$tunnel$route["application/json"];
}
export type ResponseContentType$tunnel$route$get$tunnel$route$by$ip = keyof Response$tunnel$route$get$tunnel$route$by$ip$Status$200;
export interface Params$tunnel$route$get$tunnel$route$by$ip {
    parameter: Parameter$tunnel$route$get$tunnel$route$by$ip;
}
export type RequestContentType$tunnel$route$create$a$tunnel$route$with$cidr = keyof RequestBody$tunnel$route$create$a$tunnel$route$with$cidr;
export type ResponseContentType$tunnel$route$create$a$tunnel$route$with$cidr = keyof Response$tunnel$route$create$a$tunnel$route$with$cidr$Status$200;
export interface Params$tunnel$route$create$a$tunnel$route$with$cidr {
    parameter: Parameter$tunnel$route$create$a$tunnel$route$with$cidr;
    requestBody: RequestBody$tunnel$route$create$a$tunnel$route$with$cidr["application/json"];
}
export type ResponseContentType$tunnel$route$delete$a$tunnel$route$with$cidr = keyof Response$tunnel$route$delete$a$tunnel$route$with$cidr$Status$200;
export interface Params$tunnel$route$delete$a$tunnel$route$with$cidr {
    parameter: Parameter$tunnel$route$delete$a$tunnel$route$with$cidr;
}
export type ResponseContentType$tunnel$route$update$a$tunnel$route$with$cidr = keyof Response$tunnel$route$update$a$tunnel$route$with$cidr$Status$200;
export interface Params$tunnel$route$update$a$tunnel$route$with$cidr {
    parameter: Parameter$tunnel$route$update$a$tunnel$route$with$cidr;
}
export type ResponseContentType$tunnel$virtual$network$list$virtual$networks = keyof Response$tunnel$virtual$network$list$virtual$networks$Status$200;
export interface Params$tunnel$virtual$network$list$virtual$networks {
    parameter: Parameter$tunnel$virtual$network$list$virtual$networks;
}
export type RequestContentType$tunnel$virtual$network$create$a$virtual$network = keyof RequestBody$tunnel$virtual$network$create$a$virtual$network;
export type ResponseContentType$tunnel$virtual$network$create$a$virtual$network = keyof Response$tunnel$virtual$network$create$a$virtual$network$Status$200;
export interface Params$tunnel$virtual$network$create$a$virtual$network {
    parameter: Parameter$tunnel$virtual$network$create$a$virtual$network;
    requestBody: RequestBody$tunnel$virtual$network$create$a$virtual$network["application/json"];
}
export type ResponseContentType$tunnel$virtual$network$delete$a$virtual$network = keyof Response$tunnel$virtual$network$delete$a$virtual$network$Status$200;
export interface Params$tunnel$virtual$network$delete$a$virtual$network {
    parameter: Parameter$tunnel$virtual$network$delete$a$virtual$network;
}
export type RequestContentType$tunnel$virtual$network$update$a$virtual$network = keyof RequestBody$tunnel$virtual$network$update$a$virtual$network;
export type ResponseContentType$tunnel$virtual$network$update$a$virtual$network = keyof Response$tunnel$virtual$network$update$a$virtual$network$Status$200;
export interface Params$tunnel$virtual$network$update$a$virtual$network {
    parameter: Parameter$tunnel$virtual$network$update$a$virtual$network;
    requestBody: RequestBody$tunnel$virtual$network$update$a$virtual$network["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$list$all$tunnels = keyof Response$cloudflare$tunnel$list$all$tunnels$Status$200;
export interface Params$cloudflare$tunnel$list$all$tunnels {
    parameter: Parameter$cloudflare$tunnel$list$all$tunnels;
}
export type RequestContentType$argo$tunnel$create$an$argo$tunnel = keyof RequestBody$argo$tunnel$create$an$argo$tunnel;
export type ResponseContentType$argo$tunnel$create$an$argo$tunnel = keyof Response$argo$tunnel$create$an$argo$tunnel$Status$200;
export interface Params$argo$tunnel$create$an$argo$tunnel {
    parameter: Parameter$argo$tunnel$create$an$argo$tunnel;
    requestBody: RequestBody$argo$tunnel$create$an$argo$tunnel["application/json"];
}
export type ResponseContentType$argo$tunnel$get$an$argo$tunnel = keyof Response$argo$tunnel$get$an$argo$tunnel$Status$200;
export interface Params$argo$tunnel$get$an$argo$tunnel {
    parameter: Parameter$argo$tunnel$get$an$argo$tunnel;
}
export type RequestContentType$argo$tunnel$delete$an$argo$tunnel = keyof RequestBody$argo$tunnel$delete$an$argo$tunnel;
export type ResponseContentType$argo$tunnel$delete$an$argo$tunnel = keyof Response$argo$tunnel$delete$an$argo$tunnel$Status$200;
export interface Params$argo$tunnel$delete$an$argo$tunnel {
    parameter: Parameter$argo$tunnel$delete$an$argo$tunnel;
    requestBody: RequestBody$argo$tunnel$delete$an$argo$tunnel["application/json"];
}
export type RequestContentType$argo$tunnel$clean$up$argo$tunnel$connections = keyof RequestBody$argo$tunnel$clean$up$argo$tunnel$connections;
export type ResponseContentType$argo$tunnel$clean$up$argo$tunnel$connections = keyof Response$argo$tunnel$clean$up$argo$tunnel$connections$Status$200;
export interface Params$argo$tunnel$clean$up$argo$tunnel$connections {
    parameter: Parameter$argo$tunnel$clean$up$argo$tunnel$connections;
    requestBody: RequestBody$argo$tunnel$clean$up$argo$tunnel$connections["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$list$warp$connector$tunnels = keyof Response$cloudflare$tunnel$list$warp$connector$tunnels$Status$200;
export interface Params$cloudflare$tunnel$list$warp$connector$tunnels {
    parameter: Parameter$cloudflare$tunnel$list$warp$connector$tunnels;
}
export type RequestContentType$cloudflare$tunnel$create$a$warp$connector$tunnel = keyof RequestBody$cloudflare$tunnel$create$a$warp$connector$tunnel;
export type ResponseContentType$cloudflare$tunnel$create$a$warp$connector$tunnel = keyof Response$cloudflare$tunnel$create$a$warp$connector$tunnel$Status$200;
export interface Params$cloudflare$tunnel$create$a$warp$connector$tunnel {
    parameter: Parameter$cloudflare$tunnel$create$a$warp$connector$tunnel;
    requestBody: RequestBody$cloudflare$tunnel$create$a$warp$connector$tunnel["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$get$a$warp$connector$tunnel = keyof Response$cloudflare$tunnel$get$a$warp$connector$tunnel$Status$200;
export interface Params$cloudflare$tunnel$get$a$warp$connector$tunnel {
    parameter: Parameter$cloudflare$tunnel$get$a$warp$connector$tunnel;
}
export type RequestContentType$cloudflare$tunnel$delete$a$warp$connector$tunnel = keyof RequestBody$cloudflare$tunnel$delete$a$warp$connector$tunnel;
export type ResponseContentType$cloudflare$tunnel$delete$a$warp$connector$tunnel = keyof Response$cloudflare$tunnel$delete$a$warp$connector$tunnel$Status$200;
export interface Params$cloudflare$tunnel$delete$a$warp$connector$tunnel {
    parameter: Parameter$cloudflare$tunnel$delete$a$warp$connector$tunnel;
    requestBody: RequestBody$cloudflare$tunnel$delete$a$warp$connector$tunnel["application/json"];
}
export type RequestContentType$cloudflare$tunnel$update$a$warp$connector$tunnel = keyof RequestBody$cloudflare$tunnel$update$a$warp$connector$tunnel;
export type ResponseContentType$cloudflare$tunnel$update$a$warp$connector$tunnel = keyof Response$cloudflare$tunnel$update$a$warp$connector$tunnel$Status$200;
export interface Params$cloudflare$tunnel$update$a$warp$connector$tunnel {
    parameter: Parameter$cloudflare$tunnel$update$a$warp$connector$tunnel;
    requestBody: RequestBody$cloudflare$tunnel$update$a$warp$connector$tunnel["application/json"];
}
export type ResponseContentType$cloudflare$tunnel$get$a$warp$connector$tunnel$token = keyof Response$cloudflare$tunnel$get$a$warp$connector$tunnel$token$Status$200;
export interface Params$cloudflare$tunnel$get$a$warp$connector$tunnel$token {
    parameter: Parameter$cloudflare$tunnel$get$a$warp$connector$tunnel$token;
}
export type ResponseContentType$worker$account$settings$fetch$worker$account$settings = keyof Response$worker$account$settings$fetch$worker$account$settings$Status$200;
export interface Params$worker$account$settings$fetch$worker$account$settings {
    parameter: Parameter$worker$account$settings$fetch$worker$account$settings;
}
export type RequestContentType$worker$account$settings$create$worker$account$settings = keyof RequestBody$worker$account$settings$create$worker$account$settings;
export type ResponseContentType$worker$account$settings$create$worker$account$settings = keyof Response$worker$account$settings$create$worker$account$settings$Status$200;
export interface Params$worker$account$settings$create$worker$account$settings {
    parameter: Parameter$worker$account$settings$create$worker$account$settings;
    requestBody: RequestBody$worker$account$settings$create$worker$account$settings["application/json"];
}
export type ResponseContentType$worker$deployments$list$deployments = keyof Response$worker$deployments$list$deployments$Status$200;
export interface Params$worker$deployments$list$deployments {
    parameter: Parameter$worker$deployments$list$deployments;
}
export type ResponseContentType$worker$deployments$get$deployment$detail = keyof Response$worker$deployments$get$deployment$detail$Status$200;
export interface Params$worker$deployments$get$deployment$detail {
    parameter: Parameter$worker$deployments$get$deployment$detail;
}
export type ResponseContentType$namespace$worker$script$worker$details = keyof Response$namespace$worker$script$worker$details$Status$200;
export interface Params$namespace$worker$script$worker$details {
    parameter: Parameter$namespace$worker$script$worker$details;
}
export type RequestContentType$namespace$worker$script$upload$worker$module = keyof RequestBody$namespace$worker$script$upload$worker$module;
export type ResponseContentType$namespace$worker$script$upload$worker$module = keyof Response$namespace$worker$script$upload$worker$module$Status$200;
export interface Params$namespace$worker$script$upload$worker$module<T extends RequestContentType$namespace$worker$script$upload$worker$module> {
    headers: {
        "Content-Type": T;
    };
    parameter: Parameter$namespace$worker$script$upload$worker$module;
    requestBody: RequestBody$namespace$worker$script$upload$worker$module[T];
}
export interface Params$namespace$worker$script$delete$worker {
    parameter: Parameter$namespace$worker$script$delete$worker;
}
export type ResponseContentType$namespace$worker$get$script$content = keyof Response$namespace$worker$get$script$content$Status$200;
export interface Params$namespace$worker$get$script$content {
    parameter: Parameter$namespace$worker$get$script$content;
}
export type RequestContentType$namespace$worker$put$script$content = keyof RequestBody$namespace$worker$put$script$content;
export type ResponseContentType$namespace$worker$put$script$content = keyof Response$namespace$worker$put$script$content$Status$200;
export interface Params$namespace$worker$put$script$content {
    parameter: Parameter$namespace$worker$put$script$content;
    requestBody: RequestBody$namespace$worker$put$script$content["multipart/form-data"];
}
export type ResponseContentType$namespace$worker$get$script$settings = keyof Response$namespace$worker$get$script$settings$Status$200;
export interface Params$namespace$worker$get$script$settings {
    parameter: Parameter$namespace$worker$get$script$settings;
}
export type RequestContentType$namespace$worker$patch$script$settings = keyof RequestBody$namespace$worker$patch$script$settings;
export type ResponseContentType$namespace$worker$patch$script$settings = keyof Response$namespace$worker$patch$script$settings$Status$200;
export interface Params$namespace$worker$patch$script$settings {
    parameter: Parameter$namespace$worker$patch$script$settings;
    requestBody: RequestBody$namespace$worker$patch$script$settings["application/json"];
}
export type ResponseContentType$worker$domain$list$domains = keyof Response$worker$domain$list$domains$Status$200;
export interface Params$worker$domain$list$domains {
    parameter: Parameter$worker$domain$list$domains;
}
export type RequestContentType$worker$domain$attach$to$domain = keyof RequestBody$worker$domain$attach$to$domain;
export type ResponseContentType$worker$domain$attach$to$domain = keyof Response$worker$domain$attach$to$domain$Status$200;
export interface Params$worker$domain$attach$to$domain {
    parameter: Parameter$worker$domain$attach$to$domain;
    requestBody: RequestBody$worker$domain$attach$to$domain["application/json"];
}
export type ResponseContentType$worker$domain$get$a$domain = keyof Response$worker$domain$get$a$domain$Status$200;
export interface Params$worker$domain$get$a$domain {
    parameter: Parameter$worker$domain$get$a$domain;
}
export interface Params$worker$domain$detach$from$domain {
    parameter: Parameter$worker$domain$detach$from$domain;
}
export type ResponseContentType$durable$objects$namespace$list$namespaces = keyof Response$durable$objects$namespace$list$namespaces$Status$200;
export interface Params$durable$objects$namespace$list$namespaces {
    parameter: Parameter$durable$objects$namespace$list$namespaces;
}
export type ResponseContentType$durable$objects$namespace$list$objects = keyof Response$durable$objects$namespace$list$objects$Status$200;
export interface Params$durable$objects$namespace$list$objects {
    parameter: Parameter$durable$objects$namespace$list$objects;
}
export type ResponseContentType$queue$list$queues = keyof Response$queue$list$queues$Status$200;
export interface Params$queue$list$queues {
    parameter: Parameter$queue$list$queues;
}
export type RequestContentType$queue$create$queue = keyof RequestBody$queue$create$queue;
export type ResponseContentType$queue$create$queue = keyof Response$queue$create$queue$Status$200;
export interface Params$queue$create$queue {
    parameter: Parameter$queue$create$queue;
    requestBody: RequestBody$queue$create$queue["application/json"];
}
export type ResponseContentType$queue$queue$details = keyof Response$queue$queue$details$Status$200;
export interface Params$queue$queue$details {
    parameter: Parameter$queue$queue$details;
}
export type RequestContentType$queue$update$queue = keyof RequestBody$queue$update$queue;
export type ResponseContentType$queue$update$queue = keyof Response$queue$update$queue$Status$200;
export interface Params$queue$update$queue {
    parameter: Parameter$queue$update$queue;
    requestBody: RequestBody$queue$update$queue["application/json"];
}
export type ResponseContentType$queue$delete$queue = keyof Response$queue$delete$queue$Status$200;
export interface Params$queue$delete$queue {
    parameter: Parameter$queue$delete$queue;
}
export type ResponseContentType$queue$list$queue$consumers = keyof Response$queue$list$queue$consumers$Status$200;
export interface Params$queue$list$queue$consumers {
    parameter: Parameter$queue$list$queue$consumers;
}
export type RequestContentType$queue$create$queue$consumer = keyof RequestBody$queue$create$queue$consumer;
export type ResponseContentType$queue$create$queue$consumer = keyof Response$queue$create$queue$consumer$Status$200;
export interface Params$queue$create$queue$consumer {
    parameter: Parameter$queue$create$queue$consumer;
    requestBody: RequestBody$queue$create$queue$consumer["application/json"];
}
export type RequestContentType$queue$update$queue$consumer = keyof RequestBody$queue$update$queue$consumer;
export type ResponseContentType$queue$update$queue$consumer = keyof Response$queue$update$queue$consumer$Status$200;
export interface Params$queue$update$queue$consumer {
    parameter: Parameter$queue$update$queue$consumer;
    requestBody: RequestBody$queue$update$queue$consumer["application/json"];
}
export type ResponseContentType$queue$delete$queue$consumer = keyof Response$queue$delete$queue$consumer$Status$200;
export interface Params$queue$delete$queue$consumer {
    parameter: Parameter$queue$delete$queue$consumer;
}
export type ResponseContentType$worker$script$list$workers = keyof Response$worker$script$list$workers$Status$200;
export interface Params$worker$script$list$workers {
    parameter: Parameter$worker$script$list$workers;
}
export type ResponseContentType$worker$script$download$worker = keyof Response$worker$script$download$worker$Status$200;
export interface Params$worker$script$download$worker {
    parameter: Parameter$worker$script$download$worker;
}
export type RequestContentType$worker$script$upload$worker$module = keyof RequestBody$worker$script$upload$worker$module;
export type ResponseContentType$worker$script$upload$worker$module = keyof Response$worker$script$upload$worker$module$Status$200;
export interface Params$worker$script$upload$worker$module<T extends RequestContentType$worker$script$upload$worker$module> {
    headers: {
        "Content-Type": T;
    };
    parameter: Parameter$worker$script$upload$worker$module;
    requestBody: RequestBody$worker$script$upload$worker$module[T];
}
export interface Params$worker$script$delete$worker {
    parameter: Parameter$worker$script$delete$worker;
}
export type RequestContentType$worker$script$put$content = keyof RequestBody$worker$script$put$content;
export type ResponseContentType$worker$script$put$content = keyof Response$worker$script$put$content$Status$200;
export interface Params$worker$script$put$content {
    parameter: Parameter$worker$script$put$content;
    requestBody: RequestBody$worker$script$put$content["multipart/form-data"];
}
export type ResponseContentType$worker$script$get$content = keyof Response$worker$script$get$content$Status$200;
export interface Params$worker$script$get$content {
    parameter: Parameter$worker$script$get$content;
}
export type ResponseContentType$worker$cron$trigger$get$cron$triggers = keyof Response$worker$cron$trigger$get$cron$triggers$Status$200;
export interface Params$worker$cron$trigger$get$cron$triggers {
    parameter: Parameter$worker$cron$trigger$get$cron$triggers;
}
export type RequestContentType$worker$cron$trigger$update$cron$triggers = keyof RequestBody$worker$cron$trigger$update$cron$triggers;
export type ResponseContentType$worker$cron$trigger$update$cron$triggers = keyof Response$worker$cron$trigger$update$cron$triggers$Status$200;
export interface Params$worker$cron$trigger$update$cron$triggers {
    parameter: Parameter$worker$cron$trigger$update$cron$triggers;
    requestBody: RequestBody$worker$cron$trigger$update$cron$triggers["application/json"];
}
export type ResponseContentType$worker$script$get$settings = keyof Response$worker$script$get$settings$Status$200;
export interface Params$worker$script$get$settings {
    parameter: Parameter$worker$script$get$settings;
}
export type RequestContentType$worker$script$patch$settings = keyof RequestBody$worker$script$patch$settings;
export type ResponseContentType$worker$script$patch$settings = keyof Response$worker$script$patch$settings$Status$200;
export interface Params$worker$script$patch$settings {
    parameter: Parameter$worker$script$patch$settings;
    requestBody: RequestBody$worker$script$patch$settings["multipart/form-data"];
}
export type ResponseContentType$worker$tail$logs$list$tails = keyof Response$worker$tail$logs$list$tails$Status$200;
export interface Params$worker$tail$logs$list$tails {
    parameter: Parameter$worker$tail$logs$list$tails;
}
export type ResponseContentType$worker$tail$logs$start$tail = keyof Response$worker$tail$logs$start$tail$Status$200;
export interface Params$worker$tail$logs$start$tail {
    parameter: Parameter$worker$tail$logs$start$tail;
}
export type ResponseContentType$worker$tail$logs$delete$tail = keyof Response$worker$tail$logs$delete$tail$Status$200;
export interface Params$worker$tail$logs$delete$tail {
    parameter: Parameter$worker$tail$logs$delete$tail;
}
export type ResponseContentType$worker$script$fetch$usage$model = keyof Response$worker$script$fetch$usage$model$Status$200;
export interface Params$worker$script$fetch$usage$model {
    parameter: Parameter$worker$script$fetch$usage$model;
}
export type RequestContentType$worker$script$update$usage$model = keyof RequestBody$worker$script$update$usage$model;
export type ResponseContentType$worker$script$update$usage$model = keyof Response$worker$script$update$usage$model$Status$200;
export interface Params$worker$script$update$usage$model {
    parameter: Parameter$worker$script$update$usage$model;
    requestBody: RequestBody$worker$script$update$usage$model["application/json"];
}
export type ResponseContentType$worker$environment$get$script$content = keyof Response$worker$environment$get$script$content$Status$200;
export interface Params$worker$environment$get$script$content {
    parameter: Parameter$worker$environment$get$script$content;
}
export type RequestContentType$worker$environment$put$script$content = keyof RequestBody$worker$environment$put$script$content;
export type ResponseContentType$worker$environment$put$script$content = keyof Response$worker$environment$put$script$content$Status$200;
export interface Params$worker$environment$put$script$content {
    parameter: Parameter$worker$environment$put$script$content;
    requestBody: RequestBody$worker$environment$put$script$content["multipart/form-data"];
}
export type ResponseContentType$worker$script$environment$get$settings = keyof Response$worker$script$environment$get$settings$Status$200;
export interface Params$worker$script$environment$get$settings {
    parameter: Parameter$worker$script$environment$get$settings;
}
export type RequestContentType$worker$script$environment$patch$settings = keyof RequestBody$worker$script$environment$patch$settings;
export type ResponseContentType$worker$script$environment$patch$settings = keyof Response$worker$script$environment$patch$settings$Status$200;
export interface Params$worker$script$environment$patch$settings {
    parameter: Parameter$worker$script$environment$patch$settings;
    requestBody: RequestBody$worker$script$environment$patch$settings["application/json"];
}
export type ResponseContentType$worker$subdomain$get$subdomain = keyof Response$worker$subdomain$get$subdomain$Status$200;
export interface Params$worker$subdomain$get$subdomain {
    parameter: Parameter$worker$subdomain$get$subdomain;
}
export type RequestContentType$worker$subdomain$create$subdomain = keyof RequestBody$worker$subdomain$create$subdomain;
export type ResponseContentType$worker$subdomain$create$subdomain = keyof Response$worker$subdomain$create$subdomain$Status$200;
export interface Params$worker$subdomain$create$subdomain {
    parameter: Parameter$worker$subdomain$create$subdomain;
    requestBody: RequestBody$worker$subdomain$create$subdomain["application/json"];
}
export type ResponseContentType$zero$trust$accounts$get$connectivity$settings = keyof Response$zero$trust$accounts$get$connectivity$settings$Status$200;
export interface Params$zero$trust$accounts$get$connectivity$settings {
    parameter: Parameter$zero$trust$accounts$get$connectivity$settings;
}
export type RequestContentType$zero$trust$accounts$patch$connectivity$settings = keyof RequestBody$zero$trust$accounts$patch$connectivity$settings;
export type ResponseContentType$zero$trust$accounts$patch$connectivity$settings = keyof Response$zero$trust$accounts$patch$connectivity$settings$Status$200;
export interface Params$zero$trust$accounts$patch$connectivity$settings {
    parameter: Parameter$zero$trust$accounts$patch$connectivity$settings;
    requestBody: RequestBody$zero$trust$accounts$patch$connectivity$settings["application/json"];
}
export type ResponseContentType$ip$address$management$address$maps$list$address$maps = keyof Response$ip$address$management$address$maps$list$address$maps$Status$200;
export interface Params$ip$address$management$address$maps$list$address$maps {
    parameter: Parameter$ip$address$management$address$maps$list$address$maps;
}
export type RequestContentType$ip$address$management$address$maps$create$address$map = keyof RequestBody$ip$address$management$address$maps$create$address$map;
export type ResponseContentType$ip$address$management$address$maps$create$address$map = keyof Response$ip$address$management$address$maps$create$address$map$Status$200;
export interface Params$ip$address$management$address$maps$create$address$map {
    parameter: Parameter$ip$address$management$address$maps$create$address$map;
    requestBody: RequestBody$ip$address$management$address$maps$create$address$map["application/json"];
}
export type ResponseContentType$ip$address$management$address$maps$address$map$details = keyof Response$ip$address$management$address$maps$address$map$details$Status$200;
export interface Params$ip$address$management$address$maps$address$map$details {
    parameter: Parameter$ip$address$management$address$maps$address$map$details;
}
export type ResponseContentType$ip$address$management$address$maps$delete$address$map = keyof Response$ip$address$management$address$maps$delete$address$map$Status$200;
export interface Params$ip$address$management$address$maps$delete$address$map {
    parameter: Parameter$ip$address$management$address$maps$delete$address$map;
}
export type RequestContentType$ip$address$management$address$maps$update$address$map = keyof RequestBody$ip$address$management$address$maps$update$address$map;
export type ResponseContentType$ip$address$management$address$maps$update$address$map = keyof Response$ip$address$management$address$maps$update$address$map$Status$200;
export interface Params$ip$address$management$address$maps$update$address$map {
    parameter: Parameter$ip$address$management$address$maps$update$address$map;
    requestBody: RequestBody$ip$address$management$address$maps$update$address$map["application/json"];
}
export type ResponseContentType$ip$address$management$address$maps$add$an$ip$to$an$address$map = keyof Response$ip$address$management$address$maps$add$an$ip$to$an$address$map$Status$200;
export interface Params$ip$address$management$address$maps$add$an$ip$to$an$address$map {
    parameter: Parameter$ip$address$management$address$maps$add$an$ip$to$an$address$map;
}
export type ResponseContentType$ip$address$management$address$maps$remove$an$ip$from$an$address$map = keyof Response$ip$address$management$address$maps$remove$an$ip$from$an$address$map$Status$200;
export interface Params$ip$address$management$address$maps$remove$an$ip$from$an$address$map {
    parameter: Parameter$ip$address$management$address$maps$remove$an$ip$from$an$address$map;
}
export type ResponseContentType$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map = keyof Response$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map$Status$200;
export interface Params$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map {
    parameter: Parameter$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map;
}
export type ResponseContentType$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map = keyof Response$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map$Status$200;
export interface Params$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map {
    parameter: Parameter$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map;
}
export type RequestContentType$ip$address$management$prefixes$upload$loa$document = keyof RequestBody$ip$address$management$prefixes$upload$loa$document;
export type ResponseContentType$ip$address$management$prefixes$upload$loa$document = keyof Response$ip$address$management$prefixes$upload$loa$document$Status$201;
export interface Params$ip$address$management$prefixes$upload$loa$document {
    parameter: Parameter$ip$address$management$prefixes$upload$loa$document;
    requestBody: RequestBody$ip$address$management$prefixes$upload$loa$document["multipart/form-data"];
}
export type ResponseContentType$ip$address$management$prefixes$download$loa$document = keyof Response$ip$address$management$prefixes$download$loa$document$Status$200;
export interface Params$ip$address$management$prefixes$download$loa$document {
    parameter: Parameter$ip$address$management$prefixes$download$loa$document;
}
export type ResponseContentType$ip$address$management$prefixes$list$prefixes = keyof Response$ip$address$management$prefixes$list$prefixes$Status$200;
export interface Params$ip$address$management$prefixes$list$prefixes {
    parameter: Parameter$ip$address$management$prefixes$list$prefixes;
}
export type RequestContentType$ip$address$management$prefixes$add$prefix = keyof RequestBody$ip$address$management$prefixes$add$prefix;
export type ResponseContentType$ip$address$management$prefixes$add$prefix = keyof Response$ip$address$management$prefixes$add$prefix$Status$201;
export interface Params$ip$address$management$prefixes$add$prefix {
    parameter: Parameter$ip$address$management$prefixes$add$prefix;
    requestBody: RequestBody$ip$address$management$prefixes$add$prefix["application/json"];
}
export type ResponseContentType$ip$address$management$prefixes$prefix$details = keyof Response$ip$address$management$prefixes$prefix$details$Status$200;
export interface Params$ip$address$management$prefixes$prefix$details {
    parameter: Parameter$ip$address$management$prefixes$prefix$details;
}
export type ResponseContentType$ip$address$management$prefixes$delete$prefix = keyof Response$ip$address$management$prefixes$delete$prefix$Status$200;
export interface Params$ip$address$management$prefixes$delete$prefix {
    parameter: Parameter$ip$address$management$prefixes$delete$prefix;
}
export type RequestContentType$ip$address$management$prefixes$update$prefix$description = keyof RequestBody$ip$address$management$prefixes$update$prefix$description;
export type ResponseContentType$ip$address$management$prefixes$update$prefix$description = keyof Response$ip$address$management$prefixes$update$prefix$description$Status$200;
export interface Params$ip$address$management$prefixes$update$prefix$description {
    parameter: Parameter$ip$address$management$prefixes$update$prefix$description;
    requestBody: RequestBody$ip$address$management$prefixes$update$prefix$description["application/json"];
}
export type ResponseContentType$ip$address$management$prefixes$list$bgp$prefixes = keyof Response$ip$address$management$prefixes$list$bgp$prefixes$Status$200;
export interface Params$ip$address$management$prefixes$list$bgp$prefixes {
    parameter: Parameter$ip$address$management$prefixes$list$bgp$prefixes;
}
export type ResponseContentType$ip$address$management$prefixes$fetch$bgp$prefix = keyof Response$ip$address$management$prefixes$fetch$bgp$prefix$Status$200;
export interface Params$ip$address$management$prefixes$fetch$bgp$prefix {
    parameter: Parameter$ip$address$management$prefixes$fetch$bgp$prefix;
}
export type RequestContentType$ip$address$management$prefixes$update$bgp$prefix = keyof RequestBody$ip$address$management$prefixes$update$bgp$prefix;
export type ResponseContentType$ip$address$management$prefixes$update$bgp$prefix = keyof Response$ip$address$management$prefixes$update$bgp$prefix$Status$200;
export interface Params$ip$address$management$prefixes$update$bgp$prefix {
    parameter: Parameter$ip$address$management$prefixes$update$bgp$prefix;
    requestBody: RequestBody$ip$address$management$prefixes$update$bgp$prefix["application/json"];
}
export type ResponseContentType$ip$address$management$dynamic$advertisement$get$advertisement$status = keyof Response$ip$address$management$dynamic$advertisement$get$advertisement$status$Status$200;
export interface Params$ip$address$management$dynamic$advertisement$get$advertisement$status {
    parameter: Parameter$ip$address$management$dynamic$advertisement$get$advertisement$status;
}
export type RequestContentType$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status = keyof RequestBody$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status;
export type ResponseContentType$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status = keyof Response$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status$Status$200;
export interface Params$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status {
    parameter: Parameter$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status;
    requestBody: RequestBody$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status["application/json"];
}
export type ResponseContentType$ip$address$management$service$bindings$list$service$bindings = keyof Response$ip$address$management$service$bindings$list$service$bindings$Status$200;
export interface Params$ip$address$management$service$bindings$list$service$bindings {
    parameter: Parameter$ip$address$management$service$bindings$list$service$bindings;
}
export type RequestContentType$ip$address$management$service$bindings$create$service$binding = keyof RequestBody$ip$address$management$service$bindings$create$service$binding;
export type ResponseContentType$ip$address$management$service$bindings$create$service$binding = keyof Response$ip$address$management$service$bindings$create$service$binding$Status$201;
export interface Params$ip$address$management$service$bindings$create$service$binding {
    parameter: Parameter$ip$address$management$service$bindings$create$service$binding;
    requestBody: RequestBody$ip$address$management$service$bindings$create$service$binding["application/json"];
}
export type ResponseContentType$ip$address$management$service$bindings$get$service$binding = keyof Response$ip$address$management$service$bindings$get$service$binding$Status$200;
export interface Params$ip$address$management$service$bindings$get$service$binding {
    parameter: Parameter$ip$address$management$service$bindings$get$service$binding;
}
export type ResponseContentType$ip$address$management$service$bindings$delete$service$binding = keyof Response$ip$address$management$service$bindings$delete$service$binding$Status$200;
export interface Params$ip$address$management$service$bindings$delete$service$binding {
    parameter: Parameter$ip$address$management$service$bindings$delete$service$binding;
}
export type ResponseContentType$ip$address$management$prefix$delegation$list$prefix$delegations = keyof Response$ip$address$management$prefix$delegation$list$prefix$delegations$Status$200;
export interface Params$ip$address$management$prefix$delegation$list$prefix$delegations {
    parameter: Parameter$ip$address$management$prefix$delegation$list$prefix$delegations;
}
export type RequestContentType$ip$address$management$prefix$delegation$create$prefix$delegation = keyof RequestBody$ip$address$management$prefix$delegation$create$prefix$delegation;
export type ResponseContentType$ip$address$management$prefix$delegation$create$prefix$delegation = keyof Response$ip$address$management$prefix$delegation$create$prefix$delegation$Status$200;
export interface Params$ip$address$management$prefix$delegation$create$prefix$delegation {
    parameter: Parameter$ip$address$management$prefix$delegation$create$prefix$delegation;
    requestBody: RequestBody$ip$address$management$prefix$delegation$create$prefix$delegation["application/json"];
}
export type ResponseContentType$ip$address$management$prefix$delegation$delete$prefix$delegation = keyof Response$ip$address$management$prefix$delegation$delete$prefix$delegation$Status$200;
export interface Params$ip$address$management$prefix$delegation$delete$prefix$delegation {
    parameter: Parameter$ip$address$management$prefix$delegation$delete$prefix$delegation;
}
export type ResponseContentType$ip$address$management$service$bindings$list$services = keyof Response$ip$address$management$service$bindings$list$services$Status$200;
export interface Params$ip$address$management$service$bindings$list$services {
    parameter: Parameter$ip$address$management$service$bindings$list$services;
}
export type RequestContentType$workers$ai$post$run$model = keyof RequestBody$workers$ai$post$run$model;
export type ResponseContentType$workers$ai$post$run$model = keyof Response$workers$ai$post$run$model$Status$200;
export interface Params$workers$ai$post$run$model<T extends RequestContentType$workers$ai$post$run$model> {
    headers: {
        "Content-Type": T;
    };
    parameter: Parameter$workers$ai$post$run$model;
    requestBody: RequestBody$workers$ai$post$run$model[T];
}
export type ResponseContentType$audit$logs$get$account$audit$logs = keyof Response$audit$logs$get$account$audit$logs$Status$200;
export interface Params$audit$logs$get$account$audit$logs {
    parameter: Parameter$audit$logs$get$account$audit$logs;
}
export type ResponseContentType$account$billing$profile$$$deprecated$$billing$profile$details = keyof Response$account$billing$profile$$$deprecated$$billing$profile$details$Status$200;
export interface Params$account$billing$profile$$$deprecated$$billing$profile$details {
    parameter: Parameter$account$billing$profile$$$deprecated$$billing$profile$details;
}
export type ResponseContentType$accounts$turnstile$widgets$list = keyof Response$accounts$turnstile$widgets$list$Status$200;
export interface Params$accounts$turnstile$widgets$list {
    parameter: Parameter$accounts$turnstile$widgets$list;
}
export type RequestContentType$accounts$turnstile$widget$create = keyof RequestBody$accounts$turnstile$widget$create;
export type ResponseContentType$accounts$turnstile$widget$create = keyof Response$accounts$turnstile$widget$create$Status$200;
export interface Params$accounts$turnstile$widget$create {
    parameter: Parameter$accounts$turnstile$widget$create;
    requestBody: RequestBody$accounts$turnstile$widget$create["application/json"];
}
export type ResponseContentType$accounts$turnstile$widget$get = keyof Response$accounts$turnstile$widget$get$Status$200;
export interface Params$accounts$turnstile$widget$get {
    parameter: Parameter$accounts$turnstile$widget$get;
}
export type RequestContentType$accounts$turnstile$widget$update = keyof RequestBody$accounts$turnstile$widget$update;
export type ResponseContentType$accounts$turnstile$widget$update = keyof Response$accounts$turnstile$widget$update$Status$200;
export interface Params$accounts$turnstile$widget$update {
    parameter: Parameter$accounts$turnstile$widget$update;
    requestBody: RequestBody$accounts$turnstile$widget$update["application/json"];
}
export type ResponseContentType$accounts$turnstile$widget$delete = keyof Response$accounts$turnstile$widget$delete$Status$200;
export interface Params$accounts$turnstile$widget$delete {
    parameter: Parameter$accounts$turnstile$widget$delete;
}
export type RequestContentType$accounts$turnstile$widget$rotate$secret = keyof RequestBody$accounts$turnstile$widget$rotate$secret;
export type ResponseContentType$accounts$turnstile$widget$rotate$secret = keyof Response$accounts$turnstile$widget$rotate$secret$Status$200;
export interface Params$accounts$turnstile$widget$rotate$secret {
    parameter: Parameter$accounts$turnstile$widget$rotate$secret;
    requestBody: RequestBody$accounts$turnstile$widget$rotate$secret["application/json"];
}
export type ResponseContentType$custom$pages$for$an$account$list$custom$pages = keyof Response$custom$pages$for$an$account$list$custom$pages$Status$200;
export interface Params$custom$pages$for$an$account$list$custom$pages {
    parameter: Parameter$custom$pages$for$an$account$list$custom$pages;
}
export type ResponseContentType$custom$pages$for$an$account$get$a$custom$page = keyof Response$custom$pages$for$an$account$get$a$custom$page$Status$200;
export interface Params$custom$pages$for$an$account$get$a$custom$page {
    parameter: Parameter$custom$pages$for$an$account$get$a$custom$page;
}
export type RequestContentType$custom$pages$for$an$account$update$a$custom$page = keyof RequestBody$custom$pages$for$an$account$update$a$custom$page;
export type ResponseContentType$custom$pages$for$an$account$update$a$custom$page = keyof Response$custom$pages$for$an$account$update$a$custom$page$Status$200;
export interface Params$custom$pages$for$an$account$update$a$custom$page {
    parameter: Parameter$custom$pages$for$an$account$update$a$custom$page;
    requestBody: RequestBody$custom$pages$for$an$account$update$a$custom$page["application/json"];
}
export type ResponseContentType$cloudflare$d1$get$database = keyof Response$cloudflare$d1$get$database$Status$200;
export interface Params$cloudflare$d1$get$database {
    parameter: Parameter$cloudflare$d1$get$database;
}
export type ResponseContentType$cloudflare$d1$delete$database = keyof Response$cloudflare$d1$delete$database$Status$200;
export interface Params$cloudflare$d1$delete$database {
    parameter: Parameter$cloudflare$d1$delete$database;
}
export type RequestContentType$cloudflare$d1$query$database = keyof RequestBody$cloudflare$d1$query$database;
export type ResponseContentType$cloudflare$d1$query$database = keyof Response$cloudflare$d1$query$database$Status$200;
export interface Params$cloudflare$d1$query$database {
    parameter: Parameter$cloudflare$d1$query$database;
    requestBody: RequestBody$cloudflare$d1$query$database["application/json"];
}
export type RequestContentType$diagnostics$traceroute = keyof RequestBody$diagnostics$traceroute;
export type ResponseContentType$diagnostics$traceroute = keyof Response$diagnostics$traceroute$Status$200;
export interface Params$diagnostics$traceroute {
    parameter: Parameter$diagnostics$traceroute;
    requestBody: RequestBody$diagnostics$traceroute["application/json"];
}
export type ResponseContentType$dns$firewall$analytics$table = keyof Response$dns$firewall$analytics$table$Status$200;
export interface Params$dns$firewall$analytics$table {
    parameter: Parameter$dns$firewall$analytics$table;
}
export type ResponseContentType$dns$firewall$analytics$by$time = keyof Response$dns$firewall$analytics$by$time$Status$200;
export interface Params$dns$firewall$analytics$by$time {
    parameter: Parameter$dns$firewall$analytics$by$time;
}
export type ResponseContentType$email$routing$destination$addresses$list$destination$addresses = keyof Response$email$routing$destination$addresses$list$destination$addresses$Status$200;
export interface Params$email$routing$destination$addresses$list$destination$addresses {
    parameter: Parameter$email$routing$destination$addresses$list$destination$addresses;
}
export type RequestContentType$email$routing$destination$addresses$create$a$destination$address = keyof RequestBody$email$routing$destination$addresses$create$a$destination$address;
export type ResponseContentType$email$routing$destination$addresses$create$a$destination$address = keyof Response$email$routing$destination$addresses$create$a$destination$address$Status$200;
export interface Params$email$routing$destination$addresses$create$a$destination$address {
    parameter: Parameter$email$routing$destination$addresses$create$a$destination$address;
    requestBody: RequestBody$email$routing$destination$addresses$create$a$destination$address["application/json"];
}
export type ResponseContentType$email$routing$destination$addresses$get$a$destination$address = keyof Response$email$routing$destination$addresses$get$a$destination$address$Status$200;
export interface Params$email$routing$destination$addresses$get$a$destination$address {
    parameter: Parameter$email$routing$destination$addresses$get$a$destination$address;
}
export type ResponseContentType$email$routing$destination$addresses$delete$destination$address = keyof Response$email$routing$destination$addresses$delete$destination$address$Status$200;
export interface Params$email$routing$destination$addresses$delete$destination$address {
    parameter: Parameter$email$routing$destination$addresses$delete$destination$address;
}
export type ResponseContentType$ip$access$rules$for$an$account$list$ip$access$rules = keyof Response$ip$access$rules$for$an$account$list$ip$access$rules$Status$200;
export interface Params$ip$access$rules$for$an$account$list$ip$access$rules {
    parameter: Parameter$ip$access$rules$for$an$account$list$ip$access$rules;
}
export type RequestContentType$ip$access$rules$for$an$account$create$an$ip$access$rule = keyof RequestBody$ip$access$rules$for$an$account$create$an$ip$access$rule;
export type ResponseContentType$ip$access$rules$for$an$account$create$an$ip$access$rule = keyof Response$ip$access$rules$for$an$account$create$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$an$account$create$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$an$account$create$an$ip$access$rule;
    requestBody: RequestBody$ip$access$rules$for$an$account$create$an$ip$access$rule["application/json"];
}
export type ResponseContentType$ip$access$rules$for$an$account$get$an$ip$access$rule = keyof Response$ip$access$rules$for$an$account$get$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$an$account$get$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$an$account$get$an$ip$access$rule;
}
export type ResponseContentType$ip$access$rules$for$an$account$delete$an$ip$access$rule = keyof Response$ip$access$rules$for$an$account$delete$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$an$account$delete$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$an$account$delete$an$ip$access$rule;
}
export type RequestContentType$ip$access$rules$for$an$account$update$an$ip$access$rule = keyof RequestBody$ip$access$rules$for$an$account$update$an$ip$access$rule;
export type ResponseContentType$ip$access$rules$for$an$account$update$an$ip$access$rule = keyof Response$ip$access$rules$for$an$account$update$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$an$account$update$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$an$account$update$an$ip$access$rule;
    requestBody: RequestBody$ip$access$rules$for$an$account$update$an$ip$access$rule["application/json"];
}
export type ResponseContentType$custom$indicator$feeds$get$indicator$feeds = keyof Response$custom$indicator$feeds$get$indicator$feeds$Status$200;
export interface Params$custom$indicator$feeds$get$indicator$feeds {
    parameter: Parameter$custom$indicator$feeds$get$indicator$feeds;
}
export type RequestContentType$custom$indicator$feeds$create$indicator$feeds = keyof RequestBody$custom$indicator$feeds$create$indicator$feeds;
export type ResponseContentType$custom$indicator$feeds$create$indicator$feeds = keyof Response$custom$indicator$feeds$create$indicator$feeds$Status$200;
export interface Params$custom$indicator$feeds$create$indicator$feeds {
    parameter: Parameter$custom$indicator$feeds$create$indicator$feeds;
    requestBody: RequestBody$custom$indicator$feeds$create$indicator$feeds["application/json"];
}
export type ResponseContentType$custom$indicator$feeds$get$indicator$feed$metadata = keyof Response$custom$indicator$feeds$get$indicator$feed$metadata$Status$200;
export interface Params$custom$indicator$feeds$get$indicator$feed$metadata {
    parameter: Parameter$custom$indicator$feeds$get$indicator$feed$metadata;
}
export type ResponseContentType$custom$indicator$feeds$get$indicator$feed$data = keyof Response$custom$indicator$feeds$get$indicator$feed$data$Status$200;
export interface Params$custom$indicator$feeds$get$indicator$feed$data {
    parameter: Parameter$custom$indicator$feeds$get$indicator$feed$data;
}
export type RequestContentType$custom$indicator$feeds$update$indicator$feed$data = keyof RequestBody$custom$indicator$feeds$update$indicator$feed$data;
export type ResponseContentType$custom$indicator$feeds$update$indicator$feed$data = keyof Response$custom$indicator$feeds$update$indicator$feed$data$Status$200;
export interface Params$custom$indicator$feeds$update$indicator$feed$data {
    parameter: Parameter$custom$indicator$feeds$update$indicator$feed$data;
    requestBody: RequestBody$custom$indicator$feeds$update$indicator$feed$data["multipart/form-data"];
}
export type RequestContentType$custom$indicator$feeds$add$permission = keyof RequestBody$custom$indicator$feeds$add$permission;
export type ResponseContentType$custom$indicator$feeds$add$permission = keyof Response$custom$indicator$feeds$add$permission$Status$200;
export interface Params$custom$indicator$feeds$add$permission {
    parameter: Parameter$custom$indicator$feeds$add$permission;
    requestBody: RequestBody$custom$indicator$feeds$add$permission["application/json"];
}
export type RequestContentType$custom$indicator$feeds$remove$permission = keyof RequestBody$custom$indicator$feeds$remove$permission;
export type ResponseContentType$custom$indicator$feeds$remove$permission = keyof Response$custom$indicator$feeds$remove$permission$Status$200;
export interface Params$custom$indicator$feeds$remove$permission {
    parameter: Parameter$custom$indicator$feeds$remove$permission;
    requestBody: RequestBody$custom$indicator$feeds$remove$permission["application/json"];
}
export type ResponseContentType$custom$indicator$feeds$view$permissions = keyof Response$custom$indicator$feeds$view$permissions$Status$200;
export interface Params$custom$indicator$feeds$view$permissions {
    parameter: Parameter$custom$indicator$feeds$view$permissions;
}
export type ResponseContentType$sinkhole$config$get$sinkholes = keyof Response$sinkhole$config$get$sinkholes$Status$200;
export interface Params$sinkhole$config$get$sinkholes {
    parameter: Parameter$sinkhole$config$get$sinkholes;
}
export type ResponseContentType$account$load$balancer$monitors$list$monitors = keyof Response$account$load$balancer$monitors$list$monitors$Status$200;
export interface Params$account$load$balancer$monitors$list$monitors {
    parameter: Parameter$account$load$balancer$monitors$list$monitors;
}
export type RequestContentType$account$load$balancer$monitors$create$monitor = keyof RequestBody$account$load$balancer$monitors$create$monitor;
export type ResponseContentType$account$load$balancer$monitors$create$monitor = keyof Response$account$load$balancer$monitors$create$monitor$Status$200;
export interface Params$account$load$balancer$monitors$create$monitor {
    parameter: Parameter$account$load$balancer$monitors$create$monitor;
    requestBody: RequestBody$account$load$balancer$monitors$create$monitor["application/json"];
}
export type ResponseContentType$account$load$balancer$monitors$monitor$details = keyof Response$account$load$balancer$monitors$monitor$details$Status$200;
export interface Params$account$load$balancer$monitors$monitor$details {
    parameter: Parameter$account$load$balancer$monitors$monitor$details;
}
export type RequestContentType$account$load$balancer$monitors$update$monitor = keyof RequestBody$account$load$balancer$monitors$update$monitor;
export type ResponseContentType$account$load$balancer$monitors$update$monitor = keyof Response$account$load$balancer$monitors$update$monitor$Status$200;
export interface Params$account$load$balancer$monitors$update$monitor {
    parameter: Parameter$account$load$balancer$monitors$update$monitor;
    requestBody: RequestBody$account$load$balancer$monitors$update$monitor["application/json"];
}
export type ResponseContentType$account$load$balancer$monitors$delete$monitor = keyof Response$account$load$balancer$monitors$delete$monitor$Status$200;
export interface Params$account$load$balancer$monitors$delete$monitor {
    parameter: Parameter$account$load$balancer$monitors$delete$monitor;
}
export type RequestContentType$account$load$balancer$monitors$patch$monitor = keyof RequestBody$account$load$balancer$monitors$patch$monitor;
export type ResponseContentType$account$load$balancer$monitors$patch$monitor = keyof Response$account$load$balancer$monitors$patch$monitor$Status$200;
export interface Params$account$load$balancer$monitors$patch$monitor {
    parameter: Parameter$account$load$balancer$monitors$patch$monitor;
    requestBody: RequestBody$account$load$balancer$monitors$patch$monitor["application/json"];
}
export type RequestContentType$account$load$balancer$monitors$preview$monitor = keyof RequestBody$account$load$balancer$monitors$preview$monitor;
export type ResponseContentType$account$load$balancer$monitors$preview$monitor = keyof Response$account$load$balancer$monitors$preview$monitor$Status$200;
export interface Params$account$load$balancer$monitors$preview$monitor {
    parameter: Parameter$account$load$balancer$monitors$preview$monitor;
    requestBody: RequestBody$account$load$balancer$monitors$preview$monitor["application/json"];
}
export type ResponseContentType$account$load$balancer$monitors$list$monitor$references = keyof Response$account$load$balancer$monitors$list$monitor$references$Status$200;
export interface Params$account$load$balancer$monitors$list$monitor$references {
    parameter: Parameter$account$load$balancer$monitors$list$monitor$references;
}
export type ResponseContentType$account$load$balancer$pools$list$pools = keyof Response$account$load$balancer$pools$list$pools$Status$200;
export interface Params$account$load$balancer$pools$list$pools {
    parameter: Parameter$account$load$balancer$pools$list$pools;
}
export type RequestContentType$account$load$balancer$pools$create$pool = keyof RequestBody$account$load$balancer$pools$create$pool;
export type ResponseContentType$account$load$balancer$pools$create$pool = keyof Response$account$load$balancer$pools$create$pool$Status$200;
export interface Params$account$load$balancer$pools$create$pool {
    parameter: Parameter$account$load$balancer$pools$create$pool;
    requestBody: RequestBody$account$load$balancer$pools$create$pool["application/json"];
}
export type RequestContentType$account$load$balancer$pools$patch$pools = keyof RequestBody$account$load$balancer$pools$patch$pools;
export type ResponseContentType$account$load$balancer$pools$patch$pools = keyof Response$account$load$balancer$pools$patch$pools$Status$200;
export interface Params$account$load$balancer$pools$patch$pools {
    parameter: Parameter$account$load$balancer$pools$patch$pools;
    requestBody: RequestBody$account$load$balancer$pools$patch$pools["application/json"];
}
export type ResponseContentType$account$load$balancer$pools$pool$details = keyof Response$account$load$balancer$pools$pool$details$Status$200;
export interface Params$account$load$balancer$pools$pool$details {
    parameter: Parameter$account$load$balancer$pools$pool$details;
}
export type RequestContentType$account$load$balancer$pools$update$pool = keyof RequestBody$account$load$balancer$pools$update$pool;
export type ResponseContentType$account$load$balancer$pools$update$pool = keyof Response$account$load$balancer$pools$update$pool$Status$200;
export interface Params$account$load$balancer$pools$update$pool {
    parameter: Parameter$account$load$balancer$pools$update$pool;
    requestBody: RequestBody$account$load$balancer$pools$update$pool["application/json"];
}
export type ResponseContentType$account$load$balancer$pools$delete$pool = keyof Response$account$load$balancer$pools$delete$pool$Status$200;
export interface Params$account$load$balancer$pools$delete$pool {
    parameter: Parameter$account$load$balancer$pools$delete$pool;
}
export type RequestContentType$account$load$balancer$pools$patch$pool = keyof RequestBody$account$load$balancer$pools$patch$pool;
export type ResponseContentType$account$load$balancer$pools$patch$pool = keyof Response$account$load$balancer$pools$patch$pool$Status$200;
export interface Params$account$load$balancer$pools$patch$pool {
    parameter: Parameter$account$load$balancer$pools$patch$pool;
    requestBody: RequestBody$account$load$balancer$pools$patch$pool["application/json"];
}
export type ResponseContentType$account$load$balancer$pools$pool$health$details = keyof Response$account$load$balancer$pools$pool$health$details$Status$200;
export interface Params$account$load$balancer$pools$pool$health$details {
    parameter: Parameter$account$load$balancer$pools$pool$health$details;
}
export type RequestContentType$account$load$balancer$pools$preview$pool = keyof RequestBody$account$load$balancer$pools$preview$pool;
export type ResponseContentType$account$load$balancer$pools$preview$pool = keyof Response$account$load$balancer$pools$preview$pool$Status$200;
export interface Params$account$load$balancer$pools$preview$pool {
    parameter: Parameter$account$load$balancer$pools$preview$pool;
    requestBody: RequestBody$account$load$balancer$pools$preview$pool["application/json"];
}
export type ResponseContentType$account$load$balancer$pools$list$pool$references = keyof Response$account$load$balancer$pools$list$pool$references$Status$200;
export interface Params$account$load$balancer$pools$list$pool$references {
    parameter: Parameter$account$load$balancer$pools$list$pool$references;
}
export type ResponseContentType$account$load$balancer$monitors$preview$result = keyof Response$account$load$balancer$monitors$preview$result$Status$200;
export interface Params$account$load$balancer$monitors$preview$result {
    parameter: Parameter$account$load$balancer$monitors$preview$result;
}
export type ResponseContentType$load$balancer$regions$list$regions = keyof Response$load$balancer$regions$list$regions$Status$200;
export interface Params$load$balancer$regions$list$regions {
    parameter: Parameter$load$balancer$regions$list$regions;
}
export type ResponseContentType$load$balancer$regions$get$region = keyof Response$load$balancer$regions$get$region$Status$200;
export interface Params$load$balancer$regions$get$region {
    parameter: Parameter$load$balancer$regions$get$region;
}
export type ResponseContentType$account$load$balancer$search$search$resources = keyof Response$account$load$balancer$search$search$resources$Status$200;
export interface Params$account$load$balancer$search$search$resources {
    parameter: Parameter$account$load$balancer$search$search$resources;
}
export type ResponseContentType$magic$interconnects$list$interconnects = keyof Response$magic$interconnects$list$interconnects$Status$200;
export interface Params$magic$interconnects$list$interconnects {
    parameter: Parameter$magic$interconnects$list$interconnects;
}
export type RequestContentType$magic$interconnects$update$multiple$interconnects = keyof RequestBody$magic$interconnects$update$multiple$interconnects;
export type ResponseContentType$magic$interconnects$update$multiple$interconnects = keyof Response$magic$interconnects$update$multiple$interconnects$Status$200;
export interface Params$magic$interconnects$update$multiple$interconnects {
    parameter: Parameter$magic$interconnects$update$multiple$interconnects;
    requestBody: RequestBody$magic$interconnects$update$multiple$interconnects["application/json"];
}
export type ResponseContentType$magic$interconnects$list$interconnect$details = keyof Response$magic$interconnects$list$interconnect$details$Status$200;
export interface Params$magic$interconnects$list$interconnect$details {
    parameter: Parameter$magic$interconnects$list$interconnect$details;
}
export type RequestContentType$magic$interconnects$update$interconnect = keyof RequestBody$magic$interconnects$update$interconnect;
export type ResponseContentType$magic$interconnects$update$interconnect = keyof Response$magic$interconnects$update$interconnect$Status$200;
export interface Params$magic$interconnects$update$interconnect {
    parameter: Parameter$magic$interconnects$update$interconnect;
    requestBody: RequestBody$magic$interconnects$update$interconnect["application/json"];
}
export type ResponseContentType$magic$gre$tunnels$list$gre$tunnels = keyof Response$magic$gre$tunnels$list$gre$tunnels$Status$200;
export interface Params$magic$gre$tunnels$list$gre$tunnels {
    parameter: Parameter$magic$gre$tunnels$list$gre$tunnels;
}
export type RequestContentType$magic$gre$tunnels$update$multiple$gre$tunnels = keyof RequestBody$magic$gre$tunnels$update$multiple$gre$tunnels;
export type ResponseContentType$magic$gre$tunnels$update$multiple$gre$tunnels = keyof Response$magic$gre$tunnels$update$multiple$gre$tunnels$Status$200;
export interface Params$magic$gre$tunnels$update$multiple$gre$tunnels {
    parameter: Parameter$magic$gre$tunnels$update$multiple$gre$tunnels;
    requestBody: RequestBody$magic$gre$tunnels$update$multiple$gre$tunnels["application/json"];
}
export type RequestContentType$magic$gre$tunnels$create$gre$tunnels = keyof RequestBody$magic$gre$tunnels$create$gre$tunnels;
export type ResponseContentType$magic$gre$tunnels$create$gre$tunnels = keyof Response$magic$gre$tunnels$create$gre$tunnels$Status$200;
export interface Params$magic$gre$tunnels$create$gre$tunnels {
    parameter: Parameter$magic$gre$tunnels$create$gre$tunnels;
    requestBody: RequestBody$magic$gre$tunnels$create$gre$tunnels["application/json"];
}
export type ResponseContentType$magic$gre$tunnels$list$gre$tunnel$details = keyof Response$magic$gre$tunnels$list$gre$tunnel$details$Status$200;
export interface Params$magic$gre$tunnels$list$gre$tunnel$details {
    parameter: Parameter$magic$gre$tunnels$list$gre$tunnel$details;
}
export type RequestContentType$magic$gre$tunnels$update$gre$tunnel = keyof RequestBody$magic$gre$tunnels$update$gre$tunnel;
export type ResponseContentType$magic$gre$tunnels$update$gre$tunnel = keyof Response$magic$gre$tunnels$update$gre$tunnel$Status$200;
export interface Params$magic$gre$tunnels$update$gre$tunnel {
    parameter: Parameter$magic$gre$tunnels$update$gre$tunnel;
    requestBody: RequestBody$magic$gre$tunnels$update$gre$tunnel["application/json"];
}
export type ResponseContentType$magic$gre$tunnels$delete$gre$tunnel = keyof Response$magic$gre$tunnels$delete$gre$tunnel$Status$200;
export interface Params$magic$gre$tunnels$delete$gre$tunnel {
    parameter: Parameter$magic$gre$tunnels$delete$gre$tunnel;
}
export type ResponseContentType$magic$ipsec$tunnels$list$ipsec$tunnels = keyof Response$magic$ipsec$tunnels$list$ipsec$tunnels$Status$200;
export interface Params$magic$ipsec$tunnels$list$ipsec$tunnels {
    parameter: Parameter$magic$ipsec$tunnels$list$ipsec$tunnels;
}
export type RequestContentType$magic$ipsec$tunnels$update$multiple$ipsec$tunnels = keyof RequestBody$magic$ipsec$tunnels$update$multiple$ipsec$tunnels;
export type ResponseContentType$magic$ipsec$tunnels$update$multiple$ipsec$tunnels = keyof Response$magic$ipsec$tunnels$update$multiple$ipsec$tunnels$Status$200;
export interface Params$magic$ipsec$tunnels$update$multiple$ipsec$tunnels {
    parameter: Parameter$magic$ipsec$tunnels$update$multiple$ipsec$tunnels;
    requestBody: RequestBody$magic$ipsec$tunnels$update$multiple$ipsec$tunnels["application/json"];
}
export type RequestContentType$magic$ipsec$tunnels$create$ipsec$tunnels = keyof RequestBody$magic$ipsec$tunnels$create$ipsec$tunnels;
export type ResponseContentType$magic$ipsec$tunnels$create$ipsec$tunnels = keyof Response$magic$ipsec$tunnels$create$ipsec$tunnels$Status$200;
export interface Params$magic$ipsec$tunnels$create$ipsec$tunnels {
    parameter: Parameter$magic$ipsec$tunnels$create$ipsec$tunnels;
    requestBody: RequestBody$magic$ipsec$tunnels$create$ipsec$tunnels["application/json"];
}
export type ResponseContentType$magic$ipsec$tunnels$list$ipsec$tunnel$details = keyof Response$magic$ipsec$tunnels$list$ipsec$tunnel$details$Status$200;
export interface Params$magic$ipsec$tunnels$list$ipsec$tunnel$details {
    parameter: Parameter$magic$ipsec$tunnels$list$ipsec$tunnel$details;
}
export type RequestContentType$magic$ipsec$tunnels$update$ipsec$tunnel = keyof RequestBody$magic$ipsec$tunnels$update$ipsec$tunnel;
export type ResponseContentType$magic$ipsec$tunnels$update$ipsec$tunnel = keyof Response$magic$ipsec$tunnels$update$ipsec$tunnel$Status$200;
export interface Params$magic$ipsec$tunnels$update$ipsec$tunnel {
    parameter: Parameter$magic$ipsec$tunnels$update$ipsec$tunnel;
    requestBody: RequestBody$magic$ipsec$tunnels$update$ipsec$tunnel["application/json"];
}
export type ResponseContentType$magic$ipsec$tunnels$delete$ipsec$tunnel = keyof Response$magic$ipsec$tunnels$delete$ipsec$tunnel$Status$200;
export interface Params$magic$ipsec$tunnels$delete$ipsec$tunnel {
    parameter: Parameter$magic$ipsec$tunnels$delete$ipsec$tunnel;
}
export type ResponseContentType$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels = keyof Response$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels$Status$200;
export interface Params$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels {
    parameter: Parameter$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels;
}
export type ResponseContentType$magic$static$routes$list$routes = keyof Response$magic$static$routes$list$routes$Status$200;
export interface Params$magic$static$routes$list$routes {
    parameter: Parameter$magic$static$routes$list$routes;
}
export type RequestContentType$magic$static$routes$update$many$routes = keyof RequestBody$magic$static$routes$update$many$routes;
export type ResponseContentType$magic$static$routes$update$many$routes = keyof Response$magic$static$routes$update$many$routes$Status$200;
export interface Params$magic$static$routes$update$many$routes {
    parameter: Parameter$magic$static$routes$update$many$routes;
    requestBody: RequestBody$magic$static$routes$update$many$routes["application/json"];
}
export type RequestContentType$magic$static$routes$create$routes = keyof RequestBody$magic$static$routes$create$routes;
export type ResponseContentType$magic$static$routes$create$routes = keyof Response$magic$static$routes$create$routes$Status$200;
export interface Params$magic$static$routes$create$routes {
    parameter: Parameter$magic$static$routes$create$routes;
    requestBody: RequestBody$magic$static$routes$create$routes["application/json"];
}
export type RequestContentType$magic$static$routes$delete$many$routes = keyof RequestBody$magic$static$routes$delete$many$routes;
export type ResponseContentType$magic$static$routes$delete$many$routes = keyof Response$magic$static$routes$delete$many$routes$Status$200;
export interface Params$magic$static$routes$delete$many$routes {
    parameter: Parameter$magic$static$routes$delete$many$routes;
    requestBody: RequestBody$magic$static$routes$delete$many$routes["application/json"];
}
export type ResponseContentType$magic$static$routes$route$details = keyof Response$magic$static$routes$route$details$Status$200;
export interface Params$magic$static$routes$route$details {
    parameter: Parameter$magic$static$routes$route$details;
}
export type RequestContentType$magic$static$routes$update$route = keyof RequestBody$magic$static$routes$update$route;
export type ResponseContentType$magic$static$routes$update$route = keyof Response$magic$static$routes$update$route$Status$200;
export interface Params$magic$static$routes$update$route {
    parameter: Parameter$magic$static$routes$update$route;
    requestBody: RequestBody$magic$static$routes$update$route["application/json"];
}
export type ResponseContentType$magic$static$routes$delete$route = keyof Response$magic$static$routes$delete$route$Status$200;
export interface Params$magic$static$routes$delete$route {
    parameter: Parameter$magic$static$routes$delete$route;
}
export type ResponseContentType$account$members$list$members = keyof Response$account$members$list$members$Status$200;
export interface Params$account$members$list$members {
    parameter: Parameter$account$members$list$members;
}
export type RequestContentType$account$members$add$member = keyof RequestBody$account$members$add$member;
export type ResponseContentType$account$members$add$member = keyof Response$account$members$add$member$Status$200;
export interface Params$account$members$add$member {
    parameter: Parameter$account$members$add$member;
    requestBody: RequestBody$account$members$add$member["application/json"];
}
export type ResponseContentType$account$members$member$details = keyof Response$account$members$member$details$Status$200;
export interface Params$account$members$member$details {
    parameter: Parameter$account$members$member$details;
}
export type RequestContentType$account$members$update$member = keyof RequestBody$account$members$update$member;
export type ResponseContentType$account$members$update$member = keyof Response$account$members$update$member$Status$200;
export interface Params$account$members$update$member {
    parameter: Parameter$account$members$update$member;
    requestBody: RequestBody$account$members$update$member["application/json"];
}
export type ResponseContentType$account$members$remove$member = keyof Response$account$members$remove$member$Status$200;
export interface Params$account$members$remove$member {
    parameter: Parameter$account$members$remove$member;
}
export type ResponseContentType$magic$network$monitoring$configuration$list$account$configuration = keyof Response$magic$network$monitoring$configuration$list$account$configuration$Status$200;
export interface Params$magic$network$monitoring$configuration$list$account$configuration {
    parameter: Parameter$magic$network$monitoring$configuration$list$account$configuration;
}
export type ResponseContentType$magic$network$monitoring$configuration$update$an$entire$account$configuration = keyof Response$magic$network$monitoring$configuration$update$an$entire$account$configuration$Status$200;
export interface Params$magic$network$monitoring$configuration$update$an$entire$account$configuration {
    parameter: Parameter$magic$network$monitoring$configuration$update$an$entire$account$configuration;
}
export type ResponseContentType$magic$network$monitoring$configuration$create$account$configuration = keyof Response$magic$network$monitoring$configuration$create$account$configuration$Status$200;
export interface Params$magic$network$monitoring$configuration$create$account$configuration {
    parameter: Parameter$magic$network$monitoring$configuration$create$account$configuration;
}
export type ResponseContentType$magic$network$monitoring$configuration$delete$account$configuration = keyof Response$magic$network$monitoring$configuration$delete$account$configuration$Status$200;
export interface Params$magic$network$monitoring$configuration$delete$account$configuration {
    parameter: Parameter$magic$network$monitoring$configuration$delete$account$configuration;
}
export type ResponseContentType$magic$network$monitoring$configuration$update$account$configuration$fields = keyof Response$magic$network$monitoring$configuration$update$account$configuration$fields$Status$200;
export interface Params$magic$network$monitoring$configuration$update$account$configuration$fields {
    parameter: Parameter$magic$network$monitoring$configuration$update$account$configuration$fields;
}
export type ResponseContentType$magic$network$monitoring$configuration$list$rules$and$account$configuration = keyof Response$magic$network$monitoring$configuration$list$rules$and$account$configuration$Status$200;
export interface Params$magic$network$monitoring$configuration$list$rules$and$account$configuration {
    parameter: Parameter$magic$network$monitoring$configuration$list$rules$and$account$configuration;
}
export type ResponseContentType$magic$network$monitoring$rules$list$rules = keyof Response$magic$network$monitoring$rules$list$rules$Status$200;
export interface Params$magic$network$monitoring$rules$list$rules {
    parameter: Parameter$magic$network$monitoring$rules$list$rules;
}
export type ResponseContentType$magic$network$monitoring$rules$update$rules = keyof Response$magic$network$monitoring$rules$update$rules$Status$200;
export interface Params$magic$network$monitoring$rules$update$rules {
    parameter: Parameter$magic$network$monitoring$rules$update$rules;
}
export type ResponseContentType$magic$network$monitoring$rules$create$rules = keyof Response$magic$network$monitoring$rules$create$rules$Status$200;
export interface Params$magic$network$monitoring$rules$create$rules {
    parameter: Parameter$magic$network$monitoring$rules$create$rules;
}
export type ResponseContentType$magic$network$monitoring$rules$get$rule = keyof Response$magic$network$monitoring$rules$get$rule$Status$200;
export interface Params$magic$network$monitoring$rules$get$rule {
    parameter: Parameter$magic$network$monitoring$rules$get$rule;
}
export type ResponseContentType$magic$network$monitoring$rules$delete$rule = keyof Response$magic$network$monitoring$rules$delete$rule$Status$200;
export interface Params$magic$network$monitoring$rules$delete$rule {
    parameter: Parameter$magic$network$monitoring$rules$delete$rule;
}
export type ResponseContentType$magic$network$monitoring$rules$update$rule = keyof Response$magic$network$monitoring$rules$update$rule$Status$200;
export interface Params$magic$network$monitoring$rules$update$rule {
    parameter: Parameter$magic$network$monitoring$rules$update$rule;
}
export type ResponseContentType$magic$network$monitoring$rules$update$advertisement$for$rule = keyof Response$magic$network$monitoring$rules$update$advertisement$for$rule$Status$200;
export interface Params$magic$network$monitoring$rules$update$advertisement$for$rule {
    parameter: Parameter$magic$network$monitoring$rules$update$advertisement$for$rule;
}
export type ResponseContentType$m$tls$certificate$management$list$m$tls$certificates = keyof Response$m$tls$certificate$management$list$m$tls$certificates$Status$200;
export interface Params$m$tls$certificate$management$list$m$tls$certificates {
    parameter: Parameter$m$tls$certificate$management$list$m$tls$certificates;
}
export type RequestContentType$m$tls$certificate$management$upload$m$tls$certificate = keyof RequestBody$m$tls$certificate$management$upload$m$tls$certificate;
export type ResponseContentType$m$tls$certificate$management$upload$m$tls$certificate = keyof Response$m$tls$certificate$management$upload$m$tls$certificate$Status$200;
export interface Params$m$tls$certificate$management$upload$m$tls$certificate {
    parameter: Parameter$m$tls$certificate$management$upload$m$tls$certificate;
    requestBody: RequestBody$m$tls$certificate$management$upload$m$tls$certificate["application/json"];
}
export type ResponseContentType$m$tls$certificate$management$get$m$tls$certificate = keyof Response$m$tls$certificate$management$get$m$tls$certificate$Status$200;
export interface Params$m$tls$certificate$management$get$m$tls$certificate {
    parameter: Parameter$m$tls$certificate$management$get$m$tls$certificate;
}
export type ResponseContentType$m$tls$certificate$management$delete$m$tls$certificate = keyof Response$m$tls$certificate$management$delete$m$tls$certificate$Status$200;
export interface Params$m$tls$certificate$management$delete$m$tls$certificate {
    parameter: Parameter$m$tls$certificate$management$delete$m$tls$certificate;
}
export type ResponseContentType$m$tls$certificate$management$list$m$tls$certificate$associations = keyof Response$m$tls$certificate$management$list$m$tls$certificate$associations$Status$200;
export interface Params$m$tls$certificate$management$list$m$tls$certificate$associations {
    parameter: Parameter$m$tls$certificate$management$list$m$tls$certificate$associations;
}
export type ResponseContentType$magic$pcap$collection$list$packet$capture$requests = keyof Response$magic$pcap$collection$list$packet$capture$requests$Status$200;
export interface Params$magic$pcap$collection$list$packet$capture$requests {
    parameter: Parameter$magic$pcap$collection$list$packet$capture$requests;
}
export type RequestContentType$magic$pcap$collection$create$pcap$request = keyof RequestBody$magic$pcap$collection$create$pcap$request;
export type ResponseContentType$magic$pcap$collection$create$pcap$request = keyof Response$magic$pcap$collection$create$pcap$request$Status$200;
export interface Params$magic$pcap$collection$create$pcap$request {
    parameter: Parameter$magic$pcap$collection$create$pcap$request;
    requestBody: RequestBody$magic$pcap$collection$create$pcap$request["application/json"];
}
export type ResponseContentType$magic$pcap$collection$get$pcap$request = keyof Response$magic$pcap$collection$get$pcap$request$Status$200;
export interface Params$magic$pcap$collection$get$pcap$request {
    parameter: Parameter$magic$pcap$collection$get$pcap$request;
}
export interface Params$magic$pcap$collection$download$simple$pcap {
    parameter: Parameter$magic$pcap$collection$download$simple$pcap;
}
export type ResponseContentType$magic$pcap$collection$list$pca$ps$bucket$ownership = keyof Response$magic$pcap$collection$list$pca$ps$bucket$ownership$Status$200;
export interface Params$magic$pcap$collection$list$pca$ps$bucket$ownership {
    parameter: Parameter$magic$pcap$collection$list$pca$ps$bucket$ownership;
}
export type RequestContentType$magic$pcap$collection$add$buckets$for$full$packet$captures = keyof RequestBody$magic$pcap$collection$add$buckets$for$full$packet$captures;
export type ResponseContentType$magic$pcap$collection$add$buckets$for$full$packet$captures = keyof Response$magic$pcap$collection$add$buckets$for$full$packet$captures$Status$200;
export interface Params$magic$pcap$collection$add$buckets$for$full$packet$captures {
    parameter: Parameter$magic$pcap$collection$add$buckets$for$full$packet$captures;
    requestBody: RequestBody$magic$pcap$collection$add$buckets$for$full$packet$captures["application/json"];
}
export interface Params$magic$pcap$collection$delete$buckets$for$full$packet$captures {
    parameter: Parameter$magic$pcap$collection$delete$buckets$for$full$packet$captures;
}
export type RequestContentType$magic$pcap$collection$validate$buckets$for$full$packet$captures = keyof RequestBody$magic$pcap$collection$validate$buckets$for$full$packet$captures;
export type ResponseContentType$magic$pcap$collection$validate$buckets$for$full$packet$captures = keyof Response$magic$pcap$collection$validate$buckets$for$full$packet$captures$Status$200;
export interface Params$magic$pcap$collection$validate$buckets$for$full$packet$captures {
    parameter: Parameter$magic$pcap$collection$validate$buckets$for$full$packet$captures;
    requestBody: RequestBody$magic$pcap$collection$validate$buckets$for$full$packet$captures["application/json"];
}
export type RequestContentType$account$request$tracer$request$trace = keyof RequestBody$account$request$tracer$request$trace;
export type ResponseContentType$account$request$tracer$request$trace = keyof Response$account$request$tracer$request$trace$Status$200;
export interface Params$account$request$tracer$request$trace {
    parameter: Parameter$account$request$tracer$request$trace;
    requestBody: RequestBody$account$request$tracer$request$trace["application/json"];
}
export type ResponseContentType$account$roles$list$roles = keyof Response$account$roles$list$roles$Status$200;
export interface Params$account$roles$list$roles {
    parameter: Parameter$account$roles$list$roles;
}
export type ResponseContentType$account$roles$role$details = keyof Response$account$roles$role$details$Status$200;
export interface Params$account$roles$role$details {
    parameter: Parameter$account$roles$role$details;
}
export type ResponseContentType$lists$get$a$list$item = keyof Response$lists$get$a$list$item$Status$200;
export interface Params$lists$get$a$list$item {
    parameter: Parameter$lists$get$a$list$item;
}
export type ResponseContentType$lists$get$bulk$operation$status = keyof Response$lists$get$bulk$operation$status$Status$200;
export interface Params$lists$get$bulk$operation$status {
    parameter: Parameter$lists$get$bulk$operation$status;
}
export type RequestContentType$web$analytics$create$site = keyof RequestBody$web$analytics$create$site;
export type ResponseContentType$web$analytics$create$site = keyof Response$web$analytics$create$site$Status$200;
export interface Params$web$analytics$create$site {
    parameter: Parameter$web$analytics$create$site;
    requestBody: RequestBody$web$analytics$create$site["application/json"];
}
export type ResponseContentType$web$analytics$get$site = keyof Response$web$analytics$get$site$Status$200;
export interface Params$web$analytics$get$site {
    parameter: Parameter$web$analytics$get$site;
}
export type RequestContentType$web$analytics$update$site = keyof RequestBody$web$analytics$update$site;
export type ResponseContentType$web$analytics$update$site = keyof Response$web$analytics$update$site$Status$200;
export interface Params$web$analytics$update$site {
    parameter: Parameter$web$analytics$update$site;
    requestBody: RequestBody$web$analytics$update$site["application/json"];
}
export type ResponseContentType$web$analytics$delete$site = keyof Response$web$analytics$delete$site$Status$200;
export interface Params$web$analytics$delete$site {
    parameter: Parameter$web$analytics$delete$site;
}
export type ResponseContentType$web$analytics$list$sites = keyof Response$web$analytics$list$sites$Status$200;
export interface Params$web$analytics$list$sites {
    parameter: Parameter$web$analytics$list$sites;
}
export type RequestContentType$web$analytics$create$rule = keyof RequestBody$web$analytics$create$rule;
export type ResponseContentType$web$analytics$create$rule = keyof Response$web$analytics$create$rule$Status$200;
export interface Params$web$analytics$create$rule {
    parameter: Parameter$web$analytics$create$rule;
    requestBody: RequestBody$web$analytics$create$rule["application/json"];
}
export type RequestContentType$web$analytics$update$rule = keyof RequestBody$web$analytics$update$rule;
export type ResponseContentType$web$analytics$update$rule = keyof Response$web$analytics$update$rule$Status$200;
export interface Params$web$analytics$update$rule {
    parameter: Parameter$web$analytics$update$rule;
    requestBody: RequestBody$web$analytics$update$rule["application/json"];
}
export type ResponseContentType$web$analytics$delete$rule = keyof Response$web$analytics$delete$rule$Status$200;
export interface Params$web$analytics$delete$rule {
    parameter: Parameter$web$analytics$delete$rule;
}
export type ResponseContentType$web$analytics$list$rules = keyof Response$web$analytics$list$rules$Status$200;
export interface Params$web$analytics$list$rules {
    parameter: Parameter$web$analytics$list$rules;
}
export type RequestContentType$web$analytics$modify$rules = keyof RequestBody$web$analytics$modify$rules;
export type ResponseContentType$web$analytics$modify$rules = keyof Response$web$analytics$modify$rules$Status$200;
export interface Params$web$analytics$modify$rules {
    parameter: Parameter$web$analytics$modify$rules;
    requestBody: RequestBody$web$analytics$modify$rules["application/json"];
}
export type ResponseContentType$secondary$dns$$$acl$$list$ac$ls = keyof Response$secondary$dns$$$acl$$list$ac$ls$Status$200;
export interface Params$secondary$dns$$$acl$$list$ac$ls {
    parameter: Parameter$secondary$dns$$$acl$$list$ac$ls;
}
export type RequestContentType$secondary$dns$$$acl$$create$acl = keyof RequestBody$secondary$dns$$$acl$$create$acl;
export type ResponseContentType$secondary$dns$$$acl$$create$acl = keyof Response$secondary$dns$$$acl$$create$acl$Status$200;
export interface Params$secondary$dns$$$acl$$create$acl {
    parameter: Parameter$secondary$dns$$$acl$$create$acl;
    requestBody: RequestBody$secondary$dns$$$acl$$create$acl["application/json"];
}
export type ResponseContentType$secondary$dns$$$acl$$acl$details = keyof Response$secondary$dns$$$acl$$acl$details$Status$200;
export interface Params$secondary$dns$$$acl$$acl$details {
    parameter: Parameter$secondary$dns$$$acl$$acl$details;
}
export type RequestContentType$secondary$dns$$$acl$$update$acl = keyof RequestBody$secondary$dns$$$acl$$update$acl;
export type ResponseContentType$secondary$dns$$$acl$$update$acl = keyof Response$secondary$dns$$$acl$$update$acl$Status$200;
export interface Params$secondary$dns$$$acl$$update$acl {
    parameter: Parameter$secondary$dns$$$acl$$update$acl;
    requestBody: RequestBody$secondary$dns$$$acl$$update$acl["application/json"];
}
export type ResponseContentType$secondary$dns$$$acl$$delete$acl = keyof Response$secondary$dns$$$acl$$delete$acl$Status$200;
export interface Params$secondary$dns$$$acl$$delete$acl {
    parameter: Parameter$secondary$dns$$$acl$$delete$acl;
}
export type ResponseContentType$secondary$dns$$$peer$$list$peers = keyof Response$secondary$dns$$$peer$$list$peers$Status$200;
export interface Params$secondary$dns$$$peer$$list$peers {
    parameter: Parameter$secondary$dns$$$peer$$list$peers;
}
export type RequestContentType$secondary$dns$$$peer$$create$peer = keyof RequestBody$secondary$dns$$$peer$$create$peer;
export type ResponseContentType$secondary$dns$$$peer$$create$peer = keyof Response$secondary$dns$$$peer$$create$peer$Status$200;
export interface Params$secondary$dns$$$peer$$create$peer {
    parameter: Parameter$secondary$dns$$$peer$$create$peer;
    requestBody: RequestBody$secondary$dns$$$peer$$create$peer["application/json"];
}
export type ResponseContentType$secondary$dns$$$peer$$peer$details = keyof Response$secondary$dns$$$peer$$peer$details$Status$200;
export interface Params$secondary$dns$$$peer$$peer$details {
    parameter: Parameter$secondary$dns$$$peer$$peer$details;
}
export type RequestContentType$secondary$dns$$$peer$$update$peer = keyof RequestBody$secondary$dns$$$peer$$update$peer;
export type ResponseContentType$secondary$dns$$$peer$$update$peer = keyof Response$secondary$dns$$$peer$$update$peer$Status$200;
export interface Params$secondary$dns$$$peer$$update$peer {
    parameter: Parameter$secondary$dns$$$peer$$update$peer;
    requestBody: RequestBody$secondary$dns$$$peer$$update$peer["application/json"];
}
export type ResponseContentType$secondary$dns$$$peer$$delete$peer = keyof Response$secondary$dns$$$peer$$delete$peer$Status$200;
export interface Params$secondary$dns$$$peer$$delete$peer {
    parameter: Parameter$secondary$dns$$$peer$$delete$peer;
}
export type ResponseContentType$secondary$dns$$$tsig$$list$tsi$gs = keyof Response$secondary$dns$$$tsig$$list$tsi$gs$Status$200;
export interface Params$secondary$dns$$$tsig$$list$tsi$gs {
    parameter: Parameter$secondary$dns$$$tsig$$list$tsi$gs;
}
export type RequestContentType$secondary$dns$$$tsig$$create$tsig = keyof RequestBody$secondary$dns$$$tsig$$create$tsig;
export type ResponseContentType$secondary$dns$$$tsig$$create$tsig = keyof Response$secondary$dns$$$tsig$$create$tsig$Status$200;
export interface Params$secondary$dns$$$tsig$$create$tsig {
    parameter: Parameter$secondary$dns$$$tsig$$create$tsig;
    requestBody: RequestBody$secondary$dns$$$tsig$$create$tsig["application/json"];
}
export type ResponseContentType$secondary$dns$$$tsig$$tsig$details = keyof Response$secondary$dns$$$tsig$$tsig$details$Status$200;
export interface Params$secondary$dns$$$tsig$$tsig$details {
    parameter: Parameter$secondary$dns$$$tsig$$tsig$details;
}
export type RequestContentType$secondary$dns$$$tsig$$update$tsig = keyof RequestBody$secondary$dns$$$tsig$$update$tsig;
export type ResponseContentType$secondary$dns$$$tsig$$update$tsig = keyof Response$secondary$dns$$$tsig$$update$tsig$Status$200;
export interface Params$secondary$dns$$$tsig$$update$tsig {
    parameter: Parameter$secondary$dns$$$tsig$$update$tsig;
    requestBody: RequestBody$secondary$dns$$$tsig$$update$tsig["application/json"];
}
export type ResponseContentType$secondary$dns$$$tsig$$delete$tsig = keyof Response$secondary$dns$$$tsig$$delete$tsig$Status$200;
export interface Params$secondary$dns$$$tsig$$delete$tsig {
    parameter: Parameter$secondary$dns$$$tsig$$delete$tsig;
}
export type ResponseContentType$workers$kv$request$analytics$query$request$analytics = keyof Response$workers$kv$request$analytics$query$request$analytics$Status$200;
export interface Params$workers$kv$request$analytics$query$request$analytics {
    parameter: Parameter$workers$kv$request$analytics$query$request$analytics;
}
export type ResponseContentType$workers$kv$stored$data$analytics$query$stored$data$analytics = keyof Response$workers$kv$stored$data$analytics$query$stored$data$analytics$Status$200;
export interface Params$workers$kv$stored$data$analytics$query$stored$data$analytics {
    parameter: Parameter$workers$kv$stored$data$analytics$query$stored$data$analytics;
}
export type ResponseContentType$workers$kv$namespace$list$namespaces = keyof Response$workers$kv$namespace$list$namespaces$Status$200;
export interface Params$workers$kv$namespace$list$namespaces {
    parameter: Parameter$workers$kv$namespace$list$namespaces;
}
export type RequestContentType$workers$kv$namespace$create$a$namespace = keyof RequestBody$workers$kv$namespace$create$a$namespace;
export type ResponseContentType$workers$kv$namespace$create$a$namespace = keyof Response$workers$kv$namespace$create$a$namespace$Status$200;
export interface Params$workers$kv$namespace$create$a$namespace {
    parameter: Parameter$workers$kv$namespace$create$a$namespace;
    requestBody: RequestBody$workers$kv$namespace$create$a$namespace["application/json"];
}
export type RequestContentType$workers$kv$namespace$rename$a$namespace = keyof RequestBody$workers$kv$namespace$rename$a$namespace;
export type ResponseContentType$workers$kv$namespace$rename$a$namespace = keyof Response$workers$kv$namespace$rename$a$namespace$Status$200;
export interface Params$workers$kv$namespace$rename$a$namespace {
    parameter: Parameter$workers$kv$namespace$rename$a$namespace;
    requestBody: RequestBody$workers$kv$namespace$rename$a$namespace["application/json"];
}
export type ResponseContentType$workers$kv$namespace$remove$a$namespace = keyof Response$workers$kv$namespace$remove$a$namespace$Status$200;
export interface Params$workers$kv$namespace$remove$a$namespace {
    parameter: Parameter$workers$kv$namespace$remove$a$namespace;
}
export type RequestContentType$workers$kv$namespace$write$multiple$key$value$pairs = keyof RequestBody$workers$kv$namespace$write$multiple$key$value$pairs;
export type ResponseContentType$workers$kv$namespace$write$multiple$key$value$pairs = keyof Response$workers$kv$namespace$write$multiple$key$value$pairs$Status$200;
export interface Params$workers$kv$namespace$write$multiple$key$value$pairs {
    parameter: Parameter$workers$kv$namespace$write$multiple$key$value$pairs;
    requestBody: RequestBody$workers$kv$namespace$write$multiple$key$value$pairs["application/json"];
}
export type RequestContentType$workers$kv$namespace$delete$multiple$key$value$pairs = keyof RequestBody$workers$kv$namespace$delete$multiple$key$value$pairs;
export type ResponseContentType$workers$kv$namespace$delete$multiple$key$value$pairs = keyof Response$workers$kv$namespace$delete$multiple$key$value$pairs$Status$200;
export interface Params$workers$kv$namespace$delete$multiple$key$value$pairs {
    parameter: Parameter$workers$kv$namespace$delete$multiple$key$value$pairs;
    requestBody: RequestBody$workers$kv$namespace$delete$multiple$key$value$pairs["application/json"];
}
export type ResponseContentType$workers$kv$namespace$list$a$namespace$$s$keys = keyof Response$workers$kv$namespace$list$a$namespace$$s$keys$Status$200;
export interface Params$workers$kv$namespace$list$a$namespace$$s$keys {
    parameter: Parameter$workers$kv$namespace$list$a$namespace$$s$keys;
}
export type ResponseContentType$workers$kv$namespace$read$the$metadata$for$a$key = keyof Response$workers$kv$namespace$read$the$metadata$for$a$key$Status$200;
export interface Params$workers$kv$namespace$read$the$metadata$for$a$key {
    parameter: Parameter$workers$kv$namespace$read$the$metadata$for$a$key;
}
export type ResponseContentType$workers$kv$namespace$read$key$value$pair = keyof Response$workers$kv$namespace$read$key$value$pair$Status$200;
export interface Params$workers$kv$namespace$read$key$value$pair {
    parameter: Parameter$workers$kv$namespace$read$key$value$pair;
}
export type RequestContentType$workers$kv$namespace$write$key$value$pair$with$metadata = keyof RequestBody$workers$kv$namespace$write$key$value$pair$with$metadata;
export type ResponseContentType$workers$kv$namespace$write$key$value$pair$with$metadata = keyof Response$workers$kv$namespace$write$key$value$pair$with$metadata$Status$200;
export interface Params$workers$kv$namespace$write$key$value$pair$with$metadata {
    parameter: Parameter$workers$kv$namespace$write$key$value$pair$with$metadata;
    requestBody: RequestBody$workers$kv$namespace$write$key$value$pair$with$metadata["multipart/form-data"];
}
export type ResponseContentType$workers$kv$namespace$delete$key$value$pair = keyof Response$workers$kv$namespace$delete$key$value$pair$Status$200;
export interface Params$workers$kv$namespace$delete$key$value$pair {
    parameter: Parameter$workers$kv$namespace$delete$key$value$pair;
}
export type ResponseContentType$account$subscriptions$list$subscriptions = keyof Response$account$subscriptions$list$subscriptions$Status$200;
export interface Params$account$subscriptions$list$subscriptions {
    parameter: Parameter$account$subscriptions$list$subscriptions;
}
export type RequestContentType$account$subscriptions$create$subscription = keyof RequestBody$account$subscriptions$create$subscription;
export type ResponseContentType$account$subscriptions$create$subscription = keyof Response$account$subscriptions$create$subscription$Status$200;
export interface Params$account$subscriptions$create$subscription {
    parameter: Parameter$account$subscriptions$create$subscription;
    requestBody: RequestBody$account$subscriptions$create$subscription["application/json"];
}
export type RequestContentType$account$subscriptions$update$subscription = keyof RequestBody$account$subscriptions$update$subscription;
export type ResponseContentType$account$subscriptions$update$subscription = keyof Response$account$subscriptions$update$subscription$Status$200;
export interface Params$account$subscriptions$update$subscription {
    parameter: Parameter$account$subscriptions$update$subscription;
    requestBody: RequestBody$account$subscriptions$update$subscription["application/json"];
}
export type ResponseContentType$account$subscriptions$delete$subscription = keyof Response$account$subscriptions$delete$subscription$Status$200;
export interface Params$account$subscriptions$delete$subscription {
    parameter: Parameter$account$subscriptions$delete$subscription;
}
export type ResponseContentType$vectorize$list$vectorize$indexes = keyof Response$vectorize$list$vectorize$indexes$Status$200;
export interface Params$vectorize$list$vectorize$indexes {
    parameter: Parameter$vectorize$list$vectorize$indexes;
}
export type RequestContentType$vectorize$create$vectorize$index = keyof RequestBody$vectorize$create$vectorize$index;
export type ResponseContentType$vectorize$create$vectorize$index = keyof Response$vectorize$create$vectorize$index$Status$200;
export interface Params$vectorize$create$vectorize$index {
    parameter: Parameter$vectorize$create$vectorize$index;
    requestBody: RequestBody$vectorize$create$vectorize$index["application/json"];
}
export type ResponseContentType$vectorize$get$vectorize$index = keyof Response$vectorize$get$vectorize$index$Status$200;
export interface Params$vectorize$get$vectorize$index {
    parameter: Parameter$vectorize$get$vectorize$index;
}
export type RequestContentType$vectorize$update$vectorize$index = keyof RequestBody$vectorize$update$vectorize$index;
export type ResponseContentType$vectorize$update$vectorize$index = keyof Response$vectorize$update$vectorize$index$Status$200;
export interface Params$vectorize$update$vectorize$index {
    parameter: Parameter$vectorize$update$vectorize$index;
    requestBody: RequestBody$vectorize$update$vectorize$index["application/json"];
}
export type ResponseContentType$vectorize$delete$vectorize$index = keyof Response$vectorize$delete$vectorize$index$Status$200;
export interface Params$vectorize$delete$vectorize$index {
    parameter: Parameter$vectorize$delete$vectorize$index;
}
export type RequestContentType$vectorize$delete$vectors$by$id = keyof RequestBody$vectorize$delete$vectors$by$id;
export type ResponseContentType$vectorize$delete$vectors$by$id = keyof Response$vectorize$delete$vectors$by$id$Status$200;
export interface Params$vectorize$delete$vectors$by$id {
    parameter: Parameter$vectorize$delete$vectors$by$id;
    requestBody: RequestBody$vectorize$delete$vectors$by$id["application/json"];
}
export type RequestContentType$vectorize$get$vectors$by$id = keyof RequestBody$vectorize$get$vectors$by$id;
export type ResponseContentType$vectorize$get$vectors$by$id = keyof Response$vectorize$get$vectors$by$id$Status$200;
export interface Params$vectorize$get$vectors$by$id {
    parameter: Parameter$vectorize$get$vectors$by$id;
    requestBody: RequestBody$vectorize$get$vectors$by$id["application/json"];
}
export type RequestContentType$vectorize$insert$vector = keyof RequestBody$vectorize$insert$vector;
export type ResponseContentType$vectorize$insert$vector = keyof Response$vectorize$insert$vector$Status$200;
export interface Params$vectorize$insert$vector {
    parameter: Parameter$vectorize$insert$vector;
    requestBody: RequestBody$vectorize$insert$vector["application/x-ndjson"];
}
export type RequestContentType$vectorize$query$vector = keyof RequestBody$vectorize$query$vector;
export type ResponseContentType$vectorize$query$vector = keyof Response$vectorize$query$vector$Status$200;
export interface Params$vectorize$query$vector {
    parameter: Parameter$vectorize$query$vector;
    requestBody: RequestBody$vectorize$query$vector["application/json"];
}
export type RequestContentType$vectorize$upsert$vector = keyof RequestBody$vectorize$upsert$vector;
export type ResponseContentType$vectorize$upsert$vector = keyof Response$vectorize$upsert$vector$Status$200;
export interface Params$vectorize$upsert$vector {
    parameter: Parameter$vectorize$upsert$vector;
    requestBody: RequestBody$vectorize$upsert$vector["application/x-ndjson"];
}
export type ResponseContentType$ip$address$management$address$maps$add$an$account$membership$to$an$address$map = keyof Response$ip$address$management$address$maps$add$an$account$membership$to$an$address$map$Status$200;
export interface Params$ip$address$management$address$maps$add$an$account$membership$to$an$address$map {
    parameter: Parameter$ip$address$management$address$maps$add$an$account$membership$to$an$address$map;
}
export type ResponseContentType$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map = keyof Response$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map$Status$200;
export interface Params$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map {
    parameter: Parameter$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map;
}
export type ResponseContentType$urlscanner$search$scans = keyof Response$urlscanner$search$scans$Status$200;
export interface Params$urlscanner$search$scans {
    parameter: Parameter$urlscanner$search$scans;
}
export type RequestContentType$urlscanner$create$scan = keyof RequestBody$urlscanner$create$scan;
export type ResponseContentType$urlscanner$create$scan = keyof Response$urlscanner$create$scan$Status$200;
export interface Params$urlscanner$create$scan {
    parameter: Parameter$urlscanner$create$scan;
    requestBody: RequestBody$urlscanner$create$scan["application/json"];
}
export type ResponseContentType$urlscanner$get$scan = keyof Response$urlscanner$get$scan$Status$200;
export interface Params$urlscanner$get$scan {
    parameter: Parameter$urlscanner$get$scan;
}
export type ResponseContentType$urlscanner$get$scan$har = keyof Response$urlscanner$get$scan$har$Status$200;
export interface Params$urlscanner$get$scan$har {
    parameter: Parameter$urlscanner$get$scan$har;
}
export type ResponseContentType$urlscanner$get$scan$screenshot = keyof Response$urlscanner$get$scan$screenshot$Status$200 | keyof Response$urlscanner$get$scan$screenshot$Status$202;
export interface Params$urlscanner$get$scan$screenshot<U extends ResponseContentType$urlscanner$get$scan$screenshot> {
    headers: {
        Accept: U;
    };
    parameter: Parameter$urlscanner$get$scan$screenshot;
}
export type ResponseContentType$accounts$account$details = keyof Response$accounts$account$details$Status$200;
export interface Params$accounts$account$details {
    parameter: Parameter$accounts$account$details;
}
export type RequestContentType$accounts$update$account = keyof RequestBody$accounts$update$account;
export type ResponseContentType$accounts$update$account = keyof Response$accounts$update$account$Status$200;
export interface Params$accounts$update$account {
    parameter: Parameter$accounts$update$account;
    requestBody: RequestBody$accounts$update$account["application/json"];
}
export type ResponseContentType$access$applications$list$access$applications = keyof Response$access$applications$list$access$applications$Status$200;
export interface Params$access$applications$list$access$applications {
    parameter: Parameter$access$applications$list$access$applications;
}
export type RequestContentType$access$applications$add$an$application = keyof RequestBody$access$applications$add$an$application;
export type ResponseContentType$access$applications$add$an$application = keyof Response$access$applications$add$an$application$Status$201;
export interface Params$access$applications$add$an$application {
    parameter: Parameter$access$applications$add$an$application;
    requestBody: RequestBody$access$applications$add$an$application["application/json"];
}
export type ResponseContentType$access$applications$get$an$access$application = keyof Response$access$applications$get$an$access$application$Status$200;
export interface Params$access$applications$get$an$access$application {
    parameter: Parameter$access$applications$get$an$access$application;
}
export type RequestContentType$access$applications$update$a$bookmark$application = keyof RequestBody$access$applications$update$a$bookmark$application;
export type ResponseContentType$access$applications$update$a$bookmark$application = keyof Response$access$applications$update$a$bookmark$application$Status$200;
export interface Params$access$applications$update$a$bookmark$application {
    parameter: Parameter$access$applications$update$a$bookmark$application;
    requestBody: RequestBody$access$applications$update$a$bookmark$application["application/json"];
}
export type ResponseContentType$access$applications$delete$an$access$application = keyof Response$access$applications$delete$an$access$application$Status$202;
export interface Params$access$applications$delete$an$access$application {
    parameter: Parameter$access$applications$delete$an$access$application;
}
export type ResponseContentType$access$applications$revoke$service$tokens = keyof Response$access$applications$revoke$service$tokens$Status$202;
export interface Params$access$applications$revoke$service$tokens {
    parameter: Parameter$access$applications$revoke$service$tokens;
}
export type ResponseContentType$access$applications$test$access$policies = keyof Response$access$applications$test$access$policies$Status$200;
export interface Params$access$applications$test$access$policies {
    parameter: Parameter$access$applications$test$access$policies;
}
export type ResponseContentType$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca = keyof Response$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$200;
export interface Params$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca {
    parameter: Parameter$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca;
}
export type ResponseContentType$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca = keyof Response$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$200;
export interface Params$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca {
    parameter: Parameter$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca;
}
export type ResponseContentType$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca = keyof Response$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$202;
export interface Params$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca {
    parameter: Parameter$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca;
}
export type ResponseContentType$access$policies$list$access$policies = keyof Response$access$policies$list$access$policies$Status$200;
export interface Params$access$policies$list$access$policies {
    parameter: Parameter$access$policies$list$access$policies;
}
export type RequestContentType$access$policies$create$an$access$policy = keyof RequestBody$access$policies$create$an$access$policy;
export type ResponseContentType$access$policies$create$an$access$policy = keyof Response$access$policies$create$an$access$policy$Status$201;
export interface Params$access$policies$create$an$access$policy {
    parameter: Parameter$access$policies$create$an$access$policy;
    requestBody: RequestBody$access$policies$create$an$access$policy["application/json"];
}
export type ResponseContentType$access$policies$get$an$access$policy = keyof Response$access$policies$get$an$access$policy$Status$200;
export interface Params$access$policies$get$an$access$policy {
    parameter: Parameter$access$policies$get$an$access$policy;
}
export type RequestContentType$access$policies$update$an$access$policy = keyof RequestBody$access$policies$update$an$access$policy;
export type ResponseContentType$access$policies$update$an$access$policy = keyof Response$access$policies$update$an$access$policy$Status$200;
export interface Params$access$policies$update$an$access$policy {
    parameter: Parameter$access$policies$update$an$access$policy;
    requestBody: RequestBody$access$policies$update$an$access$policy["application/json"];
}
export type ResponseContentType$access$policies$delete$an$access$policy = keyof Response$access$policies$delete$an$access$policy$Status$202;
export interface Params$access$policies$delete$an$access$policy {
    parameter: Parameter$access$policies$delete$an$access$policy;
}
export type ResponseContentType$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as = keyof Response$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$200;
export interface Params$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as {
    parameter: Parameter$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as;
}
export type ResponseContentType$access$bookmark$applications$$$deprecated$$list$bookmark$applications = keyof Response$access$bookmark$applications$$$deprecated$$list$bookmark$applications$Status$200;
export interface Params$access$bookmark$applications$$$deprecated$$list$bookmark$applications {
    parameter: Parameter$access$bookmark$applications$$$deprecated$$list$bookmark$applications;
}
export type ResponseContentType$access$bookmark$applications$$$deprecated$$get$a$bookmark$application = keyof Response$access$bookmark$applications$$$deprecated$$get$a$bookmark$application$Status$200;
export interface Params$access$bookmark$applications$$$deprecated$$get$a$bookmark$application {
    parameter: Parameter$access$bookmark$applications$$$deprecated$$get$a$bookmark$application;
}
export type ResponseContentType$access$bookmark$applications$$$deprecated$$update$a$bookmark$application = keyof Response$access$bookmark$applications$$$deprecated$$update$a$bookmark$application$Status$200;
export interface Params$access$bookmark$applications$$$deprecated$$update$a$bookmark$application {
    parameter: Parameter$access$bookmark$applications$$$deprecated$$update$a$bookmark$application;
}
export type ResponseContentType$access$bookmark$applications$$$deprecated$$create$a$bookmark$application = keyof Response$access$bookmark$applications$$$deprecated$$create$a$bookmark$application$Status$200;
export interface Params$access$bookmark$applications$$$deprecated$$create$a$bookmark$application {
    parameter: Parameter$access$bookmark$applications$$$deprecated$$create$a$bookmark$application;
}
export type ResponseContentType$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application = keyof Response$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application$Status$200;
export interface Params$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application {
    parameter: Parameter$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application;
}
export type ResponseContentType$access$mtls$authentication$list$mtls$certificates = keyof Response$access$mtls$authentication$list$mtls$certificates$Status$200;
export interface Params$access$mtls$authentication$list$mtls$certificates {
    parameter: Parameter$access$mtls$authentication$list$mtls$certificates;
}
export type RequestContentType$access$mtls$authentication$add$an$mtls$certificate = keyof RequestBody$access$mtls$authentication$add$an$mtls$certificate;
export type ResponseContentType$access$mtls$authentication$add$an$mtls$certificate = keyof Response$access$mtls$authentication$add$an$mtls$certificate$Status$201;
export interface Params$access$mtls$authentication$add$an$mtls$certificate {
    parameter: Parameter$access$mtls$authentication$add$an$mtls$certificate;
    requestBody: RequestBody$access$mtls$authentication$add$an$mtls$certificate["application/json"];
}
export type ResponseContentType$access$mtls$authentication$get$an$mtls$certificate = keyof Response$access$mtls$authentication$get$an$mtls$certificate$Status$200;
export interface Params$access$mtls$authentication$get$an$mtls$certificate {
    parameter: Parameter$access$mtls$authentication$get$an$mtls$certificate;
}
export type RequestContentType$access$mtls$authentication$update$an$mtls$certificate = keyof RequestBody$access$mtls$authentication$update$an$mtls$certificate;
export type ResponseContentType$access$mtls$authentication$update$an$mtls$certificate = keyof Response$access$mtls$authentication$update$an$mtls$certificate$Status$200;
export interface Params$access$mtls$authentication$update$an$mtls$certificate {
    parameter: Parameter$access$mtls$authentication$update$an$mtls$certificate;
    requestBody: RequestBody$access$mtls$authentication$update$an$mtls$certificate["application/json"];
}
export type ResponseContentType$access$mtls$authentication$delete$an$mtls$certificate = keyof Response$access$mtls$authentication$delete$an$mtls$certificate$Status$200;
export interface Params$access$mtls$authentication$delete$an$mtls$certificate {
    parameter: Parameter$access$mtls$authentication$delete$an$mtls$certificate;
}
export type ResponseContentType$access$mtls$authentication$list$mtls$certificates$hostname$settings = keyof Response$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$200;
export interface Params$access$mtls$authentication$list$mtls$certificates$hostname$settings {
    parameter: Parameter$access$mtls$authentication$list$mtls$certificates$hostname$settings;
}
export type RequestContentType$access$mtls$authentication$update$an$mtls$certificate$settings = keyof RequestBody$access$mtls$authentication$update$an$mtls$certificate$settings;
export type ResponseContentType$access$mtls$authentication$update$an$mtls$certificate$settings = keyof Response$access$mtls$authentication$update$an$mtls$certificate$settings$Status$202;
export interface Params$access$mtls$authentication$update$an$mtls$certificate$settings {
    parameter: Parameter$access$mtls$authentication$update$an$mtls$certificate$settings;
    requestBody: RequestBody$access$mtls$authentication$update$an$mtls$certificate$settings["application/json"];
}
export type ResponseContentType$access$custom$pages$list$custom$pages = keyof Response$access$custom$pages$list$custom$pages$Status$200;
export interface Params$access$custom$pages$list$custom$pages {
    parameter: Parameter$access$custom$pages$list$custom$pages;
}
export type RequestContentType$access$custom$pages$create$a$custom$page = keyof RequestBody$access$custom$pages$create$a$custom$page;
export type ResponseContentType$access$custom$pages$create$a$custom$page = keyof Response$access$custom$pages$create$a$custom$page$Status$201;
export interface Params$access$custom$pages$create$a$custom$page {
    parameter: Parameter$access$custom$pages$create$a$custom$page;
    requestBody: RequestBody$access$custom$pages$create$a$custom$page["application/json"];
}
export type ResponseContentType$access$custom$pages$get$a$custom$page = keyof Response$access$custom$pages$get$a$custom$page$Status$200;
export interface Params$access$custom$pages$get$a$custom$page {
    parameter: Parameter$access$custom$pages$get$a$custom$page;
}
export type RequestContentType$access$custom$pages$update$a$custom$page = keyof RequestBody$access$custom$pages$update$a$custom$page;
export type ResponseContentType$access$custom$pages$update$a$custom$page = keyof Response$access$custom$pages$update$a$custom$page$Status$200;
export interface Params$access$custom$pages$update$a$custom$page {
    parameter: Parameter$access$custom$pages$update$a$custom$page;
    requestBody: RequestBody$access$custom$pages$update$a$custom$page["application/json"];
}
export type ResponseContentType$access$custom$pages$delete$a$custom$page = keyof Response$access$custom$pages$delete$a$custom$page$Status$202;
export interface Params$access$custom$pages$delete$a$custom$page {
    parameter: Parameter$access$custom$pages$delete$a$custom$page;
}
export type ResponseContentType$access$groups$list$access$groups = keyof Response$access$groups$list$access$groups$Status$200;
export interface Params$access$groups$list$access$groups {
    parameter: Parameter$access$groups$list$access$groups;
}
export type RequestContentType$access$groups$create$an$access$group = keyof RequestBody$access$groups$create$an$access$group;
export type ResponseContentType$access$groups$create$an$access$group = keyof Response$access$groups$create$an$access$group$Status$201;
export interface Params$access$groups$create$an$access$group {
    parameter: Parameter$access$groups$create$an$access$group;
    requestBody: RequestBody$access$groups$create$an$access$group["application/json"];
}
export type ResponseContentType$access$groups$get$an$access$group = keyof Response$access$groups$get$an$access$group$Status$200;
export interface Params$access$groups$get$an$access$group {
    parameter: Parameter$access$groups$get$an$access$group;
}
export type RequestContentType$access$groups$update$an$access$group = keyof RequestBody$access$groups$update$an$access$group;
export type ResponseContentType$access$groups$update$an$access$group = keyof Response$access$groups$update$an$access$group$Status$200;
export interface Params$access$groups$update$an$access$group {
    parameter: Parameter$access$groups$update$an$access$group;
    requestBody: RequestBody$access$groups$update$an$access$group["application/json"];
}
export type ResponseContentType$access$groups$delete$an$access$group = keyof Response$access$groups$delete$an$access$group$Status$202;
export interface Params$access$groups$delete$an$access$group {
    parameter: Parameter$access$groups$delete$an$access$group;
}
export type ResponseContentType$access$identity$providers$list$access$identity$providers = keyof Response$access$identity$providers$list$access$identity$providers$Status$200;
export interface Params$access$identity$providers$list$access$identity$providers {
    parameter: Parameter$access$identity$providers$list$access$identity$providers;
}
export type RequestContentType$access$identity$providers$add$an$access$identity$provider = keyof RequestBody$access$identity$providers$add$an$access$identity$provider;
export type ResponseContentType$access$identity$providers$add$an$access$identity$provider = keyof Response$access$identity$providers$add$an$access$identity$provider$Status$201;
export interface Params$access$identity$providers$add$an$access$identity$provider {
    parameter: Parameter$access$identity$providers$add$an$access$identity$provider;
    requestBody: RequestBody$access$identity$providers$add$an$access$identity$provider["application/json"];
}
export type ResponseContentType$access$identity$providers$get$an$access$identity$provider = keyof Response$access$identity$providers$get$an$access$identity$provider$Status$200;
export interface Params$access$identity$providers$get$an$access$identity$provider {
    parameter: Parameter$access$identity$providers$get$an$access$identity$provider;
}
export type RequestContentType$access$identity$providers$update$an$access$identity$provider = keyof RequestBody$access$identity$providers$update$an$access$identity$provider;
export type ResponseContentType$access$identity$providers$update$an$access$identity$provider = keyof Response$access$identity$providers$update$an$access$identity$provider$Status$200;
export interface Params$access$identity$providers$update$an$access$identity$provider {
    parameter: Parameter$access$identity$providers$update$an$access$identity$provider;
    requestBody: RequestBody$access$identity$providers$update$an$access$identity$provider["application/json"];
}
export type ResponseContentType$access$identity$providers$delete$an$access$identity$provider = keyof Response$access$identity$providers$delete$an$access$identity$provider$Status$202;
export interface Params$access$identity$providers$delete$an$access$identity$provider {
    parameter: Parameter$access$identity$providers$delete$an$access$identity$provider;
}
export type ResponseContentType$access$key$configuration$get$the$access$key$configuration = keyof Response$access$key$configuration$get$the$access$key$configuration$Status$200;
export interface Params$access$key$configuration$get$the$access$key$configuration {
    parameter: Parameter$access$key$configuration$get$the$access$key$configuration;
}
export type RequestContentType$access$key$configuration$update$the$access$key$configuration = keyof RequestBody$access$key$configuration$update$the$access$key$configuration;
export type ResponseContentType$access$key$configuration$update$the$access$key$configuration = keyof Response$access$key$configuration$update$the$access$key$configuration$Status$200;
export interface Params$access$key$configuration$update$the$access$key$configuration {
    parameter: Parameter$access$key$configuration$update$the$access$key$configuration;
    requestBody: RequestBody$access$key$configuration$update$the$access$key$configuration["application/json"];
}
export type ResponseContentType$access$key$configuration$rotate$access$keys = keyof Response$access$key$configuration$rotate$access$keys$Status$200;
export interface Params$access$key$configuration$rotate$access$keys {
    parameter: Parameter$access$key$configuration$rotate$access$keys;
}
export type ResponseContentType$access$authentication$logs$get$access$authentication$logs = keyof Response$access$authentication$logs$get$access$authentication$logs$Status$200;
export interface Params$access$authentication$logs$get$access$authentication$logs {
    parameter: Parameter$access$authentication$logs$get$access$authentication$logs;
}
export type ResponseContentType$zero$trust$organization$get$your$zero$trust$organization = keyof Response$zero$trust$organization$get$your$zero$trust$organization$Status$200;
export interface Params$zero$trust$organization$get$your$zero$trust$organization {
    parameter: Parameter$zero$trust$organization$get$your$zero$trust$organization;
}
export type RequestContentType$zero$trust$organization$update$your$zero$trust$organization = keyof RequestBody$zero$trust$organization$update$your$zero$trust$organization;
export type ResponseContentType$zero$trust$organization$update$your$zero$trust$organization = keyof Response$zero$trust$organization$update$your$zero$trust$organization$Status$200;
export interface Params$zero$trust$organization$update$your$zero$trust$organization {
    parameter: Parameter$zero$trust$organization$update$your$zero$trust$organization;
    requestBody: RequestBody$zero$trust$organization$update$your$zero$trust$organization["application/json"];
}
export type RequestContentType$zero$trust$organization$create$your$zero$trust$organization = keyof RequestBody$zero$trust$organization$create$your$zero$trust$organization;
export type ResponseContentType$zero$trust$organization$create$your$zero$trust$organization = keyof Response$zero$trust$organization$create$your$zero$trust$organization$Status$201;
export interface Params$zero$trust$organization$create$your$zero$trust$organization {
    parameter: Parameter$zero$trust$organization$create$your$zero$trust$organization;
    requestBody: RequestBody$zero$trust$organization$create$your$zero$trust$organization["application/json"];
}
export type RequestContentType$zero$trust$organization$revoke$all$access$tokens$for$a$user = keyof RequestBody$zero$trust$organization$revoke$all$access$tokens$for$a$user;
export type ResponseContentType$zero$trust$organization$revoke$all$access$tokens$for$a$user = keyof Response$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$200;
export interface Params$zero$trust$organization$revoke$all$access$tokens$for$a$user {
    parameter: Parameter$zero$trust$organization$revoke$all$access$tokens$for$a$user;
    requestBody: RequestBody$zero$trust$organization$revoke$all$access$tokens$for$a$user["application/json"];
}
export type RequestContentType$zero$trust$seats$update$a$user$seat = keyof RequestBody$zero$trust$seats$update$a$user$seat;
export type ResponseContentType$zero$trust$seats$update$a$user$seat = keyof Response$zero$trust$seats$update$a$user$seat$Status$200;
export interface Params$zero$trust$seats$update$a$user$seat {
    parameter: Parameter$zero$trust$seats$update$a$user$seat;
    requestBody: RequestBody$zero$trust$seats$update$a$user$seat["application/json"];
}
export type ResponseContentType$access$service$tokens$list$service$tokens = keyof Response$access$service$tokens$list$service$tokens$Status$200;
export interface Params$access$service$tokens$list$service$tokens {
    parameter: Parameter$access$service$tokens$list$service$tokens;
}
export type RequestContentType$access$service$tokens$create$a$service$token = keyof RequestBody$access$service$tokens$create$a$service$token;
export type ResponseContentType$access$service$tokens$create$a$service$token = keyof Response$access$service$tokens$create$a$service$token$Status$201;
export interface Params$access$service$tokens$create$a$service$token {
    parameter: Parameter$access$service$tokens$create$a$service$token;
    requestBody: RequestBody$access$service$tokens$create$a$service$token["application/json"];
}
export type RequestContentType$access$service$tokens$update$a$service$token = keyof RequestBody$access$service$tokens$update$a$service$token;
export type ResponseContentType$access$service$tokens$update$a$service$token = keyof Response$access$service$tokens$update$a$service$token$Status$200;
export interface Params$access$service$tokens$update$a$service$token {
    parameter: Parameter$access$service$tokens$update$a$service$token;
    requestBody: RequestBody$access$service$tokens$update$a$service$token["application/json"];
}
export type ResponseContentType$access$service$tokens$delete$a$service$token = keyof Response$access$service$tokens$delete$a$service$token$Status$200;
export interface Params$access$service$tokens$delete$a$service$token {
    parameter: Parameter$access$service$tokens$delete$a$service$token;
}
export type ResponseContentType$access$service$tokens$refresh$a$service$token = keyof Response$access$service$tokens$refresh$a$service$token$Status$200;
export interface Params$access$service$tokens$refresh$a$service$token {
    parameter: Parameter$access$service$tokens$refresh$a$service$token;
}
export type ResponseContentType$access$service$tokens$rotate$a$service$token = keyof Response$access$service$tokens$rotate$a$service$token$Status$200;
export interface Params$access$service$tokens$rotate$a$service$token {
    parameter: Parameter$access$service$tokens$rotate$a$service$token;
}
export type ResponseContentType$access$tags$list$tags = keyof Response$access$tags$list$tags$Status$200;
export interface Params$access$tags$list$tags {
    parameter: Parameter$access$tags$list$tags;
}
export type RequestContentType$access$tags$create$tag = keyof RequestBody$access$tags$create$tag;
export type ResponseContentType$access$tags$create$tag = keyof Response$access$tags$create$tag$Status$201;
export interface Params$access$tags$create$tag {
    parameter: Parameter$access$tags$create$tag;
    requestBody: RequestBody$access$tags$create$tag["application/json"];
}
export type ResponseContentType$access$tags$get$a$tag = keyof Response$access$tags$get$a$tag$Status$200;
export interface Params$access$tags$get$a$tag {
    parameter: Parameter$access$tags$get$a$tag;
}
export type RequestContentType$access$tags$update$a$tag = keyof RequestBody$access$tags$update$a$tag;
export type ResponseContentType$access$tags$update$a$tag = keyof Response$access$tags$update$a$tag$Status$200;
export interface Params$access$tags$update$a$tag {
    parameter: Parameter$access$tags$update$a$tag;
    requestBody: RequestBody$access$tags$update$a$tag["application/json"];
}
export type ResponseContentType$access$tags$delete$a$tag = keyof Response$access$tags$delete$a$tag$Status$202;
export interface Params$access$tags$delete$a$tag {
    parameter: Parameter$access$tags$delete$a$tag;
}
export type ResponseContentType$zero$trust$users$get$users = keyof Response$zero$trust$users$get$users$Status$200;
export interface Params$zero$trust$users$get$users {
    parameter: Parameter$zero$trust$users$get$users;
}
export type ResponseContentType$zero$trust$users$get$active$sessions = keyof Response$zero$trust$users$get$active$sessions$Status$200;
export interface Params$zero$trust$users$get$active$sessions {
    parameter: Parameter$zero$trust$users$get$active$sessions;
}
export type ResponseContentType$zero$trust$users$get$active$session = keyof Response$zero$trust$users$get$active$session$Status$200;
export interface Params$zero$trust$users$get$active$session {
    parameter: Parameter$zero$trust$users$get$active$session;
}
export type ResponseContentType$zero$trust$users$get$failed$logins = keyof Response$zero$trust$users$get$failed$logins$Status$200;
export interface Params$zero$trust$users$get$failed$logins {
    parameter: Parameter$zero$trust$users$get$failed$logins;
}
export type ResponseContentType$zero$trust$users$get$last$seen$identity = keyof Response$zero$trust$users$get$last$seen$identity$Status$200;
export interface Params$zero$trust$users$get$last$seen$identity {
    parameter: Parameter$zero$trust$users$get$last$seen$identity;
}
export type ResponseContentType$devices$list$devices = keyof Response$devices$list$devices$Status$200;
export interface Params$devices$list$devices {
    parameter: Parameter$devices$list$devices;
}
export type ResponseContentType$devices$device$details = keyof Response$devices$device$details$Status$200;
export interface Params$devices$device$details {
    parameter: Parameter$devices$device$details;
}
export type ResponseContentType$devices$list$admin$override$code$for$device = keyof Response$devices$list$admin$override$code$for$device$Status$200;
export interface Params$devices$list$admin$override$code$for$device {
    parameter: Parameter$devices$list$admin$override$code$for$device;
}
export type ResponseContentType$device$dex$test$details = keyof Response$device$dex$test$details$Status$200;
export interface Params$device$dex$test$details {
    parameter: Parameter$device$dex$test$details;
}
export type RequestContentType$device$dex$test$create$device$dex$test = keyof RequestBody$device$dex$test$create$device$dex$test;
export type ResponseContentType$device$dex$test$create$device$dex$test = keyof Response$device$dex$test$create$device$dex$test$Status$200;
export interface Params$device$dex$test$create$device$dex$test {
    parameter: Parameter$device$dex$test$create$device$dex$test;
    requestBody: RequestBody$device$dex$test$create$device$dex$test["application/json"];
}
export type ResponseContentType$device$dex$test$get$device$dex$test = keyof Response$device$dex$test$get$device$dex$test$Status$200;
export interface Params$device$dex$test$get$device$dex$test {
    parameter: Parameter$device$dex$test$get$device$dex$test;
}
export type RequestContentType$device$dex$test$update$device$dex$test = keyof RequestBody$device$dex$test$update$device$dex$test;
export type ResponseContentType$device$dex$test$update$device$dex$test = keyof Response$device$dex$test$update$device$dex$test$Status$200;
export interface Params$device$dex$test$update$device$dex$test {
    parameter: Parameter$device$dex$test$update$device$dex$test;
    requestBody: RequestBody$device$dex$test$update$device$dex$test["application/json"];
}
export type ResponseContentType$device$dex$test$delete$device$dex$test = keyof Response$device$dex$test$delete$device$dex$test$Status$200;
export interface Params$device$dex$test$delete$device$dex$test {
    parameter: Parameter$device$dex$test$delete$device$dex$test;
}
export type ResponseContentType$device$managed$networks$list$device$managed$networks = keyof Response$device$managed$networks$list$device$managed$networks$Status$200;
export interface Params$device$managed$networks$list$device$managed$networks {
    parameter: Parameter$device$managed$networks$list$device$managed$networks;
}
export type RequestContentType$device$managed$networks$create$device$managed$network = keyof RequestBody$device$managed$networks$create$device$managed$network;
export type ResponseContentType$device$managed$networks$create$device$managed$network = keyof Response$device$managed$networks$create$device$managed$network$Status$200;
export interface Params$device$managed$networks$create$device$managed$network {
    parameter: Parameter$device$managed$networks$create$device$managed$network;
    requestBody: RequestBody$device$managed$networks$create$device$managed$network["application/json"];
}
export type ResponseContentType$device$managed$networks$device$managed$network$details = keyof Response$device$managed$networks$device$managed$network$details$Status$200;
export interface Params$device$managed$networks$device$managed$network$details {
    parameter: Parameter$device$managed$networks$device$managed$network$details;
}
export type RequestContentType$device$managed$networks$update$device$managed$network = keyof RequestBody$device$managed$networks$update$device$managed$network;
export type ResponseContentType$device$managed$networks$update$device$managed$network = keyof Response$device$managed$networks$update$device$managed$network$Status$200;
export interface Params$device$managed$networks$update$device$managed$network {
    parameter: Parameter$device$managed$networks$update$device$managed$network;
    requestBody: RequestBody$device$managed$networks$update$device$managed$network["application/json"];
}
export type ResponseContentType$device$managed$networks$delete$device$managed$network = keyof Response$device$managed$networks$delete$device$managed$network$Status$200;
export interface Params$device$managed$networks$delete$device$managed$network {
    parameter: Parameter$device$managed$networks$delete$device$managed$network;
}
export type ResponseContentType$devices$list$device$settings$policies = keyof Response$devices$list$device$settings$policies$Status$200;
export interface Params$devices$list$device$settings$policies {
    parameter: Parameter$devices$list$device$settings$policies;
}
export type ResponseContentType$devices$get$default$device$settings$policy = keyof Response$devices$get$default$device$settings$policy$Status$200;
export interface Params$devices$get$default$device$settings$policy {
    parameter: Parameter$devices$get$default$device$settings$policy;
}
export type RequestContentType$devices$create$device$settings$policy = keyof RequestBody$devices$create$device$settings$policy;
export type ResponseContentType$devices$create$device$settings$policy = keyof Response$devices$create$device$settings$policy$Status$200;
export interface Params$devices$create$device$settings$policy {
    parameter: Parameter$devices$create$device$settings$policy;
    requestBody: RequestBody$devices$create$device$settings$policy["application/json"];
}
export type RequestContentType$devices$update$default$device$settings$policy = keyof RequestBody$devices$update$default$device$settings$policy;
export type ResponseContentType$devices$update$default$device$settings$policy = keyof Response$devices$update$default$device$settings$policy$Status$200;
export interface Params$devices$update$default$device$settings$policy {
    parameter: Parameter$devices$update$default$device$settings$policy;
    requestBody: RequestBody$devices$update$default$device$settings$policy["application/json"];
}
export type ResponseContentType$devices$get$device$settings$policy$by$id = keyof Response$devices$get$device$settings$policy$by$id$Status$200;
export interface Params$devices$get$device$settings$policy$by$id {
    parameter: Parameter$devices$get$device$settings$policy$by$id;
}
export type ResponseContentType$devices$delete$device$settings$policy = keyof Response$devices$delete$device$settings$policy$Status$200;
export interface Params$devices$delete$device$settings$policy {
    parameter: Parameter$devices$delete$device$settings$policy;
}
export type RequestContentType$devices$update$device$settings$policy = keyof RequestBody$devices$update$device$settings$policy;
export type ResponseContentType$devices$update$device$settings$policy = keyof Response$devices$update$device$settings$policy$Status$200;
export interface Params$devices$update$device$settings$policy {
    parameter: Parameter$devices$update$device$settings$policy;
    requestBody: RequestBody$devices$update$device$settings$policy["application/json"];
}
export type ResponseContentType$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy = keyof Response$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy$Status$200;
export interface Params$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy {
    parameter: Parameter$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy;
}
export type RequestContentType$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy = keyof RequestBody$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy;
export type ResponseContentType$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy = keyof Response$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy$Status$200;
export interface Params$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy {
    parameter: Parameter$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy;
    requestBody: RequestBody$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy["application/json"];
}
export type ResponseContentType$devices$get$local$domain$fallback$list$for$a$device$settings$policy = keyof Response$devices$get$local$domain$fallback$list$for$a$device$settings$policy$Status$200;
export interface Params$devices$get$local$domain$fallback$list$for$a$device$settings$policy {
    parameter: Parameter$devices$get$local$domain$fallback$list$for$a$device$settings$policy;
}
export type RequestContentType$devices$set$local$domain$fallback$list$for$a$device$settings$policy = keyof RequestBody$devices$set$local$domain$fallback$list$for$a$device$settings$policy;
export type ResponseContentType$devices$set$local$domain$fallback$list$for$a$device$settings$policy = keyof Response$devices$set$local$domain$fallback$list$for$a$device$settings$policy$Status$200;
export interface Params$devices$set$local$domain$fallback$list$for$a$device$settings$policy {
    parameter: Parameter$devices$set$local$domain$fallback$list$for$a$device$settings$policy;
    requestBody: RequestBody$devices$set$local$domain$fallback$list$for$a$device$settings$policy["application/json"];
}
export type ResponseContentType$devices$get$split$tunnel$include$list$for$a$device$settings$policy = keyof Response$devices$get$split$tunnel$include$list$for$a$device$settings$policy$Status$200;
export interface Params$devices$get$split$tunnel$include$list$for$a$device$settings$policy {
    parameter: Parameter$devices$get$split$tunnel$include$list$for$a$device$settings$policy;
}
export type RequestContentType$devices$set$split$tunnel$include$list$for$a$device$settings$policy = keyof RequestBody$devices$set$split$tunnel$include$list$for$a$device$settings$policy;
export type ResponseContentType$devices$set$split$tunnel$include$list$for$a$device$settings$policy = keyof Response$devices$set$split$tunnel$include$list$for$a$device$settings$policy$Status$200;
export interface Params$devices$set$split$tunnel$include$list$for$a$device$settings$policy {
    parameter: Parameter$devices$set$split$tunnel$include$list$for$a$device$settings$policy;
    requestBody: RequestBody$devices$set$split$tunnel$include$list$for$a$device$settings$policy["application/json"];
}
export type ResponseContentType$devices$get$split$tunnel$exclude$list = keyof Response$devices$get$split$tunnel$exclude$list$Status$200;
export interface Params$devices$get$split$tunnel$exclude$list {
    parameter: Parameter$devices$get$split$tunnel$exclude$list;
}
export type RequestContentType$devices$set$split$tunnel$exclude$list = keyof RequestBody$devices$set$split$tunnel$exclude$list;
export type ResponseContentType$devices$set$split$tunnel$exclude$list = keyof Response$devices$set$split$tunnel$exclude$list$Status$200;
export interface Params$devices$set$split$tunnel$exclude$list {
    parameter: Parameter$devices$set$split$tunnel$exclude$list;
    requestBody: RequestBody$devices$set$split$tunnel$exclude$list["application/json"];
}
export type ResponseContentType$devices$get$local$domain$fallback$list = keyof Response$devices$get$local$domain$fallback$list$Status$200;
export interface Params$devices$get$local$domain$fallback$list {
    parameter: Parameter$devices$get$local$domain$fallback$list;
}
export type RequestContentType$devices$set$local$domain$fallback$list = keyof RequestBody$devices$set$local$domain$fallback$list;
export type ResponseContentType$devices$set$local$domain$fallback$list = keyof Response$devices$set$local$domain$fallback$list$Status$200;
export interface Params$devices$set$local$domain$fallback$list {
    parameter: Parameter$devices$set$local$domain$fallback$list;
    requestBody: RequestBody$devices$set$local$domain$fallback$list["application/json"];
}
export type ResponseContentType$devices$get$split$tunnel$include$list = keyof Response$devices$get$split$tunnel$include$list$Status$200;
export interface Params$devices$get$split$tunnel$include$list {
    parameter: Parameter$devices$get$split$tunnel$include$list;
}
export type RequestContentType$devices$set$split$tunnel$include$list = keyof RequestBody$devices$set$split$tunnel$include$list;
export type ResponseContentType$devices$set$split$tunnel$include$list = keyof Response$devices$set$split$tunnel$include$list$Status$200;
export interface Params$devices$set$split$tunnel$include$list {
    parameter: Parameter$devices$set$split$tunnel$include$list;
    requestBody: RequestBody$devices$set$split$tunnel$include$list["application/json"];
}
export type ResponseContentType$device$posture$rules$list$device$posture$rules = keyof Response$device$posture$rules$list$device$posture$rules$Status$200;
export interface Params$device$posture$rules$list$device$posture$rules {
    parameter: Parameter$device$posture$rules$list$device$posture$rules;
}
export type RequestContentType$device$posture$rules$create$device$posture$rule = keyof RequestBody$device$posture$rules$create$device$posture$rule;
export type ResponseContentType$device$posture$rules$create$device$posture$rule = keyof Response$device$posture$rules$create$device$posture$rule$Status$200;
export interface Params$device$posture$rules$create$device$posture$rule {
    parameter: Parameter$device$posture$rules$create$device$posture$rule;
    requestBody: RequestBody$device$posture$rules$create$device$posture$rule["application/json"];
}
export type ResponseContentType$device$posture$rules$device$posture$rules$details = keyof Response$device$posture$rules$device$posture$rules$details$Status$200;
export interface Params$device$posture$rules$device$posture$rules$details {
    parameter: Parameter$device$posture$rules$device$posture$rules$details;
}
export type RequestContentType$device$posture$rules$update$device$posture$rule = keyof RequestBody$device$posture$rules$update$device$posture$rule;
export type ResponseContentType$device$posture$rules$update$device$posture$rule = keyof Response$device$posture$rules$update$device$posture$rule$Status$200;
export interface Params$device$posture$rules$update$device$posture$rule {
    parameter: Parameter$device$posture$rules$update$device$posture$rule;
    requestBody: RequestBody$device$posture$rules$update$device$posture$rule["application/json"];
}
export type ResponseContentType$device$posture$rules$delete$device$posture$rule = keyof Response$device$posture$rules$delete$device$posture$rule$Status$200;
export interface Params$device$posture$rules$delete$device$posture$rule {
    parameter: Parameter$device$posture$rules$delete$device$posture$rule;
}
export type ResponseContentType$device$posture$integrations$list$device$posture$integrations = keyof Response$device$posture$integrations$list$device$posture$integrations$Status$200;
export interface Params$device$posture$integrations$list$device$posture$integrations {
    parameter: Parameter$device$posture$integrations$list$device$posture$integrations;
}
export type RequestContentType$device$posture$integrations$create$device$posture$integration = keyof RequestBody$device$posture$integrations$create$device$posture$integration;
export type ResponseContentType$device$posture$integrations$create$device$posture$integration = keyof Response$device$posture$integrations$create$device$posture$integration$Status$200;
export interface Params$device$posture$integrations$create$device$posture$integration {
    parameter: Parameter$device$posture$integrations$create$device$posture$integration;
    requestBody: RequestBody$device$posture$integrations$create$device$posture$integration["application/json"];
}
export type ResponseContentType$device$posture$integrations$device$posture$integration$details = keyof Response$device$posture$integrations$device$posture$integration$details$Status$200;
export interface Params$device$posture$integrations$device$posture$integration$details {
    parameter: Parameter$device$posture$integrations$device$posture$integration$details;
}
export type ResponseContentType$device$posture$integrations$delete$device$posture$integration = keyof Response$device$posture$integrations$delete$device$posture$integration$Status$200;
export interface Params$device$posture$integrations$delete$device$posture$integration {
    parameter: Parameter$device$posture$integrations$delete$device$posture$integration;
}
export type RequestContentType$device$posture$integrations$update$device$posture$integration = keyof RequestBody$device$posture$integrations$update$device$posture$integration;
export type ResponseContentType$device$posture$integrations$update$device$posture$integration = keyof Response$device$posture$integrations$update$device$posture$integration$Status$200;
export interface Params$device$posture$integrations$update$device$posture$integration {
    parameter: Parameter$device$posture$integrations$update$device$posture$integration;
    requestBody: RequestBody$device$posture$integrations$update$device$posture$integration["application/json"];
}
export type RequestContentType$devices$revoke$devices = keyof RequestBody$devices$revoke$devices;
export type ResponseContentType$devices$revoke$devices = keyof Response$devices$revoke$devices$Status$200;
export interface Params$devices$revoke$devices {
    parameter: Parameter$devices$revoke$devices;
    requestBody: RequestBody$devices$revoke$devices["application/json"];
}
export type ResponseContentType$zero$trust$accounts$get$device$settings$for$zero$trust$account = keyof Response$zero$trust$accounts$get$device$settings$for$zero$trust$account$Status$200;
export interface Params$zero$trust$accounts$get$device$settings$for$zero$trust$account {
    parameter: Parameter$zero$trust$accounts$get$device$settings$for$zero$trust$account;
}
export type RequestContentType$zero$trust$accounts$update$device$settings$for$the$zero$trust$account = keyof RequestBody$zero$trust$accounts$update$device$settings$for$the$zero$trust$account;
export type ResponseContentType$zero$trust$accounts$update$device$settings$for$the$zero$trust$account = keyof Response$zero$trust$accounts$update$device$settings$for$the$zero$trust$account$Status$200;
export interface Params$zero$trust$accounts$update$device$settings$for$the$zero$trust$account {
    parameter: Parameter$zero$trust$accounts$update$device$settings$for$the$zero$trust$account;
    requestBody: RequestBody$zero$trust$accounts$update$device$settings$for$the$zero$trust$account["application/json"];
}
export type RequestContentType$devices$unrevoke$devices = keyof RequestBody$devices$unrevoke$devices;
export type ResponseContentType$devices$unrevoke$devices = keyof Response$devices$unrevoke$devices$Status$200;
export interface Params$devices$unrevoke$devices {
    parameter: Parameter$devices$unrevoke$devices;
    requestBody: RequestBody$devices$unrevoke$devices["application/json"];
}
export type ResponseContentType$origin$ca$list$certificates = keyof Response$origin$ca$list$certificates$Status$200;
export interface Params$origin$ca$list$certificates {
    parameter: Parameter$origin$ca$list$certificates;
}
export type RequestContentType$origin$ca$create$certificate = keyof RequestBody$origin$ca$create$certificate;
export type ResponseContentType$origin$ca$create$certificate = keyof Response$origin$ca$create$certificate$Status$200;
export interface Params$origin$ca$create$certificate {
    requestBody: RequestBody$origin$ca$create$certificate["application/json"];
}
export type ResponseContentType$origin$ca$get$certificate = keyof Response$origin$ca$get$certificate$Status$200;
export interface Params$origin$ca$get$certificate {
    parameter: Parameter$origin$ca$get$certificate;
}
export type ResponseContentType$origin$ca$revoke$certificate = keyof Response$origin$ca$revoke$certificate$Status$200;
export interface Params$origin$ca$revoke$certificate {
    parameter: Parameter$origin$ca$revoke$certificate;
}
export type ResponseContentType$cloudflare$i$ps$cloudflare$ip$details = keyof Response$cloudflare$i$ps$cloudflare$ip$details$Status$200;
export interface Params$cloudflare$i$ps$cloudflare$ip$details {
    parameter: Parameter$cloudflare$i$ps$cloudflare$ip$details;
}
export type ResponseContentType$user$$s$account$memberships$list$memberships = keyof Response$user$$s$account$memberships$list$memberships$Status$200;
export interface Params$user$$s$account$memberships$list$memberships {
    parameter: Parameter$user$$s$account$memberships$list$memberships;
}
export type ResponseContentType$user$$s$account$memberships$membership$details = keyof Response$user$$s$account$memberships$membership$details$Status$200;
export interface Params$user$$s$account$memberships$membership$details {
    parameter: Parameter$user$$s$account$memberships$membership$details;
}
export type RequestContentType$user$$s$account$memberships$update$membership = keyof RequestBody$user$$s$account$memberships$update$membership;
export type ResponseContentType$user$$s$account$memberships$update$membership = keyof Response$user$$s$account$memberships$update$membership$Status$200;
export interface Params$user$$s$account$memberships$update$membership {
    parameter: Parameter$user$$s$account$memberships$update$membership;
    requestBody: RequestBody$user$$s$account$memberships$update$membership["application/json"];
}
export type ResponseContentType$user$$s$account$memberships$delete$membership = keyof Response$user$$s$account$memberships$delete$membership$Status$200;
export interface Params$user$$s$account$memberships$delete$membership {
    parameter: Parameter$user$$s$account$memberships$delete$membership;
}
export type ResponseContentType$organizations$$$deprecated$$organization$details = keyof Response$organizations$$$deprecated$$organization$details$Status$200;
export interface Params$organizations$$$deprecated$$organization$details {
    parameter: Parameter$organizations$$$deprecated$$organization$details;
}
export type RequestContentType$organizations$$$deprecated$$edit$organization = keyof RequestBody$organizations$$$deprecated$$edit$organization;
export type ResponseContentType$organizations$$$deprecated$$edit$organization = keyof Response$organizations$$$deprecated$$edit$organization$Status$200;
export interface Params$organizations$$$deprecated$$edit$organization {
    parameter: Parameter$organizations$$$deprecated$$edit$organization;
    requestBody: RequestBody$organizations$$$deprecated$$edit$organization["application/json"];
}
export type ResponseContentType$audit$logs$get$organization$audit$logs = keyof Response$audit$logs$get$organization$audit$logs$Status$200;
export interface Params$audit$logs$get$organization$audit$logs {
    parameter: Parameter$audit$logs$get$organization$audit$logs;
}
export type ResponseContentType$organization$invites$list$invitations = keyof Response$organization$invites$list$invitations$Status$200;
export interface Params$organization$invites$list$invitations {
    parameter: Parameter$organization$invites$list$invitations;
}
export type RequestContentType$organization$invites$create$invitation = keyof RequestBody$organization$invites$create$invitation;
export type ResponseContentType$organization$invites$create$invitation = keyof Response$organization$invites$create$invitation$Status$200;
export interface Params$organization$invites$create$invitation {
    parameter: Parameter$organization$invites$create$invitation;
    requestBody: RequestBody$organization$invites$create$invitation["application/json"];
}
export type ResponseContentType$organization$invites$invitation$details = keyof Response$organization$invites$invitation$details$Status$200;
export interface Params$organization$invites$invitation$details {
    parameter: Parameter$organization$invites$invitation$details;
}
export type ResponseContentType$organization$invites$cancel$invitation = keyof Response$organization$invites$cancel$invitation$Status$200;
export interface Params$organization$invites$cancel$invitation {
    parameter: Parameter$organization$invites$cancel$invitation;
}
export type RequestContentType$organization$invites$edit$invitation$roles = keyof RequestBody$organization$invites$edit$invitation$roles;
export type ResponseContentType$organization$invites$edit$invitation$roles = keyof Response$organization$invites$edit$invitation$roles$Status$200;
export interface Params$organization$invites$edit$invitation$roles {
    parameter: Parameter$organization$invites$edit$invitation$roles;
    requestBody: RequestBody$organization$invites$edit$invitation$roles["application/json"];
}
export type ResponseContentType$organization$members$list$members = keyof Response$organization$members$list$members$Status$200;
export interface Params$organization$members$list$members {
    parameter: Parameter$organization$members$list$members;
}
export type ResponseContentType$organization$members$member$details = keyof Response$organization$members$member$details$Status$200;
export interface Params$organization$members$member$details {
    parameter: Parameter$organization$members$member$details;
}
export type ResponseContentType$organization$members$remove$member = keyof Response$organization$members$remove$member$Status$200;
export interface Params$organization$members$remove$member {
    parameter: Parameter$organization$members$remove$member;
}
export type RequestContentType$organization$members$edit$member$roles = keyof RequestBody$organization$members$edit$member$roles;
export type ResponseContentType$organization$members$edit$member$roles = keyof Response$organization$members$edit$member$roles$Status$200;
export interface Params$organization$members$edit$member$roles {
    parameter: Parameter$organization$members$edit$member$roles;
    requestBody: RequestBody$organization$members$edit$member$roles["application/json"];
}
export type ResponseContentType$organization$roles$list$roles = keyof Response$organization$roles$list$roles$Status$200;
export interface Params$organization$roles$list$roles {
    parameter: Parameter$organization$roles$list$roles;
}
export type ResponseContentType$organization$roles$role$details = keyof Response$organization$roles$role$details$Status$200;
export interface Params$organization$roles$role$details {
    parameter: Parameter$organization$roles$role$details;
}
export type ResponseContentType$radar$get$annotations$outages = keyof Response$radar$get$annotations$outages$Status$200;
export interface Params$radar$get$annotations$outages {
    parameter: Parameter$radar$get$annotations$outages;
}
export type ResponseContentType$radar$get$annotations$outages$top = keyof Response$radar$get$annotations$outages$top$Status$200;
export interface Params$radar$get$annotations$outages$top {
    parameter: Parameter$radar$get$annotations$outages$top;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$by$dnssec = keyof Response$radar$get$dns$as112$timeseries$by$dnssec$Status$200;
export interface Params$radar$get$dns$as112$timeseries$by$dnssec {
    parameter: Parameter$radar$get$dns$as112$timeseries$by$dnssec;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$by$edns = keyof Response$radar$get$dns$as112$timeseries$by$edns$Status$200;
export interface Params$radar$get$dns$as112$timeseries$by$edns {
    parameter: Parameter$radar$get$dns$as112$timeseries$by$edns;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$by$ip$version = keyof Response$radar$get$dns$as112$timeseries$by$ip$version$Status$200;
export interface Params$radar$get$dns$as112$timeseries$by$ip$version {
    parameter: Parameter$radar$get$dns$as112$timeseries$by$ip$version;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$by$protocol = keyof Response$radar$get$dns$as112$timeseries$by$protocol$Status$200;
export interface Params$radar$get$dns$as112$timeseries$by$protocol {
    parameter: Parameter$radar$get$dns$as112$timeseries$by$protocol;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$by$query$type = keyof Response$radar$get$dns$as112$timeseries$by$query$type$Status$200;
export interface Params$radar$get$dns$as112$timeseries$by$query$type {
    parameter: Parameter$radar$get$dns$as112$timeseries$by$query$type;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$by$response$codes = keyof Response$radar$get$dns$as112$timeseries$by$response$codes$Status$200;
export interface Params$radar$get$dns$as112$timeseries$by$response$codes {
    parameter: Parameter$radar$get$dns$as112$timeseries$by$response$codes;
}
export type ResponseContentType$radar$get$dns$as112$timeseries = keyof Response$radar$get$dns$as112$timeseries$Status$200;
export interface Params$radar$get$dns$as112$timeseries {
    parameter: Parameter$radar$get$dns$as112$timeseries;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$group$by$dnssec = keyof Response$radar$get$dns$as112$timeseries$group$by$dnssec$Status$200;
export interface Params$radar$get$dns$as112$timeseries$group$by$dnssec {
    parameter: Parameter$radar$get$dns$as112$timeseries$group$by$dnssec;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$group$by$edns = keyof Response$radar$get$dns$as112$timeseries$group$by$edns$Status$200;
export interface Params$radar$get$dns$as112$timeseries$group$by$edns {
    parameter: Parameter$radar$get$dns$as112$timeseries$group$by$edns;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$group$by$ip$version = keyof Response$radar$get$dns$as112$timeseries$group$by$ip$version$Status$200;
export interface Params$radar$get$dns$as112$timeseries$group$by$ip$version {
    parameter: Parameter$radar$get$dns$as112$timeseries$group$by$ip$version;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$group$by$protocol = keyof Response$radar$get$dns$as112$timeseries$group$by$protocol$Status$200;
export interface Params$radar$get$dns$as112$timeseries$group$by$protocol {
    parameter: Parameter$radar$get$dns$as112$timeseries$group$by$protocol;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$group$by$query$type = keyof Response$radar$get$dns$as112$timeseries$group$by$query$type$Status$200;
export interface Params$radar$get$dns$as112$timeseries$group$by$query$type {
    parameter: Parameter$radar$get$dns$as112$timeseries$group$by$query$type;
}
export type ResponseContentType$radar$get$dns$as112$timeseries$group$by$response$codes = keyof Response$radar$get$dns$as112$timeseries$group$by$response$codes$Status$200;
export interface Params$radar$get$dns$as112$timeseries$group$by$response$codes {
    parameter: Parameter$radar$get$dns$as112$timeseries$group$by$response$codes;
}
export type ResponseContentType$radar$get$dns$as112$top$locations = keyof Response$radar$get$dns$as112$top$locations$Status$200;
export interface Params$radar$get$dns$as112$top$locations {
    parameter: Parameter$radar$get$dns$as112$top$locations;
}
export type ResponseContentType$radar$get$dns$as112$top$locations$by$dnssec = keyof Response$radar$get$dns$as112$top$locations$by$dnssec$Status$200;
export interface Params$radar$get$dns$as112$top$locations$by$dnssec {
    parameter: Parameter$radar$get$dns$as112$top$locations$by$dnssec;
}
export type ResponseContentType$radar$get$dns$as112$top$locations$by$edns = keyof Response$radar$get$dns$as112$top$locations$by$edns$Status$200;
export interface Params$radar$get$dns$as112$top$locations$by$edns {
    parameter: Parameter$radar$get$dns$as112$top$locations$by$edns;
}
export type ResponseContentType$radar$get$dns$as112$top$locations$by$ip$version = keyof Response$radar$get$dns$as112$top$locations$by$ip$version$Status$200;
export interface Params$radar$get$dns$as112$top$locations$by$ip$version {
    parameter: Parameter$radar$get$dns$as112$top$locations$by$ip$version;
}
export type ResponseContentType$radar$get$attacks$layer3$summary = keyof Response$radar$get$attacks$layer3$summary$Status$200;
export interface Params$radar$get$attacks$layer3$summary {
    parameter: Parameter$radar$get$attacks$layer3$summary;
}
export type ResponseContentType$radar$get$attacks$layer3$summary$by$bitrate = keyof Response$radar$get$attacks$layer3$summary$by$bitrate$Status$200;
export interface Params$radar$get$attacks$layer3$summary$by$bitrate {
    parameter: Parameter$radar$get$attacks$layer3$summary$by$bitrate;
}
export type ResponseContentType$radar$get$attacks$layer3$summary$by$duration = keyof Response$radar$get$attacks$layer3$summary$by$duration$Status$200;
export interface Params$radar$get$attacks$layer3$summary$by$duration {
    parameter: Parameter$radar$get$attacks$layer3$summary$by$duration;
}
export type ResponseContentType$radar$get$attacks$layer3$summary$by$ip$version = keyof Response$radar$get$attacks$layer3$summary$by$ip$version$Status$200;
export interface Params$radar$get$attacks$layer3$summary$by$ip$version {
    parameter: Parameter$radar$get$attacks$layer3$summary$by$ip$version;
}
export type ResponseContentType$radar$get$attacks$layer3$summary$by$protocol = keyof Response$radar$get$attacks$layer3$summary$by$protocol$Status$200;
export interface Params$radar$get$attacks$layer3$summary$by$protocol {
    parameter: Parameter$radar$get$attacks$layer3$summary$by$protocol;
}
export type ResponseContentType$radar$get$attacks$layer3$summary$by$vector = keyof Response$radar$get$attacks$layer3$summary$by$vector$Status$200;
export interface Params$radar$get$attacks$layer3$summary$by$vector {
    parameter: Parameter$radar$get$attacks$layer3$summary$by$vector;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$by$bytes = keyof Response$radar$get$attacks$layer3$timeseries$by$bytes$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$by$bytes {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$by$bytes;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$groups = keyof Response$radar$get$attacks$layer3$timeseries$groups$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$groups {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$groups;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$group$by$bitrate = keyof Response$radar$get$attacks$layer3$timeseries$group$by$bitrate$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$group$by$bitrate {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$group$by$bitrate;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$group$by$duration = keyof Response$radar$get$attacks$layer3$timeseries$group$by$duration$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$group$by$duration {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$group$by$duration;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$group$by$industry = keyof Response$radar$get$attacks$layer3$timeseries$group$by$industry$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$group$by$industry {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$group$by$industry;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$group$by$ip$version = keyof Response$radar$get$attacks$layer3$timeseries$group$by$ip$version$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$group$by$ip$version {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$group$by$ip$version;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$group$by$protocol = keyof Response$radar$get$attacks$layer3$timeseries$group$by$protocol$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$group$by$protocol {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$group$by$protocol;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$group$by$vector = keyof Response$radar$get$attacks$layer3$timeseries$group$by$vector$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$group$by$vector {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$group$by$vector;
}
export type ResponseContentType$radar$get$attacks$layer3$timeseries$group$by$vertical = keyof Response$radar$get$attacks$layer3$timeseries$group$by$vertical$Status$200;
export interface Params$radar$get$attacks$layer3$timeseries$group$by$vertical {
    parameter: Parameter$radar$get$attacks$layer3$timeseries$group$by$vertical;
}
export type ResponseContentType$radar$get$attacks$layer3$top$attacks = keyof Response$radar$get$attacks$layer3$top$attacks$Status$200;
export interface Params$radar$get$attacks$layer3$top$attacks {
    parameter: Parameter$radar$get$attacks$layer3$top$attacks;
}
export type ResponseContentType$radar$get$attacks$layer3$top$industries = keyof Response$radar$get$attacks$layer3$top$industries$Status$200;
export interface Params$radar$get$attacks$layer3$top$industries {
    parameter: Parameter$radar$get$attacks$layer3$top$industries;
}
export type ResponseContentType$radar$get$attacks$layer3$top$origin$locations = keyof Response$radar$get$attacks$layer3$top$origin$locations$Status$200;
export interface Params$radar$get$attacks$layer3$top$origin$locations {
    parameter: Parameter$radar$get$attacks$layer3$top$origin$locations;
}
export type ResponseContentType$radar$get$attacks$layer3$top$target$locations = keyof Response$radar$get$attacks$layer3$top$target$locations$Status$200;
export interface Params$radar$get$attacks$layer3$top$target$locations {
    parameter: Parameter$radar$get$attacks$layer3$top$target$locations;
}
export type ResponseContentType$radar$get$attacks$layer3$top$verticals = keyof Response$radar$get$attacks$layer3$top$verticals$Status$200;
export interface Params$radar$get$attacks$layer3$top$verticals {
    parameter: Parameter$radar$get$attacks$layer3$top$verticals;
}
export type ResponseContentType$radar$get$attacks$layer7$summary = keyof Response$radar$get$attacks$layer7$summary$Status$200;
export interface Params$radar$get$attacks$layer7$summary {
    parameter: Parameter$radar$get$attacks$layer7$summary;
}
export type ResponseContentType$radar$get$attacks$layer7$summary$by$http$method = keyof Response$radar$get$attacks$layer7$summary$by$http$method$Status$200;
export interface Params$radar$get$attacks$layer7$summary$by$http$method {
    parameter: Parameter$radar$get$attacks$layer7$summary$by$http$method;
}
export type ResponseContentType$radar$get$attacks$layer7$summary$by$http$version = keyof Response$radar$get$attacks$layer7$summary$by$http$version$Status$200;
export interface Params$radar$get$attacks$layer7$summary$by$http$version {
    parameter: Parameter$radar$get$attacks$layer7$summary$by$http$version;
}
export type ResponseContentType$radar$get$attacks$layer7$summary$by$ip$version = keyof Response$radar$get$attacks$layer7$summary$by$ip$version$Status$200;
export interface Params$radar$get$attacks$layer7$summary$by$ip$version {
    parameter: Parameter$radar$get$attacks$layer7$summary$by$ip$version;
}
export type ResponseContentType$radar$get$attacks$layer7$summary$by$managed$rules = keyof Response$radar$get$attacks$layer7$summary$by$managed$rules$Status$200;
export interface Params$radar$get$attacks$layer7$summary$by$managed$rules {
    parameter: Parameter$radar$get$attacks$layer7$summary$by$managed$rules;
}
export type ResponseContentType$radar$get$attacks$layer7$summary$by$mitigation$product = keyof Response$radar$get$attacks$layer7$summary$by$mitigation$product$Status$200;
export interface Params$radar$get$attacks$layer7$summary$by$mitigation$product {
    parameter: Parameter$radar$get$attacks$layer7$summary$by$mitigation$product;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries = keyof Response$radar$get$attacks$layer7$timeseries$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries {
    parameter: Parameter$radar$get$attacks$layer7$timeseries;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries$group = keyof Response$radar$get$attacks$layer7$timeseries$group$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries$group {
    parameter: Parameter$radar$get$attacks$layer7$timeseries$group;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries$group$by$http$method = keyof Response$radar$get$attacks$layer7$timeseries$group$by$http$method$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries$group$by$http$method {
    parameter: Parameter$radar$get$attacks$layer7$timeseries$group$by$http$method;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries$group$by$http$version = keyof Response$radar$get$attacks$layer7$timeseries$group$by$http$version$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries$group$by$http$version {
    parameter: Parameter$radar$get$attacks$layer7$timeseries$group$by$http$version;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries$group$by$industry = keyof Response$radar$get$attacks$layer7$timeseries$group$by$industry$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries$group$by$industry {
    parameter: Parameter$radar$get$attacks$layer7$timeseries$group$by$industry;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries$group$by$ip$version = keyof Response$radar$get$attacks$layer7$timeseries$group$by$ip$version$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries$group$by$ip$version {
    parameter: Parameter$radar$get$attacks$layer7$timeseries$group$by$ip$version;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries$group$by$managed$rules = keyof Response$radar$get$attacks$layer7$timeseries$group$by$managed$rules$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries$group$by$managed$rules {
    parameter: Parameter$radar$get$attacks$layer7$timeseries$group$by$managed$rules;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries$group$by$mitigation$product = keyof Response$radar$get$attacks$layer7$timeseries$group$by$mitigation$product$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries$group$by$mitigation$product {
    parameter: Parameter$radar$get$attacks$layer7$timeseries$group$by$mitigation$product;
}
export type ResponseContentType$radar$get$attacks$layer7$timeseries$group$by$vertical = keyof Response$radar$get$attacks$layer7$timeseries$group$by$vertical$Status$200;
export interface Params$radar$get$attacks$layer7$timeseries$group$by$vertical {
    parameter: Parameter$radar$get$attacks$layer7$timeseries$group$by$vertical;
}
export type ResponseContentType$radar$get$attacks$layer7$top$origin$as = keyof Response$radar$get$attacks$layer7$top$origin$as$Status$200;
export interface Params$radar$get$attacks$layer7$top$origin$as {
    parameter: Parameter$radar$get$attacks$layer7$top$origin$as;
}
export type ResponseContentType$radar$get$attacks$layer7$top$attacks = keyof Response$radar$get$attacks$layer7$top$attacks$Status$200;
export interface Params$radar$get$attacks$layer7$top$attacks {
    parameter: Parameter$radar$get$attacks$layer7$top$attacks;
}
export type ResponseContentType$radar$get$attacks$layer7$top$industries = keyof Response$radar$get$attacks$layer7$top$industries$Status$200;
export interface Params$radar$get$attacks$layer7$top$industries {
    parameter: Parameter$radar$get$attacks$layer7$top$industries;
}
export type ResponseContentType$radar$get$attacks$layer7$top$origin$location = keyof Response$radar$get$attacks$layer7$top$origin$location$Status$200;
export interface Params$radar$get$attacks$layer7$top$origin$location {
    parameter: Parameter$radar$get$attacks$layer7$top$origin$location;
}
export type ResponseContentType$radar$get$attacks$layer7$top$target$location = keyof Response$radar$get$attacks$layer7$top$target$location$Status$200;
export interface Params$radar$get$attacks$layer7$top$target$location {
    parameter: Parameter$radar$get$attacks$layer7$top$target$location;
}
export type ResponseContentType$radar$get$attacks$layer7$top$verticals = keyof Response$radar$get$attacks$layer7$top$verticals$Status$200;
export interface Params$radar$get$attacks$layer7$top$verticals {
    parameter: Parameter$radar$get$attacks$layer7$top$verticals;
}
export type ResponseContentType$radar$get$bgp$hijacks$events = keyof Response$radar$get$bgp$hijacks$events$Status$200;
export interface Params$radar$get$bgp$hijacks$events {
    parameter: Parameter$radar$get$bgp$hijacks$events;
}
export type ResponseContentType$radar$get$bgp$route$leak$events = keyof Response$radar$get$bgp$route$leak$events$Status$200;
export interface Params$radar$get$bgp$route$leak$events {
    parameter: Parameter$radar$get$bgp$route$leak$events;
}
export type ResponseContentType$radar$get$bgp$pfx2as$moas = keyof Response$radar$get$bgp$pfx2as$moas$Status$200;
export interface Params$radar$get$bgp$pfx2as$moas {
    parameter: Parameter$radar$get$bgp$pfx2as$moas;
}
export type ResponseContentType$radar$get$bgp$pfx2as = keyof Response$radar$get$bgp$pfx2as$Status$200;
export interface Params$radar$get$bgp$pfx2as {
    parameter: Parameter$radar$get$bgp$pfx2as;
}
export type ResponseContentType$radar$get$bgp$routes$stats = keyof Response$radar$get$bgp$routes$stats$Status$200;
export interface Params$radar$get$bgp$routes$stats {
    parameter: Parameter$radar$get$bgp$routes$stats;
}
export type ResponseContentType$radar$get$bgp$timeseries = keyof Response$radar$get$bgp$timeseries$Status$200;
export interface Params$radar$get$bgp$timeseries {
    parameter: Parameter$radar$get$bgp$timeseries;
}
export type ResponseContentType$radar$get$bgp$top$ases = keyof Response$radar$get$bgp$top$ases$Status$200;
export interface Params$radar$get$bgp$top$ases {
    parameter: Parameter$radar$get$bgp$top$ases;
}
export type ResponseContentType$radar$get$bgp$top$asns$by$prefixes = keyof Response$radar$get$bgp$top$asns$by$prefixes$Status$200;
export interface Params$radar$get$bgp$top$asns$by$prefixes {
    parameter: Parameter$radar$get$bgp$top$asns$by$prefixes;
}
export type ResponseContentType$radar$get$bgp$top$prefixes = keyof Response$radar$get$bgp$top$prefixes$Status$200;
export interface Params$radar$get$bgp$top$prefixes {
    parameter: Parameter$radar$get$bgp$top$prefixes;
}
export type ResponseContentType$radar$get$connection$tampering$summary = keyof Response$radar$get$connection$tampering$summary$Status$200;
export interface Params$radar$get$connection$tampering$summary {
    parameter: Parameter$radar$get$connection$tampering$summary;
}
export type ResponseContentType$radar$get$connection$tampering$timeseries$group = keyof Response$radar$get$connection$tampering$timeseries$group$Status$200;
export interface Params$radar$get$connection$tampering$timeseries$group {
    parameter: Parameter$radar$get$connection$tampering$timeseries$group;
}
export type ResponseContentType$radar$get$reports$datasets = keyof Response$radar$get$reports$datasets$Status$200;
export interface Params$radar$get$reports$datasets {
    parameter: Parameter$radar$get$reports$datasets;
}
export type ResponseContentType$radar$get$reports$dataset$download = keyof Response$radar$get$reports$dataset$download$Status$200;
export interface Params$radar$get$reports$dataset$download {
    parameter: Parameter$radar$get$reports$dataset$download;
}
export type RequestContentType$radar$post$reports$dataset$download$url = keyof RequestBody$radar$post$reports$dataset$download$url;
export type ResponseContentType$radar$post$reports$dataset$download$url = keyof Response$radar$post$reports$dataset$download$url$Status$200;
export interface Params$radar$post$reports$dataset$download$url {
    parameter: Parameter$radar$post$reports$dataset$download$url;
    requestBody: RequestBody$radar$post$reports$dataset$download$url["application/json"];
}
export type ResponseContentType$radar$get$dns$top$ases = keyof Response$radar$get$dns$top$ases$Status$200;
export interface Params$radar$get$dns$top$ases {
    parameter: Parameter$radar$get$dns$top$ases;
}
export type ResponseContentType$radar$get$dns$top$locations = keyof Response$radar$get$dns$top$locations$Status$200;
export interface Params$radar$get$dns$top$locations {
    parameter: Parameter$radar$get$dns$top$locations;
}
export type ResponseContentType$radar$get$email$security$summary$by$arc = keyof Response$radar$get$email$security$summary$by$arc$Status$200;
export interface Params$radar$get$email$security$summary$by$arc {
    parameter: Parameter$radar$get$email$security$summary$by$arc;
}
export type ResponseContentType$radar$get$email$security$summary$by$dkim = keyof Response$radar$get$email$security$summary$by$dkim$Status$200;
export interface Params$radar$get$email$security$summary$by$dkim {
    parameter: Parameter$radar$get$email$security$summary$by$dkim;
}
export type ResponseContentType$radar$get$email$security$summary$by$dmarc = keyof Response$radar$get$email$security$summary$by$dmarc$Status$200;
export interface Params$radar$get$email$security$summary$by$dmarc {
    parameter: Parameter$radar$get$email$security$summary$by$dmarc;
}
export type ResponseContentType$radar$get$email$security$summary$by$malicious = keyof Response$radar$get$email$security$summary$by$malicious$Status$200;
export interface Params$radar$get$email$security$summary$by$malicious {
    parameter: Parameter$radar$get$email$security$summary$by$malicious;
}
export type ResponseContentType$radar$get$email$security$summary$by$spam = keyof Response$radar$get$email$security$summary$by$spam$Status$200;
export interface Params$radar$get$email$security$summary$by$spam {
    parameter: Parameter$radar$get$email$security$summary$by$spam;
}
export type ResponseContentType$radar$get$email$security$summary$by$spf = keyof Response$radar$get$email$security$summary$by$spf$Status$200;
export interface Params$radar$get$email$security$summary$by$spf {
    parameter: Parameter$radar$get$email$security$summary$by$spf;
}
export type ResponseContentType$radar$get$email$security$summary$by$threat$category = keyof Response$radar$get$email$security$summary$by$threat$category$Status$200;
export interface Params$radar$get$email$security$summary$by$threat$category {
    parameter: Parameter$radar$get$email$security$summary$by$threat$category;
}
export type ResponseContentType$radar$get$email$security$timeseries$group$by$arc = keyof Response$radar$get$email$security$timeseries$group$by$arc$Status$200;
export interface Params$radar$get$email$security$timeseries$group$by$arc {
    parameter: Parameter$radar$get$email$security$timeseries$group$by$arc;
}
export type ResponseContentType$radar$get$email$security$timeseries$group$by$dkim = keyof Response$radar$get$email$security$timeseries$group$by$dkim$Status$200;
export interface Params$radar$get$email$security$timeseries$group$by$dkim {
    parameter: Parameter$radar$get$email$security$timeseries$group$by$dkim;
}
export type ResponseContentType$radar$get$email$security$timeseries$group$by$dmarc = keyof Response$radar$get$email$security$timeseries$group$by$dmarc$Status$200;
export interface Params$radar$get$email$security$timeseries$group$by$dmarc {
    parameter: Parameter$radar$get$email$security$timeseries$group$by$dmarc;
}
export type ResponseContentType$radar$get$email$security$timeseries$group$by$malicious = keyof Response$radar$get$email$security$timeseries$group$by$malicious$Status$200;
export interface Params$radar$get$email$security$timeseries$group$by$malicious {
    parameter: Parameter$radar$get$email$security$timeseries$group$by$malicious;
}
export type ResponseContentType$radar$get$email$security$timeseries$group$by$spam = keyof Response$radar$get$email$security$timeseries$group$by$spam$Status$200;
export interface Params$radar$get$email$security$timeseries$group$by$spam {
    parameter: Parameter$radar$get$email$security$timeseries$group$by$spam;
}
export type ResponseContentType$radar$get$email$security$timeseries$group$by$spf = keyof Response$radar$get$email$security$timeseries$group$by$spf$Status$200;
export interface Params$radar$get$email$security$timeseries$group$by$spf {
    parameter: Parameter$radar$get$email$security$timeseries$group$by$spf;
}
export type ResponseContentType$radar$get$email$security$timeseries$group$by$threat$category = keyof Response$radar$get$email$security$timeseries$group$by$threat$category$Status$200;
export interface Params$radar$get$email$security$timeseries$group$by$threat$category {
    parameter: Parameter$radar$get$email$security$timeseries$group$by$threat$category;
}
export type ResponseContentType$radar$get$email$security$top$ases$by$messages = keyof Response$radar$get$email$security$top$ases$by$messages$Status$200;
export interface Params$radar$get$email$security$top$ases$by$messages {
    parameter: Parameter$radar$get$email$security$top$ases$by$messages;
}
export type ResponseContentType$radar$get$email$security$top$ases$by$arc = keyof Response$radar$get$email$security$top$ases$by$arc$Status$200;
export interface Params$radar$get$email$security$top$ases$by$arc {
    parameter: Parameter$radar$get$email$security$top$ases$by$arc;
}
export type ResponseContentType$radar$get$email$security$top$ases$by$dkim = keyof Response$radar$get$email$security$top$ases$by$dkim$Status$200;
export interface Params$radar$get$email$security$top$ases$by$dkim {
    parameter: Parameter$radar$get$email$security$top$ases$by$dkim;
}
export type ResponseContentType$radar$get$email$security$top$ases$by$dmarc = keyof Response$radar$get$email$security$top$ases$by$dmarc$Status$200;
export interface Params$radar$get$email$security$top$ases$by$dmarc {
    parameter: Parameter$radar$get$email$security$top$ases$by$dmarc;
}
export type ResponseContentType$radar$get$email$security$top$ases$by$malicious = keyof Response$radar$get$email$security$top$ases$by$malicious$Status$200;
export interface Params$radar$get$email$security$top$ases$by$malicious {
    parameter: Parameter$radar$get$email$security$top$ases$by$malicious;
}
export type ResponseContentType$radar$get$email$security$top$ases$by$spam = keyof Response$radar$get$email$security$top$ases$by$spam$Status$200;
export interface Params$radar$get$email$security$top$ases$by$spam {
    parameter: Parameter$radar$get$email$security$top$ases$by$spam;
}
export type ResponseContentType$radar$get$email$security$top$ases$by$spf = keyof Response$radar$get$email$security$top$ases$by$spf$Status$200;
export interface Params$radar$get$email$security$top$ases$by$spf {
    parameter: Parameter$radar$get$email$security$top$ases$by$spf;
}
export type ResponseContentType$radar$get$email$security$top$locations$by$messages = keyof Response$radar$get$email$security$top$locations$by$messages$Status$200;
export interface Params$radar$get$email$security$top$locations$by$messages {
    parameter: Parameter$radar$get$email$security$top$locations$by$messages;
}
export type ResponseContentType$radar$get$email$security$top$locations$by$arc = keyof Response$radar$get$email$security$top$locations$by$arc$Status$200;
export interface Params$radar$get$email$security$top$locations$by$arc {
    parameter: Parameter$radar$get$email$security$top$locations$by$arc;
}
export type ResponseContentType$radar$get$email$security$top$locations$by$dkim = keyof Response$radar$get$email$security$top$locations$by$dkim$Status$200;
export interface Params$radar$get$email$security$top$locations$by$dkim {
    parameter: Parameter$radar$get$email$security$top$locations$by$dkim;
}
export type ResponseContentType$radar$get$email$security$top$locations$by$dmarc = keyof Response$radar$get$email$security$top$locations$by$dmarc$Status$200;
export interface Params$radar$get$email$security$top$locations$by$dmarc {
    parameter: Parameter$radar$get$email$security$top$locations$by$dmarc;
}
export type ResponseContentType$radar$get$email$security$top$locations$by$malicious = keyof Response$radar$get$email$security$top$locations$by$malicious$Status$200;
export interface Params$radar$get$email$security$top$locations$by$malicious {
    parameter: Parameter$radar$get$email$security$top$locations$by$malicious;
}
export type ResponseContentType$radar$get$email$security$top$locations$by$spam = keyof Response$radar$get$email$security$top$locations$by$spam$Status$200;
export interface Params$radar$get$email$security$top$locations$by$spam {
    parameter: Parameter$radar$get$email$security$top$locations$by$spam;
}
export type ResponseContentType$radar$get$email$security$top$locations$by$spf = keyof Response$radar$get$email$security$top$locations$by$spf$Status$200;
export interface Params$radar$get$email$security$top$locations$by$spf {
    parameter: Parameter$radar$get$email$security$top$locations$by$spf;
}
export type ResponseContentType$radar$get$entities$asn$list = keyof Response$radar$get$entities$asn$list$Status$200;
export interface Params$radar$get$entities$asn$list {
    parameter: Parameter$radar$get$entities$asn$list;
}
export type ResponseContentType$radar$get$entities$asn$by$id = keyof Response$radar$get$entities$asn$by$id$Status$200;
export interface Params$radar$get$entities$asn$by$id {
    parameter: Parameter$radar$get$entities$asn$by$id;
}
export type ResponseContentType$radar$get$asns$rel = keyof Response$radar$get$asns$rel$Status$200;
export interface Params$radar$get$asns$rel {
    parameter: Parameter$radar$get$asns$rel;
}
export type ResponseContentType$radar$get$entities$asn$by$ip = keyof Response$radar$get$entities$asn$by$ip$Status$200;
export interface Params$radar$get$entities$asn$by$ip {
    parameter: Parameter$radar$get$entities$asn$by$ip;
}
export type ResponseContentType$radar$get$entities$ip = keyof Response$radar$get$entities$ip$Status$200;
export interface Params$radar$get$entities$ip {
    parameter: Parameter$radar$get$entities$ip;
}
export type ResponseContentType$radar$get$entities$locations = keyof Response$radar$get$entities$locations$Status$200;
export interface Params$radar$get$entities$locations {
    parameter: Parameter$radar$get$entities$locations;
}
export type ResponseContentType$radar$get$entities$location$by$alpha2 = keyof Response$radar$get$entities$location$by$alpha2$Status$200;
export interface Params$radar$get$entities$location$by$alpha2 {
    parameter: Parameter$radar$get$entities$location$by$alpha2;
}
export type ResponseContentType$radar$get$http$summary$by$bot$class = keyof Response$radar$get$http$summary$by$bot$class$Status$200;
export interface Params$radar$get$http$summary$by$bot$class {
    parameter: Parameter$radar$get$http$summary$by$bot$class;
}
export type ResponseContentType$radar$get$http$summary$by$device$type = keyof Response$radar$get$http$summary$by$device$type$Status$200;
export interface Params$radar$get$http$summary$by$device$type {
    parameter: Parameter$radar$get$http$summary$by$device$type;
}
export type ResponseContentType$radar$get$http$summary$by$http$protocol = keyof Response$radar$get$http$summary$by$http$protocol$Status$200;
export interface Params$radar$get$http$summary$by$http$protocol {
    parameter: Parameter$radar$get$http$summary$by$http$protocol;
}
export type ResponseContentType$radar$get$http$summary$by$http$version = keyof Response$radar$get$http$summary$by$http$version$Status$200;
export interface Params$radar$get$http$summary$by$http$version {
    parameter: Parameter$radar$get$http$summary$by$http$version;
}
export type ResponseContentType$radar$get$http$summary$by$ip$version = keyof Response$radar$get$http$summary$by$ip$version$Status$200;
export interface Params$radar$get$http$summary$by$ip$version {
    parameter: Parameter$radar$get$http$summary$by$ip$version;
}
export type ResponseContentType$radar$get$http$summary$by$operating$system = keyof Response$radar$get$http$summary$by$operating$system$Status$200;
export interface Params$radar$get$http$summary$by$operating$system {
    parameter: Parameter$radar$get$http$summary$by$operating$system;
}
export type ResponseContentType$radar$get$http$summary$by$tls$version = keyof Response$radar$get$http$summary$by$tls$version$Status$200;
export interface Params$radar$get$http$summary$by$tls$version {
    parameter: Parameter$radar$get$http$summary$by$tls$version;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$bot$class = keyof Response$radar$get$http$timeseries$group$by$bot$class$Status$200;
export interface Params$radar$get$http$timeseries$group$by$bot$class {
    parameter: Parameter$radar$get$http$timeseries$group$by$bot$class;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$browsers = keyof Response$radar$get$http$timeseries$group$by$browsers$Status$200;
export interface Params$radar$get$http$timeseries$group$by$browsers {
    parameter: Parameter$radar$get$http$timeseries$group$by$browsers;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$browser$families = keyof Response$radar$get$http$timeseries$group$by$browser$families$Status$200;
export interface Params$radar$get$http$timeseries$group$by$browser$families {
    parameter: Parameter$radar$get$http$timeseries$group$by$browser$families;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$device$type = keyof Response$radar$get$http$timeseries$group$by$device$type$Status$200;
export interface Params$radar$get$http$timeseries$group$by$device$type {
    parameter: Parameter$radar$get$http$timeseries$group$by$device$type;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$http$protocol = keyof Response$radar$get$http$timeseries$group$by$http$protocol$Status$200;
export interface Params$radar$get$http$timeseries$group$by$http$protocol {
    parameter: Parameter$radar$get$http$timeseries$group$by$http$protocol;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$http$version = keyof Response$radar$get$http$timeseries$group$by$http$version$Status$200;
export interface Params$radar$get$http$timeseries$group$by$http$version {
    parameter: Parameter$radar$get$http$timeseries$group$by$http$version;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$ip$version = keyof Response$radar$get$http$timeseries$group$by$ip$version$Status$200;
export interface Params$radar$get$http$timeseries$group$by$ip$version {
    parameter: Parameter$radar$get$http$timeseries$group$by$ip$version;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$operating$system = keyof Response$radar$get$http$timeseries$group$by$operating$system$Status$200;
export interface Params$radar$get$http$timeseries$group$by$operating$system {
    parameter: Parameter$radar$get$http$timeseries$group$by$operating$system;
}
export type ResponseContentType$radar$get$http$timeseries$group$by$tls$version = keyof Response$radar$get$http$timeseries$group$by$tls$version$Status$200;
export interface Params$radar$get$http$timeseries$group$by$tls$version {
    parameter: Parameter$radar$get$http$timeseries$group$by$tls$version;
}
export type ResponseContentType$radar$get$http$top$ases$by$http$requests = keyof Response$radar$get$http$top$ases$by$http$requests$Status$200;
export interface Params$radar$get$http$top$ases$by$http$requests {
    parameter: Parameter$radar$get$http$top$ases$by$http$requests;
}
export type ResponseContentType$radar$get$http$top$ases$by$bot$class = keyof Response$radar$get$http$top$ases$by$bot$class$Status$200;
export interface Params$radar$get$http$top$ases$by$bot$class {
    parameter: Parameter$radar$get$http$top$ases$by$bot$class;
}
export type ResponseContentType$radar$get$http$top$ases$by$device$type = keyof Response$radar$get$http$top$ases$by$device$type$Status$200;
export interface Params$radar$get$http$top$ases$by$device$type {
    parameter: Parameter$radar$get$http$top$ases$by$device$type;
}
export type ResponseContentType$radar$get$http$top$ases$by$http$protocol = keyof Response$radar$get$http$top$ases$by$http$protocol$Status$200;
export interface Params$radar$get$http$top$ases$by$http$protocol {
    parameter: Parameter$radar$get$http$top$ases$by$http$protocol;
}
export type ResponseContentType$radar$get$http$top$ases$by$http$version = keyof Response$radar$get$http$top$ases$by$http$version$Status$200;
export interface Params$radar$get$http$top$ases$by$http$version {
    parameter: Parameter$radar$get$http$top$ases$by$http$version;
}
export type ResponseContentType$radar$get$http$top$ases$by$ip$version = keyof Response$radar$get$http$top$ases$by$ip$version$Status$200;
export interface Params$radar$get$http$top$ases$by$ip$version {
    parameter: Parameter$radar$get$http$top$ases$by$ip$version;
}
export type ResponseContentType$radar$get$http$top$ases$by$operating$system = keyof Response$radar$get$http$top$ases$by$operating$system$Status$200;
export interface Params$radar$get$http$top$ases$by$operating$system {
    parameter: Parameter$radar$get$http$top$ases$by$operating$system;
}
export type ResponseContentType$radar$get$http$top$ases$by$tls$version = keyof Response$radar$get$http$top$ases$by$tls$version$Status$200;
export interface Params$radar$get$http$top$ases$by$tls$version {
    parameter: Parameter$radar$get$http$top$ases$by$tls$version;
}
export type ResponseContentType$radar$get$http$top$browser$families = keyof Response$radar$get$http$top$browser$families$Status$200;
export interface Params$radar$get$http$top$browser$families {
    parameter: Parameter$radar$get$http$top$browser$families;
}
export type ResponseContentType$radar$get$http$top$browsers = keyof Response$radar$get$http$top$browsers$Status$200;
export interface Params$radar$get$http$top$browsers {
    parameter: Parameter$radar$get$http$top$browsers;
}
export type ResponseContentType$radar$get$http$top$locations$by$http$requests = keyof Response$radar$get$http$top$locations$by$http$requests$Status$200;
export interface Params$radar$get$http$top$locations$by$http$requests {
    parameter: Parameter$radar$get$http$top$locations$by$http$requests;
}
export type ResponseContentType$radar$get$http$top$locations$by$bot$class = keyof Response$radar$get$http$top$locations$by$bot$class$Status$200;
export interface Params$radar$get$http$top$locations$by$bot$class {
    parameter: Parameter$radar$get$http$top$locations$by$bot$class;
}
export type ResponseContentType$radar$get$http$top$locations$by$device$type = keyof Response$radar$get$http$top$locations$by$device$type$Status$200;
export interface Params$radar$get$http$top$locations$by$device$type {
    parameter: Parameter$radar$get$http$top$locations$by$device$type;
}
export type ResponseContentType$radar$get$http$top$locations$by$http$protocol = keyof Response$radar$get$http$top$locations$by$http$protocol$Status$200;
export interface Params$radar$get$http$top$locations$by$http$protocol {
    parameter: Parameter$radar$get$http$top$locations$by$http$protocol;
}
export type ResponseContentType$radar$get$http$top$locations$by$http$version = keyof Response$radar$get$http$top$locations$by$http$version$Status$200;
export interface Params$radar$get$http$top$locations$by$http$version {
    parameter: Parameter$radar$get$http$top$locations$by$http$version;
}
export type ResponseContentType$radar$get$http$top$locations$by$ip$version = keyof Response$radar$get$http$top$locations$by$ip$version$Status$200;
export interface Params$radar$get$http$top$locations$by$ip$version {
    parameter: Parameter$radar$get$http$top$locations$by$ip$version;
}
export type ResponseContentType$radar$get$http$top$locations$by$operating$system = keyof Response$radar$get$http$top$locations$by$operating$system$Status$200;
export interface Params$radar$get$http$top$locations$by$operating$system {
    parameter: Parameter$radar$get$http$top$locations$by$operating$system;
}
export type ResponseContentType$radar$get$http$top$locations$by$tls$version = keyof Response$radar$get$http$top$locations$by$tls$version$Status$200;
export interface Params$radar$get$http$top$locations$by$tls$version {
    parameter: Parameter$radar$get$http$top$locations$by$tls$version;
}
export type ResponseContentType$radar$get$netflows$timeseries = keyof Response$radar$get$netflows$timeseries$Status$200;
export interface Params$radar$get$netflows$timeseries {
    parameter: Parameter$radar$get$netflows$timeseries;
}
export type ResponseContentType$radar$get$netflows$top$ases = keyof Response$radar$get$netflows$top$ases$Status$200;
export interface Params$radar$get$netflows$top$ases {
    parameter: Parameter$radar$get$netflows$top$ases;
}
export type ResponseContentType$radar$get$netflows$top$locations = keyof Response$radar$get$netflows$top$locations$Status$200;
export interface Params$radar$get$netflows$top$locations {
    parameter: Parameter$radar$get$netflows$top$locations;
}
export type ResponseContentType$radar$get$quality$index$summary = keyof Response$radar$get$quality$index$summary$Status$200;
export interface Params$radar$get$quality$index$summary {
    parameter: Parameter$radar$get$quality$index$summary;
}
export type ResponseContentType$radar$get$quality$index$timeseries$group = keyof Response$radar$get$quality$index$timeseries$group$Status$200;
export interface Params$radar$get$quality$index$timeseries$group {
    parameter: Parameter$radar$get$quality$index$timeseries$group;
}
export type ResponseContentType$radar$get$quality$speed$histogram = keyof Response$radar$get$quality$speed$histogram$Status$200;
export interface Params$radar$get$quality$speed$histogram {
    parameter: Parameter$radar$get$quality$speed$histogram;
}
export type ResponseContentType$radar$get$quality$speed$summary = keyof Response$radar$get$quality$speed$summary$Status$200;
export interface Params$radar$get$quality$speed$summary {
    parameter: Parameter$radar$get$quality$speed$summary;
}
export type ResponseContentType$radar$get$quality$speed$top$ases = keyof Response$radar$get$quality$speed$top$ases$Status$200;
export interface Params$radar$get$quality$speed$top$ases {
    parameter: Parameter$radar$get$quality$speed$top$ases;
}
export type ResponseContentType$radar$get$quality$speed$top$locations = keyof Response$radar$get$quality$speed$top$locations$Status$200;
export interface Params$radar$get$quality$speed$top$locations {
    parameter: Parameter$radar$get$quality$speed$top$locations;
}
export type ResponseContentType$radar$get$ranking$domain$details = keyof Response$radar$get$ranking$domain$details$Status$200;
export interface Params$radar$get$ranking$domain$details {
    parameter: Parameter$radar$get$ranking$domain$details;
}
export type ResponseContentType$radar$get$ranking$domain$timeseries = keyof Response$radar$get$ranking$domain$timeseries$Status$200;
export interface Params$radar$get$ranking$domain$timeseries {
    parameter: Parameter$radar$get$ranking$domain$timeseries;
}
export type ResponseContentType$radar$get$ranking$top$domains = keyof Response$radar$get$ranking$top$domains$Status$200;
export interface Params$radar$get$ranking$top$domains {
    parameter: Parameter$radar$get$ranking$top$domains;
}
export type ResponseContentType$radar$get$search$global = keyof Response$radar$get$search$global$Status$200;
export interface Params$radar$get$search$global {
    parameter: Parameter$radar$get$search$global;
}
export type ResponseContentType$radar$get$traffic$anomalies = keyof Response$radar$get$traffic$anomalies$Status$200;
export interface Params$radar$get$traffic$anomalies {
    parameter: Parameter$radar$get$traffic$anomalies;
}
export type ResponseContentType$radar$get$traffic$anomalies$top = keyof Response$radar$get$traffic$anomalies$top$Status$200;
export interface Params$radar$get$traffic$anomalies$top {
    parameter: Parameter$radar$get$traffic$anomalies$top;
}
export type ResponseContentType$radar$get$verified$bots$top$by$http$requests = keyof Response$radar$get$verified$bots$top$by$http$requests$Status$200;
export interface Params$radar$get$verified$bots$top$by$http$requests {
    parameter: Parameter$radar$get$verified$bots$top$by$http$requests;
}
export type ResponseContentType$radar$get$verified$bots$top$categories$by$http$requests = keyof Response$radar$get$verified$bots$top$categories$by$http$requests$Status$200;
export interface Params$radar$get$verified$bots$top$categories$by$http$requests {
    parameter: Parameter$radar$get$verified$bots$top$categories$by$http$requests;
}
export type ResponseContentType$user$user$details = keyof Response$user$user$details$Status$200;
export type RequestContentType$user$edit$user = keyof RequestBody$user$edit$user;
export type ResponseContentType$user$edit$user = keyof Response$user$edit$user$Status$200;
export interface Params$user$edit$user {
    requestBody: RequestBody$user$edit$user["application/json"];
}
export type ResponseContentType$audit$logs$get$user$audit$logs = keyof Response$audit$logs$get$user$audit$logs$Status$200;
export interface Params$audit$logs$get$user$audit$logs {
    parameter: Parameter$audit$logs$get$user$audit$logs;
}
export type ResponseContentType$user$billing$history$$$deprecated$$billing$history$details = keyof Response$user$billing$history$$$deprecated$$billing$history$details$Status$200;
export interface Params$user$billing$history$$$deprecated$$billing$history$details {
    parameter: Parameter$user$billing$history$$$deprecated$$billing$history$details;
}
export type ResponseContentType$user$billing$profile$$$deprecated$$billing$profile$details = keyof Response$user$billing$profile$$$deprecated$$billing$profile$details$Status$200;
export type ResponseContentType$ip$access$rules$for$a$user$list$ip$access$rules = keyof Response$ip$access$rules$for$a$user$list$ip$access$rules$Status$200;
export interface Params$ip$access$rules$for$a$user$list$ip$access$rules {
    parameter: Parameter$ip$access$rules$for$a$user$list$ip$access$rules;
}
export type RequestContentType$ip$access$rules$for$a$user$create$an$ip$access$rule = keyof RequestBody$ip$access$rules$for$a$user$create$an$ip$access$rule;
export type ResponseContentType$ip$access$rules$for$a$user$create$an$ip$access$rule = keyof Response$ip$access$rules$for$a$user$create$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$a$user$create$an$ip$access$rule {
    requestBody: RequestBody$ip$access$rules$for$a$user$create$an$ip$access$rule["application/json"];
}
export type ResponseContentType$ip$access$rules$for$a$user$delete$an$ip$access$rule = keyof Response$ip$access$rules$for$a$user$delete$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$a$user$delete$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$a$user$delete$an$ip$access$rule;
}
export type RequestContentType$ip$access$rules$for$a$user$update$an$ip$access$rule = keyof RequestBody$ip$access$rules$for$a$user$update$an$ip$access$rule;
export type ResponseContentType$ip$access$rules$for$a$user$update$an$ip$access$rule = keyof Response$ip$access$rules$for$a$user$update$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$a$user$update$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$a$user$update$an$ip$access$rule;
    requestBody: RequestBody$ip$access$rules$for$a$user$update$an$ip$access$rule["application/json"];
}
export type ResponseContentType$user$$s$invites$list$invitations = keyof Response$user$$s$invites$list$invitations$Status$200;
export type ResponseContentType$user$$s$invites$invitation$details = keyof Response$user$$s$invites$invitation$details$Status$200;
export interface Params$user$$s$invites$invitation$details {
    parameter: Parameter$user$$s$invites$invitation$details;
}
export type RequestContentType$user$$s$invites$respond$to$invitation = keyof RequestBody$user$$s$invites$respond$to$invitation;
export type ResponseContentType$user$$s$invites$respond$to$invitation = keyof Response$user$$s$invites$respond$to$invitation$Status$200;
export interface Params$user$$s$invites$respond$to$invitation {
    parameter: Parameter$user$$s$invites$respond$to$invitation;
    requestBody: RequestBody$user$$s$invites$respond$to$invitation["application/json"];
}
export type ResponseContentType$load$balancer$monitors$list$monitors = keyof Response$load$balancer$monitors$list$monitors$Status$200;
export type RequestContentType$load$balancer$monitors$create$monitor = keyof RequestBody$load$balancer$monitors$create$monitor;
export type ResponseContentType$load$balancer$monitors$create$monitor = keyof Response$load$balancer$monitors$create$monitor$Status$200;
export interface Params$load$balancer$monitors$create$monitor {
    requestBody: RequestBody$load$balancer$monitors$create$monitor["application/json"];
}
export type ResponseContentType$load$balancer$monitors$monitor$details = keyof Response$load$balancer$monitors$monitor$details$Status$200;
export interface Params$load$balancer$monitors$monitor$details {
    parameter: Parameter$load$balancer$monitors$monitor$details;
}
export type RequestContentType$load$balancer$monitors$update$monitor = keyof RequestBody$load$balancer$monitors$update$monitor;
export type ResponseContentType$load$balancer$monitors$update$monitor = keyof Response$load$balancer$monitors$update$monitor$Status$200;
export interface Params$load$balancer$monitors$update$monitor {
    parameter: Parameter$load$balancer$monitors$update$monitor;
    requestBody: RequestBody$load$balancer$monitors$update$monitor["application/json"];
}
export type ResponseContentType$load$balancer$monitors$delete$monitor = keyof Response$load$balancer$monitors$delete$monitor$Status$200;
export interface Params$load$balancer$monitors$delete$monitor {
    parameter: Parameter$load$balancer$monitors$delete$monitor;
}
export type RequestContentType$load$balancer$monitors$patch$monitor = keyof RequestBody$load$balancer$monitors$patch$monitor;
export type ResponseContentType$load$balancer$monitors$patch$monitor = keyof Response$load$balancer$monitors$patch$monitor$Status$200;
export interface Params$load$balancer$monitors$patch$monitor {
    parameter: Parameter$load$balancer$monitors$patch$monitor;
    requestBody: RequestBody$load$balancer$monitors$patch$monitor["application/json"];
}
export type RequestContentType$load$balancer$monitors$preview$monitor = keyof RequestBody$load$balancer$monitors$preview$monitor;
export type ResponseContentType$load$balancer$monitors$preview$monitor = keyof Response$load$balancer$monitors$preview$monitor$Status$200;
export interface Params$load$balancer$monitors$preview$monitor {
    parameter: Parameter$load$balancer$monitors$preview$monitor;
    requestBody: RequestBody$load$balancer$monitors$preview$monitor["application/json"];
}
export type ResponseContentType$load$balancer$monitors$list$monitor$references = keyof Response$load$balancer$monitors$list$monitor$references$Status$200;
export interface Params$load$balancer$monitors$list$monitor$references {
    parameter: Parameter$load$balancer$monitors$list$monitor$references;
}
export type ResponseContentType$load$balancer$pools$list$pools = keyof Response$load$balancer$pools$list$pools$Status$200;
export interface Params$load$balancer$pools$list$pools {
    parameter: Parameter$load$balancer$pools$list$pools;
}
export type RequestContentType$load$balancer$pools$create$pool = keyof RequestBody$load$balancer$pools$create$pool;
export type ResponseContentType$load$balancer$pools$create$pool = keyof Response$load$balancer$pools$create$pool$Status$200;
export interface Params$load$balancer$pools$create$pool {
    requestBody: RequestBody$load$balancer$pools$create$pool["application/json"];
}
export type RequestContentType$load$balancer$pools$patch$pools = keyof RequestBody$load$balancer$pools$patch$pools;
export type ResponseContentType$load$balancer$pools$patch$pools = keyof Response$load$balancer$pools$patch$pools$Status$200;
export interface Params$load$balancer$pools$patch$pools {
    requestBody: RequestBody$load$balancer$pools$patch$pools["application/json"];
}
export type ResponseContentType$load$balancer$pools$pool$details = keyof Response$load$balancer$pools$pool$details$Status$200;
export interface Params$load$balancer$pools$pool$details {
    parameter: Parameter$load$balancer$pools$pool$details;
}
export type RequestContentType$load$balancer$pools$update$pool = keyof RequestBody$load$balancer$pools$update$pool;
export type ResponseContentType$load$balancer$pools$update$pool = keyof Response$load$balancer$pools$update$pool$Status$200;
export interface Params$load$balancer$pools$update$pool {
    parameter: Parameter$load$balancer$pools$update$pool;
    requestBody: RequestBody$load$balancer$pools$update$pool["application/json"];
}
export type ResponseContentType$load$balancer$pools$delete$pool = keyof Response$load$balancer$pools$delete$pool$Status$200;
export interface Params$load$balancer$pools$delete$pool {
    parameter: Parameter$load$balancer$pools$delete$pool;
}
export type RequestContentType$load$balancer$pools$patch$pool = keyof RequestBody$load$balancer$pools$patch$pool;
export type ResponseContentType$load$balancer$pools$patch$pool = keyof Response$load$balancer$pools$patch$pool$Status$200;
export interface Params$load$balancer$pools$patch$pool {
    parameter: Parameter$load$balancer$pools$patch$pool;
    requestBody: RequestBody$load$balancer$pools$patch$pool["application/json"];
}
export type ResponseContentType$load$balancer$pools$pool$health$details = keyof Response$load$balancer$pools$pool$health$details$Status$200;
export interface Params$load$balancer$pools$pool$health$details {
    parameter: Parameter$load$balancer$pools$pool$health$details;
}
export type RequestContentType$load$balancer$pools$preview$pool = keyof RequestBody$load$balancer$pools$preview$pool;
export type ResponseContentType$load$balancer$pools$preview$pool = keyof Response$load$balancer$pools$preview$pool$Status$200;
export interface Params$load$balancer$pools$preview$pool {
    parameter: Parameter$load$balancer$pools$preview$pool;
    requestBody: RequestBody$load$balancer$pools$preview$pool["application/json"];
}
export type ResponseContentType$load$balancer$pools$list$pool$references = keyof Response$load$balancer$pools$list$pool$references$Status$200;
export interface Params$load$balancer$pools$list$pool$references {
    parameter: Parameter$load$balancer$pools$list$pool$references;
}
export type ResponseContentType$load$balancer$monitors$preview$result = keyof Response$load$balancer$monitors$preview$result$Status$200;
export interface Params$load$balancer$monitors$preview$result {
    parameter: Parameter$load$balancer$monitors$preview$result;
}
export type ResponseContentType$load$balancer$healthcheck$events$list$healthcheck$events = keyof Response$load$balancer$healthcheck$events$list$healthcheck$events$Status$200;
export interface Params$load$balancer$healthcheck$events$list$healthcheck$events {
    parameter: Parameter$load$balancer$healthcheck$events$list$healthcheck$events;
}
export type ResponseContentType$user$$s$organizations$list$organizations = keyof Response$user$$s$organizations$list$organizations$Status$200;
export interface Params$user$$s$organizations$list$organizations {
    parameter: Parameter$user$$s$organizations$list$organizations;
}
export type ResponseContentType$user$$s$organizations$organization$details = keyof Response$user$$s$organizations$organization$details$Status$200;
export interface Params$user$$s$organizations$organization$details {
    parameter: Parameter$user$$s$organizations$organization$details;
}
export type ResponseContentType$user$$s$organizations$leave$organization = keyof Response$user$$s$organizations$leave$organization$Status$200;
export interface Params$user$$s$organizations$leave$organization {
    parameter: Parameter$user$$s$organizations$leave$organization;
}
export type ResponseContentType$user$subscription$get$user$subscriptions = keyof Response$user$subscription$get$user$subscriptions$Status$200;
export type RequestContentType$user$subscription$update$user$subscription = keyof RequestBody$user$subscription$update$user$subscription;
export type ResponseContentType$user$subscription$update$user$subscription = keyof Response$user$subscription$update$user$subscription$Status$200;
export interface Params$user$subscription$update$user$subscription {
    parameter: Parameter$user$subscription$update$user$subscription;
    requestBody: RequestBody$user$subscription$update$user$subscription["application/json"];
}
export type ResponseContentType$user$subscription$delete$user$subscription = keyof Response$user$subscription$delete$user$subscription$Status$200;
export interface Params$user$subscription$delete$user$subscription {
    parameter: Parameter$user$subscription$delete$user$subscription;
}
export type ResponseContentType$user$api$tokens$list$tokens = keyof Response$user$api$tokens$list$tokens$Status$200;
export interface Params$user$api$tokens$list$tokens {
    parameter: Parameter$user$api$tokens$list$tokens;
}
export type RequestContentType$user$api$tokens$create$token = keyof RequestBody$user$api$tokens$create$token;
export type ResponseContentType$user$api$tokens$create$token = keyof Response$user$api$tokens$create$token$Status$200;
export interface Params$user$api$tokens$create$token {
    requestBody: RequestBody$user$api$tokens$create$token["application/json"];
}
export type ResponseContentType$user$api$tokens$token$details = keyof Response$user$api$tokens$token$details$Status$200;
export interface Params$user$api$tokens$token$details {
    parameter: Parameter$user$api$tokens$token$details;
}
export type RequestContentType$user$api$tokens$update$token = keyof RequestBody$user$api$tokens$update$token;
export type ResponseContentType$user$api$tokens$update$token = keyof Response$user$api$tokens$update$token$Status$200;
export interface Params$user$api$tokens$update$token {
    parameter: Parameter$user$api$tokens$update$token;
    requestBody: RequestBody$user$api$tokens$update$token["application/json"];
}
export type ResponseContentType$user$api$tokens$delete$token = keyof Response$user$api$tokens$delete$token$Status$200;
export interface Params$user$api$tokens$delete$token {
    parameter: Parameter$user$api$tokens$delete$token;
}
export type RequestContentType$user$api$tokens$roll$token = keyof RequestBody$user$api$tokens$roll$token;
export type ResponseContentType$user$api$tokens$roll$token = keyof Response$user$api$tokens$roll$token$Status$200;
export interface Params$user$api$tokens$roll$token {
    parameter: Parameter$user$api$tokens$roll$token;
    requestBody: RequestBody$user$api$tokens$roll$token["application/json"];
}
export type ResponseContentType$permission$groups$list$permission$groups = keyof Response$permission$groups$list$permission$groups$Status$200;
export type ResponseContentType$user$api$tokens$verify$token = keyof Response$user$api$tokens$verify$token$Status$200;
export type ResponseContentType$zones$get = keyof Response$zones$get$Status$200;
export interface Params$zones$get {
    parameter: Parameter$zones$get;
}
export type RequestContentType$zones$post = keyof RequestBody$zones$post;
export type ResponseContentType$zones$post = keyof Response$zones$post$Status$200;
export interface Params$zones$post {
    requestBody: RequestBody$zones$post["application/json"];
}
export type ResponseContentType$zone$level$access$applications$list$access$applications = keyof Response$zone$level$access$applications$list$access$applications$Status$200;
export interface Params$zone$level$access$applications$list$access$applications {
    parameter: Parameter$zone$level$access$applications$list$access$applications;
}
export type RequestContentType$zone$level$access$applications$add$a$bookmark$application = keyof RequestBody$zone$level$access$applications$add$a$bookmark$application;
export type ResponseContentType$zone$level$access$applications$add$a$bookmark$application = keyof Response$zone$level$access$applications$add$a$bookmark$application$Status$201;
export interface Params$zone$level$access$applications$add$a$bookmark$application {
    parameter: Parameter$zone$level$access$applications$add$a$bookmark$application;
    requestBody: RequestBody$zone$level$access$applications$add$a$bookmark$application["application/json"];
}
export type ResponseContentType$zone$level$access$applications$get$an$access$application = keyof Response$zone$level$access$applications$get$an$access$application$Status$200;
export interface Params$zone$level$access$applications$get$an$access$application {
    parameter: Parameter$zone$level$access$applications$get$an$access$application;
}
export type RequestContentType$zone$level$access$applications$update$a$bookmark$application = keyof RequestBody$zone$level$access$applications$update$a$bookmark$application;
export type ResponseContentType$zone$level$access$applications$update$a$bookmark$application = keyof Response$zone$level$access$applications$update$a$bookmark$application$Status$200;
export interface Params$zone$level$access$applications$update$a$bookmark$application {
    parameter: Parameter$zone$level$access$applications$update$a$bookmark$application;
    requestBody: RequestBody$zone$level$access$applications$update$a$bookmark$application["application/json"];
}
export type ResponseContentType$zone$level$access$applications$delete$an$access$application = keyof Response$zone$level$access$applications$delete$an$access$application$Status$202;
export interface Params$zone$level$access$applications$delete$an$access$application {
    parameter: Parameter$zone$level$access$applications$delete$an$access$application;
}
export type ResponseContentType$zone$level$access$applications$revoke$service$tokens = keyof Response$zone$level$access$applications$revoke$service$tokens$Status$202;
export interface Params$zone$level$access$applications$revoke$service$tokens {
    parameter: Parameter$zone$level$access$applications$revoke$service$tokens;
}
export type ResponseContentType$zone$level$access$applications$test$access$policies = keyof Response$zone$level$access$applications$test$access$policies$Status$200;
export interface Params$zone$level$access$applications$test$access$policies {
    parameter: Parameter$zone$level$access$applications$test$access$policies;
}
export type ResponseContentType$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca = keyof Response$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$200;
export interface Params$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca {
    parameter: Parameter$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca;
}
export type ResponseContentType$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca = keyof Response$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$200;
export interface Params$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca {
    parameter: Parameter$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca;
}
export type ResponseContentType$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca = keyof Response$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$202;
export interface Params$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca {
    parameter: Parameter$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca;
}
export type ResponseContentType$zone$level$access$policies$list$access$policies = keyof Response$zone$level$access$policies$list$access$policies$Status$200;
export interface Params$zone$level$access$policies$list$access$policies {
    parameter: Parameter$zone$level$access$policies$list$access$policies;
}
export type RequestContentType$zone$level$access$policies$create$an$access$policy = keyof RequestBody$zone$level$access$policies$create$an$access$policy;
export type ResponseContentType$zone$level$access$policies$create$an$access$policy = keyof Response$zone$level$access$policies$create$an$access$policy$Status$201;
export interface Params$zone$level$access$policies$create$an$access$policy {
    parameter: Parameter$zone$level$access$policies$create$an$access$policy;
    requestBody: RequestBody$zone$level$access$policies$create$an$access$policy["application/json"];
}
export type ResponseContentType$zone$level$access$policies$get$an$access$policy = keyof Response$zone$level$access$policies$get$an$access$policy$Status$200;
export interface Params$zone$level$access$policies$get$an$access$policy {
    parameter: Parameter$zone$level$access$policies$get$an$access$policy;
}
export type RequestContentType$zone$level$access$policies$update$an$access$policy = keyof RequestBody$zone$level$access$policies$update$an$access$policy;
export type ResponseContentType$zone$level$access$policies$update$an$access$policy = keyof Response$zone$level$access$policies$update$an$access$policy$Status$200;
export interface Params$zone$level$access$policies$update$an$access$policy {
    parameter: Parameter$zone$level$access$policies$update$an$access$policy;
    requestBody: RequestBody$zone$level$access$policies$update$an$access$policy["application/json"];
}
export type ResponseContentType$zone$level$access$policies$delete$an$access$policy = keyof Response$zone$level$access$policies$delete$an$access$policy$Status$202;
export interface Params$zone$level$access$policies$delete$an$access$policy {
    parameter: Parameter$zone$level$access$policies$delete$an$access$policy;
}
export type ResponseContentType$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as = keyof Response$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$200;
export interface Params$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as {
    parameter: Parameter$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as;
}
export type ResponseContentType$zone$level$access$mtls$authentication$list$mtls$certificates = keyof Response$zone$level$access$mtls$authentication$list$mtls$certificates$Status$200;
export interface Params$zone$level$access$mtls$authentication$list$mtls$certificates {
    parameter: Parameter$zone$level$access$mtls$authentication$list$mtls$certificates;
}
export type RequestContentType$zone$level$access$mtls$authentication$add$an$mtls$certificate = keyof RequestBody$zone$level$access$mtls$authentication$add$an$mtls$certificate;
export type ResponseContentType$zone$level$access$mtls$authentication$add$an$mtls$certificate = keyof Response$zone$level$access$mtls$authentication$add$an$mtls$certificate$Status$201;
export interface Params$zone$level$access$mtls$authentication$add$an$mtls$certificate {
    parameter: Parameter$zone$level$access$mtls$authentication$add$an$mtls$certificate;
    requestBody: RequestBody$zone$level$access$mtls$authentication$add$an$mtls$certificate["application/json"];
}
export type ResponseContentType$zone$level$access$mtls$authentication$get$an$mtls$certificate = keyof Response$zone$level$access$mtls$authentication$get$an$mtls$certificate$Status$200;
export interface Params$zone$level$access$mtls$authentication$get$an$mtls$certificate {
    parameter: Parameter$zone$level$access$mtls$authentication$get$an$mtls$certificate;
}
export type RequestContentType$zone$level$access$mtls$authentication$update$an$mtls$certificate = keyof RequestBody$zone$level$access$mtls$authentication$update$an$mtls$certificate;
export type ResponseContentType$zone$level$access$mtls$authentication$update$an$mtls$certificate = keyof Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$Status$200;
export interface Params$zone$level$access$mtls$authentication$update$an$mtls$certificate {
    parameter: Parameter$zone$level$access$mtls$authentication$update$an$mtls$certificate;
    requestBody: RequestBody$zone$level$access$mtls$authentication$update$an$mtls$certificate["application/json"];
}
export type ResponseContentType$zone$level$access$mtls$authentication$delete$an$mtls$certificate = keyof Response$zone$level$access$mtls$authentication$delete$an$mtls$certificate$Status$200;
export interface Params$zone$level$access$mtls$authentication$delete$an$mtls$certificate {
    parameter: Parameter$zone$level$access$mtls$authentication$delete$an$mtls$certificate;
}
export type ResponseContentType$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings = keyof Response$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$200;
export interface Params$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings {
    parameter: Parameter$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings;
}
export type RequestContentType$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings = keyof RequestBody$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings;
export type ResponseContentType$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings = keyof Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings$Status$202;
export interface Params$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings {
    parameter: Parameter$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings;
    requestBody: RequestBody$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings["application/json"];
}
export type ResponseContentType$zone$level$access$groups$list$access$groups = keyof Response$zone$level$access$groups$list$access$groups$Status$200;
export interface Params$zone$level$access$groups$list$access$groups {
    parameter: Parameter$zone$level$access$groups$list$access$groups;
}
export type RequestContentType$zone$level$access$groups$create$an$access$group = keyof RequestBody$zone$level$access$groups$create$an$access$group;
export type ResponseContentType$zone$level$access$groups$create$an$access$group = keyof Response$zone$level$access$groups$create$an$access$group$Status$201;
export interface Params$zone$level$access$groups$create$an$access$group {
    parameter: Parameter$zone$level$access$groups$create$an$access$group;
    requestBody: RequestBody$zone$level$access$groups$create$an$access$group["application/json"];
}
export type ResponseContentType$zone$level$access$groups$get$an$access$group = keyof Response$zone$level$access$groups$get$an$access$group$Status$200;
export interface Params$zone$level$access$groups$get$an$access$group {
    parameter: Parameter$zone$level$access$groups$get$an$access$group;
}
export type RequestContentType$zone$level$access$groups$update$an$access$group = keyof RequestBody$zone$level$access$groups$update$an$access$group;
export type ResponseContentType$zone$level$access$groups$update$an$access$group = keyof Response$zone$level$access$groups$update$an$access$group$Status$200;
export interface Params$zone$level$access$groups$update$an$access$group {
    parameter: Parameter$zone$level$access$groups$update$an$access$group;
    requestBody: RequestBody$zone$level$access$groups$update$an$access$group["application/json"];
}
export type ResponseContentType$zone$level$access$groups$delete$an$access$group = keyof Response$zone$level$access$groups$delete$an$access$group$Status$202;
export interface Params$zone$level$access$groups$delete$an$access$group {
    parameter: Parameter$zone$level$access$groups$delete$an$access$group;
}
export type ResponseContentType$zone$level$access$identity$providers$list$access$identity$providers = keyof Response$zone$level$access$identity$providers$list$access$identity$providers$Status$200;
export interface Params$zone$level$access$identity$providers$list$access$identity$providers {
    parameter: Parameter$zone$level$access$identity$providers$list$access$identity$providers;
}
export type RequestContentType$zone$level$access$identity$providers$add$an$access$identity$provider = keyof RequestBody$zone$level$access$identity$providers$add$an$access$identity$provider;
export type ResponseContentType$zone$level$access$identity$providers$add$an$access$identity$provider = keyof Response$zone$level$access$identity$providers$add$an$access$identity$provider$Status$201;
export interface Params$zone$level$access$identity$providers$add$an$access$identity$provider {
    parameter: Parameter$zone$level$access$identity$providers$add$an$access$identity$provider;
    requestBody: RequestBody$zone$level$access$identity$providers$add$an$access$identity$provider["application/json"];
}
export type ResponseContentType$zone$level$access$identity$providers$get$an$access$identity$provider = keyof Response$zone$level$access$identity$providers$get$an$access$identity$provider$Status$200;
export interface Params$zone$level$access$identity$providers$get$an$access$identity$provider {
    parameter: Parameter$zone$level$access$identity$providers$get$an$access$identity$provider;
}
export type RequestContentType$zone$level$access$identity$providers$update$an$access$identity$provider = keyof RequestBody$zone$level$access$identity$providers$update$an$access$identity$provider;
export type ResponseContentType$zone$level$access$identity$providers$update$an$access$identity$provider = keyof Response$zone$level$access$identity$providers$update$an$access$identity$provider$Status$200;
export interface Params$zone$level$access$identity$providers$update$an$access$identity$provider {
    parameter: Parameter$zone$level$access$identity$providers$update$an$access$identity$provider;
    requestBody: RequestBody$zone$level$access$identity$providers$update$an$access$identity$provider["application/json"];
}
export type ResponseContentType$zone$level$access$identity$providers$delete$an$access$identity$provider = keyof Response$zone$level$access$identity$providers$delete$an$access$identity$provider$Status$202;
export interface Params$zone$level$access$identity$providers$delete$an$access$identity$provider {
    parameter: Parameter$zone$level$access$identity$providers$delete$an$access$identity$provider;
}
export type ResponseContentType$zone$level$zero$trust$organization$get$your$zero$trust$organization = keyof Response$zone$level$zero$trust$organization$get$your$zero$trust$organization$Status$200;
export interface Params$zone$level$zero$trust$organization$get$your$zero$trust$organization {
    parameter: Parameter$zone$level$zero$trust$organization$get$your$zero$trust$organization;
}
export type RequestContentType$zone$level$zero$trust$organization$update$your$zero$trust$organization = keyof RequestBody$zone$level$zero$trust$organization$update$your$zero$trust$organization;
export type ResponseContentType$zone$level$zero$trust$organization$update$your$zero$trust$organization = keyof Response$zone$level$zero$trust$organization$update$your$zero$trust$organization$Status$200;
export interface Params$zone$level$zero$trust$organization$update$your$zero$trust$organization {
    parameter: Parameter$zone$level$zero$trust$organization$update$your$zero$trust$organization;
    requestBody: RequestBody$zone$level$zero$trust$organization$update$your$zero$trust$organization["application/json"];
}
export type RequestContentType$zone$level$zero$trust$organization$create$your$zero$trust$organization = keyof RequestBody$zone$level$zero$trust$organization$create$your$zero$trust$organization;
export type ResponseContentType$zone$level$zero$trust$organization$create$your$zero$trust$organization = keyof Response$zone$level$zero$trust$organization$create$your$zero$trust$organization$Status$201;
export interface Params$zone$level$zero$trust$organization$create$your$zero$trust$organization {
    parameter: Parameter$zone$level$zero$trust$organization$create$your$zero$trust$organization;
    requestBody: RequestBody$zone$level$zero$trust$organization$create$your$zero$trust$organization["application/json"];
}
export type RequestContentType$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user = keyof RequestBody$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user;
export type ResponseContentType$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user = keyof Response$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$200;
export interface Params$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user {
    parameter: Parameter$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user;
    requestBody: RequestBody$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user["application/json"];
}
export type ResponseContentType$zone$level$access$service$tokens$list$service$tokens = keyof Response$zone$level$access$service$tokens$list$service$tokens$Status$200;
export interface Params$zone$level$access$service$tokens$list$service$tokens {
    parameter: Parameter$zone$level$access$service$tokens$list$service$tokens;
}
export type RequestContentType$zone$level$access$service$tokens$create$a$service$token = keyof RequestBody$zone$level$access$service$tokens$create$a$service$token;
export type ResponseContentType$zone$level$access$service$tokens$create$a$service$token = keyof Response$zone$level$access$service$tokens$create$a$service$token$Status$201;
export interface Params$zone$level$access$service$tokens$create$a$service$token {
    parameter: Parameter$zone$level$access$service$tokens$create$a$service$token;
    requestBody: RequestBody$zone$level$access$service$tokens$create$a$service$token["application/json"];
}
export type RequestContentType$zone$level$access$service$tokens$update$a$service$token = keyof RequestBody$zone$level$access$service$tokens$update$a$service$token;
export type ResponseContentType$zone$level$access$service$tokens$update$a$service$token = keyof Response$zone$level$access$service$tokens$update$a$service$token$Status$200;
export interface Params$zone$level$access$service$tokens$update$a$service$token {
    parameter: Parameter$zone$level$access$service$tokens$update$a$service$token;
    requestBody: RequestBody$zone$level$access$service$tokens$update$a$service$token["application/json"];
}
export type ResponseContentType$zone$level$access$service$tokens$delete$a$service$token = keyof Response$zone$level$access$service$tokens$delete$a$service$token$Status$200;
export interface Params$zone$level$access$service$tokens$delete$a$service$token {
    parameter: Parameter$zone$level$access$service$tokens$delete$a$service$token;
}
export type ResponseContentType$dns$analytics$table = keyof Response$dns$analytics$table$Status$200;
export interface Params$dns$analytics$table {
    parameter: Parameter$dns$analytics$table;
}
export type ResponseContentType$dns$analytics$by$time = keyof Response$dns$analytics$by$time$Status$200;
export interface Params$dns$analytics$by$time {
    parameter: Parameter$dns$analytics$by$time;
}
export type ResponseContentType$load$balancers$list$load$balancers = keyof Response$load$balancers$list$load$balancers$Status$200;
export interface Params$load$balancers$list$load$balancers {
    parameter: Parameter$load$balancers$list$load$balancers;
}
export type RequestContentType$load$balancers$create$load$balancer = keyof RequestBody$load$balancers$create$load$balancer;
export type ResponseContentType$load$balancers$create$load$balancer = keyof Response$load$balancers$create$load$balancer$Status$200;
export interface Params$load$balancers$create$load$balancer {
    parameter: Parameter$load$balancers$create$load$balancer;
    requestBody: RequestBody$load$balancers$create$load$balancer["application/json"];
}
export type RequestContentType$zone$purge = keyof RequestBody$zone$purge;
export type ResponseContentType$zone$purge = keyof Response$zone$purge$Status$200;
export interface Params$zone$purge {
    parameter: Parameter$zone$purge;
    requestBody: RequestBody$zone$purge["application/json"];
}
export type RequestContentType$analyze$certificate$analyze$certificate = keyof RequestBody$analyze$certificate$analyze$certificate;
export type ResponseContentType$analyze$certificate$analyze$certificate = keyof Response$analyze$certificate$analyze$certificate$Status$200;
export interface Params$analyze$certificate$analyze$certificate {
    parameter: Parameter$analyze$certificate$analyze$certificate;
    requestBody: RequestBody$analyze$certificate$analyze$certificate["application/json"];
}
export type ResponseContentType$zone$subscription$zone$subscription$details = keyof Response$zone$subscription$zone$subscription$details$Status$200;
export interface Params$zone$subscription$zone$subscription$details {
    parameter: Parameter$zone$subscription$zone$subscription$details;
}
export type RequestContentType$zone$subscription$update$zone$subscription = keyof RequestBody$zone$subscription$update$zone$subscription;
export type ResponseContentType$zone$subscription$update$zone$subscription = keyof Response$zone$subscription$update$zone$subscription$Status$200;
export interface Params$zone$subscription$update$zone$subscription {
    parameter: Parameter$zone$subscription$update$zone$subscription;
    requestBody: RequestBody$zone$subscription$update$zone$subscription["application/json"];
}
export type RequestContentType$zone$subscription$create$zone$subscription = keyof RequestBody$zone$subscription$create$zone$subscription;
export type ResponseContentType$zone$subscription$create$zone$subscription = keyof Response$zone$subscription$create$zone$subscription$Status$200;
export interface Params$zone$subscription$create$zone$subscription {
    parameter: Parameter$zone$subscription$create$zone$subscription;
    requestBody: RequestBody$zone$subscription$create$zone$subscription["application/json"];
}
export type ResponseContentType$load$balancers$load$balancer$details = keyof Response$load$balancers$load$balancer$details$Status$200;
export interface Params$load$balancers$load$balancer$details {
    parameter: Parameter$load$balancers$load$balancer$details;
}
export type RequestContentType$load$balancers$update$load$balancer = keyof RequestBody$load$balancers$update$load$balancer;
export type ResponseContentType$load$balancers$update$load$balancer = keyof Response$load$balancers$update$load$balancer$Status$200;
export interface Params$load$balancers$update$load$balancer {
    parameter: Parameter$load$balancers$update$load$balancer;
    requestBody: RequestBody$load$balancers$update$load$balancer["application/json"];
}
export type ResponseContentType$load$balancers$delete$load$balancer = keyof Response$load$balancers$delete$load$balancer$Status$200;
export interface Params$load$balancers$delete$load$balancer {
    parameter: Parameter$load$balancers$delete$load$balancer;
}
export type RequestContentType$load$balancers$patch$load$balancer = keyof RequestBody$load$balancers$patch$load$balancer;
export type ResponseContentType$load$balancers$patch$load$balancer = keyof Response$load$balancers$patch$load$balancer$Status$200;
export interface Params$load$balancers$patch$load$balancer {
    parameter: Parameter$load$balancers$patch$load$balancer;
    requestBody: RequestBody$load$balancers$patch$load$balancer["application/json"];
}
export type ResponseContentType$zones$0$get = keyof Response$zones$0$get$Status$200;
export interface Params$zones$0$get {
    parameter: Parameter$zones$0$get;
}
export type ResponseContentType$zones$0$delete = keyof Response$zones$0$delete$Status$200;
export interface Params$zones$0$delete {
    parameter: Parameter$zones$0$delete;
}
export type RequestContentType$zones$0$patch = keyof RequestBody$zones$0$patch;
export type ResponseContentType$zones$0$patch = keyof Response$zones$0$patch$Status$200;
export interface Params$zones$0$patch {
    parameter: Parameter$zones$0$patch;
    requestBody: RequestBody$zones$0$patch["application/json"];
}
export type ResponseContentType$put$zones$zone_id$activation_check = keyof Response$put$zones$zone_id$activation_check$Status$200;
export interface Params$put$zones$zone_id$activation_check {
    parameter: Parameter$put$zones$zone_id$activation_check;
}
export type ResponseContentType$argo$analytics$for$zone$argo$analytics$for$a$zone = keyof Response$argo$analytics$for$zone$argo$analytics$for$a$zone$Status$200;
export interface Params$argo$analytics$for$zone$argo$analytics$for$a$zone {
    parameter: Parameter$argo$analytics$for$zone$argo$analytics$for$a$zone;
}
export type ResponseContentType$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps = keyof Response$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps$Status$200;
export interface Params$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps {
    parameter: Parameter$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps;
}
export type ResponseContentType$api$shield$settings$retrieve$information$about$specific$configuration$properties = keyof Response$api$shield$settings$retrieve$information$about$specific$configuration$properties$Status$200;
export interface Params$api$shield$settings$retrieve$information$about$specific$configuration$properties {
    parameter: Parameter$api$shield$settings$retrieve$information$about$specific$configuration$properties;
}
export type RequestContentType$api$shield$settings$set$configuration$properties = keyof RequestBody$api$shield$settings$set$configuration$properties;
export type ResponseContentType$api$shield$settings$set$configuration$properties = keyof Response$api$shield$settings$set$configuration$properties$Status$200;
export interface Params$api$shield$settings$set$configuration$properties {
    parameter: Parameter$api$shield$settings$set$configuration$properties;
    requestBody: RequestBody$api$shield$settings$set$configuration$properties["application/json"];
}
export type ResponseContentType$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi = keyof Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi$Status$200;
export interface Params$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi {
    parameter: Parameter$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi;
}
export type ResponseContentType$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone = keyof Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$Status$200;
export interface Params$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone {
    parameter: Parameter$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone;
}
export type RequestContentType$api$shield$api$patch$discovered$operations = keyof RequestBody$api$shield$api$patch$discovered$operations;
export type ResponseContentType$api$shield$api$patch$discovered$operations = keyof Response$api$shield$api$patch$discovered$operations$Status$200;
export interface Params$api$shield$api$patch$discovered$operations {
    parameter: Parameter$api$shield$api$patch$discovered$operations;
    requestBody: RequestBody$api$shield$api$patch$discovered$operations["application/json"];
}
export type RequestContentType$api$shield$api$patch$discovered$operation = keyof RequestBody$api$shield$api$patch$discovered$operation;
export type ResponseContentType$api$shield$api$patch$discovered$operation = keyof Response$api$shield$api$patch$discovered$operation$Status$200;
export interface Params$api$shield$api$patch$discovered$operation {
    parameter: Parameter$api$shield$api$patch$discovered$operation;
    requestBody: RequestBody$api$shield$api$patch$discovered$operation["application/json"];
}
export type ResponseContentType$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone = keyof Response$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone$Status$200;
export interface Params$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone {
    parameter: Parameter$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone;
}
export type RequestContentType$api$shield$endpoint$management$add$operations$to$a$zone = keyof RequestBody$api$shield$endpoint$management$add$operations$to$a$zone;
export type ResponseContentType$api$shield$endpoint$management$add$operations$to$a$zone = keyof Response$api$shield$endpoint$management$add$operations$to$a$zone$Status$200;
export interface Params$api$shield$endpoint$management$add$operations$to$a$zone {
    parameter: Parameter$api$shield$endpoint$management$add$operations$to$a$zone;
    requestBody: RequestBody$api$shield$endpoint$management$add$operations$to$a$zone["application/json"];
}
export type ResponseContentType$api$shield$endpoint$management$retrieve$information$about$an$operation = keyof Response$api$shield$endpoint$management$retrieve$information$about$an$operation$Status$200;
export interface Params$api$shield$endpoint$management$retrieve$information$about$an$operation {
    parameter: Parameter$api$shield$endpoint$management$retrieve$information$about$an$operation;
}
export type ResponseContentType$api$shield$endpoint$management$delete$an$operation = keyof Response$api$shield$endpoint$management$delete$an$operation$Status$200;
export interface Params$api$shield$endpoint$management$delete$an$operation {
    parameter: Parameter$api$shield$endpoint$management$delete$an$operation;
}
export type ResponseContentType$api$shield$schema$validation$retrieve$operation$level$settings = keyof Response$api$shield$schema$validation$retrieve$operation$level$settings$Status$200;
export interface Params$api$shield$schema$validation$retrieve$operation$level$settings {
    parameter: Parameter$api$shield$schema$validation$retrieve$operation$level$settings;
}
export type RequestContentType$api$shield$schema$validation$update$operation$level$settings = keyof RequestBody$api$shield$schema$validation$update$operation$level$settings;
export type ResponseContentType$api$shield$schema$validation$update$operation$level$settings = keyof Response$api$shield$schema$validation$update$operation$level$settings$Status$200;
export interface Params$api$shield$schema$validation$update$operation$level$settings {
    parameter: Parameter$api$shield$schema$validation$update$operation$level$settings;
    requestBody: RequestBody$api$shield$schema$validation$update$operation$level$settings["application/json"];
}
export type RequestContentType$api$shield$schema$validation$update$multiple$operation$level$settings = keyof RequestBody$api$shield$schema$validation$update$multiple$operation$level$settings;
export type ResponseContentType$api$shield$schema$validation$update$multiple$operation$level$settings = keyof Response$api$shield$schema$validation$update$multiple$operation$level$settings$Status$200;
export interface Params$api$shield$schema$validation$update$multiple$operation$level$settings {
    parameter: Parameter$api$shield$schema$validation$update$multiple$operation$level$settings;
    requestBody: RequestBody$api$shield$schema$validation$update$multiple$operation$level$settings["application/json"];
}
export type ResponseContentType$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas = keyof Response$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas$Status$200;
export interface Params$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas {
    parameter: Parameter$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas;
}
export type ResponseContentType$api$shield$schema$validation$retrieve$zone$level$settings = keyof Response$api$shield$schema$validation$retrieve$zone$level$settings$Status$200;
export interface Params$api$shield$schema$validation$retrieve$zone$level$settings {
    parameter: Parameter$api$shield$schema$validation$retrieve$zone$level$settings;
}
export type RequestContentType$api$shield$schema$validation$update$zone$level$settings = keyof RequestBody$api$shield$schema$validation$update$zone$level$settings;
export type ResponseContentType$api$shield$schema$validation$update$zone$level$settings = keyof Response$api$shield$schema$validation$update$zone$level$settings$Status$200;
export interface Params$api$shield$schema$validation$update$zone$level$settings {
    parameter: Parameter$api$shield$schema$validation$update$zone$level$settings;
    requestBody: RequestBody$api$shield$schema$validation$update$zone$level$settings["application/json"];
}
export type RequestContentType$api$shield$schema$validation$patch$zone$level$settings = keyof RequestBody$api$shield$schema$validation$patch$zone$level$settings;
export type ResponseContentType$api$shield$schema$validation$patch$zone$level$settings = keyof Response$api$shield$schema$validation$patch$zone$level$settings$Status$200;
export interface Params$api$shield$schema$validation$patch$zone$level$settings {
    parameter: Parameter$api$shield$schema$validation$patch$zone$level$settings;
    requestBody: RequestBody$api$shield$schema$validation$patch$zone$level$settings["application/json"];
}
export type ResponseContentType$api$shield$schema$validation$retrieve$information$about$all$schemas = keyof Response$api$shield$schema$validation$retrieve$information$about$all$schemas$Status$200;
export interface Params$api$shield$schema$validation$retrieve$information$about$all$schemas {
    parameter: Parameter$api$shield$schema$validation$retrieve$information$about$all$schemas;
}
export type RequestContentType$api$shield$schema$validation$post$schema = keyof RequestBody$api$shield$schema$validation$post$schema;
export type ResponseContentType$api$shield$schema$validation$post$schema = keyof Response$api$shield$schema$validation$post$schema$Status$200;
export interface Params$api$shield$schema$validation$post$schema {
    parameter: Parameter$api$shield$schema$validation$post$schema;
    requestBody: RequestBody$api$shield$schema$validation$post$schema["multipart/form-data"];
}
export type ResponseContentType$api$shield$schema$validation$retrieve$information$about$specific$schema = keyof Response$api$shield$schema$validation$retrieve$information$about$specific$schema$Status$200;
export interface Params$api$shield$schema$validation$retrieve$information$about$specific$schema {
    parameter: Parameter$api$shield$schema$validation$retrieve$information$about$specific$schema;
}
export type ResponseContentType$api$shield$schema$delete$a$schema = keyof Response$api$shield$schema$delete$a$schema$Status$200;
export interface Params$api$shield$schema$delete$a$schema {
    parameter: Parameter$api$shield$schema$delete$a$schema;
}
export type RequestContentType$api$shield$schema$validation$enable$validation$for$a$schema = keyof RequestBody$api$shield$schema$validation$enable$validation$for$a$schema;
export type ResponseContentType$api$shield$schema$validation$enable$validation$for$a$schema = keyof Response$api$shield$schema$validation$enable$validation$for$a$schema$Status$200;
export interface Params$api$shield$schema$validation$enable$validation$for$a$schema {
    parameter: Parameter$api$shield$schema$validation$enable$validation$for$a$schema;
    requestBody: RequestBody$api$shield$schema$validation$enable$validation$for$a$schema["application/json"];
}
export type ResponseContentType$api$shield$schema$validation$extract$operations$from$schema = keyof Response$api$shield$schema$validation$extract$operations$from$schema$Status$200;
export interface Params$api$shield$schema$validation$extract$operations$from$schema {
    parameter: Parameter$api$shield$schema$validation$extract$operations$from$schema;
}
export type ResponseContentType$argo$smart$routing$get$argo$smart$routing$setting = keyof Response$argo$smart$routing$get$argo$smart$routing$setting$Status$200;
export interface Params$argo$smart$routing$get$argo$smart$routing$setting {
    parameter: Parameter$argo$smart$routing$get$argo$smart$routing$setting;
}
export type RequestContentType$argo$smart$routing$patch$argo$smart$routing$setting = keyof RequestBody$argo$smart$routing$patch$argo$smart$routing$setting;
export type ResponseContentType$argo$smart$routing$patch$argo$smart$routing$setting = keyof Response$argo$smart$routing$patch$argo$smart$routing$setting$Status$200;
export interface Params$argo$smart$routing$patch$argo$smart$routing$setting {
    parameter: Parameter$argo$smart$routing$patch$argo$smart$routing$setting;
    requestBody: RequestBody$argo$smart$routing$patch$argo$smart$routing$setting["application/json"];
}
export type ResponseContentType$tiered$caching$get$tiered$caching$setting = keyof Response$tiered$caching$get$tiered$caching$setting$Status$200;
export interface Params$tiered$caching$get$tiered$caching$setting {
    parameter: Parameter$tiered$caching$get$tiered$caching$setting;
}
export type RequestContentType$tiered$caching$patch$tiered$caching$setting = keyof RequestBody$tiered$caching$patch$tiered$caching$setting;
export type ResponseContentType$tiered$caching$patch$tiered$caching$setting = keyof Response$tiered$caching$patch$tiered$caching$setting$Status$200;
export interface Params$tiered$caching$patch$tiered$caching$setting {
    parameter: Parameter$tiered$caching$patch$tiered$caching$setting;
    requestBody: RequestBody$tiered$caching$patch$tiered$caching$setting["application/json"];
}
export type ResponseContentType$bot$management$for$a$zone$get$config = keyof Response$bot$management$for$a$zone$get$config$Status$200;
export interface Params$bot$management$for$a$zone$get$config {
    parameter: Parameter$bot$management$for$a$zone$get$config;
}
export type RequestContentType$bot$management$for$a$zone$update$config = keyof RequestBody$bot$management$for$a$zone$update$config;
export type ResponseContentType$bot$management$for$a$zone$update$config = keyof Response$bot$management$for$a$zone$update$config$Status$200;
export interface Params$bot$management$for$a$zone$update$config {
    parameter: Parameter$bot$management$for$a$zone$update$config;
    requestBody: RequestBody$bot$management$for$a$zone$update$config["application/json"];
}
export type ResponseContentType$zone$cache$settings$get$cache$reserve$setting = keyof Response$zone$cache$settings$get$cache$reserve$setting$Status$200;
export interface Params$zone$cache$settings$get$cache$reserve$setting {
    parameter: Parameter$zone$cache$settings$get$cache$reserve$setting;
}
export type RequestContentType$zone$cache$settings$change$cache$reserve$setting = keyof RequestBody$zone$cache$settings$change$cache$reserve$setting;
export type ResponseContentType$zone$cache$settings$change$cache$reserve$setting = keyof Response$zone$cache$settings$change$cache$reserve$setting$Status$200;
export interface Params$zone$cache$settings$change$cache$reserve$setting {
    parameter: Parameter$zone$cache$settings$change$cache$reserve$setting;
    requestBody: RequestBody$zone$cache$settings$change$cache$reserve$setting["application/json"];
}
export type ResponseContentType$zone$cache$settings$get$cache$reserve$clear = keyof Response$zone$cache$settings$get$cache$reserve$clear$Status$200;
export interface Params$zone$cache$settings$get$cache$reserve$clear {
    parameter: Parameter$zone$cache$settings$get$cache$reserve$clear;
}
export type RequestContentType$zone$cache$settings$start$cache$reserve$clear = keyof RequestBody$zone$cache$settings$start$cache$reserve$clear;
export type ResponseContentType$zone$cache$settings$start$cache$reserve$clear = keyof Response$zone$cache$settings$start$cache$reserve$clear$Status$200;
export interface Params$zone$cache$settings$start$cache$reserve$clear {
    parameter: Parameter$zone$cache$settings$start$cache$reserve$clear;
    requestBody: RequestBody$zone$cache$settings$start$cache$reserve$clear["application/json"];
}
export type ResponseContentType$zone$cache$settings$get$origin$post$quantum$encryption$setting = keyof Response$zone$cache$settings$get$origin$post$quantum$encryption$setting$Status$200;
export interface Params$zone$cache$settings$get$origin$post$quantum$encryption$setting {
    parameter: Parameter$zone$cache$settings$get$origin$post$quantum$encryption$setting;
}
export type RequestContentType$zone$cache$settings$change$origin$post$quantum$encryption$setting = keyof RequestBody$zone$cache$settings$change$origin$post$quantum$encryption$setting;
export type ResponseContentType$zone$cache$settings$change$origin$post$quantum$encryption$setting = keyof Response$zone$cache$settings$change$origin$post$quantum$encryption$setting$Status$200;
export interface Params$zone$cache$settings$change$origin$post$quantum$encryption$setting {
    parameter: Parameter$zone$cache$settings$change$origin$post$quantum$encryption$setting;
    requestBody: RequestBody$zone$cache$settings$change$origin$post$quantum$encryption$setting["application/json"];
}
export type ResponseContentType$zone$cache$settings$get$regional$tiered$cache$setting = keyof Response$zone$cache$settings$get$regional$tiered$cache$setting$Status$200;
export interface Params$zone$cache$settings$get$regional$tiered$cache$setting {
    parameter: Parameter$zone$cache$settings$get$regional$tiered$cache$setting;
}
export type RequestContentType$zone$cache$settings$change$regional$tiered$cache$setting = keyof RequestBody$zone$cache$settings$change$regional$tiered$cache$setting;
export type ResponseContentType$zone$cache$settings$change$regional$tiered$cache$setting = keyof Response$zone$cache$settings$change$regional$tiered$cache$setting$Status$200;
export interface Params$zone$cache$settings$change$regional$tiered$cache$setting {
    parameter: Parameter$zone$cache$settings$change$regional$tiered$cache$setting;
    requestBody: RequestBody$zone$cache$settings$change$regional$tiered$cache$setting["application/json"];
}
export type ResponseContentType$smart$tiered$cache$get$smart$tiered$cache$setting = keyof Response$smart$tiered$cache$get$smart$tiered$cache$setting$Status$200;
export interface Params$smart$tiered$cache$get$smart$tiered$cache$setting {
    parameter: Parameter$smart$tiered$cache$get$smart$tiered$cache$setting;
}
export type ResponseContentType$smart$tiered$cache$delete$smart$tiered$cache$setting = keyof Response$smart$tiered$cache$delete$smart$tiered$cache$setting$Status$200;
export interface Params$smart$tiered$cache$delete$smart$tiered$cache$setting {
    parameter: Parameter$smart$tiered$cache$delete$smart$tiered$cache$setting;
}
export type RequestContentType$smart$tiered$cache$patch$smart$tiered$cache$setting = keyof RequestBody$smart$tiered$cache$patch$smart$tiered$cache$setting;
export type ResponseContentType$smart$tiered$cache$patch$smart$tiered$cache$setting = keyof Response$smart$tiered$cache$patch$smart$tiered$cache$setting$Status$200;
export interface Params$smart$tiered$cache$patch$smart$tiered$cache$setting {
    parameter: Parameter$smart$tiered$cache$patch$smart$tiered$cache$setting;
    requestBody: RequestBody$smart$tiered$cache$patch$smart$tiered$cache$setting["application/json"];
}
export type ResponseContentType$zone$cache$settings$get$variants$setting = keyof Response$zone$cache$settings$get$variants$setting$Status$200;
export interface Params$zone$cache$settings$get$variants$setting {
    parameter: Parameter$zone$cache$settings$get$variants$setting;
}
export type ResponseContentType$zone$cache$settings$delete$variants$setting = keyof Response$zone$cache$settings$delete$variants$setting$Status$200;
export interface Params$zone$cache$settings$delete$variants$setting {
    parameter: Parameter$zone$cache$settings$delete$variants$setting;
}
export type RequestContentType$zone$cache$settings$change$variants$setting = keyof RequestBody$zone$cache$settings$change$variants$setting;
export type ResponseContentType$zone$cache$settings$change$variants$setting = keyof Response$zone$cache$settings$change$variants$setting$Status$200;
export interface Params$zone$cache$settings$change$variants$setting {
    parameter: Parameter$zone$cache$settings$change$variants$setting;
    requestBody: RequestBody$zone$cache$settings$change$variants$setting["application/json"];
}
export type ResponseContentType$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata = keyof Response$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata$Status$200;
export interface Params$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata {
    parameter: Parameter$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata;
}
export type RequestContentType$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata = keyof RequestBody$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata;
export type ResponseContentType$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata = keyof Response$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata$Status$200;
export interface Params$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata {
    parameter: Parameter$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata;
    requestBody: RequestBody$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata["application/json"];
}
export type ResponseContentType$dns$records$for$a$zone$list$dns$records = keyof Response$dns$records$for$a$zone$list$dns$records$Status$200;
export interface Params$dns$records$for$a$zone$list$dns$records {
    parameter: Parameter$dns$records$for$a$zone$list$dns$records;
}
export type RequestContentType$dns$records$for$a$zone$create$dns$record = keyof RequestBody$dns$records$for$a$zone$create$dns$record;
export type ResponseContentType$dns$records$for$a$zone$create$dns$record = keyof Response$dns$records$for$a$zone$create$dns$record$Status$200;
export interface Params$dns$records$for$a$zone$create$dns$record {
    parameter: Parameter$dns$records$for$a$zone$create$dns$record;
    requestBody: RequestBody$dns$records$for$a$zone$create$dns$record["application/json"];
}
export type ResponseContentType$dns$records$for$a$zone$dns$record$details = keyof Response$dns$records$for$a$zone$dns$record$details$Status$200;
export interface Params$dns$records$for$a$zone$dns$record$details {
    parameter: Parameter$dns$records$for$a$zone$dns$record$details;
}
export type RequestContentType$dns$records$for$a$zone$update$dns$record = keyof RequestBody$dns$records$for$a$zone$update$dns$record;
export type ResponseContentType$dns$records$for$a$zone$update$dns$record = keyof Response$dns$records$for$a$zone$update$dns$record$Status$200;
export interface Params$dns$records$for$a$zone$update$dns$record {
    parameter: Parameter$dns$records$for$a$zone$update$dns$record;
    requestBody: RequestBody$dns$records$for$a$zone$update$dns$record["application/json"];
}
export type ResponseContentType$dns$records$for$a$zone$delete$dns$record = keyof Response$dns$records$for$a$zone$delete$dns$record$Status$200;
export interface Params$dns$records$for$a$zone$delete$dns$record {
    parameter: Parameter$dns$records$for$a$zone$delete$dns$record;
}
export type RequestContentType$dns$records$for$a$zone$patch$dns$record = keyof RequestBody$dns$records$for$a$zone$patch$dns$record;
export type ResponseContentType$dns$records$for$a$zone$patch$dns$record = keyof Response$dns$records$for$a$zone$patch$dns$record$Status$200;
export interface Params$dns$records$for$a$zone$patch$dns$record {
    parameter: Parameter$dns$records$for$a$zone$patch$dns$record;
    requestBody: RequestBody$dns$records$for$a$zone$patch$dns$record["application/json"];
}
export type ResponseContentType$dns$records$for$a$zone$export$dns$records = keyof Response$dns$records$for$a$zone$export$dns$records$Status$200;
export interface Params$dns$records$for$a$zone$export$dns$records {
    parameter: Parameter$dns$records$for$a$zone$export$dns$records;
}
export type RequestContentType$dns$records$for$a$zone$import$dns$records = keyof RequestBody$dns$records$for$a$zone$import$dns$records;
export type ResponseContentType$dns$records$for$a$zone$import$dns$records = keyof Response$dns$records$for$a$zone$import$dns$records$Status$200;
export interface Params$dns$records$for$a$zone$import$dns$records {
    parameter: Parameter$dns$records$for$a$zone$import$dns$records;
    requestBody: RequestBody$dns$records$for$a$zone$import$dns$records["multipart/form-data"];
}
export type ResponseContentType$dns$records$for$a$zone$scan$dns$records = keyof Response$dns$records$for$a$zone$scan$dns$records$Status$200;
export interface Params$dns$records$for$a$zone$scan$dns$records {
    parameter: Parameter$dns$records$for$a$zone$scan$dns$records;
}
export type ResponseContentType$dnssec$dnssec$details = keyof Response$dnssec$dnssec$details$Status$200;
export interface Params$dnssec$dnssec$details {
    parameter: Parameter$dnssec$dnssec$details;
}
export type ResponseContentType$dnssec$delete$dnssec$records = keyof Response$dnssec$delete$dnssec$records$Status$200;
export interface Params$dnssec$delete$dnssec$records {
    parameter: Parameter$dnssec$delete$dnssec$records;
}
export type RequestContentType$dnssec$edit$dnssec$status = keyof RequestBody$dnssec$edit$dnssec$status;
export type ResponseContentType$dnssec$edit$dnssec$status = keyof Response$dnssec$edit$dnssec$status$Status$200;
export interface Params$dnssec$edit$dnssec$status {
    parameter: Parameter$dnssec$edit$dnssec$status;
    requestBody: RequestBody$dnssec$edit$dnssec$status["application/json"];
}
export type ResponseContentType$ip$access$rules$for$a$zone$list$ip$access$rules = keyof Response$ip$access$rules$for$a$zone$list$ip$access$rules$Status$200;
export interface Params$ip$access$rules$for$a$zone$list$ip$access$rules {
    parameter: Parameter$ip$access$rules$for$a$zone$list$ip$access$rules;
}
export type RequestContentType$ip$access$rules$for$a$zone$create$an$ip$access$rule = keyof RequestBody$ip$access$rules$for$a$zone$create$an$ip$access$rule;
export type ResponseContentType$ip$access$rules$for$a$zone$create$an$ip$access$rule = keyof Response$ip$access$rules$for$a$zone$create$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$a$zone$create$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$a$zone$create$an$ip$access$rule;
    requestBody: RequestBody$ip$access$rules$for$a$zone$create$an$ip$access$rule["application/json"];
}
export type RequestContentType$ip$access$rules$for$a$zone$delete$an$ip$access$rule = keyof RequestBody$ip$access$rules$for$a$zone$delete$an$ip$access$rule;
export type ResponseContentType$ip$access$rules$for$a$zone$delete$an$ip$access$rule = keyof Response$ip$access$rules$for$a$zone$delete$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$a$zone$delete$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$a$zone$delete$an$ip$access$rule;
    requestBody: RequestBody$ip$access$rules$for$a$zone$delete$an$ip$access$rule["application/json"];
}
export type RequestContentType$ip$access$rules$for$a$zone$update$an$ip$access$rule = keyof RequestBody$ip$access$rules$for$a$zone$update$an$ip$access$rule;
export type ResponseContentType$ip$access$rules$for$a$zone$update$an$ip$access$rule = keyof Response$ip$access$rules$for$a$zone$update$an$ip$access$rule$Status$200;
export interface Params$ip$access$rules$for$a$zone$update$an$ip$access$rule {
    parameter: Parameter$ip$access$rules$for$a$zone$update$an$ip$access$rule;
    requestBody: RequestBody$ip$access$rules$for$a$zone$update$an$ip$access$rule["application/json"];
}
export type ResponseContentType$waf$rule$groups$list$waf$rule$groups = keyof Response$waf$rule$groups$list$waf$rule$groups$Status$200;
export interface Params$waf$rule$groups$list$waf$rule$groups {
    parameter: Parameter$waf$rule$groups$list$waf$rule$groups;
}
export type ResponseContentType$waf$rule$groups$get$a$waf$rule$group = keyof Response$waf$rule$groups$get$a$waf$rule$group$Status$200;
export interface Params$waf$rule$groups$get$a$waf$rule$group {
    parameter: Parameter$waf$rule$groups$get$a$waf$rule$group;
}
export type RequestContentType$waf$rule$groups$update$a$waf$rule$group = keyof RequestBody$waf$rule$groups$update$a$waf$rule$group;
export type ResponseContentType$waf$rule$groups$update$a$waf$rule$group = keyof Response$waf$rule$groups$update$a$waf$rule$group$Status$200;
export interface Params$waf$rule$groups$update$a$waf$rule$group {
    parameter: Parameter$waf$rule$groups$update$a$waf$rule$group;
    requestBody: RequestBody$waf$rule$groups$update$a$waf$rule$group["application/json"];
}
export type ResponseContentType$waf$rules$list$waf$rules = keyof Response$waf$rules$list$waf$rules$Status$200;
export interface Params$waf$rules$list$waf$rules {
    parameter: Parameter$waf$rules$list$waf$rules;
}
export type ResponseContentType$waf$rules$get$a$waf$rule = keyof Response$waf$rules$get$a$waf$rule$Status$200;
export interface Params$waf$rules$get$a$waf$rule {
    parameter: Parameter$waf$rules$get$a$waf$rule;
}
export type RequestContentType$waf$rules$update$a$waf$rule = keyof RequestBody$waf$rules$update$a$waf$rule;
export type ResponseContentType$waf$rules$update$a$waf$rule = keyof Response$waf$rules$update$a$waf$rule$Status$200;
export interface Params$waf$rules$update$a$waf$rule {
    parameter: Parameter$waf$rules$update$a$waf$rule;
    requestBody: RequestBody$waf$rules$update$a$waf$rule["application/json"];
}
export type ResponseContentType$zones$0$hold$get = keyof Response$zones$0$hold$get$Status$200;
export interface Params$zones$0$hold$get {
    parameter: Parameter$zones$0$hold$get;
}
export type ResponseContentType$zones$0$hold$post = keyof Response$zones$0$hold$post$Status$200;
export interface Params$zones$0$hold$post {
    parameter: Parameter$zones$0$hold$post;
}
export type ResponseContentType$zones$0$hold$delete = keyof Response$zones$0$hold$delete$Status$200;
export interface Params$zones$0$hold$delete {
    parameter: Parameter$zones$0$hold$delete;
}
export type ResponseContentType$get$zones$zone_identifier$logpush$datasets$dataset$fields = keyof Response$get$zones$zone_identifier$logpush$datasets$dataset$fields$Status$200;
export interface Params$get$zones$zone_identifier$logpush$datasets$dataset$fields {
    parameter: Parameter$get$zones$zone_identifier$logpush$datasets$dataset$fields;
}
export type ResponseContentType$get$zones$zone_identifier$logpush$datasets$dataset$jobs = keyof Response$get$zones$zone_identifier$logpush$datasets$dataset$jobs$Status$200;
export interface Params$get$zones$zone_identifier$logpush$datasets$dataset$jobs {
    parameter: Parameter$get$zones$zone_identifier$logpush$datasets$dataset$jobs;
}
export type ResponseContentType$get$zones$zone_identifier$logpush$edge$jobs = keyof Response$get$zones$zone_identifier$logpush$edge$jobs$Status$200;
export interface Params$get$zones$zone_identifier$logpush$edge$jobs {
    parameter: Parameter$get$zones$zone_identifier$logpush$edge$jobs;
}
export type RequestContentType$post$zones$zone_identifier$logpush$edge$jobs = keyof RequestBody$post$zones$zone_identifier$logpush$edge$jobs;
export type ResponseContentType$post$zones$zone_identifier$logpush$edge$jobs = keyof Response$post$zones$zone_identifier$logpush$edge$jobs$Status$200;
export interface Params$post$zones$zone_identifier$logpush$edge$jobs {
    parameter: Parameter$post$zones$zone_identifier$logpush$edge$jobs;
    requestBody: RequestBody$post$zones$zone_identifier$logpush$edge$jobs["application/json"];
}
export type ResponseContentType$get$zones$zone_identifier$logpush$jobs = keyof Response$get$zones$zone_identifier$logpush$jobs$Status$200;
export interface Params$get$zones$zone_identifier$logpush$jobs {
    parameter: Parameter$get$zones$zone_identifier$logpush$jobs;
}
export type RequestContentType$post$zones$zone_identifier$logpush$jobs = keyof RequestBody$post$zones$zone_identifier$logpush$jobs;
export type ResponseContentType$post$zones$zone_identifier$logpush$jobs = keyof Response$post$zones$zone_identifier$logpush$jobs$Status$200;
export interface Params$post$zones$zone_identifier$logpush$jobs {
    parameter: Parameter$post$zones$zone_identifier$logpush$jobs;
    requestBody: RequestBody$post$zones$zone_identifier$logpush$jobs["application/json"];
}
export type ResponseContentType$get$zones$zone_identifier$logpush$jobs$job_identifier = keyof Response$get$zones$zone_identifier$logpush$jobs$job_identifier$Status$200;
export interface Params$get$zones$zone_identifier$logpush$jobs$job_identifier {
    parameter: Parameter$get$zones$zone_identifier$logpush$jobs$job_identifier;
}
export type RequestContentType$put$zones$zone_identifier$logpush$jobs$job_identifier = keyof RequestBody$put$zones$zone_identifier$logpush$jobs$job_identifier;
export type ResponseContentType$put$zones$zone_identifier$logpush$jobs$job_identifier = keyof Response$put$zones$zone_identifier$logpush$jobs$job_identifier$Status$200;
export interface Params$put$zones$zone_identifier$logpush$jobs$job_identifier {
    parameter: Parameter$put$zones$zone_identifier$logpush$jobs$job_identifier;
    requestBody: RequestBody$put$zones$zone_identifier$logpush$jobs$job_identifier["application/json"];
}
export type ResponseContentType$delete$zones$zone_identifier$logpush$jobs$job_identifier = keyof Response$delete$zones$zone_identifier$logpush$jobs$job_identifier$Status$200;
export interface Params$delete$zones$zone_identifier$logpush$jobs$job_identifier {
    parameter: Parameter$delete$zones$zone_identifier$logpush$jobs$job_identifier;
}
export type RequestContentType$post$zones$zone_identifier$logpush$ownership = keyof RequestBody$post$zones$zone_identifier$logpush$ownership;
export type ResponseContentType$post$zones$zone_identifier$logpush$ownership = keyof Response$post$zones$zone_identifier$logpush$ownership$Status$200;
export interface Params$post$zones$zone_identifier$logpush$ownership {
    parameter: Parameter$post$zones$zone_identifier$logpush$ownership;
    requestBody: RequestBody$post$zones$zone_identifier$logpush$ownership["application/json"];
}
export type RequestContentType$post$zones$zone_identifier$logpush$ownership$validate = keyof RequestBody$post$zones$zone_identifier$logpush$ownership$validate;
export type ResponseContentType$post$zones$zone_identifier$logpush$ownership$validate = keyof Response$post$zones$zone_identifier$logpush$ownership$validate$Status$200;
export interface Params$post$zones$zone_identifier$logpush$ownership$validate {
    parameter: Parameter$post$zones$zone_identifier$logpush$ownership$validate;
    requestBody: RequestBody$post$zones$zone_identifier$logpush$ownership$validate["application/json"];
}
export type RequestContentType$post$zones$zone_identifier$logpush$validate$destination$exists = keyof RequestBody$post$zones$zone_identifier$logpush$validate$destination$exists;
export type ResponseContentType$post$zones$zone_identifier$logpush$validate$destination$exists = keyof Response$post$zones$zone_identifier$logpush$validate$destination$exists$Status$200;
export interface Params$post$zones$zone_identifier$logpush$validate$destination$exists {
    parameter: Parameter$post$zones$zone_identifier$logpush$validate$destination$exists;
    requestBody: RequestBody$post$zones$zone_identifier$logpush$validate$destination$exists["application/json"];
}
export type RequestContentType$post$zones$zone_identifier$logpush$validate$origin = keyof RequestBody$post$zones$zone_identifier$logpush$validate$origin;
export type ResponseContentType$post$zones$zone_identifier$logpush$validate$origin = keyof Response$post$zones$zone_identifier$logpush$validate$origin$Status$200;
export interface Params$post$zones$zone_identifier$logpush$validate$origin {
    parameter: Parameter$post$zones$zone_identifier$logpush$validate$origin;
    requestBody: RequestBody$post$zones$zone_identifier$logpush$validate$origin["application/json"];
}
export type ResponseContentType$managed$transforms$list$managed$transforms = keyof Response$managed$transforms$list$managed$transforms$Status$200;
export interface Params$managed$transforms$list$managed$transforms {
    parameter: Parameter$managed$transforms$list$managed$transforms;
}
export type RequestContentType$managed$transforms$update$status$of$managed$transforms = keyof RequestBody$managed$transforms$update$status$of$managed$transforms;
export type ResponseContentType$managed$transforms$update$status$of$managed$transforms = keyof Response$managed$transforms$update$status$of$managed$transforms$Status$200;
export interface Params$managed$transforms$update$status$of$managed$transforms {
    parameter: Parameter$managed$transforms$update$status$of$managed$transforms;
    requestBody: RequestBody$managed$transforms$update$status$of$managed$transforms["application/json"];
}
export type ResponseContentType$page$shield$get$page$shield$settings = keyof Response$page$shield$get$page$shield$settings$Status$200;
export interface Params$page$shield$get$page$shield$settings {
    parameter: Parameter$page$shield$get$page$shield$settings;
}
export type RequestContentType$page$shield$update$page$shield$settings = keyof RequestBody$page$shield$update$page$shield$settings;
export type ResponseContentType$page$shield$update$page$shield$settings = keyof Response$page$shield$update$page$shield$settings$Status$200;
export interface Params$page$shield$update$page$shield$settings {
    parameter: Parameter$page$shield$update$page$shield$settings;
    requestBody: RequestBody$page$shield$update$page$shield$settings["application/json"];
}
export type ResponseContentType$page$shield$list$page$shield$connections = keyof Response$page$shield$list$page$shield$connections$Status$200;
export interface Params$page$shield$list$page$shield$connections {
    parameter: Parameter$page$shield$list$page$shield$connections;
}
export type ResponseContentType$page$shield$get$a$page$shield$connection = keyof Response$page$shield$get$a$page$shield$connection$Status$200;
export interface Params$page$shield$get$a$page$shield$connection {
    parameter: Parameter$page$shield$get$a$page$shield$connection;
}
export type ResponseContentType$page$shield$list$page$shield$policies = keyof Response$page$shield$list$page$shield$policies$Status$200;
export interface Params$page$shield$list$page$shield$policies {
    parameter: Parameter$page$shield$list$page$shield$policies;
}
export type RequestContentType$page$shield$create$a$page$shield$policy = keyof RequestBody$page$shield$create$a$page$shield$policy;
export type ResponseContentType$page$shield$create$a$page$shield$policy = keyof Response$page$shield$create$a$page$shield$policy$Status$200;
export interface Params$page$shield$create$a$page$shield$policy {
    parameter: Parameter$page$shield$create$a$page$shield$policy;
    requestBody: RequestBody$page$shield$create$a$page$shield$policy["application/json"];
}
export type ResponseContentType$page$shield$get$a$page$shield$policy = keyof Response$page$shield$get$a$page$shield$policy$Status$200;
export interface Params$page$shield$get$a$page$shield$policy {
    parameter: Parameter$page$shield$get$a$page$shield$policy;
}
export type RequestContentType$page$shield$update$a$page$shield$policy = keyof RequestBody$page$shield$update$a$page$shield$policy;
export type ResponseContentType$page$shield$update$a$page$shield$policy = keyof Response$page$shield$update$a$page$shield$policy$Status$200;
export interface Params$page$shield$update$a$page$shield$policy {
    parameter: Parameter$page$shield$update$a$page$shield$policy;
    requestBody: RequestBody$page$shield$update$a$page$shield$policy["application/json"];
}
export interface Params$page$shield$delete$a$page$shield$policy {
    parameter: Parameter$page$shield$delete$a$page$shield$policy;
}
export type ResponseContentType$page$shield$list$page$shield$scripts = keyof Response$page$shield$list$page$shield$scripts$Status$200;
export interface Params$page$shield$list$page$shield$scripts {
    parameter: Parameter$page$shield$list$page$shield$scripts;
}
export type ResponseContentType$page$shield$get$a$page$shield$script = keyof Response$page$shield$get$a$page$shield$script$Status$200;
export interface Params$page$shield$get$a$page$shield$script {
    parameter: Parameter$page$shield$get$a$page$shield$script;
}
export type ResponseContentType$page$rules$list$page$rules = keyof Response$page$rules$list$page$rules$Status$200;
export interface Params$page$rules$list$page$rules {
    parameter: Parameter$page$rules$list$page$rules;
}
export type RequestContentType$page$rules$create$a$page$rule = keyof RequestBody$page$rules$create$a$page$rule;
export type ResponseContentType$page$rules$create$a$page$rule = keyof Response$page$rules$create$a$page$rule$Status$200;
export interface Params$page$rules$create$a$page$rule {
    parameter: Parameter$page$rules$create$a$page$rule;
    requestBody: RequestBody$page$rules$create$a$page$rule["application/json"];
}
export type ResponseContentType$page$rules$get$a$page$rule = keyof Response$page$rules$get$a$page$rule$Status$200;
export interface Params$page$rules$get$a$page$rule {
    parameter: Parameter$page$rules$get$a$page$rule;
}
export type RequestContentType$page$rules$update$a$page$rule = keyof RequestBody$page$rules$update$a$page$rule;
export type ResponseContentType$page$rules$update$a$page$rule = keyof Response$page$rules$update$a$page$rule$Status$200;
export interface Params$page$rules$update$a$page$rule {
    parameter: Parameter$page$rules$update$a$page$rule;
    requestBody: RequestBody$page$rules$update$a$page$rule["application/json"];
}
export type ResponseContentType$page$rules$delete$a$page$rule = keyof Response$page$rules$delete$a$page$rule$Status$200;
export interface Params$page$rules$delete$a$page$rule {
    parameter: Parameter$page$rules$delete$a$page$rule;
}
export type RequestContentType$page$rules$edit$a$page$rule = keyof RequestBody$page$rules$edit$a$page$rule;
export type ResponseContentType$page$rules$edit$a$page$rule = keyof Response$page$rules$edit$a$page$rule$Status$200;
export interface Params$page$rules$edit$a$page$rule {
    parameter: Parameter$page$rules$edit$a$page$rule;
    requestBody: RequestBody$page$rules$edit$a$page$rule["application/json"];
}
export type ResponseContentType$available$page$rules$settings$list$available$page$rules$settings = keyof Response$available$page$rules$settings$list$available$page$rules$settings$Status$200;
export interface Params$available$page$rules$settings$list$available$page$rules$settings {
    parameter: Parameter$available$page$rules$settings$list$available$page$rules$settings;
}
export type ResponseContentType$listZoneRulesets = keyof Response$listZoneRulesets$Status$200;
export interface Params$listZoneRulesets {
    parameter: Parameter$listZoneRulesets;
}
export type RequestContentType$createZoneRuleset = keyof RequestBody$createZoneRuleset;
export type ResponseContentType$createZoneRuleset = keyof Response$createZoneRuleset$Status$200;
export interface Params$createZoneRuleset {
    parameter: Parameter$createZoneRuleset;
    requestBody: RequestBody$createZoneRuleset["application/json"];
}
export type ResponseContentType$getZoneRuleset = keyof Response$getZoneRuleset$Status$200;
export interface Params$getZoneRuleset {
    parameter: Parameter$getZoneRuleset;
}
export type RequestContentType$updateZoneRuleset = keyof RequestBody$updateZoneRuleset;
export type ResponseContentType$updateZoneRuleset = keyof Response$updateZoneRuleset$Status$200;
export interface Params$updateZoneRuleset {
    parameter: Parameter$updateZoneRuleset;
    requestBody: RequestBody$updateZoneRuleset["application/json"];
}
export interface Params$deleteZoneRuleset {
    parameter: Parameter$deleteZoneRuleset;
}
export type RequestContentType$createZoneRulesetRule = keyof RequestBody$createZoneRulesetRule;
export type ResponseContentType$createZoneRulesetRule = keyof Response$createZoneRulesetRule$Status$200;
export interface Params$createZoneRulesetRule {
    parameter: Parameter$createZoneRulesetRule;
    requestBody: RequestBody$createZoneRulesetRule["application/json"];
}
export type ResponseContentType$deleteZoneRulesetRule = keyof Response$deleteZoneRulesetRule$Status$200;
export interface Params$deleteZoneRulesetRule {
    parameter: Parameter$deleteZoneRulesetRule;
}
export type RequestContentType$updateZoneRulesetRule = keyof RequestBody$updateZoneRulesetRule;
export type ResponseContentType$updateZoneRulesetRule = keyof Response$updateZoneRulesetRule$Status$200;
export interface Params$updateZoneRulesetRule {
    parameter: Parameter$updateZoneRulesetRule;
    requestBody: RequestBody$updateZoneRulesetRule["application/json"];
}
export type ResponseContentType$listZoneRulesetVersions = keyof Response$listZoneRulesetVersions$Status$200;
export interface Params$listZoneRulesetVersions {
    parameter: Parameter$listZoneRulesetVersions;
}
export type ResponseContentType$getZoneRulesetVersion = keyof Response$getZoneRulesetVersion$Status$200;
export interface Params$getZoneRulesetVersion {
    parameter: Parameter$getZoneRulesetVersion;
}
export interface Params$deleteZoneRulesetVersion {
    parameter: Parameter$deleteZoneRulesetVersion;
}
export type ResponseContentType$getZoneEntrypointRuleset = keyof Response$getZoneEntrypointRuleset$Status$200;
export interface Params$getZoneEntrypointRuleset {
    parameter: Parameter$getZoneEntrypointRuleset;
}
export type RequestContentType$updateZoneEntrypointRuleset = keyof RequestBody$updateZoneEntrypointRuleset;
export type ResponseContentType$updateZoneEntrypointRuleset = keyof Response$updateZoneEntrypointRuleset$Status$200;
export interface Params$updateZoneEntrypointRuleset {
    parameter: Parameter$updateZoneEntrypointRuleset;
    requestBody: RequestBody$updateZoneEntrypointRuleset["application/json"];
}
export type ResponseContentType$listZoneEntrypointRulesetVersions = keyof Response$listZoneEntrypointRulesetVersions$Status$200;
export interface Params$listZoneEntrypointRulesetVersions {
    parameter: Parameter$listZoneEntrypointRulesetVersions;
}
export type ResponseContentType$getZoneEntrypointRulesetVersion = keyof Response$getZoneEntrypointRulesetVersion$Status$200;
export interface Params$getZoneEntrypointRulesetVersion {
    parameter: Parameter$getZoneEntrypointRulesetVersion;
}
export type ResponseContentType$zone$settings$get$all$zone$settings = keyof Response$zone$settings$get$all$zone$settings$Status$200;
export interface Params$zone$settings$get$all$zone$settings {
    parameter: Parameter$zone$settings$get$all$zone$settings;
}
export type RequestContentType$zone$settings$edit$zone$settings$info = keyof RequestBody$zone$settings$edit$zone$settings$info;
export type ResponseContentType$zone$settings$edit$zone$settings$info = keyof Response$zone$settings$edit$zone$settings$info$Status$200;
export interface Params$zone$settings$edit$zone$settings$info {
    parameter: Parameter$zone$settings$edit$zone$settings$info;
    requestBody: RequestBody$zone$settings$edit$zone$settings$info["application/json"];
}
export type ResponseContentType$zone$settings$get$0$rtt$session$resumption$setting = keyof Response$zone$settings$get$0$rtt$session$resumption$setting$Status$200;
export interface Params$zone$settings$get$0$rtt$session$resumption$setting {
    parameter: Parameter$zone$settings$get$0$rtt$session$resumption$setting;
}
export type RequestContentType$zone$settings$change$0$rtt$session$resumption$setting = keyof RequestBody$zone$settings$change$0$rtt$session$resumption$setting;
export type ResponseContentType$zone$settings$change$0$rtt$session$resumption$setting = keyof Response$zone$settings$change$0$rtt$session$resumption$setting$Status$200;
export interface Params$zone$settings$change$0$rtt$session$resumption$setting {
    parameter: Parameter$zone$settings$change$0$rtt$session$resumption$setting;
    requestBody: RequestBody$zone$settings$change$0$rtt$session$resumption$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$advanced$ddos$setting = keyof Response$zone$settings$get$advanced$ddos$setting$Status$200;
export interface Params$zone$settings$get$advanced$ddos$setting {
    parameter: Parameter$zone$settings$get$advanced$ddos$setting;
}
export type ResponseContentType$zone$settings$get$always$online$setting = keyof Response$zone$settings$get$always$online$setting$Status$200;
export interface Params$zone$settings$get$always$online$setting {
    parameter: Parameter$zone$settings$get$always$online$setting;
}
export type RequestContentType$zone$settings$change$always$online$setting = keyof RequestBody$zone$settings$change$always$online$setting;
export type ResponseContentType$zone$settings$change$always$online$setting = keyof Response$zone$settings$change$always$online$setting$Status$200;
export interface Params$zone$settings$change$always$online$setting {
    parameter: Parameter$zone$settings$change$always$online$setting;
    requestBody: RequestBody$zone$settings$change$always$online$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$always$use$https$setting = keyof Response$zone$settings$get$always$use$https$setting$Status$200;
export interface Params$zone$settings$get$always$use$https$setting {
    parameter: Parameter$zone$settings$get$always$use$https$setting;
}
export type RequestContentType$zone$settings$change$always$use$https$setting = keyof RequestBody$zone$settings$change$always$use$https$setting;
export type ResponseContentType$zone$settings$change$always$use$https$setting = keyof Response$zone$settings$change$always$use$https$setting$Status$200;
export interface Params$zone$settings$change$always$use$https$setting {
    parameter: Parameter$zone$settings$change$always$use$https$setting;
    requestBody: RequestBody$zone$settings$change$always$use$https$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$automatic$https$rewrites$setting = keyof Response$zone$settings$get$automatic$https$rewrites$setting$Status$200;
export interface Params$zone$settings$get$automatic$https$rewrites$setting {
    parameter: Parameter$zone$settings$get$automatic$https$rewrites$setting;
}
export type RequestContentType$zone$settings$change$automatic$https$rewrites$setting = keyof RequestBody$zone$settings$change$automatic$https$rewrites$setting;
export type ResponseContentType$zone$settings$change$automatic$https$rewrites$setting = keyof Response$zone$settings$change$automatic$https$rewrites$setting$Status$200;
export interface Params$zone$settings$change$automatic$https$rewrites$setting {
    parameter: Parameter$zone$settings$change$automatic$https$rewrites$setting;
    requestBody: RequestBody$zone$settings$change$automatic$https$rewrites$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$automatic_platform_optimization$setting = keyof Response$zone$settings$get$automatic_platform_optimization$setting$Status$200;
export interface Params$zone$settings$get$automatic_platform_optimization$setting {
    parameter: Parameter$zone$settings$get$automatic_platform_optimization$setting;
}
export type RequestContentType$zone$settings$change$automatic_platform_optimization$setting = keyof RequestBody$zone$settings$change$automatic_platform_optimization$setting;
export type ResponseContentType$zone$settings$change$automatic_platform_optimization$setting = keyof Response$zone$settings$change$automatic_platform_optimization$setting$Status$200;
export interface Params$zone$settings$change$automatic_platform_optimization$setting {
    parameter: Parameter$zone$settings$change$automatic_platform_optimization$setting;
    requestBody: RequestBody$zone$settings$change$automatic_platform_optimization$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$brotli$setting = keyof Response$zone$settings$get$brotli$setting$Status$200;
export interface Params$zone$settings$get$brotli$setting {
    parameter: Parameter$zone$settings$get$brotli$setting;
}
export type RequestContentType$zone$settings$change$brotli$setting = keyof RequestBody$zone$settings$change$brotli$setting;
export type ResponseContentType$zone$settings$change$brotli$setting = keyof Response$zone$settings$change$brotli$setting$Status$200;
export interface Params$zone$settings$change$brotli$setting {
    parameter: Parameter$zone$settings$change$brotli$setting;
    requestBody: RequestBody$zone$settings$change$brotli$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$browser$cache$ttl$setting = keyof Response$zone$settings$get$browser$cache$ttl$setting$Status$200;
export interface Params$zone$settings$get$browser$cache$ttl$setting {
    parameter: Parameter$zone$settings$get$browser$cache$ttl$setting;
}
export type RequestContentType$zone$settings$change$browser$cache$ttl$setting = keyof RequestBody$zone$settings$change$browser$cache$ttl$setting;
export type ResponseContentType$zone$settings$change$browser$cache$ttl$setting = keyof Response$zone$settings$change$browser$cache$ttl$setting$Status$200;
export interface Params$zone$settings$change$browser$cache$ttl$setting {
    parameter: Parameter$zone$settings$change$browser$cache$ttl$setting;
    requestBody: RequestBody$zone$settings$change$browser$cache$ttl$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$browser$check$setting = keyof Response$zone$settings$get$browser$check$setting$Status$200;
export interface Params$zone$settings$get$browser$check$setting {
    parameter: Parameter$zone$settings$get$browser$check$setting;
}
export type RequestContentType$zone$settings$change$browser$check$setting = keyof RequestBody$zone$settings$change$browser$check$setting;
export type ResponseContentType$zone$settings$change$browser$check$setting = keyof Response$zone$settings$change$browser$check$setting$Status$200;
export interface Params$zone$settings$change$browser$check$setting {
    parameter: Parameter$zone$settings$change$browser$check$setting;
    requestBody: RequestBody$zone$settings$change$browser$check$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$cache$level$setting = keyof Response$zone$settings$get$cache$level$setting$Status$200;
export interface Params$zone$settings$get$cache$level$setting {
    parameter: Parameter$zone$settings$get$cache$level$setting;
}
export type RequestContentType$zone$settings$change$cache$level$setting = keyof RequestBody$zone$settings$change$cache$level$setting;
export type ResponseContentType$zone$settings$change$cache$level$setting = keyof Response$zone$settings$change$cache$level$setting$Status$200;
export interface Params$zone$settings$change$cache$level$setting {
    parameter: Parameter$zone$settings$change$cache$level$setting;
    requestBody: RequestBody$zone$settings$change$cache$level$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$challenge$ttl$setting = keyof Response$zone$settings$get$challenge$ttl$setting$Status$200;
export interface Params$zone$settings$get$challenge$ttl$setting {
    parameter: Parameter$zone$settings$get$challenge$ttl$setting;
}
export type RequestContentType$zone$settings$change$challenge$ttl$setting = keyof RequestBody$zone$settings$change$challenge$ttl$setting;
export type ResponseContentType$zone$settings$change$challenge$ttl$setting = keyof Response$zone$settings$change$challenge$ttl$setting$Status$200;
export interface Params$zone$settings$change$challenge$ttl$setting {
    parameter: Parameter$zone$settings$change$challenge$ttl$setting;
    requestBody: RequestBody$zone$settings$change$challenge$ttl$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$ciphers$setting = keyof Response$zone$settings$get$ciphers$setting$Status$200;
export interface Params$zone$settings$get$ciphers$setting {
    parameter: Parameter$zone$settings$get$ciphers$setting;
}
export type RequestContentType$zone$settings$change$ciphers$setting = keyof RequestBody$zone$settings$change$ciphers$setting;
export type ResponseContentType$zone$settings$change$ciphers$setting = keyof Response$zone$settings$change$ciphers$setting$Status$200;
export interface Params$zone$settings$change$ciphers$setting {
    parameter: Parameter$zone$settings$change$ciphers$setting;
    requestBody: RequestBody$zone$settings$change$ciphers$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$development$mode$setting = keyof Response$zone$settings$get$development$mode$setting$Status$200;
export interface Params$zone$settings$get$development$mode$setting {
    parameter: Parameter$zone$settings$get$development$mode$setting;
}
export type RequestContentType$zone$settings$change$development$mode$setting = keyof RequestBody$zone$settings$change$development$mode$setting;
export type ResponseContentType$zone$settings$change$development$mode$setting = keyof Response$zone$settings$change$development$mode$setting$Status$200;
export interface Params$zone$settings$change$development$mode$setting {
    parameter: Parameter$zone$settings$change$development$mode$setting;
    requestBody: RequestBody$zone$settings$change$development$mode$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$early$hints$setting = keyof Response$zone$settings$get$early$hints$setting$Status$200;
export interface Params$zone$settings$get$early$hints$setting {
    parameter: Parameter$zone$settings$get$early$hints$setting;
}
export type RequestContentType$zone$settings$change$early$hints$setting = keyof RequestBody$zone$settings$change$early$hints$setting;
export type ResponseContentType$zone$settings$change$early$hints$setting = keyof Response$zone$settings$change$early$hints$setting$Status$200;
export interface Params$zone$settings$change$early$hints$setting {
    parameter: Parameter$zone$settings$change$early$hints$setting;
    requestBody: RequestBody$zone$settings$change$early$hints$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$email$obfuscation$setting = keyof Response$zone$settings$get$email$obfuscation$setting$Status$200;
export interface Params$zone$settings$get$email$obfuscation$setting {
    parameter: Parameter$zone$settings$get$email$obfuscation$setting;
}
export type RequestContentType$zone$settings$change$email$obfuscation$setting = keyof RequestBody$zone$settings$change$email$obfuscation$setting;
export type ResponseContentType$zone$settings$change$email$obfuscation$setting = keyof Response$zone$settings$change$email$obfuscation$setting$Status$200;
export interface Params$zone$settings$change$email$obfuscation$setting {
    parameter: Parameter$zone$settings$change$email$obfuscation$setting;
    requestBody: RequestBody$zone$settings$change$email$obfuscation$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$fonts$setting = keyof Response$zone$settings$get$fonts$setting$Status$200;
export interface Params$zone$settings$get$fonts$setting {
    parameter: Parameter$zone$settings$get$fonts$setting;
}
export type RequestContentType$zone$settings$change$fonts$setting = keyof RequestBody$zone$settings$change$fonts$setting;
export type ResponseContentType$zone$settings$change$fonts$setting = keyof Response$zone$settings$change$fonts$setting$Status$200;
export interface Params$zone$settings$change$fonts$setting {
    parameter: Parameter$zone$settings$change$fonts$setting;
    requestBody: RequestBody$zone$settings$change$fonts$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$h2_prioritization$setting = keyof Response$zone$settings$get$h2_prioritization$setting$Status$200;
export interface Params$zone$settings$get$h2_prioritization$setting {
    parameter: Parameter$zone$settings$get$h2_prioritization$setting;
}
export type RequestContentType$zone$settings$change$h2_prioritization$setting = keyof RequestBody$zone$settings$change$h2_prioritization$setting;
export type ResponseContentType$zone$settings$change$h2_prioritization$setting = keyof Response$zone$settings$change$h2_prioritization$setting$Status$200;
export interface Params$zone$settings$change$h2_prioritization$setting {
    parameter: Parameter$zone$settings$change$h2_prioritization$setting;
    requestBody: RequestBody$zone$settings$change$h2_prioritization$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$hotlink$protection$setting = keyof Response$zone$settings$get$hotlink$protection$setting$Status$200;
export interface Params$zone$settings$get$hotlink$protection$setting {
    parameter: Parameter$zone$settings$get$hotlink$protection$setting;
}
export type RequestContentType$zone$settings$change$hotlink$protection$setting = keyof RequestBody$zone$settings$change$hotlink$protection$setting;
export type ResponseContentType$zone$settings$change$hotlink$protection$setting = keyof Response$zone$settings$change$hotlink$protection$setting$Status$200;
export interface Params$zone$settings$change$hotlink$protection$setting {
    parameter: Parameter$zone$settings$change$hotlink$protection$setting;
    requestBody: RequestBody$zone$settings$change$hotlink$protection$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$h$t$t$p$2$setting = keyof Response$zone$settings$get$h$t$t$p$2$setting$Status$200;
export interface Params$zone$settings$get$h$t$t$p$2$setting {
    parameter: Parameter$zone$settings$get$h$t$t$p$2$setting;
}
export type RequestContentType$zone$settings$change$h$t$t$p$2$setting = keyof RequestBody$zone$settings$change$h$t$t$p$2$setting;
export type ResponseContentType$zone$settings$change$h$t$t$p$2$setting = keyof Response$zone$settings$change$h$t$t$p$2$setting$Status$200;
export interface Params$zone$settings$change$h$t$t$p$2$setting {
    parameter: Parameter$zone$settings$change$h$t$t$p$2$setting;
    requestBody: RequestBody$zone$settings$change$h$t$t$p$2$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$h$t$t$p$3$setting = keyof Response$zone$settings$get$h$t$t$p$3$setting$Status$200;
export interface Params$zone$settings$get$h$t$t$p$3$setting {
    parameter: Parameter$zone$settings$get$h$t$t$p$3$setting;
}
export type RequestContentType$zone$settings$change$h$t$t$p$3$setting = keyof RequestBody$zone$settings$change$h$t$t$p$3$setting;
export type ResponseContentType$zone$settings$change$h$t$t$p$3$setting = keyof Response$zone$settings$change$h$t$t$p$3$setting$Status$200;
export interface Params$zone$settings$change$h$t$t$p$3$setting {
    parameter: Parameter$zone$settings$change$h$t$t$p$3$setting;
    requestBody: RequestBody$zone$settings$change$h$t$t$p$3$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$image_resizing$setting = keyof Response$zone$settings$get$image_resizing$setting$Status$200;
export interface Params$zone$settings$get$image_resizing$setting {
    parameter: Parameter$zone$settings$get$image_resizing$setting;
}
export type RequestContentType$zone$settings$change$image_resizing$setting = keyof RequestBody$zone$settings$change$image_resizing$setting;
export type ResponseContentType$zone$settings$change$image_resizing$setting = keyof Response$zone$settings$change$image_resizing$setting$Status$200;
export interface Params$zone$settings$change$image_resizing$setting {
    parameter: Parameter$zone$settings$change$image_resizing$setting;
    requestBody: RequestBody$zone$settings$change$image_resizing$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$ip$geolocation$setting = keyof Response$zone$settings$get$ip$geolocation$setting$Status$200;
export interface Params$zone$settings$get$ip$geolocation$setting {
    parameter: Parameter$zone$settings$get$ip$geolocation$setting;
}
export type RequestContentType$zone$settings$change$ip$geolocation$setting = keyof RequestBody$zone$settings$change$ip$geolocation$setting;
export type ResponseContentType$zone$settings$change$ip$geolocation$setting = keyof Response$zone$settings$change$ip$geolocation$setting$Status$200;
export interface Params$zone$settings$change$ip$geolocation$setting {
    parameter: Parameter$zone$settings$change$ip$geolocation$setting;
    requestBody: RequestBody$zone$settings$change$ip$geolocation$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$i$pv6$setting = keyof Response$zone$settings$get$i$pv6$setting$Status$200;
export interface Params$zone$settings$get$i$pv6$setting {
    parameter: Parameter$zone$settings$get$i$pv6$setting;
}
export type RequestContentType$zone$settings$change$i$pv6$setting = keyof RequestBody$zone$settings$change$i$pv6$setting;
export type ResponseContentType$zone$settings$change$i$pv6$setting = keyof Response$zone$settings$change$i$pv6$setting$Status$200;
export interface Params$zone$settings$change$i$pv6$setting {
    parameter: Parameter$zone$settings$change$i$pv6$setting;
    requestBody: RequestBody$zone$settings$change$i$pv6$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$minimum$tls$version$setting = keyof Response$zone$settings$get$minimum$tls$version$setting$Status$200;
export interface Params$zone$settings$get$minimum$tls$version$setting {
    parameter: Parameter$zone$settings$get$minimum$tls$version$setting;
}
export type RequestContentType$zone$settings$change$minimum$tls$version$setting = keyof RequestBody$zone$settings$change$minimum$tls$version$setting;
export type ResponseContentType$zone$settings$change$minimum$tls$version$setting = keyof Response$zone$settings$change$minimum$tls$version$setting$Status$200;
export interface Params$zone$settings$change$minimum$tls$version$setting {
    parameter: Parameter$zone$settings$change$minimum$tls$version$setting;
    requestBody: RequestBody$zone$settings$change$minimum$tls$version$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$minify$setting = keyof Response$zone$settings$get$minify$setting$Status$200;
export interface Params$zone$settings$get$minify$setting {
    parameter: Parameter$zone$settings$get$minify$setting;
}
export type RequestContentType$zone$settings$change$minify$setting = keyof RequestBody$zone$settings$change$minify$setting;
export type ResponseContentType$zone$settings$change$minify$setting = keyof Response$zone$settings$change$minify$setting$Status$200;
export interface Params$zone$settings$change$minify$setting {
    parameter: Parameter$zone$settings$change$minify$setting;
    requestBody: RequestBody$zone$settings$change$minify$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$mirage$setting = keyof Response$zone$settings$get$mirage$setting$Status$200;
export interface Params$zone$settings$get$mirage$setting {
    parameter: Parameter$zone$settings$get$mirage$setting;
}
export type RequestContentType$zone$settings$change$web$mirage$setting = keyof RequestBody$zone$settings$change$web$mirage$setting;
export type ResponseContentType$zone$settings$change$web$mirage$setting = keyof Response$zone$settings$change$web$mirage$setting$Status$200;
export interface Params$zone$settings$change$web$mirage$setting {
    parameter: Parameter$zone$settings$change$web$mirage$setting;
    requestBody: RequestBody$zone$settings$change$web$mirage$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$mobile$redirect$setting = keyof Response$zone$settings$get$mobile$redirect$setting$Status$200;
export interface Params$zone$settings$get$mobile$redirect$setting {
    parameter: Parameter$zone$settings$get$mobile$redirect$setting;
}
export type RequestContentType$zone$settings$change$mobile$redirect$setting = keyof RequestBody$zone$settings$change$mobile$redirect$setting;
export type ResponseContentType$zone$settings$change$mobile$redirect$setting = keyof Response$zone$settings$change$mobile$redirect$setting$Status$200;
export interface Params$zone$settings$change$mobile$redirect$setting {
    parameter: Parameter$zone$settings$change$mobile$redirect$setting;
    requestBody: RequestBody$zone$settings$change$mobile$redirect$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$nel$setting = keyof Response$zone$settings$get$nel$setting$Status$200;
export interface Params$zone$settings$get$nel$setting {
    parameter: Parameter$zone$settings$get$nel$setting;
}
export type RequestContentType$zone$settings$change$nel$setting = keyof RequestBody$zone$settings$change$nel$setting;
export type ResponseContentType$zone$settings$change$nel$setting = keyof Response$zone$settings$change$nel$setting$Status$200;
export interface Params$zone$settings$change$nel$setting {
    parameter: Parameter$zone$settings$change$nel$setting;
    requestBody: RequestBody$zone$settings$change$nel$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$opportunistic$encryption$setting = keyof Response$zone$settings$get$opportunistic$encryption$setting$Status$200;
export interface Params$zone$settings$get$opportunistic$encryption$setting {
    parameter: Parameter$zone$settings$get$opportunistic$encryption$setting;
}
export type RequestContentType$zone$settings$change$opportunistic$encryption$setting = keyof RequestBody$zone$settings$change$opportunistic$encryption$setting;
export type ResponseContentType$zone$settings$change$opportunistic$encryption$setting = keyof Response$zone$settings$change$opportunistic$encryption$setting$Status$200;
export interface Params$zone$settings$change$opportunistic$encryption$setting {
    parameter: Parameter$zone$settings$change$opportunistic$encryption$setting;
    requestBody: RequestBody$zone$settings$change$opportunistic$encryption$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$opportunistic$onion$setting = keyof Response$zone$settings$get$opportunistic$onion$setting$Status$200;
export interface Params$zone$settings$get$opportunistic$onion$setting {
    parameter: Parameter$zone$settings$get$opportunistic$onion$setting;
}
export type RequestContentType$zone$settings$change$opportunistic$onion$setting = keyof RequestBody$zone$settings$change$opportunistic$onion$setting;
export type ResponseContentType$zone$settings$change$opportunistic$onion$setting = keyof Response$zone$settings$change$opportunistic$onion$setting$Status$200;
export interface Params$zone$settings$change$opportunistic$onion$setting {
    parameter: Parameter$zone$settings$change$opportunistic$onion$setting;
    requestBody: RequestBody$zone$settings$change$opportunistic$onion$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$orange_to_orange$setting = keyof Response$zone$settings$get$orange_to_orange$setting$Status$200;
export interface Params$zone$settings$get$orange_to_orange$setting {
    parameter: Parameter$zone$settings$get$orange_to_orange$setting;
}
export type RequestContentType$zone$settings$change$orange_to_orange$setting = keyof RequestBody$zone$settings$change$orange_to_orange$setting;
export type ResponseContentType$zone$settings$change$orange_to_orange$setting = keyof Response$zone$settings$change$orange_to_orange$setting$Status$200;
export interface Params$zone$settings$change$orange_to_orange$setting {
    parameter: Parameter$zone$settings$change$orange_to_orange$setting;
    requestBody: RequestBody$zone$settings$change$orange_to_orange$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$enable$error$pages$on$setting = keyof Response$zone$settings$get$enable$error$pages$on$setting$Status$200;
export interface Params$zone$settings$get$enable$error$pages$on$setting {
    parameter: Parameter$zone$settings$get$enable$error$pages$on$setting;
}
export type RequestContentType$zone$settings$change$enable$error$pages$on$setting = keyof RequestBody$zone$settings$change$enable$error$pages$on$setting;
export type ResponseContentType$zone$settings$change$enable$error$pages$on$setting = keyof Response$zone$settings$change$enable$error$pages$on$setting$Status$200;
export interface Params$zone$settings$change$enable$error$pages$on$setting {
    parameter: Parameter$zone$settings$change$enable$error$pages$on$setting;
    requestBody: RequestBody$zone$settings$change$enable$error$pages$on$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$polish$setting = keyof Response$zone$settings$get$polish$setting$Status$200;
export interface Params$zone$settings$get$polish$setting {
    parameter: Parameter$zone$settings$get$polish$setting;
}
export type RequestContentType$zone$settings$change$polish$setting = keyof RequestBody$zone$settings$change$polish$setting;
export type ResponseContentType$zone$settings$change$polish$setting = keyof Response$zone$settings$change$polish$setting$Status$200;
export interface Params$zone$settings$change$polish$setting {
    parameter: Parameter$zone$settings$change$polish$setting;
    requestBody: RequestBody$zone$settings$change$polish$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$prefetch$preload$setting = keyof Response$zone$settings$get$prefetch$preload$setting$Status$200;
export interface Params$zone$settings$get$prefetch$preload$setting {
    parameter: Parameter$zone$settings$get$prefetch$preload$setting;
}
export type RequestContentType$zone$settings$change$prefetch$preload$setting = keyof RequestBody$zone$settings$change$prefetch$preload$setting;
export type ResponseContentType$zone$settings$change$prefetch$preload$setting = keyof Response$zone$settings$change$prefetch$preload$setting$Status$200;
export interface Params$zone$settings$change$prefetch$preload$setting {
    parameter: Parameter$zone$settings$change$prefetch$preload$setting;
    requestBody: RequestBody$zone$settings$change$prefetch$preload$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$proxy_read_timeout$setting = keyof Response$zone$settings$get$proxy_read_timeout$setting$Status$200;
export interface Params$zone$settings$get$proxy_read_timeout$setting {
    parameter: Parameter$zone$settings$get$proxy_read_timeout$setting;
}
export type RequestContentType$zone$settings$change$proxy_read_timeout$setting = keyof RequestBody$zone$settings$change$proxy_read_timeout$setting;
export type ResponseContentType$zone$settings$change$proxy_read_timeout$setting = keyof Response$zone$settings$change$proxy_read_timeout$setting$Status$200;
export interface Params$zone$settings$change$proxy_read_timeout$setting {
    parameter: Parameter$zone$settings$change$proxy_read_timeout$setting;
    requestBody: RequestBody$zone$settings$change$proxy_read_timeout$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$pseudo$i$pv4$setting = keyof Response$zone$settings$get$pseudo$i$pv4$setting$Status$200;
export interface Params$zone$settings$get$pseudo$i$pv4$setting {
    parameter: Parameter$zone$settings$get$pseudo$i$pv4$setting;
}
export type RequestContentType$zone$settings$change$pseudo$i$pv4$setting = keyof RequestBody$zone$settings$change$pseudo$i$pv4$setting;
export type ResponseContentType$zone$settings$change$pseudo$i$pv4$setting = keyof Response$zone$settings$change$pseudo$i$pv4$setting$Status$200;
export interface Params$zone$settings$change$pseudo$i$pv4$setting {
    parameter: Parameter$zone$settings$change$pseudo$i$pv4$setting;
    requestBody: RequestBody$zone$settings$change$pseudo$i$pv4$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$response$buffering$setting = keyof Response$zone$settings$get$response$buffering$setting$Status$200;
export interface Params$zone$settings$get$response$buffering$setting {
    parameter: Parameter$zone$settings$get$response$buffering$setting;
}
export type RequestContentType$zone$settings$change$response$buffering$setting = keyof RequestBody$zone$settings$change$response$buffering$setting;
export type ResponseContentType$zone$settings$change$response$buffering$setting = keyof Response$zone$settings$change$response$buffering$setting$Status$200;
export interface Params$zone$settings$change$response$buffering$setting {
    parameter: Parameter$zone$settings$change$response$buffering$setting;
    requestBody: RequestBody$zone$settings$change$response$buffering$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$rocket_loader$setting = keyof Response$zone$settings$get$rocket_loader$setting$Status$200;
export interface Params$zone$settings$get$rocket_loader$setting {
    parameter: Parameter$zone$settings$get$rocket_loader$setting;
}
export type RequestContentType$zone$settings$change$rocket_loader$setting = keyof RequestBody$zone$settings$change$rocket_loader$setting;
export type ResponseContentType$zone$settings$change$rocket_loader$setting = keyof Response$zone$settings$change$rocket_loader$setting$Status$200;
export interface Params$zone$settings$change$rocket_loader$setting {
    parameter: Parameter$zone$settings$change$rocket_loader$setting;
    requestBody: RequestBody$zone$settings$change$rocket_loader$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$security$header$$$hsts$$setting = keyof Response$zone$settings$get$security$header$$$hsts$$setting$Status$200;
export interface Params$zone$settings$get$security$header$$$hsts$$setting {
    parameter: Parameter$zone$settings$get$security$header$$$hsts$$setting;
}
export type RequestContentType$zone$settings$change$security$header$$$hsts$$setting = keyof RequestBody$zone$settings$change$security$header$$$hsts$$setting;
export type ResponseContentType$zone$settings$change$security$header$$$hsts$$setting = keyof Response$zone$settings$change$security$header$$$hsts$$setting$Status$200;
export interface Params$zone$settings$change$security$header$$$hsts$$setting {
    parameter: Parameter$zone$settings$change$security$header$$$hsts$$setting;
    requestBody: RequestBody$zone$settings$change$security$header$$$hsts$$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$security$level$setting = keyof Response$zone$settings$get$security$level$setting$Status$200;
export interface Params$zone$settings$get$security$level$setting {
    parameter: Parameter$zone$settings$get$security$level$setting;
}
export type RequestContentType$zone$settings$change$security$level$setting = keyof RequestBody$zone$settings$change$security$level$setting;
export type ResponseContentType$zone$settings$change$security$level$setting = keyof Response$zone$settings$change$security$level$setting$Status$200;
export interface Params$zone$settings$change$security$level$setting {
    parameter: Parameter$zone$settings$change$security$level$setting;
    requestBody: RequestBody$zone$settings$change$security$level$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$server$side$exclude$setting = keyof Response$zone$settings$get$server$side$exclude$setting$Status$200;
export interface Params$zone$settings$get$server$side$exclude$setting {
    parameter: Parameter$zone$settings$get$server$side$exclude$setting;
}
export type RequestContentType$zone$settings$change$server$side$exclude$setting = keyof RequestBody$zone$settings$change$server$side$exclude$setting;
export type ResponseContentType$zone$settings$change$server$side$exclude$setting = keyof Response$zone$settings$change$server$side$exclude$setting$Status$200;
export interface Params$zone$settings$change$server$side$exclude$setting {
    parameter: Parameter$zone$settings$change$server$side$exclude$setting;
    requestBody: RequestBody$zone$settings$change$server$side$exclude$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$enable$query$string$sort$setting = keyof Response$zone$settings$get$enable$query$string$sort$setting$Status$200;
export interface Params$zone$settings$get$enable$query$string$sort$setting {
    parameter: Parameter$zone$settings$get$enable$query$string$sort$setting;
}
export type RequestContentType$zone$settings$change$enable$query$string$sort$setting = keyof RequestBody$zone$settings$change$enable$query$string$sort$setting;
export type ResponseContentType$zone$settings$change$enable$query$string$sort$setting = keyof Response$zone$settings$change$enable$query$string$sort$setting$Status$200;
export interface Params$zone$settings$change$enable$query$string$sort$setting {
    parameter: Parameter$zone$settings$change$enable$query$string$sort$setting;
    requestBody: RequestBody$zone$settings$change$enable$query$string$sort$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$ssl$setting = keyof Response$zone$settings$get$ssl$setting$Status$200;
export interface Params$zone$settings$get$ssl$setting {
    parameter: Parameter$zone$settings$get$ssl$setting;
}
export type RequestContentType$zone$settings$change$ssl$setting = keyof RequestBody$zone$settings$change$ssl$setting;
export type ResponseContentType$zone$settings$change$ssl$setting = keyof Response$zone$settings$change$ssl$setting$Status$200;
export interface Params$zone$settings$change$ssl$setting {
    parameter: Parameter$zone$settings$change$ssl$setting;
    requestBody: RequestBody$zone$settings$change$ssl$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$ssl_recommender$setting = keyof Response$zone$settings$get$ssl_recommender$setting$Status$200;
export interface Params$zone$settings$get$ssl_recommender$setting {
    parameter: Parameter$zone$settings$get$ssl_recommender$setting;
}
export type RequestContentType$zone$settings$change$ssl_recommender$setting = keyof RequestBody$zone$settings$change$ssl_recommender$setting;
export type ResponseContentType$zone$settings$change$ssl_recommender$setting = keyof Response$zone$settings$change$ssl_recommender$setting$Status$200;
export interface Params$zone$settings$change$ssl_recommender$setting {
    parameter: Parameter$zone$settings$change$ssl_recommender$setting;
    requestBody: RequestBody$zone$settings$change$ssl_recommender$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone = keyof Response$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone$Status$200;
export interface Params$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone {
    parameter: Parameter$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone;
}
export type RequestContentType$zone$settings$change$tls$1$$3$setting = keyof RequestBody$zone$settings$change$tls$1$$3$setting;
export type ResponseContentType$zone$settings$change$tls$1$$3$setting = keyof Response$zone$settings$change$tls$1$$3$setting$Status$200;
export interface Params$zone$settings$change$tls$1$$3$setting {
    parameter: Parameter$zone$settings$change$tls$1$$3$setting;
    requestBody: RequestBody$zone$settings$change$tls$1$$3$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$tls$client$auth$setting = keyof Response$zone$settings$get$tls$client$auth$setting$Status$200;
export interface Params$zone$settings$get$tls$client$auth$setting {
    parameter: Parameter$zone$settings$get$tls$client$auth$setting;
}
export type RequestContentType$zone$settings$change$tls$client$auth$setting = keyof RequestBody$zone$settings$change$tls$client$auth$setting;
export type ResponseContentType$zone$settings$change$tls$client$auth$setting = keyof Response$zone$settings$change$tls$client$auth$setting$Status$200;
export interface Params$zone$settings$change$tls$client$auth$setting {
    parameter: Parameter$zone$settings$change$tls$client$auth$setting;
    requestBody: RequestBody$zone$settings$change$tls$client$auth$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$true$client$ip$setting = keyof Response$zone$settings$get$true$client$ip$setting$Status$200;
export interface Params$zone$settings$get$true$client$ip$setting {
    parameter: Parameter$zone$settings$get$true$client$ip$setting;
}
export type RequestContentType$zone$settings$change$true$client$ip$setting = keyof RequestBody$zone$settings$change$true$client$ip$setting;
export type ResponseContentType$zone$settings$change$true$client$ip$setting = keyof Response$zone$settings$change$true$client$ip$setting$Status$200;
export interface Params$zone$settings$change$true$client$ip$setting {
    parameter: Parameter$zone$settings$change$true$client$ip$setting;
    requestBody: RequestBody$zone$settings$change$true$client$ip$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$web$application$firewall$$$waf$$setting = keyof Response$zone$settings$get$web$application$firewall$$$waf$$setting$Status$200;
export interface Params$zone$settings$get$web$application$firewall$$$waf$$setting {
    parameter: Parameter$zone$settings$get$web$application$firewall$$$waf$$setting;
}
export type RequestContentType$zone$settings$change$web$application$firewall$$$waf$$setting = keyof RequestBody$zone$settings$change$web$application$firewall$$$waf$$setting;
export type ResponseContentType$zone$settings$change$web$application$firewall$$$waf$$setting = keyof Response$zone$settings$change$web$application$firewall$$$waf$$setting$Status$200;
export interface Params$zone$settings$change$web$application$firewall$$$waf$$setting {
    parameter: Parameter$zone$settings$change$web$application$firewall$$$waf$$setting;
    requestBody: RequestBody$zone$settings$change$web$application$firewall$$$waf$$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$web$p$setting = keyof Response$zone$settings$get$web$p$setting$Status$200;
export interface Params$zone$settings$get$web$p$setting {
    parameter: Parameter$zone$settings$get$web$p$setting;
}
export type RequestContentType$zone$settings$change$web$p$setting = keyof RequestBody$zone$settings$change$web$p$setting;
export type ResponseContentType$zone$settings$change$web$p$setting = keyof Response$zone$settings$change$web$p$setting$Status$200;
export interface Params$zone$settings$change$web$p$setting {
    parameter: Parameter$zone$settings$change$web$p$setting;
    requestBody: RequestBody$zone$settings$change$web$p$setting["application/json"];
}
export type ResponseContentType$zone$settings$get$web$sockets$setting = keyof Response$zone$settings$get$web$sockets$setting$Status$200;
export interface Params$zone$settings$get$web$sockets$setting {
    parameter: Parameter$zone$settings$get$web$sockets$setting;
}
export type RequestContentType$zone$settings$change$web$sockets$setting = keyof RequestBody$zone$settings$change$web$sockets$setting;
export type ResponseContentType$zone$settings$change$web$sockets$setting = keyof Response$zone$settings$change$web$sockets$setting$Status$200;
export interface Params$zone$settings$change$web$sockets$setting {
    parameter: Parameter$zone$settings$change$web$sockets$setting;
    requestBody: RequestBody$zone$settings$change$web$sockets$setting["application/json"];
}
export type ResponseContentType$get$zones$zone_identifier$zaraz$config = keyof Response$get$zones$zone_identifier$zaraz$config$Status$200;
export interface Params$get$zones$zone_identifier$zaraz$config {
    parameter: Parameter$get$zones$zone_identifier$zaraz$config;
}
export type RequestContentType$put$zones$zone_identifier$zaraz$config = keyof RequestBody$put$zones$zone_identifier$zaraz$config;
export type ResponseContentType$put$zones$zone_identifier$zaraz$config = keyof Response$put$zones$zone_identifier$zaraz$config$Status$200;
export interface Params$put$zones$zone_identifier$zaraz$config {
    parameter: Parameter$put$zones$zone_identifier$zaraz$config;
    requestBody: RequestBody$put$zones$zone_identifier$zaraz$config["application/json"];
}
export type ResponseContentType$get$zones$zone_identifier$zaraz$default = keyof Response$get$zones$zone_identifier$zaraz$default$Status$200;
export interface Params$get$zones$zone_identifier$zaraz$default {
    parameter: Parameter$get$zones$zone_identifier$zaraz$default;
}
export type ResponseContentType$get$zones$zone_identifier$zaraz$export = keyof Response$get$zones$zone_identifier$zaraz$export$Status$200;
export interface Params$get$zones$zone_identifier$zaraz$export {
    parameter: Parameter$get$zones$zone_identifier$zaraz$export;
}
export type ResponseContentType$get$zones$zone_identifier$zaraz$history = keyof Response$get$zones$zone_identifier$zaraz$history$Status$200;
export interface Params$get$zones$zone_identifier$zaraz$history {
    parameter: Parameter$get$zones$zone_identifier$zaraz$history;
}
export type RequestContentType$put$zones$zone_identifier$zaraz$history = keyof RequestBody$put$zones$zone_identifier$zaraz$history;
export type ResponseContentType$put$zones$zone_identifier$zaraz$history = keyof Response$put$zones$zone_identifier$zaraz$history$Status$200;
export interface Params$put$zones$zone_identifier$zaraz$history {
    parameter: Parameter$put$zones$zone_identifier$zaraz$history;
    requestBody: RequestBody$put$zones$zone_identifier$zaraz$history["application/json"];
}
export type ResponseContentType$get$zones$zone_identifier$zaraz$config$history = keyof Response$get$zones$zone_identifier$zaraz$config$history$Status$200;
export interface Params$get$zones$zone_identifier$zaraz$config$history {
    parameter: Parameter$get$zones$zone_identifier$zaraz$config$history;
}
export type RequestContentType$post$zones$zone_identifier$zaraz$publish = keyof RequestBody$post$zones$zone_identifier$zaraz$publish;
export type ResponseContentType$post$zones$zone_identifier$zaraz$publish = keyof Response$post$zones$zone_identifier$zaraz$publish$Status$200;
export interface Params$post$zones$zone_identifier$zaraz$publish {
    parameter: Parameter$post$zones$zone_identifier$zaraz$publish;
    requestBody: RequestBody$post$zones$zone_identifier$zaraz$publish["application/json"];
}
export type ResponseContentType$get$zones$zone_identifier$zaraz$workflow = keyof Response$get$zones$zone_identifier$zaraz$workflow$Status$200;
export interface Params$get$zones$zone_identifier$zaraz$workflow {
    parameter: Parameter$get$zones$zone_identifier$zaraz$workflow;
}
export type RequestContentType$put$zones$zone_identifier$zaraz$workflow = keyof RequestBody$put$zones$zone_identifier$zaraz$workflow;
export type ResponseContentType$put$zones$zone_identifier$zaraz$workflow = keyof Response$put$zones$zone_identifier$zaraz$workflow$Status$200;
export interface Params$put$zones$zone_identifier$zaraz$workflow {
    parameter: Parameter$put$zones$zone_identifier$zaraz$workflow;
    requestBody: RequestBody$put$zones$zone_identifier$zaraz$workflow["application/json"];
}
export type ResponseContentType$speed$get$availabilities = keyof Response$speed$get$availabilities$Status$200;
export interface Params$speed$get$availabilities {
    parameter: Parameter$speed$get$availabilities;
}
export type ResponseContentType$speed$list$pages = keyof Response$speed$list$pages$Status$200;
export interface Params$speed$list$pages {
    parameter: Parameter$speed$list$pages;
}
export type ResponseContentType$speed$list$test$history = keyof Response$speed$list$test$history$Status$200;
export interface Params$speed$list$test$history {
    parameter: Parameter$speed$list$test$history;
}
export type RequestContentType$speed$create$test = keyof RequestBody$speed$create$test;
export type ResponseContentType$speed$create$test = keyof Response$speed$create$test$Status$200;
export interface Params$speed$create$test {
    parameter: Parameter$speed$create$test;
    requestBody: RequestBody$speed$create$test["application/json"];
}
export type ResponseContentType$speed$delete$tests = keyof Response$speed$delete$tests$Status$200;
export interface Params$speed$delete$tests {
    parameter: Parameter$speed$delete$tests;
}
export type ResponseContentType$speed$get$test = keyof Response$speed$get$test$Status$200;
export interface Params$speed$get$test {
    parameter: Parameter$speed$get$test;
}
export type ResponseContentType$speed$list$page$trend = keyof Response$speed$list$page$trend$Status$200;
export interface Params$speed$list$page$trend {
    parameter: Parameter$speed$list$page$trend;
}
export type ResponseContentType$speed$get$scheduled$test = keyof Response$speed$get$scheduled$test$Status$200;
export interface Params$speed$get$scheduled$test {
    parameter: Parameter$speed$get$scheduled$test;
}
export type ResponseContentType$speed$create$scheduled$test = keyof Response$speed$create$scheduled$test$Status$200;
export interface Params$speed$create$scheduled$test {
    parameter: Parameter$speed$create$scheduled$test;
}
export type ResponseContentType$speed$delete$test$schedule = keyof Response$speed$delete$test$schedule$Status$200;
export interface Params$speed$delete$test$schedule {
    parameter: Parameter$speed$delete$test$schedule;
}
export type ResponseContentType$url$normalization$get$url$normalization$settings = keyof Response$url$normalization$get$url$normalization$settings$Status$200;
export interface Params$url$normalization$get$url$normalization$settings {
    parameter: Parameter$url$normalization$get$url$normalization$settings;
}
export type RequestContentType$url$normalization$update$url$normalization$settings = keyof RequestBody$url$normalization$update$url$normalization$settings;
export type ResponseContentType$url$normalization$update$url$normalization$settings = keyof Response$url$normalization$update$url$normalization$settings$Status$200;
export interface Params$url$normalization$update$url$normalization$settings {
    parameter: Parameter$url$normalization$update$url$normalization$settings;
    requestBody: RequestBody$url$normalization$update$url$normalization$settings["application/json"];
}
export type ResponseContentType$worker$filters$$$deprecated$$list$filters = keyof Response$worker$filters$$$deprecated$$list$filters$Status$200;
export interface Params$worker$filters$$$deprecated$$list$filters {
    parameter: Parameter$worker$filters$$$deprecated$$list$filters;
}
export type RequestContentType$worker$filters$$$deprecated$$create$filter = keyof RequestBody$worker$filters$$$deprecated$$create$filter;
export type ResponseContentType$worker$filters$$$deprecated$$create$filter = keyof Response$worker$filters$$$deprecated$$create$filter$Status$200;
export interface Params$worker$filters$$$deprecated$$create$filter {
    parameter: Parameter$worker$filters$$$deprecated$$create$filter;
    requestBody: RequestBody$worker$filters$$$deprecated$$create$filter["application/json"];
}
export type RequestContentType$worker$filters$$$deprecated$$update$filter = keyof RequestBody$worker$filters$$$deprecated$$update$filter;
export type ResponseContentType$worker$filters$$$deprecated$$update$filter = keyof Response$worker$filters$$$deprecated$$update$filter$Status$200;
export interface Params$worker$filters$$$deprecated$$update$filter {
    parameter: Parameter$worker$filters$$$deprecated$$update$filter;
    requestBody: RequestBody$worker$filters$$$deprecated$$update$filter["application/json"];
}
export type ResponseContentType$worker$filters$$$deprecated$$delete$filter = keyof Response$worker$filters$$$deprecated$$delete$filter$Status$200;
export interface Params$worker$filters$$$deprecated$$delete$filter {
    parameter: Parameter$worker$filters$$$deprecated$$delete$filter;
}
export type ResponseContentType$worker$routes$list$routes = keyof Response$worker$routes$list$routes$Status$200;
export interface Params$worker$routes$list$routes {
    parameter: Parameter$worker$routes$list$routes;
}
export type RequestContentType$worker$routes$create$route = keyof RequestBody$worker$routes$create$route;
export type ResponseContentType$worker$routes$create$route = keyof Response$worker$routes$create$route$Status$200;
export interface Params$worker$routes$create$route {
    parameter: Parameter$worker$routes$create$route;
    requestBody: RequestBody$worker$routes$create$route["application/json"];
}
export type ResponseContentType$worker$routes$get$route = keyof Response$worker$routes$get$route$Status$200;
export interface Params$worker$routes$get$route {
    parameter: Parameter$worker$routes$get$route;
}
export type RequestContentType$worker$routes$update$route = keyof RequestBody$worker$routes$update$route;
export type ResponseContentType$worker$routes$update$route = keyof Response$worker$routes$update$route$Status$200;
export interface Params$worker$routes$update$route {
    parameter: Parameter$worker$routes$update$route;
    requestBody: RequestBody$worker$routes$update$route["application/json"];
}
export type ResponseContentType$worker$routes$delete$route = keyof Response$worker$routes$delete$route$Status$200;
export interface Params$worker$routes$delete$route {
    parameter: Parameter$worker$routes$delete$route;
}
export type ResponseContentType$worker$script$$$deprecated$$download$worker = keyof Response$worker$script$$$deprecated$$download$worker$Status$200;
export interface Params$worker$script$$$deprecated$$download$worker {
    parameter: Parameter$worker$script$$$deprecated$$download$worker;
}
export type RequestContentType$worker$script$$$deprecated$$upload$worker = keyof RequestBody$worker$script$$$deprecated$$upload$worker;
export type ResponseContentType$worker$script$$$deprecated$$upload$worker = keyof Response$worker$script$$$deprecated$$upload$worker$Status$200;
export interface Params$worker$script$$$deprecated$$upload$worker {
    parameter: Parameter$worker$script$$$deprecated$$upload$worker;
    requestBody: RequestBody$worker$script$$$deprecated$$upload$worker["application/javascript"];
}
export interface Params$worker$script$$$deprecated$$delete$worker {
    parameter: Parameter$worker$script$$$deprecated$$delete$worker;
}
export type ResponseContentType$worker$binding$$$deprecated$$list$bindings = keyof Response$worker$binding$$$deprecated$$list$bindings$Status$200;
export interface Params$worker$binding$$$deprecated$$list$bindings {
    parameter: Parameter$worker$binding$$$deprecated$$list$bindings;
}
export type ResponseContentType$total$tls$total$tls$settings$details = keyof Response$total$tls$total$tls$settings$details$Status$200;
export interface Params$total$tls$total$tls$settings$details {
    parameter: Parameter$total$tls$total$tls$settings$details;
}
export type RequestContentType$total$tls$enable$or$disable$total$tls = keyof RequestBody$total$tls$enable$or$disable$total$tls;
export type ResponseContentType$total$tls$enable$or$disable$total$tls = keyof Response$total$tls$enable$or$disable$total$tls$Status$200;
export interface Params$total$tls$enable$or$disable$total$tls {
    parameter: Parameter$total$tls$enable$or$disable$total$tls;
    requestBody: RequestBody$total$tls$enable$or$disable$total$tls["application/json"];
}
export type ResponseContentType$zone$analytics$$$deprecated$$get$analytics$by$co$locations = keyof Response$zone$analytics$$$deprecated$$get$analytics$by$co$locations$Status$200;
export interface Params$zone$analytics$$$deprecated$$get$analytics$by$co$locations {
    parameter: Parameter$zone$analytics$$$deprecated$$get$analytics$by$co$locations;
}
export type ResponseContentType$zone$analytics$$$deprecated$$get$dashboard = keyof Response$zone$analytics$$$deprecated$$get$dashboard$Status$200;
export interface Params$zone$analytics$$$deprecated$$get$dashboard {
    parameter: Parameter$zone$analytics$$$deprecated$$get$dashboard;
}
export type ResponseContentType$zone$rate$plan$list$available$plans = keyof Response$zone$rate$plan$list$available$plans$Status$200;
export interface Params$zone$rate$plan$list$available$plans {
    parameter: Parameter$zone$rate$plan$list$available$plans;
}
export type ResponseContentType$zone$rate$plan$available$plan$details = keyof Response$zone$rate$plan$available$plan$details$Status$200;
export interface Params$zone$rate$plan$available$plan$details {
    parameter: Parameter$zone$rate$plan$available$plan$details;
}
export type ResponseContentType$zone$rate$plan$list$available$rate$plans = keyof Response$zone$rate$plan$list$available$rate$plans$Status$200;
export interface Params$zone$rate$plan$list$available$rate$plans {
    parameter: Parameter$zone$rate$plan$list$available$rate$plans;
}
export type ResponseContentType$client$certificate$for$a$zone$list$hostname$associations = keyof Response$client$certificate$for$a$zone$list$hostname$associations$Status$200;
export interface Params$client$certificate$for$a$zone$list$hostname$associations {
    parameter: Parameter$client$certificate$for$a$zone$list$hostname$associations;
}
export type RequestContentType$client$certificate$for$a$zone$put$hostname$associations = keyof RequestBody$client$certificate$for$a$zone$put$hostname$associations;
export type ResponseContentType$client$certificate$for$a$zone$put$hostname$associations = keyof Response$client$certificate$for$a$zone$put$hostname$associations$Status$200;
export interface Params$client$certificate$for$a$zone$put$hostname$associations {
    parameter: Parameter$client$certificate$for$a$zone$put$hostname$associations;
    requestBody: RequestBody$client$certificate$for$a$zone$put$hostname$associations["application/json"];
}
export type ResponseContentType$client$certificate$for$a$zone$list$client$certificates = keyof Response$client$certificate$for$a$zone$list$client$certificates$Status$200;
export interface Params$client$certificate$for$a$zone$list$client$certificates {
    parameter: Parameter$client$certificate$for$a$zone$list$client$certificates;
}
export type RequestContentType$client$certificate$for$a$zone$create$client$certificate = keyof RequestBody$client$certificate$for$a$zone$create$client$certificate;
export type ResponseContentType$client$certificate$for$a$zone$create$client$certificate = keyof Response$client$certificate$for$a$zone$create$client$certificate$Status$200;
export interface Params$client$certificate$for$a$zone$create$client$certificate {
    parameter: Parameter$client$certificate$for$a$zone$create$client$certificate;
    requestBody: RequestBody$client$certificate$for$a$zone$create$client$certificate["application/json"];
}
export type ResponseContentType$client$certificate$for$a$zone$client$certificate$details = keyof Response$client$certificate$for$a$zone$client$certificate$details$Status$200;
export interface Params$client$certificate$for$a$zone$client$certificate$details {
    parameter: Parameter$client$certificate$for$a$zone$client$certificate$details;
}
export type ResponseContentType$client$certificate$for$a$zone$delete$client$certificate = keyof Response$client$certificate$for$a$zone$delete$client$certificate$Status$200;
export interface Params$client$certificate$for$a$zone$delete$client$certificate {
    parameter: Parameter$client$certificate$for$a$zone$delete$client$certificate;
}
export type ResponseContentType$client$certificate$for$a$zone$edit$client$certificate = keyof Response$client$certificate$for$a$zone$edit$client$certificate$Status$200;
export interface Params$client$certificate$for$a$zone$edit$client$certificate {
    parameter: Parameter$client$certificate$for$a$zone$edit$client$certificate;
}
export type ResponseContentType$custom$ssl$for$a$zone$list$ssl$configurations = keyof Response$custom$ssl$for$a$zone$list$ssl$configurations$Status$200;
export interface Params$custom$ssl$for$a$zone$list$ssl$configurations {
    parameter: Parameter$custom$ssl$for$a$zone$list$ssl$configurations;
}
export type RequestContentType$custom$ssl$for$a$zone$create$ssl$configuration = keyof RequestBody$custom$ssl$for$a$zone$create$ssl$configuration;
export type ResponseContentType$custom$ssl$for$a$zone$create$ssl$configuration = keyof Response$custom$ssl$for$a$zone$create$ssl$configuration$Status$200;
export interface Params$custom$ssl$for$a$zone$create$ssl$configuration {
    parameter: Parameter$custom$ssl$for$a$zone$create$ssl$configuration;
    requestBody: RequestBody$custom$ssl$for$a$zone$create$ssl$configuration["application/json"];
}
export type ResponseContentType$custom$ssl$for$a$zone$ssl$configuration$details = keyof Response$custom$ssl$for$a$zone$ssl$configuration$details$Status$200;
export interface Params$custom$ssl$for$a$zone$ssl$configuration$details {
    parameter: Parameter$custom$ssl$for$a$zone$ssl$configuration$details;
}
export type ResponseContentType$custom$ssl$for$a$zone$delete$ssl$configuration = keyof Response$custom$ssl$for$a$zone$delete$ssl$configuration$Status$200;
export interface Params$custom$ssl$for$a$zone$delete$ssl$configuration {
    parameter: Parameter$custom$ssl$for$a$zone$delete$ssl$configuration;
}
export type RequestContentType$custom$ssl$for$a$zone$edit$ssl$configuration = keyof RequestBody$custom$ssl$for$a$zone$edit$ssl$configuration;
export type ResponseContentType$custom$ssl$for$a$zone$edit$ssl$configuration = keyof Response$custom$ssl$for$a$zone$edit$ssl$configuration$Status$200;
export interface Params$custom$ssl$for$a$zone$edit$ssl$configuration {
    parameter: Parameter$custom$ssl$for$a$zone$edit$ssl$configuration;
    requestBody: RequestBody$custom$ssl$for$a$zone$edit$ssl$configuration["application/json"];
}
export type RequestContentType$custom$ssl$for$a$zone$re$prioritize$ssl$certificates = keyof RequestBody$custom$ssl$for$a$zone$re$prioritize$ssl$certificates;
export type ResponseContentType$custom$ssl$for$a$zone$re$prioritize$ssl$certificates = keyof Response$custom$ssl$for$a$zone$re$prioritize$ssl$certificates$Status$200;
export interface Params$custom$ssl$for$a$zone$re$prioritize$ssl$certificates {
    parameter: Parameter$custom$ssl$for$a$zone$re$prioritize$ssl$certificates;
    requestBody: RequestBody$custom$ssl$for$a$zone$re$prioritize$ssl$certificates["application/json"];
}
export type ResponseContentType$custom$hostname$for$a$zone$list$custom$hostnames = keyof Response$custom$hostname$for$a$zone$list$custom$hostnames$Status$200;
export interface Params$custom$hostname$for$a$zone$list$custom$hostnames {
    parameter: Parameter$custom$hostname$for$a$zone$list$custom$hostnames;
}
export type RequestContentType$custom$hostname$for$a$zone$create$custom$hostname = keyof RequestBody$custom$hostname$for$a$zone$create$custom$hostname;
export type ResponseContentType$custom$hostname$for$a$zone$create$custom$hostname = keyof Response$custom$hostname$for$a$zone$create$custom$hostname$Status$200;
export interface Params$custom$hostname$for$a$zone$create$custom$hostname {
    parameter: Parameter$custom$hostname$for$a$zone$create$custom$hostname;
    requestBody: RequestBody$custom$hostname$for$a$zone$create$custom$hostname["application/json"];
}
export type ResponseContentType$custom$hostname$for$a$zone$custom$hostname$details = keyof Response$custom$hostname$for$a$zone$custom$hostname$details$Status$200;
export interface Params$custom$hostname$for$a$zone$custom$hostname$details {
    parameter: Parameter$custom$hostname$for$a$zone$custom$hostname$details;
}
export type ResponseContentType$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$ = keyof Response$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$$Status$200;
export interface Params$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$ {
    parameter: Parameter$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$;
}
export type RequestContentType$custom$hostname$for$a$zone$edit$custom$hostname = keyof RequestBody$custom$hostname$for$a$zone$edit$custom$hostname;
export type ResponseContentType$custom$hostname$for$a$zone$edit$custom$hostname = keyof Response$custom$hostname$for$a$zone$edit$custom$hostname$Status$200;
export interface Params$custom$hostname$for$a$zone$edit$custom$hostname {
    parameter: Parameter$custom$hostname$for$a$zone$edit$custom$hostname;
    requestBody: RequestBody$custom$hostname$for$a$zone$edit$custom$hostname["application/json"];
}
export type ResponseContentType$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames = keyof Response$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames$Status$200;
export interface Params$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames {
    parameter: Parameter$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames;
}
export type RequestContentType$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames = keyof RequestBody$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames;
export type ResponseContentType$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames = keyof Response$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames$Status$200;
export interface Params$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames {
    parameter: Parameter$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames;
    requestBody: RequestBody$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames["application/json"];
}
export type ResponseContentType$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames = keyof Response$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames$Status$200;
export interface Params$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames {
    parameter: Parameter$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames;
}
export type ResponseContentType$custom$pages$for$a$zone$list$custom$pages = keyof Response$custom$pages$for$a$zone$list$custom$pages$Status$200;
export interface Params$custom$pages$for$a$zone$list$custom$pages {
    parameter: Parameter$custom$pages$for$a$zone$list$custom$pages;
}
export type ResponseContentType$custom$pages$for$a$zone$get$a$custom$page = keyof Response$custom$pages$for$a$zone$get$a$custom$page$Status$200;
export interface Params$custom$pages$for$a$zone$get$a$custom$page {
    parameter: Parameter$custom$pages$for$a$zone$get$a$custom$page;
}
export type RequestContentType$custom$pages$for$a$zone$update$a$custom$page = keyof RequestBody$custom$pages$for$a$zone$update$a$custom$page;
export type ResponseContentType$custom$pages$for$a$zone$update$a$custom$page = keyof Response$custom$pages$for$a$zone$update$a$custom$page$Status$200;
export interface Params$custom$pages$for$a$zone$update$a$custom$page {
    parameter: Parameter$custom$pages$for$a$zone$update$a$custom$page;
    requestBody: RequestBody$custom$pages$for$a$zone$update$a$custom$page["application/json"];
}
export type ResponseContentType$dcv$delegation$uuid$get = keyof Response$dcv$delegation$uuid$get$Status$200;
export interface Params$dcv$delegation$uuid$get {
    parameter: Parameter$dcv$delegation$uuid$get;
}
export type ResponseContentType$email$routing$settings$get$email$routing$settings = keyof Response$email$routing$settings$get$email$routing$settings$Status$200;
export interface Params$email$routing$settings$get$email$routing$settings {
    parameter: Parameter$email$routing$settings$get$email$routing$settings;
}
export type ResponseContentType$email$routing$settings$disable$email$routing = keyof Response$email$routing$settings$disable$email$routing$Status$200;
export interface Params$email$routing$settings$disable$email$routing {
    parameter: Parameter$email$routing$settings$disable$email$routing;
}
export type ResponseContentType$email$routing$settings$email$routing$dns$settings = keyof Response$email$routing$settings$email$routing$dns$settings$Status$200;
export interface Params$email$routing$settings$email$routing$dns$settings {
    parameter: Parameter$email$routing$settings$email$routing$dns$settings;
}
export type ResponseContentType$email$routing$settings$enable$email$routing = keyof Response$email$routing$settings$enable$email$routing$Status$200;
export interface Params$email$routing$settings$enable$email$routing {
    parameter: Parameter$email$routing$settings$enable$email$routing;
}
export type ResponseContentType$email$routing$routing$rules$list$routing$rules = keyof Response$email$routing$routing$rules$list$routing$rules$Status$200;
export interface Params$email$routing$routing$rules$list$routing$rules {
    parameter: Parameter$email$routing$routing$rules$list$routing$rules;
}
export type RequestContentType$email$routing$routing$rules$create$routing$rule = keyof RequestBody$email$routing$routing$rules$create$routing$rule;
export type ResponseContentType$email$routing$routing$rules$create$routing$rule = keyof Response$email$routing$routing$rules$create$routing$rule$Status$200;
export interface Params$email$routing$routing$rules$create$routing$rule {
    parameter: Parameter$email$routing$routing$rules$create$routing$rule;
    requestBody: RequestBody$email$routing$routing$rules$create$routing$rule["application/json"];
}
export type ResponseContentType$email$routing$routing$rules$get$routing$rule = keyof Response$email$routing$routing$rules$get$routing$rule$Status$200;
export interface Params$email$routing$routing$rules$get$routing$rule {
    parameter: Parameter$email$routing$routing$rules$get$routing$rule;
}
export type RequestContentType$email$routing$routing$rules$update$routing$rule = keyof RequestBody$email$routing$routing$rules$update$routing$rule;
export type ResponseContentType$email$routing$routing$rules$update$routing$rule = keyof Response$email$routing$routing$rules$update$routing$rule$Status$200;
export interface Params$email$routing$routing$rules$update$routing$rule {
    parameter: Parameter$email$routing$routing$rules$update$routing$rule;
    requestBody: RequestBody$email$routing$routing$rules$update$routing$rule["application/json"];
}
export type ResponseContentType$email$routing$routing$rules$delete$routing$rule = keyof Response$email$routing$routing$rules$delete$routing$rule$Status$200;
export interface Params$email$routing$routing$rules$delete$routing$rule {
    parameter: Parameter$email$routing$routing$rules$delete$routing$rule;
}
export type ResponseContentType$email$routing$routing$rules$get$catch$all$rule = keyof Response$email$routing$routing$rules$get$catch$all$rule$Status$200;
export interface Params$email$routing$routing$rules$get$catch$all$rule {
    parameter: Parameter$email$routing$routing$rules$get$catch$all$rule;
}
export type RequestContentType$email$routing$routing$rules$update$catch$all$rule = keyof RequestBody$email$routing$routing$rules$update$catch$all$rule;
export type ResponseContentType$email$routing$routing$rules$update$catch$all$rule = keyof Response$email$routing$routing$rules$update$catch$all$rule$Status$200;
export interface Params$email$routing$routing$rules$update$catch$all$rule {
    parameter: Parameter$email$routing$routing$rules$update$catch$all$rule;
    requestBody: RequestBody$email$routing$routing$rules$update$catch$all$rule["application/json"];
}
export type ResponseContentType$filters$list$filters = keyof Response$filters$list$filters$Status$200;
export interface Params$filters$list$filters {
    parameter: Parameter$filters$list$filters;
}
export type RequestContentType$filters$update$filters = keyof RequestBody$filters$update$filters;
export type ResponseContentType$filters$update$filters = keyof Response$filters$update$filters$Status$200;
export interface Params$filters$update$filters {
    parameter: Parameter$filters$update$filters;
    requestBody: RequestBody$filters$update$filters["application/json"];
}
export type RequestContentType$filters$create$filters = keyof RequestBody$filters$create$filters;
export type ResponseContentType$filters$create$filters = keyof Response$filters$create$filters$Status$200;
export interface Params$filters$create$filters {
    parameter: Parameter$filters$create$filters;
    requestBody: RequestBody$filters$create$filters["application/json"];
}
export type RequestContentType$filters$delete$filters = keyof RequestBody$filters$delete$filters;
export type ResponseContentType$filters$delete$filters = keyof Response$filters$delete$filters$Status$200;
export interface Params$filters$delete$filters {
    parameter: Parameter$filters$delete$filters;
    requestBody: RequestBody$filters$delete$filters["application/json"];
}
export type ResponseContentType$filters$get$a$filter = keyof Response$filters$get$a$filter$Status$200;
export interface Params$filters$get$a$filter {
    parameter: Parameter$filters$get$a$filter;
}
export type RequestContentType$filters$update$a$filter = keyof RequestBody$filters$update$a$filter;
export type ResponseContentType$filters$update$a$filter = keyof Response$filters$update$a$filter$Status$200;
export interface Params$filters$update$a$filter {
    parameter: Parameter$filters$update$a$filter;
    requestBody: RequestBody$filters$update$a$filter["application/json"];
}
export type ResponseContentType$filters$delete$a$filter = keyof Response$filters$delete$a$filter$Status$200;
export interface Params$filters$delete$a$filter {
    parameter: Parameter$filters$delete$a$filter;
}
export type ResponseContentType$zone$lockdown$list$zone$lockdown$rules = keyof Response$zone$lockdown$list$zone$lockdown$rules$Status$200;
export interface Params$zone$lockdown$list$zone$lockdown$rules {
    parameter: Parameter$zone$lockdown$list$zone$lockdown$rules;
}
export type RequestContentType$zone$lockdown$create$a$zone$lockdown$rule = keyof RequestBody$zone$lockdown$create$a$zone$lockdown$rule;
export type ResponseContentType$zone$lockdown$create$a$zone$lockdown$rule = keyof Response$zone$lockdown$create$a$zone$lockdown$rule$Status$200;
export interface Params$zone$lockdown$create$a$zone$lockdown$rule {
    parameter: Parameter$zone$lockdown$create$a$zone$lockdown$rule;
    requestBody: RequestBody$zone$lockdown$create$a$zone$lockdown$rule["application/json"];
}
export type ResponseContentType$zone$lockdown$get$a$zone$lockdown$rule = keyof Response$zone$lockdown$get$a$zone$lockdown$rule$Status$200;
export interface Params$zone$lockdown$get$a$zone$lockdown$rule {
    parameter: Parameter$zone$lockdown$get$a$zone$lockdown$rule;
}
export type RequestContentType$zone$lockdown$update$a$zone$lockdown$rule = keyof RequestBody$zone$lockdown$update$a$zone$lockdown$rule;
export type ResponseContentType$zone$lockdown$update$a$zone$lockdown$rule = keyof Response$zone$lockdown$update$a$zone$lockdown$rule$Status$200;
export interface Params$zone$lockdown$update$a$zone$lockdown$rule {
    parameter: Parameter$zone$lockdown$update$a$zone$lockdown$rule;
    requestBody: RequestBody$zone$lockdown$update$a$zone$lockdown$rule["application/json"];
}
export type ResponseContentType$zone$lockdown$delete$a$zone$lockdown$rule = keyof Response$zone$lockdown$delete$a$zone$lockdown$rule$Status$200;
export interface Params$zone$lockdown$delete$a$zone$lockdown$rule {
    parameter: Parameter$zone$lockdown$delete$a$zone$lockdown$rule;
}
export type ResponseContentType$firewall$rules$list$firewall$rules = keyof Response$firewall$rules$list$firewall$rules$Status$200;
export interface Params$firewall$rules$list$firewall$rules {
    parameter: Parameter$firewall$rules$list$firewall$rules;
}
export type RequestContentType$firewall$rules$update$firewall$rules = keyof RequestBody$firewall$rules$update$firewall$rules;
export type ResponseContentType$firewall$rules$update$firewall$rules = keyof Response$firewall$rules$update$firewall$rules$Status$200;
export interface Params$firewall$rules$update$firewall$rules {
    parameter: Parameter$firewall$rules$update$firewall$rules;
    requestBody: RequestBody$firewall$rules$update$firewall$rules["application/json"];
}
export type RequestContentType$firewall$rules$create$firewall$rules = keyof RequestBody$firewall$rules$create$firewall$rules;
export type ResponseContentType$firewall$rules$create$firewall$rules = keyof Response$firewall$rules$create$firewall$rules$Status$200;
export interface Params$firewall$rules$create$firewall$rules {
    parameter: Parameter$firewall$rules$create$firewall$rules;
    requestBody: RequestBody$firewall$rules$create$firewall$rules["application/json"];
}
export type RequestContentType$firewall$rules$delete$firewall$rules = keyof RequestBody$firewall$rules$delete$firewall$rules;
export type ResponseContentType$firewall$rules$delete$firewall$rules = keyof Response$firewall$rules$delete$firewall$rules$Status$200;
export interface Params$firewall$rules$delete$firewall$rules {
    parameter: Parameter$firewall$rules$delete$firewall$rules;
    requestBody: RequestBody$firewall$rules$delete$firewall$rules["application/json"];
}
export type RequestContentType$firewall$rules$update$priority$of$firewall$rules = keyof RequestBody$firewall$rules$update$priority$of$firewall$rules;
export type ResponseContentType$firewall$rules$update$priority$of$firewall$rules = keyof Response$firewall$rules$update$priority$of$firewall$rules$Status$200;
export interface Params$firewall$rules$update$priority$of$firewall$rules {
    parameter: Parameter$firewall$rules$update$priority$of$firewall$rules;
    requestBody: RequestBody$firewall$rules$update$priority$of$firewall$rules["application/json"];
}
export type ResponseContentType$firewall$rules$get$a$firewall$rule = keyof Response$firewall$rules$get$a$firewall$rule$Status$200;
export interface Params$firewall$rules$get$a$firewall$rule {
    parameter: Parameter$firewall$rules$get$a$firewall$rule;
}
export type RequestContentType$firewall$rules$update$a$firewall$rule = keyof RequestBody$firewall$rules$update$a$firewall$rule;
export type ResponseContentType$firewall$rules$update$a$firewall$rule = keyof Response$firewall$rules$update$a$firewall$rule$Status$200;
export interface Params$firewall$rules$update$a$firewall$rule {
    parameter: Parameter$firewall$rules$update$a$firewall$rule;
    requestBody: RequestBody$firewall$rules$update$a$firewall$rule["application/json"];
}
export type RequestContentType$firewall$rules$delete$a$firewall$rule = keyof RequestBody$firewall$rules$delete$a$firewall$rule;
export type ResponseContentType$firewall$rules$delete$a$firewall$rule = keyof Response$firewall$rules$delete$a$firewall$rule$Status$200;
export interface Params$firewall$rules$delete$a$firewall$rule {
    parameter: Parameter$firewall$rules$delete$a$firewall$rule;
    requestBody: RequestBody$firewall$rules$delete$a$firewall$rule["application/json"];
}
export type RequestContentType$firewall$rules$update$priority$of$a$firewall$rule = keyof RequestBody$firewall$rules$update$priority$of$a$firewall$rule;
export type ResponseContentType$firewall$rules$update$priority$of$a$firewall$rule = keyof Response$firewall$rules$update$priority$of$a$firewall$rule$Status$200;
export interface Params$firewall$rules$update$priority$of$a$firewall$rule {
    parameter: Parameter$firewall$rules$update$priority$of$a$firewall$rule;
    requestBody: RequestBody$firewall$rules$update$priority$of$a$firewall$rule["application/json"];
}
export type ResponseContentType$user$agent$blocking$rules$list$user$agent$blocking$rules = keyof Response$user$agent$blocking$rules$list$user$agent$blocking$rules$Status$200;
export interface Params$user$agent$blocking$rules$list$user$agent$blocking$rules {
    parameter: Parameter$user$agent$blocking$rules$list$user$agent$blocking$rules;
}
export type RequestContentType$user$agent$blocking$rules$create$a$user$agent$blocking$rule = keyof RequestBody$user$agent$blocking$rules$create$a$user$agent$blocking$rule;
export type ResponseContentType$user$agent$blocking$rules$create$a$user$agent$blocking$rule = keyof Response$user$agent$blocking$rules$create$a$user$agent$blocking$rule$Status$200;
export interface Params$user$agent$blocking$rules$create$a$user$agent$blocking$rule {
    parameter: Parameter$user$agent$blocking$rules$create$a$user$agent$blocking$rule;
    requestBody: RequestBody$user$agent$blocking$rules$create$a$user$agent$blocking$rule["application/json"];
}
export type ResponseContentType$user$agent$blocking$rules$get$a$user$agent$blocking$rule = keyof Response$user$agent$blocking$rules$get$a$user$agent$blocking$rule$Status$200;
export interface Params$user$agent$blocking$rules$get$a$user$agent$blocking$rule {
    parameter: Parameter$user$agent$blocking$rules$get$a$user$agent$blocking$rule;
}
export type RequestContentType$user$agent$blocking$rules$update$a$user$agent$blocking$rule = keyof RequestBody$user$agent$blocking$rules$update$a$user$agent$blocking$rule;
export type ResponseContentType$user$agent$blocking$rules$update$a$user$agent$blocking$rule = keyof Response$user$agent$blocking$rules$update$a$user$agent$blocking$rule$Status$200;
export interface Params$user$agent$blocking$rules$update$a$user$agent$blocking$rule {
    parameter: Parameter$user$agent$blocking$rules$update$a$user$agent$blocking$rule;
    requestBody: RequestBody$user$agent$blocking$rules$update$a$user$agent$blocking$rule["application/json"];
}
export type ResponseContentType$user$agent$blocking$rules$delete$a$user$agent$blocking$rule = keyof Response$user$agent$blocking$rules$delete$a$user$agent$blocking$rule$Status$200;
export interface Params$user$agent$blocking$rules$delete$a$user$agent$blocking$rule {
    parameter: Parameter$user$agent$blocking$rules$delete$a$user$agent$blocking$rule;
}
export type ResponseContentType$waf$overrides$list$waf$overrides = keyof Response$waf$overrides$list$waf$overrides$Status$200;
export interface Params$waf$overrides$list$waf$overrides {
    parameter: Parameter$waf$overrides$list$waf$overrides;
}
export type RequestContentType$waf$overrides$create$a$waf$override = keyof RequestBody$waf$overrides$create$a$waf$override;
export type ResponseContentType$waf$overrides$create$a$waf$override = keyof Response$waf$overrides$create$a$waf$override$Status$200;
export interface Params$waf$overrides$create$a$waf$override {
    parameter: Parameter$waf$overrides$create$a$waf$override;
    requestBody: RequestBody$waf$overrides$create$a$waf$override["application/json"];
}
export type ResponseContentType$waf$overrides$get$a$waf$override = keyof Response$waf$overrides$get$a$waf$override$Status$200;
export interface Params$waf$overrides$get$a$waf$override {
    parameter: Parameter$waf$overrides$get$a$waf$override;
}
export type RequestContentType$waf$overrides$update$waf$override = keyof RequestBody$waf$overrides$update$waf$override;
export type ResponseContentType$waf$overrides$update$waf$override = keyof Response$waf$overrides$update$waf$override$Status$200;
export interface Params$waf$overrides$update$waf$override {
    parameter: Parameter$waf$overrides$update$waf$override;
    requestBody: RequestBody$waf$overrides$update$waf$override["application/json"];
}
export type ResponseContentType$waf$overrides$delete$a$waf$override = keyof Response$waf$overrides$delete$a$waf$override$Status$200;
export interface Params$waf$overrides$delete$a$waf$override {
    parameter: Parameter$waf$overrides$delete$a$waf$override;
}
export type ResponseContentType$waf$packages$list$waf$packages = keyof Response$waf$packages$list$waf$packages$Status$200;
export interface Params$waf$packages$list$waf$packages {
    parameter: Parameter$waf$packages$list$waf$packages;
}
export type ResponseContentType$waf$packages$get$a$waf$package = keyof Response$waf$packages$get$a$waf$package$Status$200;
export interface Params$waf$packages$get$a$waf$package {
    parameter: Parameter$waf$packages$get$a$waf$package;
}
export type RequestContentType$waf$packages$update$a$waf$package = keyof RequestBody$waf$packages$update$a$waf$package;
export type ResponseContentType$waf$packages$update$a$waf$package = keyof Response$waf$packages$update$a$waf$package$Status$200;
export interface Params$waf$packages$update$a$waf$package {
    parameter: Parameter$waf$packages$update$a$waf$package;
    requestBody: RequestBody$waf$packages$update$a$waf$package["application/json"];
}
export type ResponseContentType$health$checks$list$health$checks = keyof Response$health$checks$list$health$checks$Status$200;
export interface Params$health$checks$list$health$checks {
    parameter: Parameter$health$checks$list$health$checks;
}
export type RequestContentType$health$checks$create$health$check = keyof RequestBody$health$checks$create$health$check;
export type ResponseContentType$health$checks$create$health$check = keyof Response$health$checks$create$health$check$Status$200;
export interface Params$health$checks$create$health$check {
    parameter: Parameter$health$checks$create$health$check;
    requestBody: RequestBody$health$checks$create$health$check["application/json"];
}
export type ResponseContentType$health$checks$health$check$details = keyof Response$health$checks$health$check$details$Status$200;
export interface Params$health$checks$health$check$details {
    parameter: Parameter$health$checks$health$check$details;
}
export type RequestContentType$health$checks$update$health$check = keyof RequestBody$health$checks$update$health$check;
export type ResponseContentType$health$checks$update$health$check = keyof Response$health$checks$update$health$check$Status$200;
export interface Params$health$checks$update$health$check {
    parameter: Parameter$health$checks$update$health$check;
    requestBody: RequestBody$health$checks$update$health$check["application/json"];
}
export type ResponseContentType$health$checks$delete$health$check = keyof Response$health$checks$delete$health$check$Status$200;
export interface Params$health$checks$delete$health$check {
    parameter: Parameter$health$checks$delete$health$check;
}
export type RequestContentType$health$checks$patch$health$check = keyof RequestBody$health$checks$patch$health$check;
export type ResponseContentType$health$checks$patch$health$check = keyof Response$health$checks$patch$health$check$Status$200;
export interface Params$health$checks$patch$health$check {
    parameter: Parameter$health$checks$patch$health$check;
    requestBody: RequestBody$health$checks$patch$health$check["application/json"];
}
export type RequestContentType$health$checks$create$preview$health$check = keyof RequestBody$health$checks$create$preview$health$check;
export type ResponseContentType$health$checks$create$preview$health$check = keyof Response$health$checks$create$preview$health$check$Status$200;
export interface Params$health$checks$create$preview$health$check {
    parameter: Parameter$health$checks$create$preview$health$check;
    requestBody: RequestBody$health$checks$create$preview$health$check["application/json"];
}
export type ResponseContentType$health$checks$health$check$preview$details = keyof Response$health$checks$health$check$preview$details$Status$200;
export interface Params$health$checks$health$check$preview$details {
    parameter: Parameter$health$checks$health$check$preview$details;
}
export type ResponseContentType$health$checks$delete$preview$health$check = keyof Response$health$checks$delete$preview$health$check$Status$200;
export interface Params$health$checks$delete$preview$health$check {
    parameter: Parameter$health$checks$delete$preview$health$check;
}
export type ResponseContentType$per$hostname$tls$settings$list = keyof Response$per$hostname$tls$settings$list$Status$200;
export interface Params$per$hostname$tls$settings$list {
    parameter: Parameter$per$hostname$tls$settings$list;
}
export type RequestContentType$per$hostname$tls$settings$put = keyof RequestBody$per$hostname$tls$settings$put;
export type ResponseContentType$per$hostname$tls$settings$put = keyof Response$per$hostname$tls$settings$put$Status$200;
export interface Params$per$hostname$tls$settings$put {
    parameter: Parameter$per$hostname$tls$settings$put;
    requestBody: RequestBody$per$hostname$tls$settings$put["application/json"];
}
export type ResponseContentType$per$hostname$tls$settings$delete = keyof Response$per$hostname$tls$settings$delete$Status$200;
export interface Params$per$hostname$tls$settings$delete {
    parameter: Parameter$per$hostname$tls$settings$delete;
}
export type ResponseContentType$keyless$ssl$for$a$zone$list$keyless$ssl$configurations = keyof Response$keyless$ssl$for$a$zone$list$keyless$ssl$configurations$Status$200;
export interface Params$keyless$ssl$for$a$zone$list$keyless$ssl$configurations {
    parameter: Parameter$keyless$ssl$for$a$zone$list$keyless$ssl$configurations;
}
export type RequestContentType$keyless$ssl$for$a$zone$create$keyless$ssl$configuration = keyof RequestBody$keyless$ssl$for$a$zone$create$keyless$ssl$configuration;
export type ResponseContentType$keyless$ssl$for$a$zone$create$keyless$ssl$configuration = keyof Response$keyless$ssl$for$a$zone$create$keyless$ssl$configuration$Status$200;
export interface Params$keyless$ssl$for$a$zone$create$keyless$ssl$configuration {
    parameter: Parameter$keyless$ssl$for$a$zone$create$keyless$ssl$configuration;
    requestBody: RequestBody$keyless$ssl$for$a$zone$create$keyless$ssl$configuration["application/json"];
}
export type ResponseContentType$keyless$ssl$for$a$zone$get$keyless$ssl$configuration = keyof Response$keyless$ssl$for$a$zone$get$keyless$ssl$configuration$Status$200;
export interface Params$keyless$ssl$for$a$zone$get$keyless$ssl$configuration {
    parameter: Parameter$keyless$ssl$for$a$zone$get$keyless$ssl$configuration;
}
export type ResponseContentType$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration = keyof Response$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration$Status$200;
export interface Params$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration {
    parameter: Parameter$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration;
}
export type RequestContentType$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration = keyof RequestBody$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration;
export type ResponseContentType$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration = keyof Response$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration$Status$200;
export interface Params$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration {
    parameter: Parameter$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration;
    requestBody: RequestBody$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration["application/json"];
}
export type ResponseContentType$logs$received$get$log$retention$flag = keyof Response$logs$received$get$log$retention$flag$Status$200;
export interface Params$logs$received$get$log$retention$flag {
    parameter: Parameter$logs$received$get$log$retention$flag;
}
export type RequestContentType$logs$received$update$log$retention$flag = keyof RequestBody$logs$received$update$log$retention$flag;
export type ResponseContentType$logs$received$update$log$retention$flag = keyof Response$logs$received$update$log$retention$flag$Status$200;
export interface Params$logs$received$update$log$retention$flag {
    parameter: Parameter$logs$received$update$log$retention$flag;
    requestBody: RequestBody$logs$received$update$log$retention$flag["application/json"];
}
export type ResponseContentType$logs$received$get$logs$ray$i$ds = keyof Response$logs$received$get$logs$ray$i$ds$Status$200;
export interface Params$logs$received$get$logs$ray$i$ds {
    parameter: Parameter$logs$received$get$logs$ray$i$ds;
}
export type ResponseContentType$logs$received$get$logs$received = keyof Response$logs$received$get$logs$received$Status$200;
export interface Params$logs$received$get$logs$received {
    parameter: Parameter$logs$received$get$logs$received;
}
export type ResponseContentType$logs$received$list$fields = keyof Response$logs$received$list$fields$Status$200;
export interface Params$logs$received$list$fields {
    parameter: Parameter$logs$received$list$fields;
}
export type ResponseContentType$zone$level$authenticated$origin$pulls$list$certificates = keyof Response$zone$level$authenticated$origin$pulls$list$certificates$Status$200;
export interface Params$zone$level$authenticated$origin$pulls$list$certificates {
    parameter: Parameter$zone$level$authenticated$origin$pulls$list$certificates;
}
export type RequestContentType$zone$level$authenticated$origin$pulls$upload$certificate = keyof RequestBody$zone$level$authenticated$origin$pulls$upload$certificate;
export type ResponseContentType$zone$level$authenticated$origin$pulls$upload$certificate = keyof Response$zone$level$authenticated$origin$pulls$upload$certificate$Status$200;
export interface Params$zone$level$authenticated$origin$pulls$upload$certificate {
    parameter: Parameter$zone$level$authenticated$origin$pulls$upload$certificate;
    requestBody: RequestBody$zone$level$authenticated$origin$pulls$upload$certificate["application/json"];
}
export type ResponseContentType$zone$level$authenticated$origin$pulls$get$certificate$details = keyof Response$zone$level$authenticated$origin$pulls$get$certificate$details$Status$200;
export interface Params$zone$level$authenticated$origin$pulls$get$certificate$details {
    parameter: Parameter$zone$level$authenticated$origin$pulls$get$certificate$details;
}
export type ResponseContentType$zone$level$authenticated$origin$pulls$delete$certificate = keyof Response$zone$level$authenticated$origin$pulls$delete$certificate$Status$200;
export interface Params$zone$level$authenticated$origin$pulls$delete$certificate {
    parameter: Parameter$zone$level$authenticated$origin$pulls$delete$certificate;
}
export type RequestContentType$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication = keyof RequestBody$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication;
export type ResponseContentType$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication = keyof Response$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication$Status$200;
export interface Params$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication {
    parameter: Parameter$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication;
    requestBody: RequestBody$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication["application/json"];
}
export type ResponseContentType$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication = keyof Response$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication$Status$200;
export interface Params$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication {
    parameter: Parameter$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication;
}
export type ResponseContentType$per$hostname$authenticated$origin$pull$list$certificates = keyof Response$per$hostname$authenticated$origin$pull$list$certificates$Status$200;
export interface Params$per$hostname$authenticated$origin$pull$list$certificates {
    parameter: Parameter$per$hostname$authenticated$origin$pull$list$certificates;
}
export type RequestContentType$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate = keyof RequestBody$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate;
export type ResponseContentType$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate = keyof Response$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate$Status$200;
export interface Params$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate {
    parameter: Parameter$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate;
    requestBody: RequestBody$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate["application/json"];
}
export type ResponseContentType$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate = keyof Response$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate$Status$200;
export interface Params$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate {
    parameter: Parameter$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate;
}
export type ResponseContentType$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate = keyof Response$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate$Status$200;
export interface Params$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate {
    parameter: Parameter$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate;
}
export type ResponseContentType$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone = keyof Response$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone$Status$200;
export interface Params$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone {
    parameter: Parameter$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone;
}
export type RequestContentType$zone$level$authenticated$origin$pulls$set$enablement$for$zone = keyof RequestBody$zone$level$authenticated$origin$pulls$set$enablement$for$zone;
export type ResponseContentType$zone$level$authenticated$origin$pulls$set$enablement$for$zone = keyof Response$zone$level$authenticated$origin$pulls$set$enablement$for$zone$Status$200;
export interface Params$zone$level$authenticated$origin$pulls$set$enablement$for$zone {
    parameter: Parameter$zone$level$authenticated$origin$pulls$set$enablement$for$zone;
    requestBody: RequestBody$zone$level$authenticated$origin$pulls$set$enablement$for$zone["application/json"];
}
export type ResponseContentType$rate$limits$for$a$zone$list$rate$limits = keyof Response$rate$limits$for$a$zone$list$rate$limits$Status$200;
export interface Params$rate$limits$for$a$zone$list$rate$limits {
    parameter: Parameter$rate$limits$for$a$zone$list$rate$limits;
}
export type RequestContentType$rate$limits$for$a$zone$create$a$rate$limit = keyof RequestBody$rate$limits$for$a$zone$create$a$rate$limit;
export type ResponseContentType$rate$limits$for$a$zone$create$a$rate$limit = keyof Response$rate$limits$for$a$zone$create$a$rate$limit$Status$200;
export interface Params$rate$limits$for$a$zone$create$a$rate$limit {
    parameter: Parameter$rate$limits$for$a$zone$create$a$rate$limit;
    requestBody: RequestBody$rate$limits$for$a$zone$create$a$rate$limit["application/json"];
}
export type ResponseContentType$rate$limits$for$a$zone$get$a$rate$limit = keyof Response$rate$limits$for$a$zone$get$a$rate$limit$Status$200;
export interface Params$rate$limits$for$a$zone$get$a$rate$limit {
    parameter: Parameter$rate$limits$for$a$zone$get$a$rate$limit;
}
export type RequestContentType$rate$limits$for$a$zone$update$a$rate$limit = keyof RequestBody$rate$limits$for$a$zone$update$a$rate$limit;
export type ResponseContentType$rate$limits$for$a$zone$update$a$rate$limit = keyof Response$rate$limits$for$a$zone$update$a$rate$limit$Status$200;
export interface Params$rate$limits$for$a$zone$update$a$rate$limit {
    parameter: Parameter$rate$limits$for$a$zone$update$a$rate$limit;
    requestBody: RequestBody$rate$limits$for$a$zone$update$a$rate$limit["application/json"];
}
export type ResponseContentType$rate$limits$for$a$zone$delete$a$rate$limit = keyof Response$rate$limits$for$a$zone$delete$a$rate$limit$Status$200;
export interface Params$rate$limits$for$a$zone$delete$a$rate$limit {
    parameter: Parameter$rate$limits$for$a$zone$delete$a$rate$limit;
}
export type ResponseContentType$secondary$dns$$$secondary$zone$$force$axfr = keyof Response$secondary$dns$$$secondary$zone$$force$axfr$Status$200;
export interface Params$secondary$dns$$$secondary$zone$$force$axfr {
    parameter: Parameter$secondary$dns$$$secondary$zone$$force$axfr;
}
export type ResponseContentType$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details = keyof Response$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details$Status$200;
export interface Params$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details {
    parameter: Parameter$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details;
}
export type RequestContentType$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration = keyof RequestBody$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration;
export type ResponseContentType$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration = keyof Response$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration$Status$200;
export interface Params$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration {
    parameter: Parameter$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration;
    requestBody: RequestBody$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration["application/json"];
}
export type RequestContentType$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration = keyof RequestBody$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration;
export type ResponseContentType$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration = keyof Response$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration$Status$200;
export interface Params$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration {
    parameter: Parameter$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration;
    requestBody: RequestBody$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration["application/json"];
}
export type ResponseContentType$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration = keyof Response$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration$Status$200;
export interface Params$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration {
    parameter: Parameter$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration;
}
export type ResponseContentType$secondary$dns$$$primary$zone$$primary$zone$configuration$details = keyof Response$secondary$dns$$$primary$zone$$primary$zone$configuration$details$Status$200;
export interface Params$secondary$dns$$$primary$zone$$primary$zone$configuration$details {
    parameter: Parameter$secondary$dns$$$primary$zone$$primary$zone$configuration$details;
}
export type RequestContentType$secondary$dns$$$primary$zone$$update$primary$zone$configuration = keyof RequestBody$secondary$dns$$$primary$zone$$update$primary$zone$configuration;
export type ResponseContentType$secondary$dns$$$primary$zone$$update$primary$zone$configuration = keyof Response$secondary$dns$$$primary$zone$$update$primary$zone$configuration$Status$200;
export interface Params$secondary$dns$$$primary$zone$$update$primary$zone$configuration {
    parameter: Parameter$secondary$dns$$$primary$zone$$update$primary$zone$configuration;
    requestBody: RequestBody$secondary$dns$$$primary$zone$$update$primary$zone$configuration["application/json"];
}
export type RequestContentType$secondary$dns$$$primary$zone$$create$primary$zone$configuration = keyof RequestBody$secondary$dns$$$primary$zone$$create$primary$zone$configuration;
export type ResponseContentType$secondary$dns$$$primary$zone$$create$primary$zone$configuration = keyof Response$secondary$dns$$$primary$zone$$create$primary$zone$configuration$Status$200;
export interface Params$secondary$dns$$$primary$zone$$create$primary$zone$configuration {
    parameter: Parameter$secondary$dns$$$primary$zone$$create$primary$zone$configuration;
    requestBody: RequestBody$secondary$dns$$$primary$zone$$create$primary$zone$configuration["application/json"];
}
export type ResponseContentType$secondary$dns$$$primary$zone$$delete$primary$zone$configuration = keyof Response$secondary$dns$$$primary$zone$$delete$primary$zone$configuration$Status$200;
export interface Params$secondary$dns$$$primary$zone$$delete$primary$zone$configuration {
    parameter: Parameter$secondary$dns$$$primary$zone$$delete$primary$zone$configuration;
}
export type ResponseContentType$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers = keyof Response$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers$Status$200;
export interface Params$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers {
    parameter: Parameter$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers;
}
export type ResponseContentType$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers = keyof Response$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers$Status$200;
export interface Params$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers {
    parameter: Parameter$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers;
}
export type ResponseContentType$secondary$dns$$$primary$zone$$force$dns$notify = keyof Response$secondary$dns$$$primary$zone$$force$dns$notify$Status$200;
export interface Params$secondary$dns$$$primary$zone$$force$dns$notify {
    parameter: Parameter$secondary$dns$$$primary$zone$$force$dns$notify;
}
export type ResponseContentType$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status = keyof Response$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status$Status$200;
export interface Params$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status {
    parameter: Parameter$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status;
}
export type ResponseContentType$zone$snippets = keyof Response$zone$snippets$Status$200;
export interface Params$zone$snippets {
    parameter: Parameter$zone$snippets;
}
export type ResponseContentType$zone$snippets$snippet = keyof Response$zone$snippets$snippet$Status$200;
export interface Params$zone$snippets$snippet {
    parameter: Parameter$zone$snippets$snippet;
}
export type RequestContentType$zone$snippets$snippet$put = keyof RequestBody$zone$snippets$snippet$put;
export type ResponseContentType$zone$snippets$snippet$put = keyof Response$zone$snippets$snippet$put$Status$200;
export interface Params$zone$snippets$snippet$put {
    parameter: Parameter$zone$snippets$snippet$put;
    requestBody: RequestBody$zone$snippets$snippet$put["multipart/form-data"];
}
export type ResponseContentType$zone$snippets$snippet$delete = keyof Response$zone$snippets$snippet$delete$Status$200;
export interface Params$zone$snippets$snippet$delete {
    parameter: Parameter$zone$snippets$snippet$delete;
}
export type ResponseContentType$zone$snippets$snippet$content = keyof Response$zone$snippets$snippet$content$Status$200;
export interface Params$zone$snippets$snippet$content {
    parameter: Parameter$zone$snippets$snippet$content;
}
export type ResponseContentType$zone$snippets$snippet$rules = keyof Response$zone$snippets$snippet$rules$Status$200;
export interface Params$zone$snippets$snippet$rules {
    parameter: Parameter$zone$snippets$snippet$rules;
}
export type RequestContentType$zone$snippets$snippet$rules$put = keyof RequestBody$zone$snippets$snippet$rules$put;
export type ResponseContentType$zone$snippets$snippet$rules$put = keyof Response$zone$snippets$snippet$rules$put$Status$200;
export interface Params$zone$snippets$snippet$rules$put {
    parameter: Parameter$zone$snippets$snippet$rules$put;
    requestBody: RequestBody$zone$snippets$snippet$rules$put["application/json"];
}
export type ResponseContentType$certificate$packs$list$certificate$packs = keyof Response$certificate$packs$list$certificate$packs$Status$200;
export interface Params$certificate$packs$list$certificate$packs {
    parameter: Parameter$certificate$packs$list$certificate$packs;
}
export type ResponseContentType$certificate$packs$get$certificate$pack = keyof Response$certificate$packs$get$certificate$pack$Status$200;
export interface Params$certificate$packs$get$certificate$pack {
    parameter: Parameter$certificate$packs$get$certificate$pack;
}
export type ResponseContentType$certificate$packs$delete$advanced$certificate$manager$certificate$pack = keyof Response$certificate$packs$delete$advanced$certificate$manager$certificate$pack$Status$200;
export interface Params$certificate$packs$delete$advanced$certificate$manager$certificate$pack {
    parameter: Parameter$certificate$packs$delete$advanced$certificate$manager$certificate$pack;
}
export type ResponseContentType$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack = keyof Response$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack$Status$200;
export interface Params$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack {
    parameter: Parameter$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack;
}
export type RequestContentType$certificate$packs$order$advanced$certificate$manager$certificate$pack = keyof RequestBody$certificate$packs$order$advanced$certificate$manager$certificate$pack;
export type ResponseContentType$certificate$packs$order$advanced$certificate$manager$certificate$pack = keyof Response$certificate$packs$order$advanced$certificate$manager$certificate$pack$Status$200;
export interface Params$certificate$packs$order$advanced$certificate$manager$certificate$pack {
    parameter: Parameter$certificate$packs$order$advanced$certificate$manager$certificate$pack;
    requestBody: RequestBody$certificate$packs$order$advanced$certificate$manager$certificate$pack["application/json"];
}
export type ResponseContentType$certificate$packs$get$certificate$pack$quotas = keyof Response$certificate$packs$get$certificate$pack$quotas$Status$200;
export interface Params$certificate$packs$get$certificate$pack$quotas {
    parameter: Parameter$certificate$packs$get$certificate$pack$quotas;
}
export type ResponseContentType$ssl$$tls$mode$recommendation$ssl$$tls$recommendation = keyof Response$ssl$$tls$mode$recommendation$ssl$$tls$recommendation$Status$200;
export interface Params$ssl$$tls$mode$recommendation$ssl$$tls$recommendation {
    parameter: Parameter$ssl$$tls$mode$recommendation$ssl$$tls$recommendation;
}
export type ResponseContentType$universal$ssl$settings$for$a$zone$universal$ssl$settings$details = keyof Response$universal$ssl$settings$for$a$zone$universal$ssl$settings$details$Status$200;
export interface Params$universal$ssl$settings$for$a$zone$universal$ssl$settings$details {
    parameter: Parameter$universal$ssl$settings$for$a$zone$universal$ssl$settings$details;
}
export type RequestContentType$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings = keyof RequestBody$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings;
export type ResponseContentType$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings = keyof Response$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings$Status$200;
export interface Params$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings {
    parameter: Parameter$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings;
    requestBody: RequestBody$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings["application/json"];
}
export type ResponseContentType$ssl$verification$ssl$verification$details = keyof Response$ssl$verification$ssl$verification$details$Status$200;
export interface Params$ssl$verification$ssl$verification$details {
    parameter: Parameter$ssl$verification$ssl$verification$details;
}
export type RequestContentType$ssl$verification$edit$ssl$certificate$pack$validation$method = keyof RequestBody$ssl$verification$edit$ssl$certificate$pack$validation$method;
export type ResponseContentType$ssl$verification$edit$ssl$certificate$pack$validation$method = keyof Response$ssl$verification$edit$ssl$certificate$pack$validation$method$Status$200;
export interface Params$ssl$verification$edit$ssl$certificate$pack$validation$method {
    parameter: Parameter$ssl$verification$edit$ssl$certificate$pack$validation$method;
    requestBody: RequestBody$ssl$verification$edit$ssl$certificate$pack$validation$method["application/json"];
}
export type ResponseContentType$waiting$room$list$waiting$rooms = keyof Response$waiting$room$list$waiting$rooms$Status$200;
export interface Params$waiting$room$list$waiting$rooms {
    parameter: Parameter$waiting$room$list$waiting$rooms;
}
export type RequestContentType$waiting$room$create$waiting$room = keyof RequestBody$waiting$room$create$waiting$room;
export type ResponseContentType$waiting$room$create$waiting$room = keyof Response$waiting$room$create$waiting$room$Status$200;
export interface Params$waiting$room$create$waiting$room {
    parameter: Parameter$waiting$room$create$waiting$room;
    requestBody: RequestBody$waiting$room$create$waiting$room["application/json"];
}
export type ResponseContentType$waiting$room$waiting$room$details = keyof Response$waiting$room$waiting$room$details$Status$200;
export interface Params$waiting$room$waiting$room$details {
    parameter: Parameter$waiting$room$waiting$room$details;
}
export type RequestContentType$waiting$room$update$waiting$room = keyof RequestBody$waiting$room$update$waiting$room;
export type ResponseContentType$waiting$room$update$waiting$room = keyof Response$waiting$room$update$waiting$room$Status$200;
export interface Params$waiting$room$update$waiting$room {
    parameter: Parameter$waiting$room$update$waiting$room;
    requestBody: RequestBody$waiting$room$update$waiting$room["application/json"];
}
export type ResponseContentType$waiting$room$delete$waiting$room = keyof Response$waiting$room$delete$waiting$room$Status$200;
export interface Params$waiting$room$delete$waiting$room {
    parameter: Parameter$waiting$room$delete$waiting$room;
}
export type RequestContentType$waiting$room$patch$waiting$room = keyof RequestBody$waiting$room$patch$waiting$room;
export type ResponseContentType$waiting$room$patch$waiting$room = keyof Response$waiting$room$patch$waiting$room$Status$200;
export interface Params$waiting$room$patch$waiting$room {
    parameter: Parameter$waiting$room$patch$waiting$room;
    requestBody: RequestBody$waiting$room$patch$waiting$room["application/json"];
}
export type ResponseContentType$waiting$room$list$events = keyof Response$waiting$room$list$events$Status$200;
export interface Params$waiting$room$list$events {
    parameter: Parameter$waiting$room$list$events;
}
export type RequestContentType$waiting$room$create$event = keyof RequestBody$waiting$room$create$event;
export type ResponseContentType$waiting$room$create$event = keyof Response$waiting$room$create$event$Status$200;
export interface Params$waiting$room$create$event {
    parameter: Parameter$waiting$room$create$event;
    requestBody: RequestBody$waiting$room$create$event["application/json"];
}
export type ResponseContentType$waiting$room$event$details = keyof Response$waiting$room$event$details$Status$200;
export interface Params$waiting$room$event$details {
    parameter: Parameter$waiting$room$event$details;
}
export type RequestContentType$waiting$room$update$event = keyof RequestBody$waiting$room$update$event;
export type ResponseContentType$waiting$room$update$event = keyof Response$waiting$room$update$event$Status$200;
export interface Params$waiting$room$update$event {
    parameter: Parameter$waiting$room$update$event;
    requestBody: RequestBody$waiting$room$update$event["application/json"];
}
export type ResponseContentType$waiting$room$delete$event = keyof Response$waiting$room$delete$event$Status$200;
export interface Params$waiting$room$delete$event {
    parameter: Parameter$waiting$room$delete$event;
}
export type RequestContentType$waiting$room$patch$event = keyof RequestBody$waiting$room$patch$event;
export type ResponseContentType$waiting$room$patch$event = keyof Response$waiting$room$patch$event$Status$200;
export interface Params$waiting$room$patch$event {
    parameter: Parameter$waiting$room$patch$event;
    requestBody: RequestBody$waiting$room$patch$event["application/json"];
}
export type ResponseContentType$waiting$room$preview$active$event$details = keyof Response$waiting$room$preview$active$event$details$Status$200;
export interface Params$waiting$room$preview$active$event$details {
    parameter: Parameter$waiting$room$preview$active$event$details;
}
export type ResponseContentType$waiting$room$list$waiting$room$rules = keyof Response$waiting$room$list$waiting$room$rules$Status$200;
export interface Params$waiting$room$list$waiting$room$rules {
    parameter: Parameter$waiting$room$list$waiting$room$rules;
}
export type RequestContentType$waiting$room$replace$waiting$room$rules = keyof RequestBody$waiting$room$replace$waiting$room$rules;
export type ResponseContentType$waiting$room$replace$waiting$room$rules = keyof Response$waiting$room$replace$waiting$room$rules$Status$200;
export interface Params$waiting$room$replace$waiting$room$rules {
    parameter: Parameter$waiting$room$replace$waiting$room$rules;
    requestBody: RequestBody$waiting$room$replace$waiting$room$rules["application/json"];
}
export type RequestContentType$waiting$room$create$waiting$room$rule = keyof RequestBody$waiting$room$create$waiting$room$rule;
export type ResponseContentType$waiting$room$create$waiting$room$rule = keyof Response$waiting$room$create$waiting$room$rule$Status$200;
export interface Params$waiting$room$create$waiting$room$rule {
    parameter: Parameter$waiting$room$create$waiting$room$rule;
    requestBody: RequestBody$waiting$room$create$waiting$room$rule["application/json"];
}
export type ResponseContentType$waiting$room$delete$waiting$room$rule = keyof Response$waiting$room$delete$waiting$room$rule$Status$200;
export interface Params$waiting$room$delete$waiting$room$rule {
    parameter: Parameter$waiting$room$delete$waiting$room$rule;
}
export type RequestContentType$waiting$room$patch$waiting$room$rule = keyof RequestBody$waiting$room$patch$waiting$room$rule;
export type ResponseContentType$waiting$room$patch$waiting$room$rule = keyof Response$waiting$room$patch$waiting$room$rule$Status$200;
export interface Params$waiting$room$patch$waiting$room$rule {
    parameter: Parameter$waiting$room$patch$waiting$room$rule;
    requestBody: RequestBody$waiting$room$patch$waiting$room$rule["application/json"];
}
export type ResponseContentType$waiting$room$get$waiting$room$status = keyof Response$waiting$room$get$waiting$room$status$Status$200;
export interface Params$waiting$room$get$waiting$room$status {
    parameter: Parameter$waiting$room$get$waiting$room$status;
}
export type RequestContentType$waiting$room$create$a$custom$waiting$room$page$preview = keyof RequestBody$waiting$room$create$a$custom$waiting$room$page$preview;
export type ResponseContentType$waiting$room$create$a$custom$waiting$room$page$preview = keyof Response$waiting$room$create$a$custom$waiting$room$page$preview$Status$200;
export interface Params$waiting$room$create$a$custom$waiting$room$page$preview {
    parameter: Parameter$waiting$room$create$a$custom$waiting$room$page$preview;
    requestBody: RequestBody$waiting$room$create$a$custom$waiting$room$page$preview["application/json"];
}
export type ResponseContentType$waiting$room$get$zone$settings = keyof Response$waiting$room$get$zone$settings$Status$200;
export interface Params$waiting$room$get$zone$settings {
    parameter: Parameter$waiting$room$get$zone$settings;
}
export type RequestContentType$waiting$room$update$zone$settings = keyof RequestBody$waiting$room$update$zone$settings;
export type ResponseContentType$waiting$room$update$zone$settings = keyof Response$waiting$room$update$zone$settings$Status$200;
export interface Params$waiting$room$update$zone$settings {
    parameter: Parameter$waiting$room$update$zone$settings;
    requestBody: RequestBody$waiting$room$update$zone$settings["application/json"];
}
export type RequestContentType$waiting$room$patch$zone$settings = keyof RequestBody$waiting$room$patch$zone$settings;
export type ResponseContentType$waiting$room$patch$zone$settings = keyof Response$waiting$room$patch$zone$settings$Status$200;
export interface Params$waiting$room$patch$zone$settings {
    parameter: Parameter$waiting$room$patch$zone$settings;
    requestBody: RequestBody$waiting$room$patch$zone$settings["application/json"];
}
export type ResponseContentType$web3$hostname$list$web3$hostnames = keyof Response$web3$hostname$list$web3$hostnames$Status$200;
export interface Params$web3$hostname$list$web3$hostnames {
    parameter: Parameter$web3$hostname$list$web3$hostnames;
}
export type RequestContentType$web3$hostname$create$web3$hostname = keyof RequestBody$web3$hostname$create$web3$hostname;
export type ResponseContentType$web3$hostname$create$web3$hostname = keyof Response$web3$hostname$create$web3$hostname$Status$200;
export interface Params$web3$hostname$create$web3$hostname {
    parameter: Parameter$web3$hostname$create$web3$hostname;
    requestBody: RequestBody$web3$hostname$create$web3$hostname["application/json"];
}
export type ResponseContentType$web3$hostname$web3$hostname$details = keyof Response$web3$hostname$web3$hostname$details$Status$200;
export interface Params$web3$hostname$web3$hostname$details {
    parameter: Parameter$web3$hostname$web3$hostname$details;
}
export type ResponseContentType$web3$hostname$delete$web3$hostname = keyof Response$web3$hostname$delete$web3$hostname$Status$200;
export interface Params$web3$hostname$delete$web3$hostname {
    parameter: Parameter$web3$hostname$delete$web3$hostname;
}
export type RequestContentType$web3$hostname$edit$web3$hostname = keyof RequestBody$web3$hostname$edit$web3$hostname;
export type ResponseContentType$web3$hostname$edit$web3$hostname = keyof Response$web3$hostname$edit$web3$hostname$Status$200;
export interface Params$web3$hostname$edit$web3$hostname {
    parameter: Parameter$web3$hostname$edit$web3$hostname;
    requestBody: RequestBody$web3$hostname$edit$web3$hostname["application/json"];
}
export type ResponseContentType$web3$hostname$ipfs$universal$path$gateway$content$list$details = keyof Response$web3$hostname$ipfs$universal$path$gateway$content$list$details$Status$200;
export interface Params$web3$hostname$ipfs$universal$path$gateway$content$list$details {
    parameter: Parameter$web3$hostname$ipfs$universal$path$gateway$content$list$details;
}
export type RequestContentType$web3$hostname$update$ipfs$universal$path$gateway$content$list = keyof RequestBody$web3$hostname$update$ipfs$universal$path$gateway$content$list;
export type ResponseContentType$web3$hostname$update$ipfs$universal$path$gateway$content$list = keyof Response$web3$hostname$update$ipfs$universal$path$gateway$content$list$Status$200;
export interface Params$web3$hostname$update$ipfs$universal$path$gateway$content$list {
    parameter: Parameter$web3$hostname$update$ipfs$universal$path$gateway$content$list;
    requestBody: RequestBody$web3$hostname$update$ipfs$universal$path$gateway$content$list["application/json"];
}
export type ResponseContentType$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries = keyof Response$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries$Status$200;
export interface Params$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries {
    parameter: Parameter$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries;
}
export type RequestContentType$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry = keyof RequestBody$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry;
export type ResponseContentType$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry = keyof Response$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry$Status$200;
export interface Params$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry {
    parameter: Parameter$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry;
    requestBody: RequestBody$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry["application/json"];
}
export type ResponseContentType$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details = keyof Response$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details$Status$200;
export interface Params$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details {
    parameter: Parameter$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details;
}
export type RequestContentType$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry = keyof RequestBody$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry;
export type ResponseContentType$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry = keyof Response$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry$Status$200;
export interface Params$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry {
    parameter: Parameter$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry;
    requestBody: RequestBody$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry["application/json"];
}
export type ResponseContentType$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry = keyof Response$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry$Status$200;
export interface Params$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry {
    parameter: Parameter$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry;
}
export type ResponseContentType$spectrum$aggregate$analytics$get$current$aggregated$analytics = keyof Response$spectrum$aggregate$analytics$get$current$aggregated$analytics$Status$200;
export interface Params$spectrum$aggregate$analytics$get$current$aggregated$analytics {
    parameter: Parameter$spectrum$aggregate$analytics$get$current$aggregated$analytics;
}
export type ResponseContentType$spectrum$analytics$$$by$time$$get$analytics$by$time = keyof Response$spectrum$analytics$$$by$time$$get$analytics$by$time$Status$200;
export interface Params$spectrum$analytics$$$by$time$$get$analytics$by$time {
    parameter: Parameter$spectrum$analytics$$$by$time$$get$analytics$by$time;
}
export type ResponseContentType$spectrum$analytics$$$summary$$get$analytics$summary = keyof Response$spectrum$analytics$$$summary$$get$analytics$summary$Status$200;
export interface Params$spectrum$analytics$$$summary$$get$analytics$summary {
    parameter: Parameter$spectrum$analytics$$$summary$$get$analytics$summary;
}
export type ResponseContentType$spectrum$applications$list$spectrum$applications = keyof Response$spectrum$applications$list$spectrum$applications$Status$200;
export interface Params$spectrum$applications$list$spectrum$applications {
    parameter: Parameter$spectrum$applications$list$spectrum$applications;
}
export type RequestContentType$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin = keyof RequestBody$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin;
export type ResponseContentType$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin = keyof Response$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin$Status$200;
export interface Params$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin {
    parameter: Parameter$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin;
    requestBody: RequestBody$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin["application/json"];
}
export type ResponseContentType$spectrum$applications$get$spectrum$application$configuration = keyof Response$spectrum$applications$get$spectrum$application$configuration$Status$200;
export interface Params$spectrum$applications$get$spectrum$application$configuration {
    parameter: Parameter$spectrum$applications$get$spectrum$application$configuration;
}
export type RequestContentType$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin = keyof RequestBody$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin;
export type ResponseContentType$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin = keyof Response$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin$Status$200;
export interface Params$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin {
    parameter: Parameter$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin;
    requestBody: RequestBody$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin["application/json"];
}
export type ResponseContentType$spectrum$applications$delete$spectrum$application = keyof Response$spectrum$applications$delete$spectrum$application$Status$200;
export interface Params$spectrum$applications$delete$spectrum$application {
    parameter: Parameter$spectrum$applications$delete$spectrum$application;
}
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$accounts$list$accounts$Status$200 | Response$notification$alert$types$get$alert$types$Status$200 | Response$notification$mechanism$eligibility$get$delivery$mechanism$eligibility$Status$200 | Response$notification$destinations$with$pager$duty$list$pager$duty$services$Status$200 | Response$notification$destinations$with$pager$duty$delete$pager$duty$services$Status$200 | Response$notification$destinations$with$pager$duty$connect$pager$duty$Status$201 | Response$notification$destinations$with$pager$duty$connect$pager$duty$token$Status$200 | Response$notification$webhooks$list$webhooks$Status$200 | Response$notification$webhooks$create$a$webhook$Status$201 | Response$notification$webhooks$get$a$webhook$Status$200 | Response$notification$webhooks$update$a$webhook$Status$200 | Response$notification$webhooks$delete$a$webhook$Status$200 | Response$notification$history$list$history$Status$200 | Response$notification$policies$list$notification$policies$Status$200 | Response$notification$policies$create$a$notification$policy$Status$200 | Response$notification$policies$get$a$notification$policy$Status$200 | Response$notification$policies$update$a$notification$policy$Status$200 | Response$notification$policies$delete$a$notification$policy$Status$200 | Response$phishing$url$scanner$submit$suspicious$url$for$scanning$Status$200 | Response$phishing$url$information$get$results$for$a$url$scan$Status$200 | Response$cloudflare$tunnel$list$cloudflare$tunnels$Status$200 | Response$cloudflare$tunnel$create$a$cloudflare$tunnel$Status$200 | Response$cloudflare$tunnel$get$a$cloudflare$tunnel$Status$200 | Response$cloudflare$tunnel$delete$a$cloudflare$tunnel$Status$200 | Response$cloudflare$tunnel$update$a$cloudflare$tunnel$Status$200 | Response$cloudflare$tunnel$configuration$get$configuration$Status$200 | Response$cloudflare$tunnel$configuration$put$configuration$Status$200 | Response$cloudflare$tunnel$list$cloudflare$tunnel$connections$Status$200 | Response$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections$Status$200 | Response$cloudflare$tunnel$get$cloudflare$tunnel$connector$Status$200 | Response$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token$Status$200 | Response$cloudflare$tunnel$get$a$cloudflare$tunnel$token$Status$200 | Response$account$level$custom$nameservers$list$account$custom$nameservers$Status$200 | Response$account$level$custom$nameservers$add$account$custom$nameserver$Status$200 | Response$account$level$custom$nameservers$delete$account$custom$nameserver$Status$200 | Response$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers$Status$200 | Response$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records$Status$200 | Response$cloudflare$d1$list$databases$Status$200 | Response$cloudflare$d1$create$database$Status$200 | Response$dex$endpoints$list$colos$Status$200 | Response$dex$fleet$status$devices$Status$200 | Response$dex$fleet$status$live$Status$200 | Response$dex$endpoints$http$test$details$Status$200 | Response$dex$endpoints$http$test$percentiles$Status$200 | Response$dex$endpoints$list$tests$Status$200 | Response$dex$endpoints$tests$unique$devices$Status$200 | Response$dex$endpoints$traceroute$test$result$network$path$Status$200 | Response$dex$endpoints$traceroute$test$details$Status$200 | Response$dex$endpoints$traceroute$test$network$path$Status$200 | Response$dex$endpoints$traceroute$test$percentiles$Status$200 | Response$dlp$datasets$read$all$Status$200 | Response$dlp$datasets$create$Status$200 | Response$dlp$datasets$read$Status$200 | Response$dlp$datasets$update$Status$200 | Response$dlp$datasets$create$version$Status$200 | Response$dlp$datasets$upload$version$Status$200 | Response$dlp$pattern$validation$validate$pattern$Status$200 | Response$dlp$payload$log$settings$get$settings$Status$200 | Response$dlp$payload$log$settings$update$settings$Status$200 | Response$dlp$profiles$list$all$profiles$Status$200 | Response$dlp$profiles$get$dlp$profile$Status$200 | Response$dlp$profiles$create$custom$profiles$Status$200 | Response$dlp$profiles$get$custom$profile$Status$200 | Response$dlp$profiles$update$custom$profile$Status$200 | Response$dlp$profiles$delete$custom$profile$Status$200 | Response$dlp$profiles$get$predefined$profile$Status$200 | Response$dlp$profiles$update$predefined$profile$Status$200 | Response$dns$firewall$list$dns$firewall$clusters$Status$200 | Response$dns$firewall$create$dns$firewall$cluster$Status$200 | Response$dns$firewall$dns$firewall$cluster$details$Status$200 | Response$dns$firewall$delete$dns$firewall$cluster$Status$200 | Response$dns$firewall$update$dns$firewall$cluster$Status$200 | Response$zero$trust$accounts$get$zero$trust$account$information$Status$200 | Response$zero$trust$accounts$create$zero$trust$account$Status$200 | Response$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings$Status$200 | Response$zero$trust$get$audit$ssh$settings$Status$200 | Response$zero$trust$update$audit$ssh$settings$Status$200 | Response$zero$trust$gateway$categories$list$categories$Status$200 | Response$zero$trust$accounts$get$zero$trust$account$configuration$Status$200 | Response$zero$trust$accounts$update$zero$trust$account$configuration$Status$200 | Response$zero$trust$accounts$patch$zero$trust$account$configuration$Status$200 | Response$zero$trust$lists$list$zero$trust$lists$Status$200 | Response$zero$trust$lists$create$zero$trust$list$Status$200 | Response$zero$trust$lists$zero$trust$list$details$Status$200 | Response$zero$trust$lists$update$zero$trust$list$Status$200 | Response$zero$trust$lists$delete$zero$trust$list$Status$200 | Response$zero$trust$lists$patch$zero$trust$list$Status$200 | Response$zero$trust$lists$zero$trust$list$items$Status$200 | Response$zero$trust$gateway$locations$list$zero$trust$gateway$locations$Status$200 | Response$zero$trust$gateway$locations$create$zero$trust$gateway$location$Status$200 | Response$zero$trust$gateway$locations$zero$trust$gateway$location$details$Status$200 | Response$zero$trust$gateway$locations$update$zero$trust$gateway$location$Status$200 | Response$zero$trust$gateway$locations$delete$zero$trust$gateway$location$Status$200 | Response$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account$Status$200 | Response$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account$Status$200 | Response$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints$Status$200 | Response$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint$Status$200 | Response$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details$Status$200 | Response$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint$Status$200 | Response$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint$Status$200 | Response$zero$trust$gateway$rules$list$zero$trust$gateway$rules$Status$200 | Response$zero$trust$gateway$rules$create$zero$trust$gateway$rule$Status$200 | Response$zero$trust$gateway$rules$zero$trust$gateway$rule$details$Status$200 | Response$zero$trust$gateway$rules$update$zero$trust$gateway$rule$Status$200 | Response$zero$trust$gateway$rules$delete$zero$trust$gateway$rule$Status$200 | Response$list$hyperdrive$Status$200 | Response$create$hyperdrive$Status$200 | Response$get$hyperdrive$Status$200 | Response$update$hyperdrive$Status$200 | Response$delete$hyperdrive$Status$200 | Response$cloudflare$images$list$images$Status$200 | Response$cloudflare$images$upload$an$image$via$url$Status$200 | Response$cloudflare$images$image$details$Status$200 | Response$cloudflare$images$delete$image$Status$200 | Response$cloudflare$images$update$image$Status$200 | Response$cloudflare$images$base$image$Status$200 | Response$cloudflare$images$keys$list$signing$keys$Status$200 | Response$cloudflare$images$images$usage$statistics$Status$200 | Response$cloudflare$images$variants$list$variants$Status$200 | Response$cloudflare$images$variants$create$a$variant$Status$200 | Response$cloudflare$images$variants$variant$details$Status$200 | Response$cloudflare$images$variants$delete$a$variant$Status$200 | Response$cloudflare$images$variants$update$a$variant$Status$200 | Response$cloudflare$images$list$images$v2$Status$200 | Response$cloudflare$images$create$authenticated$direct$upload$url$v$2$Status$200 | Response$asn$intelligence$get$asn$overview$Status$200 | Response$asn$intelligence$get$asn$subnets$Status$200 | Response$passive$dns$by$ip$get$passive$dns$by$ip$Status$200 | Response$domain$intelligence$get$domain$details$Status$200 | Response$domain$history$get$domain$history$Status$200 | Response$domain$intelligence$get$multiple$domain$details$Status$200 | Response$ip$intelligence$get$ip$overview$Status$200 | Response$ip$list$get$ip$lists$Status$200 | Response$miscategorization$create$miscategorization$Status$200 | Response$whois$record$get$whois$record$Status$200 | Response$get$accounts$account_identifier$logpush$datasets$dataset$fields$Status$200 | Response$get$accounts$account_identifier$logpush$datasets$dataset$jobs$Status$200 | Response$get$accounts$account_identifier$logpush$jobs$Status$200 | Response$post$accounts$account_identifier$logpush$jobs$Status$200 | Response$get$accounts$account_identifier$logpush$jobs$job_identifier$Status$200 | Response$put$accounts$account_identifier$logpush$jobs$job_identifier$Status$200 | Response$delete$accounts$account_identifier$logpush$jobs$job_identifier$Status$200 | Response$post$accounts$account_identifier$logpush$ownership$Status$200 | Response$post$accounts$account_identifier$logpush$ownership$validate$Status$200 | Response$delete$accounts$account_identifier$logpush$validate$destination$exists$Status$200 | Response$post$accounts$account_identifier$logpush$validate$origin$Status$200 | Response$get$accounts$account_identifier$logs$control$cmb$config$Status$200 | Response$put$accounts$account_identifier$logs$control$cmb$config$Status$200 | Response$delete$accounts$account_identifier$logs$control$cmb$config$Status$200 | Response$pages$project$get$projects$Status$200 | Response$pages$project$create$project$Status$200 | Response$pages$project$get$project$Status$200 | Response$pages$project$delete$project$Status$200 | Response$pages$project$update$project$Status$200 | Response$pages$deployment$get$deployments$Status$200 | Response$pages$deployment$create$deployment$Status$200 | Response$pages$deployment$get$deployment$info$Status$200 | Response$pages$deployment$delete$deployment$Status$200 | Response$pages$deployment$get$deployment$logs$Status$200 | Response$pages$deployment$retry$deployment$Status$200 | Response$pages$deployment$rollback$deployment$Status$200 | Response$pages$domains$get$domains$Status$200 | Response$pages$domains$add$domain$Status$200 | Response$pages$domains$get$domain$Status$200 | Response$pages$domains$delete$domain$Status$200 | Response$pages$domains$patch$domain$Status$200 | Response$pages$purge$build$cache$Status$200 | Response$r2$list$buckets$Status$200 | Response$r2$create$bucket$Status$200 | Response$r2$get$bucket$Status$200 | Response$r2$delete$bucket$Status$200 | Response$r2$get$bucket$sippy$config$Status$200 | Response$r2$put$bucket$sippy$config$Status$200 | Response$r2$delete$bucket$sippy$config$Status$200 | Response$registrar$domains$list$domains$Status$200 | Response$registrar$domains$get$domain$Status$200 | Response$registrar$domains$update$domain$Status$200 | Response$lists$get$lists$Status$200 | Response$lists$create$a$list$Status$200 | Response$lists$get$a$list$Status$200 | Response$lists$update$a$list$Status$200 | Response$lists$delete$a$list$Status$200 | Response$lists$get$list$items$Status$200 | Response$lists$update$all$list$items$Status$200 | Response$lists$create$list$items$Status$200 | Response$lists$delete$list$items$Status$200 | Response$listAccountRulesets$Status$200 | Response$createAccountRuleset$Status$200 | Response$getAccountRuleset$Status$200 | Response$updateAccountRuleset$Status$200 | Response$createAccountRulesetRule$Status$200 | Response$deleteAccountRulesetRule$Status$200 | Response$updateAccountRulesetRule$Status$200 | Response$listAccountRulesetVersions$Status$200 | Response$getAccountRulesetVersion$Status$200 | Response$listAccountRulesetVersionRulesByTag$Status$200 | Response$getAccountEntrypointRuleset$Status$200 | Response$updateAccountEntrypointRuleset$Status$200 | Response$listAccountEntrypointRulesetVersions$Status$200 | Response$getAccountEntrypointRulesetVersion$Status$200 | Response$stream$videos$list$videos$Status$200 | Response$stream$videos$retrieve$video$details$Status$200 | Response$stream$videos$update$video$details$Status$200 | Response$list$audio$tracks$Status$200 | Response$delete$audio$tracks$Status$200 | Response$edit$audio$tracks$Status$200 | Response$add$audio$track$Status$200 | Response$stream$subtitles$$captions$list$captions$or$subtitles$Status$200 | Response$stream$subtitles$$captions$upload$captions$or$subtitles$Status$200 | Response$stream$subtitles$$captions$delete$captions$or$subtitles$Status$200 | Response$stream$m$p$4$downloads$list$downloads$Status$200 | Response$stream$m$p$4$downloads$create$downloads$Status$200 | Response$stream$m$p$4$downloads$delete$downloads$Status$200 | Response$stream$videos$retreieve$embed$code$html$Status$200 | Response$stream$videos$create$signed$url$tokens$for$videos$Status$200 | Response$stream$video$clipping$clip$videos$given$a$start$and$end$time$Status$200 | Response$stream$videos$upload$videos$from$a$url$Status$200 | Response$stream$videos$upload$videos$via$direct$upload$ur$ls$Status$200 | Response$stream$signing$keys$list$signing$keys$Status$200 | Response$stream$signing$keys$create$signing$keys$Status$200 | Response$stream$signing$keys$delete$signing$keys$Status$200 | Response$stream$live$inputs$list$live$inputs$Status$200 | Response$stream$live$inputs$create$a$live$input$Status$200 | Response$stream$live$inputs$retrieve$a$live$input$Status$200 | Response$stream$live$inputs$update$a$live$input$Status$200 | Response$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input$Status$200 | Response$stream$live$inputs$create$a$new$output$$connected$to$a$live$input$Status$200 | Response$stream$live$inputs$update$an$output$Status$200 | Response$stream$videos$storage$usage$Status$200 | Response$stream$watermark$profile$list$watermark$profiles$Status$200 | Response$stream$watermark$profile$create$watermark$profiles$via$basic$upload$Status$200 | Response$stream$watermark$profile$watermark$profile$details$Status$200 | Response$stream$watermark$profile$delete$watermark$profiles$Status$200 | Response$stream$webhook$view$webhooks$Status$200 | Response$stream$webhook$create$webhooks$Status$200 | Response$stream$webhook$delete$webhooks$Status$200 | Response$tunnel$route$list$tunnel$routes$Status$200 | Response$tunnel$route$create$a$tunnel$route$Status$200 | Response$tunnel$route$delete$a$tunnel$route$Status$200 | Response$tunnel$route$update$a$tunnel$route$Status$200 | Response$tunnel$route$get$tunnel$route$by$ip$Status$200 | Response$tunnel$route$create$a$tunnel$route$with$cidr$Status$200 | Response$tunnel$route$delete$a$tunnel$route$with$cidr$Status$200 | Response$tunnel$route$update$a$tunnel$route$with$cidr$Status$200 | Response$tunnel$virtual$network$list$virtual$networks$Status$200 | Response$tunnel$virtual$network$create$a$virtual$network$Status$200 | Response$tunnel$virtual$network$delete$a$virtual$network$Status$200 | Response$tunnel$virtual$network$update$a$virtual$network$Status$200 | Response$cloudflare$tunnel$list$all$tunnels$Status$200 | Response$argo$tunnel$create$an$argo$tunnel$Status$200 | Response$argo$tunnel$get$an$argo$tunnel$Status$200 | Response$argo$tunnel$delete$an$argo$tunnel$Status$200 | Response$argo$tunnel$clean$up$argo$tunnel$connections$Status$200 | Response$cloudflare$tunnel$list$warp$connector$tunnels$Status$200 | Response$cloudflare$tunnel$create$a$warp$connector$tunnel$Status$200 | Response$cloudflare$tunnel$get$a$warp$connector$tunnel$Status$200 | Response$cloudflare$tunnel$delete$a$warp$connector$tunnel$Status$200 | Response$cloudflare$tunnel$update$a$warp$connector$tunnel$Status$200 | Response$cloudflare$tunnel$get$a$warp$connector$tunnel$token$Status$200 | Response$worker$account$settings$fetch$worker$account$settings$Status$200 | Response$worker$account$settings$create$worker$account$settings$Status$200 | Response$worker$deployments$list$deployments$Status$200 | Response$worker$deployments$get$deployment$detail$Status$200 | Response$namespace$worker$script$worker$details$Status$200 | Response$namespace$worker$script$upload$worker$module$Status$200 | Response$namespace$worker$get$script$content$Status$200 | Response$namespace$worker$put$script$content$Status$200 | Response$namespace$worker$get$script$settings$Status$200 | Response$namespace$worker$patch$script$settings$Status$200 | Response$worker$domain$list$domains$Status$200 | Response$worker$domain$attach$to$domain$Status$200 | Response$worker$domain$get$a$domain$Status$200 | Response$durable$objects$namespace$list$namespaces$Status$200 | Response$durable$objects$namespace$list$objects$Status$200 | Response$queue$list$queues$Status$200 | Response$queue$create$queue$Status$200 | Response$queue$queue$details$Status$200 | Response$queue$update$queue$Status$200 | Response$queue$delete$queue$Status$200 | Response$queue$list$queue$consumers$Status$200 | Response$queue$create$queue$consumer$Status$200 | Response$queue$update$queue$consumer$Status$200 | Response$queue$delete$queue$consumer$Status$200 | Response$worker$script$list$workers$Status$200 | Response$worker$script$download$worker$Status$200 | Response$worker$script$upload$worker$module$Status$200 | Response$worker$script$put$content$Status$200 | Response$worker$script$get$content$Status$200 | Response$worker$cron$trigger$get$cron$triggers$Status$200 | Response$worker$cron$trigger$update$cron$triggers$Status$200 | Response$worker$script$get$settings$Status$200 | Response$worker$script$patch$settings$Status$200 | Response$worker$tail$logs$list$tails$Status$200 | Response$worker$tail$logs$start$tail$Status$200 | Response$worker$tail$logs$delete$tail$Status$200 | Response$worker$script$fetch$usage$model$Status$200 | Response$worker$script$update$usage$model$Status$200 | Response$worker$environment$get$script$content$Status$200 | Response$worker$environment$put$script$content$Status$200 | Response$worker$script$environment$get$settings$Status$200 | Response$worker$script$environment$patch$settings$Status$200 | Response$worker$subdomain$get$subdomain$Status$200 | Response$worker$subdomain$create$subdomain$Status$200 | Response$zero$trust$accounts$get$connectivity$settings$Status$200 | Response$zero$trust$accounts$patch$connectivity$settings$Status$200 | Response$ip$address$management$address$maps$list$address$maps$Status$200 | Response$ip$address$management$address$maps$create$address$map$Status$200 | Response$ip$address$management$address$maps$address$map$details$Status$200 | Response$ip$address$management$address$maps$delete$address$map$Status$200 | Response$ip$address$management$address$maps$update$address$map$Status$200 | Response$ip$address$management$address$maps$add$an$ip$to$an$address$map$Status$200 | Response$ip$address$management$address$maps$remove$an$ip$from$an$address$map$Status$200 | Response$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map$Status$200 | Response$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map$Status$200 | Response$ip$address$management$prefixes$upload$loa$document$Status$201 | Response$ip$address$management$prefixes$download$loa$document$Status$200 | Response$ip$address$management$prefixes$list$prefixes$Status$200 | Response$ip$address$management$prefixes$add$prefix$Status$201 | Response$ip$address$management$prefixes$prefix$details$Status$200 | Response$ip$address$management$prefixes$delete$prefix$Status$200 | Response$ip$address$management$prefixes$update$prefix$description$Status$200 | Response$ip$address$management$prefixes$list$bgp$prefixes$Status$200 | Response$ip$address$management$prefixes$fetch$bgp$prefix$Status$200 | Response$ip$address$management$prefixes$update$bgp$prefix$Status$200 | Response$ip$address$management$dynamic$advertisement$get$advertisement$status$Status$200 | Response$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status$Status$200 | Response$ip$address$management$service$bindings$list$service$bindings$Status$200 | Response$ip$address$management$service$bindings$create$service$binding$Status$201 | Response$ip$address$management$service$bindings$get$service$binding$Status$200 | Response$ip$address$management$service$bindings$delete$service$binding$Status$200 | Response$ip$address$management$prefix$delegation$list$prefix$delegations$Status$200 | Response$ip$address$management$prefix$delegation$create$prefix$delegation$Status$200 | Response$ip$address$management$prefix$delegation$delete$prefix$delegation$Status$200 | Response$ip$address$management$service$bindings$list$services$Status$200 | Response$workers$ai$post$run$model$Status$200 | Response$audit$logs$get$account$audit$logs$Status$200 | Response$account$billing$profile$$$deprecated$$billing$profile$details$Status$200 | Response$accounts$turnstile$widgets$list$Status$200 | Response$accounts$turnstile$widget$create$Status$200 | Response$accounts$turnstile$widget$get$Status$200 | Response$accounts$turnstile$widget$update$Status$200 | Response$accounts$turnstile$widget$delete$Status$200 | Response$accounts$turnstile$widget$rotate$secret$Status$200 | Response$custom$pages$for$an$account$list$custom$pages$Status$200 | Response$custom$pages$for$an$account$get$a$custom$page$Status$200 | Response$custom$pages$for$an$account$update$a$custom$page$Status$200 | Response$cloudflare$d1$get$database$Status$200 | Response$cloudflare$d1$delete$database$Status$200 | Response$cloudflare$d1$query$database$Status$200 | Response$diagnostics$traceroute$Status$200 | Response$dns$firewall$analytics$table$Status$200 | Response$dns$firewall$analytics$by$time$Status$200 | Response$email$routing$destination$addresses$list$destination$addresses$Status$200 | Response$email$routing$destination$addresses$create$a$destination$address$Status$200 | Response$email$routing$destination$addresses$get$a$destination$address$Status$200 | Response$email$routing$destination$addresses$delete$destination$address$Status$200 | Response$ip$access$rules$for$an$account$list$ip$access$rules$Status$200 | Response$ip$access$rules$for$an$account$create$an$ip$access$rule$Status$200 | Response$ip$access$rules$for$an$account$get$an$ip$access$rule$Status$200 | Response$ip$access$rules$for$an$account$delete$an$ip$access$rule$Status$200 | Response$ip$access$rules$for$an$account$update$an$ip$access$rule$Status$200 | Response$custom$indicator$feeds$get$indicator$feeds$Status$200 | Response$custom$indicator$feeds$create$indicator$feeds$Status$200 | Response$custom$indicator$feeds$get$indicator$feed$metadata$Status$200 | Response$custom$indicator$feeds$get$indicator$feed$data$Status$200 | Response$custom$indicator$feeds$update$indicator$feed$data$Status$200 | Response$custom$indicator$feeds$add$permission$Status$200 | Response$custom$indicator$feeds$remove$permission$Status$200 | Response$custom$indicator$feeds$view$permissions$Status$200 | Response$sinkhole$config$get$sinkholes$Status$200 | Response$account$load$balancer$monitors$list$monitors$Status$200 | Response$account$load$balancer$monitors$create$monitor$Status$200 | Response$account$load$balancer$monitors$monitor$details$Status$200 | Response$account$load$balancer$monitors$update$monitor$Status$200 | Response$account$load$balancer$monitors$delete$monitor$Status$200 | Response$account$load$balancer$monitors$patch$monitor$Status$200 | Response$account$load$balancer$monitors$preview$monitor$Status$200 | Response$account$load$balancer$monitors$list$monitor$references$Status$200 | Response$account$load$balancer$pools$list$pools$Status$200 | Response$account$load$balancer$pools$create$pool$Status$200 | Response$account$load$balancer$pools$patch$pools$Status$200 | Response$account$load$balancer$pools$pool$details$Status$200 | Response$account$load$balancer$pools$update$pool$Status$200 | Response$account$load$balancer$pools$delete$pool$Status$200 | Response$account$load$balancer$pools$patch$pool$Status$200 | Response$account$load$balancer$pools$pool$health$details$Status$200 | Response$account$load$balancer$pools$preview$pool$Status$200 | Response$account$load$balancer$pools$list$pool$references$Status$200 | Response$account$load$balancer$monitors$preview$result$Status$200 | Response$load$balancer$regions$list$regions$Status$200 | Response$load$balancer$regions$get$region$Status$200 | Response$account$load$balancer$search$search$resources$Status$200 | Response$magic$interconnects$list$interconnects$Status$200 | Response$magic$interconnects$update$multiple$interconnects$Status$200 | Response$magic$interconnects$list$interconnect$details$Status$200 | Response$magic$interconnects$update$interconnect$Status$200 | Response$magic$gre$tunnels$list$gre$tunnels$Status$200 | Response$magic$gre$tunnels$update$multiple$gre$tunnels$Status$200 | Response$magic$gre$tunnels$create$gre$tunnels$Status$200 | Response$magic$gre$tunnels$list$gre$tunnel$details$Status$200 | Response$magic$gre$tunnels$update$gre$tunnel$Status$200 | Response$magic$gre$tunnels$delete$gre$tunnel$Status$200 | Response$magic$ipsec$tunnels$list$ipsec$tunnels$Status$200 | Response$magic$ipsec$tunnels$update$multiple$ipsec$tunnels$Status$200 | Response$magic$ipsec$tunnels$create$ipsec$tunnels$Status$200 | Response$magic$ipsec$tunnels$list$ipsec$tunnel$details$Status$200 | Response$magic$ipsec$tunnels$update$ipsec$tunnel$Status$200 | Response$magic$ipsec$tunnels$delete$ipsec$tunnel$Status$200 | Response$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels$Status$200 | Response$magic$static$routes$list$routes$Status$200 | Response$magic$static$routes$update$many$routes$Status$200 | Response$magic$static$routes$create$routes$Status$200 | Response$magic$static$routes$delete$many$routes$Status$200 | Response$magic$static$routes$route$details$Status$200 | Response$magic$static$routes$update$route$Status$200 | Response$magic$static$routes$delete$route$Status$200 | Response$account$members$list$members$Status$200 | Response$account$members$add$member$Status$200 | Response$account$members$member$details$Status$200 | Response$account$members$update$member$Status$200 | Response$account$members$remove$member$Status$200 | Response$magic$network$monitoring$configuration$list$account$configuration$Status$200 | Response$magic$network$monitoring$configuration$update$an$entire$account$configuration$Status$200 | Response$magic$network$monitoring$configuration$create$account$configuration$Status$200 | Response$magic$network$monitoring$configuration$delete$account$configuration$Status$200 | Response$magic$network$monitoring$configuration$update$account$configuration$fields$Status$200 | Response$magic$network$monitoring$configuration$list$rules$and$account$configuration$Status$200 | Response$magic$network$monitoring$rules$list$rules$Status$200 | Response$magic$network$monitoring$rules$update$rules$Status$200 | Response$magic$network$monitoring$rules$create$rules$Status$200 | Response$magic$network$monitoring$rules$get$rule$Status$200 | Response$magic$network$monitoring$rules$delete$rule$Status$200 | Response$magic$network$monitoring$rules$update$rule$Status$200 | Response$magic$network$monitoring$rules$update$advertisement$for$rule$Status$200 | Response$m$tls$certificate$management$list$m$tls$certificates$Status$200 | Response$m$tls$certificate$management$upload$m$tls$certificate$Status$200 | Response$m$tls$certificate$management$get$m$tls$certificate$Status$200 | Response$m$tls$certificate$management$delete$m$tls$certificate$Status$200 | Response$m$tls$certificate$management$list$m$tls$certificate$associations$Status$200 | Response$magic$pcap$collection$list$packet$capture$requests$Status$200 | Response$magic$pcap$collection$create$pcap$request$Status$200 | Response$magic$pcap$collection$get$pcap$request$Status$200 | Response$magic$pcap$collection$list$pca$ps$bucket$ownership$Status$200 | Response$magic$pcap$collection$add$buckets$for$full$packet$captures$Status$200 | Response$magic$pcap$collection$validate$buckets$for$full$packet$captures$Status$200 | Response$account$request$tracer$request$trace$Status$200 | Response$account$roles$list$roles$Status$200 | Response$account$roles$role$details$Status$200 | Response$lists$get$a$list$item$Status$200 | Response$lists$get$bulk$operation$status$Status$200 | Response$web$analytics$create$site$Status$200 | Response$web$analytics$get$site$Status$200 | Response$web$analytics$update$site$Status$200 | Response$web$analytics$delete$site$Status$200 | Response$web$analytics$list$sites$Status$200 | Response$web$analytics$create$rule$Status$200 | Response$web$analytics$update$rule$Status$200 | Response$web$analytics$delete$rule$Status$200 | Response$web$analytics$list$rules$Status$200 | Response$web$analytics$modify$rules$Status$200 | Response$secondary$dns$$$acl$$list$ac$ls$Status$200 | Response$secondary$dns$$$acl$$create$acl$Status$200 | Response$secondary$dns$$$acl$$acl$details$Status$200 | Response$secondary$dns$$$acl$$update$acl$Status$200 | Response$secondary$dns$$$acl$$delete$acl$Status$200 | Response$secondary$dns$$$peer$$list$peers$Status$200 | Response$secondary$dns$$$peer$$create$peer$Status$200 | Response$secondary$dns$$$peer$$peer$details$Status$200 | Response$secondary$dns$$$peer$$update$peer$Status$200 | Response$secondary$dns$$$peer$$delete$peer$Status$200 | Response$secondary$dns$$$tsig$$list$tsi$gs$Status$200 | Response$secondary$dns$$$tsig$$create$tsig$Status$200 | Response$secondary$dns$$$tsig$$tsig$details$Status$200 | Response$secondary$dns$$$tsig$$update$tsig$Status$200 | Response$secondary$dns$$$tsig$$delete$tsig$Status$200 | Response$workers$kv$request$analytics$query$request$analytics$Status$200 | Response$workers$kv$stored$data$analytics$query$stored$data$analytics$Status$200 | Response$workers$kv$namespace$list$namespaces$Status$200 | Response$workers$kv$namespace$create$a$namespace$Status$200 | Response$workers$kv$namespace$rename$a$namespace$Status$200 | Response$workers$kv$namespace$remove$a$namespace$Status$200 | Response$workers$kv$namespace$write$multiple$key$value$pairs$Status$200 | Response$workers$kv$namespace$delete$multiple$key$value$pairs$Status$200 | Response$workers$kv$namespace$list$a$namespace$$s$keys$Status$200 | Response$workers$kv$namespace$read$the$metadata$for$a$key$Status$200 | Response$workers$kv$namespace$read$key$value$pair$Status$200 | Response$workers$kv$namespace$write$key$value$pair$with$metadata$Status$200 | Response$workers$kv$namespace$delete$key$value$pair$Status$200 | Response$account$subscriptions$list$subscriptions$Status$200 | Response$account$subscriptions$create$subscription$Status$200 | Response$account$subscriptions$update$subscription$Status$200 | Response$account$subscriptions$delete$subscription$Status$200 | Response$vectorize$list$vectorize$indexes$Status$200 | Response$vectorize$create$vectorize$index$Status$200 | Response$vectorize$get$vectorize$index$Status$200 | Response$vectorize$update$vectorize$index$Status$200 | Response$vectorize$delete$vectorize$index$Status$200 | Response$vectorize$delete$vectors$by$id$Status$200 | Response$vectorize$get$vectors$by$id$Status$200 | Response$vectorize$insert$vector$Status$200 | Response$vectorize$query$vector$Status$200 | Response$vectorize$upsert$vector$Status$200 | Response$ip$address$management$address$maps$add$an$account$membership$to$an$address$map$Status$200 | Response$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map$Status$200 | Response$urlscanner$search$scans$Status$200 | Response$urlscanner$create$scan$Status$200 | Response$urlscanner$get$scan$Status$200 | Response$urlscanner$get$scan$Status$202 | Response$urlscanner$get$scan$har$Status$200 | Response$urlscanner$get$scan$har$Status$202 | Response$urlscanner$get$scan$screenshot$Status$200 | Response$urlscanner$get$scan$screenshot$Status$202 | Response$accounts$account$details$Status$200 | Response$accounts$update$account$Status$200 | Response$access$applications$list$access$applications$Status$200 | Response$access$applications$add$an$application$Status$201 | Response$access$applications$get$an$access$application$Status$200 | Response$access$applications$update$a$bookmark$application$Status$200 | Response$access$applications$delete$an$access$application$Status$202 | Response$access$applications$revoke$service$tokens$Status$202 | Response$access$applications$test$access$policies$Status$200 | Response$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$200 | Response$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$200 | Response$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$202 | Response$access$policies$list$access$policies$Status$200 | Response$access$policies$create$an$access$policy$Status$201 | Response$access$policies$get$an$access$policy$Status$200 | Response$access$policies$update$an$access$policy$Status$200 | Response$access$policies$delete$an$access$policy$Status$202 | Response$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$200 | Response$access$bookmark$applications$$$deprecated$$list$bookmark$applications$Status$200 | Response$access$bookmark$applications$$$deprecated$$get$a$bookmark$application$Status$200 | Response$access$bookmark$applications$$$deprecated$$update$a$bookmark$application$Status$200 | Response$access$bookmark$applications$$$deprecated$$create$a$bookmark$application$Status$200 | Response$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application$Status$200 | Response$access$mtls$authentication$list$mtls$certificates$Status$200 | Response$access$mtls$authentication$add$an$mtls$certificate$Status$201 | Response$access$mtls$authentication$get$an$mtls$certificate$Status$200 | Response$access$mtls$authentication$update$an$mtls$certificate$Status$200 | Response$access$mtls$authentication$delete$an$mtls$certificate$Status$200 | Response$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$200 | Response$access$mtls$authentication$update$an$mtls$certificate$settings$Status$202 | Response$access$custom$pages$list$custom$pages$Status$200 | Response$access$custom$pages$create$a$custom$page$Status$201 | Response$access$custom$pages$get$a$custom$page$Status$200 | Response$access$custom$pages$update$a$custom$page$Status$200 | Response$access$custom$pages$delete$a$custom$page$Status$202 | Response$access$groups$list$access$groups$Status$200 | Response$access$groups$create$an$access$group$Status$201 | Response$access$groups$get$an$access$group$Status$200 | Response$access$groups$update$an$access$group$Status$200 | Response$access$groups$delete$an$access$group$Status$202 | Response$access$identity$providers$list$access$identity$providers$Status$200 | Response$access$identity$providers$add$an$access$identity$provider$Status$201 | Response$access$identity$providers$get$an$access$identity$provider$Status$200 | Response$access$identity$providers$update$an$access$identity$provider$Status$200 | Response$access$identity$providers$delete$an$access$identity$provider$Status$202 | Response$access$key$configuration$get$the$access$key$configuration$Status$200 | Response$access$key$configuration$update$the$access$key$configuration$Status$200 | Response$access$key$configuration$rotate$access$keys$Status$200 | Response$access$authentication$logs$get$access$authentication$logs$Status$200 | Response$zero$trust$organization$get$your$zero$trust$organization$Status$200 | Response$zero$trust$organization$update$your$zero$trust$organization$Status$200 | Response$zero$trust$organization$create$your$zero$trust$organization$Status$201 | Response$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$200 | Response$zero$trust$seats$update$a$user$seat$Status$200 | Response$access$service$tokens$list$service$tokens$Status$200 | Response$access$service$tokens$create$a$service$token$Status$201 | Response$access$service$tokens$update$a$service$token$Status$200 | Response$access$service$tokens$delete$a$service$token$Status$200 | Response$access$service$tokens$refresh$a$service$token$Status$200 | Response$access$service$tokens$rotate$a$service$token$Status$200 | Response$access$tags$list$tags$Status$200 | Response$access$tags$create$tag$Status$201 | Response$access$tags$get$a$tag$Status$200 | Response$access$tags$update$a$tag$Status$200 | Response$access$tags$delete$a$tag$Status$202 | Response$zero$trust$users$get$users$Status$200 | Response$zero$trust$users$get$active$sessions$Status$200 | Response$zero$trust$users$get$active$session$Status$200 | Response$zero$trust$users$get$failed$logins$Status$200 | Response$zero$trust$users$get$last$seen$identity$Status$200 | Response$devices$list$devices$Status$200 | Response$devices$device$details$Status$200 | Response$devices$list$admin$override$code$for$device$Status$200 | Response$device$dex$test$details$Status$200 | Response$device$dex$test$create$device$dex$test$Status$200 | Response$device$dex$test$get$device$dex$test$Status$200 | Response$device$dex$test$update$device$dex$test$Status$200 | Response$device$dex$test$delete$device$dex$test$Status$200 | Response$device$managed$networks$list$device$managed$networks$Status$200 | Response$device$managed$networks$create$device$managed$network$Status$200 | Response$device$managed$networks$device$managed$network$details$Status$200 | Response$device$managed$networks$update$device$managed$network$Status$200 | Response$device$managed$networks$delete$device$managed$network$Status$200 | Response$devices$list$device$settings$policies$Status$200 | Response$devices$get$default$device$settings$policy$Status$200 | Response$devices$create$device$settings$policy$Status$200 | Response$devices$update$default$device$settings$policy$Status$200 | Response$devices$get$device$settings$policy$by$id$Status$200 | Response$devices$delete$device$settings$policy$Status$200 | Response$devices$update$device$settings$policy$Status$200 | Response$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy$Status$200 | Response$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy$Status$200 | Response$devices$get$local$domain$fallback$list$for$a$device$settings$policy$Status$200 | Response$devices$set$local$domain$fallback$list$for$a$device$settings$policy$Status$200 | Response$devices$get$split$tunnel$include$list$for$a$device$settings$policy$Status$200 | Response$devices$set$split$tunnel$include$list$for$a$device$settings$policy$Status$200 | Response$devices$get$split$tunnel$exclude$list$Status$200 | Response$devices$set$split$tunnel$exclude$list$Status$200 | Response$devices$get$local$domain$fallback$list$Status$200 | Response$devices$set$local$domain$fallback$list$Status$200 | Response$devices$get$split$tunnel$include$list$Status$200 | Response$devices$set$split$tunnel$include$list$Status$200 | Response$device$posture$rules$list$device$posture$rules$Status$200 | Response$device$posture$rules$create$device$posture$rule$Status$200 | Response$device$posture$rules$device$posture$rules$details$Status$200 | Response$device$posture$rules$update$device$posture$rule$Status$200 | Response$device$posture$rules$delete$device$posture$rule$Status$200 | Response$device$posture$integrations$list$device$posture$integrations$Status$200 | Response$device$posture$integrations$create$device$posture$integration$Status$200 | Response$device$posture$integrations$device$posture$integration$details$Status$200 | Response$device$posture$integrations$delete$device$posture$integration$Status$200 | Response$device$posture$integrations$update$device$posture$integration$Status$200 | Response$devices$revoke$devices$Status$200 | Response$zero$trust$accounts$get$device$settings$for$zero$trust$account$Status$200 | Response$zero$trust$accounts$update$device$settings$for$the$zero$trust$account$Status$200 | Response$devices$unrevoke$devices$Status$200 | Response$origin$ca$list$certificates$Status$200 | Response$origin$ca$create$certificate$Status$200 | Response$origin$ca$get$certificate$Status$200 | Response$origin$ca$revoke$certificate$Status$200 | Response$cloudflare$i$ps$cloudflare$ip$details$Status$200 | Response$user$$s$account$memberships$list$memberships$Status$200 | Response$user$$s$account$memberships$membership$details$Status$200 | Response$user$$s$account$memberships$update$membership$Status$200 | Response$user$$s$account$memberships$delete$membership$Status$200 | Response$organizations$$$deprecated$$organization$details$Status$200 | Response$organizations$$$deprecated$$edit$organization$Status$200 | Response$audit$logs$get$organization$audit$logs$Status$200 | Response$organization$invites$list$invitations$Status$200 | Response$organization$invites$create$invitation$Status$200 | Response$organization$invites$invitation$details$Status$200 | Response$organization$invites$cancel$invitation$Status$200 | Response$organization$invites$edit$invitation$roles$Status$200 | Response$organization$members$list$members$Status$200 | Response$organization$members$member$details$Status$200 | Response$organization$members$remove$member$Status$200 | Response$organization$members$edit$member$roles$Status$200 | Response$organization$roles$list$roles$Status$200 | Response$organization$roles$role$details$Status$200 | Response$radar$get$annotations$outages$Status$200 | Response$radar$get$annotations$outages$top$Status$200 | Response$radar$get$dns$as112$timeseries$by$dnssec$Status$200 | Response$radar$get$dns$as112$timeseries$by$edns$Status$200 | Response$radar$get$dns$as112$timeseries$by$ip$version$Status$200 | Response$radar$get$dns$as112$timeseries$by$protocol$Status$200 | Response$radar$get$dns$as112$timeseries$by$query$type$Status$200 | Response$radar$get$dns$as112$timeseries$by$response$codes$Status$200 | Response$radar$get$dns$as112$timeseries$Status$200 | Response$radar$get$dns$as112$timeseries$group$by$dnssec$Status$200 | Response$radar$get$dns$as112$timeseries$group$by$edns$Status$200 | Response$radar$get$dns$as112$timeseries$group$by$ip$version$Status$200 | Response$radar$get$dns$as112$timeseries$group$by$protocol$Status$200 | Response$radar$get$dns$as112$timeseries$group$by$query$type$Status$200 | Response$radar$get$dns$as112$timeseries$group$by$response$codes$Status$200 | Response$radar$get$dns$as112$top$locations$Status$200 | Response$radar$get$dns$as112$top$locations$by$dnssec$Status$200 | Response$radar$get$dns$as112$top$locations$by$edns$Status$200 | Response$radar$get$dns$as112$top$locations$by$ip$version$Status$200 | Response$radar$get$attacks$layer3$summary$Status$200 | Response$radar$get$attacks$layer3$summary$by$bitrate$Status$200 | Response$radar$get$attacks$layer3$summary$by$duration$Status$200 | Response$radar$get$attacks$layer3$summary$by$ip$version$Status$200 | Response$radar$get$attacks$layer3$summary$by$protocol$Status$200 | Response$radar$get$attacks$layer3$summary$by$vector$Status$200 | Response$radar$get$attacks$layer3$timeseries$by$bytes$Status$200 | Response$radar$get$attacks$layer3$timeseries$groups$Status$200 | Response$radar$get$attacks$layer3$timeseries$group$by$bitrate$Status$200 | Response$radar$get$attacks$layer3$timeseries$group$by$duration$Status$200 | Response$radar$get$attacks$layer3$timeseries$group$by$industry$Status$200 | Response$radar$get$attacks$layer3$timeseries$group$by$ip$version$Status$200 | Response$radar$get$attacks$layer3$timeseries$group$by$protocol$Status$200 | Response$radar$get$attacks$layer3$timeseries$group$by$vector$Status$200 | Response$radar$get$attacks$layer3$timeseries$group$by$vertical$Status$200 | Response$radar$get$attacks$layer3$top$attacks$Status$200 | Response$radar$get$attacks$layer3$top$industries$Status$200 | Response$radar$get$attacks$layer3$top$origin$locations$Status$200 | Response$radar$get$attacks$layer3$top$target$locations$Status$200 | Response$radar$get$attacks$layer3$top$verticals$Status$200 | Response$radar$get$attacks$layer7$summary$Status$200 | Response$radar$get$attacks$layer7$summary$by$http$method$Status$200 | Response$radar$get$attacks$layer7$summary$by$http$version$Status$200 | Response$radar$get$attacks$layer7$summary$by$ip$version$Status$200 | Response$radar$get$attacks$layer7$summary$by$managed$rules$Status$200 | Response$radar$get$attacks$layer7$summary$by$mitigation$product$Status$200 | Response$radar$get$attacks$layer7$timeseries$Status$200 | Response$radar$get$attacks$layer7$timeseries$group$Status$200 | Response$radar$get$attacks$layer7$timeseries$group$by$http$method$Status$200 | Response$radar$get$attacks$layer7$timeseries$group$by$http$version$Status$200 | Response$radar$get$attacks$layer7$timeseries$group$by$industry$Status$200 | Response$radar$get$attacks$layer7$timeseries$group$by$ip$version$Status$200 | Response$radar$get$attacks$layer7$timeseries$group$by$managed$rules$Status$200 | Response$radar$get$attacks$layer7$timeseries$group$by$mitigation$product$Status$200 | Response$radar$get$attacks$layer7$timeseries$group$by$vertical$Status$200 | Response$radar$get$attacks$layer7$top$origin$as$Status$200 | Response$radar$get$attacks$layer7$top$attacks$Status$200 | Response$radar$get$attacks$layer7$top$industries$Status$200 | Response$radar$get$attacks$layer7$top$origin$location$Status$200 | Response$radar$get$attacks$layer7$top$target$location$Status$200 | Response$radar$get$attacks$layer7$top$verticals$Status$200 | Response$radar$get$bgp$hijacks$events$Status$200 | Response$radar$get$bgp$route$leak$events$Status$200 | Response$radar$get$bgp$pfx2as$moas$Status$200 | Response$radar$get$bgp$pfx2as$Status$200 | Response$radar$get$bgp$routes$stats$Status$200 | Response$radar$get$bgp$timeseries$Status$200 | Response$radar$get$bgp$top$ases$Status$200 | Response$radar$get$bgp$top$asns$by$prefixes$Status$200 | Response$radar$get$bgp$top$prefixes$Status$200 | Response$radar$get$connection$tampering$summary$Status$200 | Response$radar$get$connection$tampering$timeseries$group$Status$200 | Response$radar$get$reports$datasets$Status$200 | Response$radar$get$reports$dataset$download$Status$200 | Response$radar$post$reports$dataset$download$url$Status$200 | Response$radar$get$dns$top$ases$Status$200 | Response$radar$get$dns$top$locations$Status$200 | Response$radar$get$email$security$summary$by$arc$Status$200 | Response$radar$get$email$security$summary$by$dkim$Status$200 | Response$radar$get$email$security$summary$by$dmarc$Status$200 | Response$radar$get$email$security$summary$by$malicious$Status$200 | Response$radar$get$email$security$summary$by$spam$Status$200 | Response$radar$get$email$security$summary$by$spf$Status$200 | Response$radar$get$email$security$summary$by$threat$category$Status$200 | Response$radar$get$email$security$timeseries$group$by$arc$Status$200 | Response$radar$get$email$security$timeseries$group$by$dkim$Status$200 | Response$radar$get$email$security$timeseries$group$by$dmarc$Status$200 | Response$radar$get$email$security$timeseries$group$by$malicious$Status$200 | Response$radar$get$email$security$timeseries$group$by$spam$Status$200 | Response$radar$get$email$security$timeseries$group$by$spf$Status$200 | Response$radar$get$email$security$timeseries$group$by$threat$category$Status$200 | Response$radar$get$email$security$top$ases$by$messages$Status$200 | Response$radar$get$email$security$top$ases$by$arc$Status$200 | Response$radar$get$email$security$top$ases$by$dkim$Status$200 | Response$radar$get$email$security$top$ases$by$dmarc$Status$200 | Response$radar$get$email$security$top$ases$by$malicious$Status$200 | Response$radar$get$email$security$top$ases$by$spam$Status$200 | Response$radar$get$email$security$top$ases$by$spf$Status$200 | Response$radar$get$email$security$top$locations$by$messages$Status$200 | Response$radar$get$email$security$top$locations$by$arc$Status$200 | Response$radar$get$email$security$top$locations$by$dkim$Status$200 | Response$radar$get$email$security$top$locations$by$dmarc$Status$200 | Response$radar$get$email$security$top$locations$by$malicious$Status$200 | Response$radar$get$email$security$top$locations$by$spam$Status$200 | Response$radar$get$email$security$top$locations$by$spf$Status$200 | Response$radar$get$entities$asn$list$Status$200 | Response$radar$get$entities$asn$by$id$Status$200 | Response$radar$get$asns$rel$Status$200 | Response$radar$get$entities$asn$by$ip$Status$200 | Response$radar$get$entities$ip$Status$200 | Response$radar$get$entities$locations$Status$200 | Response$radar$get$entities$location$by$alpha2$Status$200 | Response$radar$get$http$summary$by$bot$class$Status$200 | Response$radar$get$http$summary$by$device$type$Status$200 | Response$radar$get$http$summary$by$http$protocol$Status$200 | Response$radar$get$http$summary$by$http$version$Status$200 | Response$radar$get$http$summary$by$ip$version$Status$200 | Response$radar$get$http$summary$by$operating$system$Status$200 | Response$radar$get$http$summary$by$tls$version$Status$200 | Response$radar$get$http$timeseries$group$by$bot$class$Status$200 | Response$radar$get$http$timeseries$group$by$browsers$Status$200 | Response$radar$get$http$timeseries$group$by$browser$families$Status$200 | Response$radar$get$http$timeseries$group$by$device$type$Status$200 | Response$radar$get$http$timeseries$group$by$http$protocol$Status$200 | Response$radar$get$http$timeseries$group$by$http$version$Status$200 | Response$radar$get$http$timeseries$group$by$ip$version$Status$200 | Response$radar$get$http$timeseries$group$by$operating$system$Status$200 | Response$radar$get$http$timeseries$group$by$tls$version$Status$200 | Response$radar$get$http$top$ases$by$http$requests$Status$200 | Response$radar$get$http$top$ases$by$bot$class$Status$200 | Response$radar$get$http$top$ases$by$device$type$Status$200 | Response$radar$get$http$top$ases$by$http$protocol$Status$200 | Response$radar$get$http$top$ases$by$http$version$Status$200 | Response$radar$get$http$top$ases$by$ip$version$Status$200 | Response$radar$get$http$top$ases$by$operating$system$Status$200 | Response$radar$get$http$top$ases$by$tls$version$Status$200 | Response$radar$get$http$top$browser$families$Status$200 | Response$radar$get$http$top$browsers$Status$200 | Response$radar$get$http$top$locations$by$http$requests$Status$200 | Response$radar$get$http$top$locations$by$bot$class$Status$200 | Response$radar$get$http$top$locations$by$device$type$Status$200 | Response$radar$get$http$top$locations$by$http$protocol$Status$200 | Response$radar$get$http$top$locations$by$http$version$Status$200 | Response$radar$get$http$top$locations$by$ip$version$Status$200 | Response$radar$get$http$top$locations$by$operating$system$Status$200 | Response$radar$get$http$top$locations$by$tls$version$Status$200 | Response$radar$get$netflows$timeseries$Status$200 | Response$radar$get$netflows$top$ases$Status$200 | Response$radar$get$netflows$top$locations$Status$200 | Response$radar$get$quality$index$summary$Status$200 | Response$radar$get$quality$index$timeseries$group$Status$200 | Response$radar$get$quality$speed$histogram$Status$200 | Response$radar$get$quality$speed$summary$Status$200 | Response$radar$get$quality$speed$top$ases$Status$200 | Response$radar$get$quality$speed$top$locations$Status$200 | Response$radar$get$ranking$domain$details$Status$200 | Response$radar$get$ranking$domain$timeseries$Status$200 | Response$radar$get$ranking$top$domains$Status$200 | Response$radar$get$search$global$Status$200 | Response$radar$get$traffic$anomalies$Status$200 | Response$radar$get$traffic$anomalies$top$Status$200 | Response$radar$get$verified$bots$top$by$http$requests$Status$200 | Response$radar$get$verified$bots$top$categories$by$http$requests$Status$200 | Response$user$user$details$Status$200 | Response$user$edit$user$Status$200 | Response$audit$logs$get$user$audit$logs$Status$200 | Response$user$billing$history$$$deprecated$$billing$history$details$Status$200 | Response$user$billing$profile$$$deprecated$$billing$profile$details$Status$200 | Response$ip$access$rules$for$a$user$list$ip$access$rules$Status$200 | Response$ip$access$rules$for$a$user$create$an$ip$access$rule$Status$200 | Response$ip$access$rules$for$a$user$delete$an$ip$access$rule$Status$200 | Response$ip$access$rules$for$a$user$update$an$ip$access$rule$Status$200 | Response$user$$s$invites$list$invitations$Status$200 | Response$user$$s$invites$invitation$details$Status$200 | Response$user$$s$invites$respond$to$invitation$Status$200 | Response$load$balancer$monitors$list$monitors$Status$200 | Response$load$balancer$monitors$create$monitor$Status$200 | Response$load$balancer$monitors$monitor$details$Status$200 | Response$load$balancer$monitors$update$monitor$Status$200 | Response$load$balancer$monitors$delete$monitor$Status$200 | Response$load$balancer$monitors$patch$monitor$Status$200 | Response$load$balancer$monitors$preview$monitor$Status$200 | Response$load$balancer$monitors$list$monitor$references$Status$200 | Response$load$balancer$pools$list$pools$Status$200 | Response$load$balancer$pools$create$pool$Status$200 | Response$load$balancer$pools$patch$pools$Status$200 | Response$load$balancer$pools$pool$details$Status$200 | Response$load$balancer$pools$update$pool$Status$200 | Response$load$balancer$pools$delete$pool$Status$200 | Response$load$balancer$pools$patch$pool$Status$200 | Response$load$balancer$pools$pool$health$details$Status$200 | Response$load$balancer$pools$preview$pool$Status$200 | Response$load$balancer$pools$list$pool$references$Status$200 | Response$load$balancer$monitors$preview$result$Status$200 | Response$load$balancer$healthcheck$events$list$healthcheck$events$Status$200 | Response$user$$s$organizations$list$organizations$Status$200 | Response$user$$s$organizations$organization$details$Status$200 | Response$user$$s$organizations$leave$organization$Status$200 | Response$user$subscription$get$user$subscriptions$Status$200 | Response$user$subscription$update$user$subscription$Status$200 | Response$user$subscription$delete$user$subscription$Status$200 | Response$user$api$tokens$list$tokens$Status$200 | Response$user$api$tokens$create$token$Status$200 | Response$user$api$tokens$token$details$Status$200 | Response$user$api$tokens$update$token$Status$200 | Response$user$api$tokens$delete$token$Status$200 | Response$user$api$tokens$roll$token$Status$200 | Response$permission$groups$list$permission$groups$Status$200 | Response$user$api$tokens$verify$token$Status$200 | Response$zones$get$Status$200 | Response$zones$post$Status$200 | Response$zone$level$access$applications$list$access$applications$Status$200 | Response$zone$level$access$applications$add$a$bookmark$application$Status$201 | Response$zone$level$access$applications$get$an$access$application$Status$200 | Response$zone$level$access$applications$update$a$bookmark$application$Status$200 | Response$zone$level$access$applications$delete$an$access$application$Status$202 | Response$zone$level$access$applications$revoke$service$tokens$Status$202 | Response$zone$level$access$applications$test$access$policies$Status$200 | Response$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$200 | Response$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$200 | Response$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$202 | Response$zone$level$access$policies$list$access$policies$Status$200 | Response$zone$level$access$policies$create$an$access$policy$Status$201 | Response$zone$level$access$policies$get$an$access$policy$Status$200 | Response$zone$level$access$policies$update$an$access$policy$Status$200 | Response$zone$level$access$policies$delete$an$access$policy$Status$202 | Response$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$200 | Response$zone$level$access$mtls$authentication$list$mtls$certificates$Status$200 | Response$zone$level$access$mtls$authentication$add$an$mtls$certificate$Status$201 | Response$zone$level$access$mtls$authentication$get$an$mtls$certificate$Status$200 | Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$Status$200 | Response$zone$level$access$mtls$authentication$delete$an$mtls$certificate$Status$200 | Response$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$200 | Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings$Status$202 | Response$zone$level$access$groups$list$access$groups$Status$200 | Response$zone$level$access$groups$create$an$access$group$Status$201 | Response$zone$level$access$groups$get$an$access$group$Status$200 | Response$zone$level$access$groups$update$an$access$group$Status$200 | Response$zone$level$access$groups$delete$an$access$group$Status$202 | Response$zone$level$access$identity$providers$list$access$identity$providers$Status$200 | Response$zone$level$access$identity$providers$add$an$access$identity$provider$Status$201 | Response$zone$level$access$identity$providers$get$an$access$identity$provider$Status$200 | Response$zone$level$access$identity$providers$update$an$access$identity$provider$Status$200 | Response$zone$level$access$identity$providers$delete$an$access$identity$provider$Status$202 | Response$zone$level$zero$trust$organization$get$your$zero$trust$organization$Status$200 | Response$zone$level$zero$trust$organization$update$your$zero$trust$organization$Status$200 | Response$zone$level$zero$trust$organization$create$your$zero$trust$organization$Status$201 | Response$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$200 | Response$zone$level$access$service$tokens$list$service$tokens$Status$200 | Response$zone$level$access$service$tokens$create$a$service$token$Status$201 | Response$zone$level$access$service$tokens$update$a$service$token$Status$200 | Response$zone$level$access$service$tokens$delete$a$service$token$Status$200 | Response$dns$analytics$table$Status$200 | Response$dns$analytics$by$time$Status$200 | Response$load$balancers$list$load$balancers$Status$200 | Response$load$balancers$create$load$balancer$Status$200 | Response$zone$purge$Status$200 | Response$analyze$certificate$analyze$certificate$Status$200 | Response$zone$subscription$zone$subscription$details$Status$200 | Response$zone$subscription$update$zone$subscription$Status$200 | Response$zone$subscription$create$zone$subscription$Status$200 | Response$load$balancers$load$balancer$details$Status$200 | Response$load$balancers$update$load$balancer$Status$200 | Response$load$balancers$delete$load$balancer$Status$200 | Response$load$balancers$patch$load$balancer$Status$200 | Response$zones$0$get$Status$200 | Response$zones$0$delete$Status$200 | Response$zones$0$patch$Status$200 | Response$put$zones$zone_id$activation_check$Status$200 | Response$argo$analytics$for$zone$argo$analytics$for$a$zone$Status$200 | Response$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps$Status$200 | Response$api$shield$settings$retrieve$information$about$specific$configuration$properties$Status$200 | Response$api$shield$settings$set$configuration$properties$Status$200 | Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi$Status$200 | Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$Status$200 | Response$api$shield$api$patch$discovered$operations$Status$200 | Response$api$shield$api$patch$discovered$operation$Status$200 | Response$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone$Status$200 | Response$api$shield$endpoint$management$add$operations$to$a$zone$Status$200 | Response$api$shield$endpoint$management$retrieve$information$about$an$operation$Status$200 | Response$api$shield$endpoint$management$delete$an$operation$Status$200 | Response$api$shield$schema$validation$retrieve$operation$level$settings$Status$200 | Response$api$shield$schema$validation$update$operation$level$settings$Status$200 | Response$api$shield$schema$validation$update$multiple$operation$level$settings$Status$200 | Response$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas$Status$200 | Response$api$shield$schema$validation$retrieve$zone$level$settings$Status$200 | Response$api$shield$schema$validation$update$zone$level$settings$Status$200 | Response$api$shield$schema$validation$patch$zone$level$settings$Status$200 | Response$api$shield$schema$validation$retrieve$information$about$all$schemas$Status$200 | Response$api$shield$schema$validation$post$schema$Status$200 | Response$api$shield$schema$validation$retrieve$information$about$specific$schema$Status$200 | Response$api$shield$schema$delete$a$schema$Status$200 | Response$api$shield$schema$validation$enable$validation$for$a$schema$Status$200 | Response$api$shield$schema$validation$extract$operations$from$schema$Status$200 | Response$argo$smart$routing$get$argo$smart$routing$setting$Status$200 | Response$argo$smart$routing$patch$argo$smart$routing$setting$Status$200 | Response$tiered$caching$get$tiered$caching$setting$Status$200 | Response$tiered$caching$patch$tiered$caching$setting$Status$200 | Response$bot$management$for$a$zone$get$config$Status$200 | Response$bot$management$for$a$zone$update$config$Status$200 | Response$zone$cache$settings$get$cache$reserve$setting$Status$200 | Response$zone$cache$settings$change$cache$reserve$setting$Status$200 | Response$zone$cache$settings$get$cache$reserve$clear$Status$200 | Response$zone$cache$settings$start$cache$reserve$clear$Status$200 | Response$zone$cache$settings$get$origin$post$quantum$encryption$setting$Status$200 | Response$zone$cache$settings$change$origin$post$quantum$encryption$setting$Status$200 | Response$zone$cache$settings$get$regional$tiered$cache$setting$Status$200 | Response$zone$cache$settings$change$regional$tiered$cache$setting$Status$200 | Response$smart$tiered$cache$get$smart$tiered$cache$setting$Status$200 | Response$smart$tiered$cache$delete$smart$tiered$cache$setting$Status$200 | Response$smart$tiered$cache$patch$smart$tiered$cache$setting$Status$200 | Response$zone$cache$settings$get$variants$setting$Status$200 | Response$zone$cache$settings$delete$variants$setting$Status$200 | Response$zone$cache$settings$change$variants$setting$Status$200 | Response$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata$Status$200 | Response$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata$Status$200 | Response$dns$records$for$a$zone$list$dns$records$Status$200 | Response$dns$records$for$a$zone$create$dns$record$Status$200 | Response$dns$records$for$a$zone$dns$record$details$Status$200 | Response$dns$records$for$a$zone$update$dns$record$Status$200 | Response$dns$records$for$a$zone$delete$dns$record$Status$200 | Response$dns$records$for$a$zone$patch$dns$record$Status$200 | Response$dns$records$for$a$zone$export$dns$records$Status$200 | Response$dns$records$for$a$zone$import$dns$records$Status$200 | Response$dns$records$for$a$zone$scan$dns$records$Status$200 | Response$dnssec$dnssec$details$Status$200 | Response$dnssec$delete$dnssec$records$Status$200 | Response$dnssec$edit$dnssec$status$Status$200 | Response$ip$access$rules$for$a$zone$list$ip$access$rules$Status$200 | Response$ip$access$rules$for$a$zone$create$an$ip$access$rule$Status$200 | Response$ip$access$rules$for$a$zone$delete$an$ip$access$rule$Status$200 | Response$ip$access$rules$for$a$zone$update$an$ip$access$rule$Status$200 | Response$waf$rule$groups$list$waf$rule$groups$Status$200 | Response$waf$rule$groups$get$a$waf$rule$group$Status$200 | Response$waf$rule$groups$update$a$waf$rule$group$Status$200 | Response$waf$rules$list$waf$rules$Status$200 | Response$waf$rules$get$a$waf$rule$Status$200 | Response$waf$rules$update$a$waf$rule$Status$200 | Response$zones$0$hold$get$Status$200 | Response$zones$0$hold$post$Status$200 | Response$zones$0$hold$delete$Status$200 | Response$get$zones$zone_identifier$logpush$datasets$dataset$fields$Status$200 | Response$get$zones$zone_identifier$logpush$datasets$dataset$jobs$Status$200 | Response$get$zones$zone_identifier$logpush$edge$jobs$Status$200 | Response$post$zones$zone_identifier$logpush$edge$jobs$Status$200 | Response$get$zones$zone_identifier$logpush$jobs$Status$200 | Response$post$zones$zone_identifier$logpush$jobs$Status$200 | Response$get$zones$zone_identifier$logpush$jobs$job_identifier$Status$200 | Response$put$zones$zone_identifier$logpush$jobs$job_identifier$Status$200 | Response$delete$zones$zone_identifier$logpush$jobs$job_identifier$Status$200 | Response$post$zones$zone_identifier$logpush$ownership$Status$200 | Response$post$zones$zone_identifier$logpush$ownership$validate$Status$200 | Response$post$zones$zone_identifier$logpush$validate$destination$exists$Status$200 | Response$post$zones$zone_identifier$logpush$validate$origin$Status$200 | Response$managed$transforms$list$managed$transforms$Status$200 | Response$managed$transforms$update$status$of$managed$transforms$Status$200 | Response$page$shield$get$page$shield$settings$Status$200 | Response$page$shield$update$page$shield$settings$Status$200 | Response$page$shield$list$page$shield$connections$Status$200 | Response$page$shield$get$a$page$shield$connection$Status$200 | Response$page$shield$list$page$shield$policies$Status$200 | Response$page$shield$create$a$page$shield$policy$Status$200 | Response$page$shield$get$a$page$shield$policy$Status$200 | Response$page$shield$update$a$page$shield$policy$Status$200 | Response$page$shield$list$page$shield$scripts$Status$200 | Response$page$shield$get$a$page$shield$script$Status$200 | Response$page$rules$list$page$rules$Status$200 | Response$page$rules$create$a$page$rule$Status$200 | Response$page$rules$get$a$page$rule$Status$200 | Response$page$rules$update$a$page$rule$Status$200 | Response$page$rules$delete$a$page$rule$Status$200 | Response$page$rules$edit$a$page$rule$Status$200 | Response$available$page$rules$settings$list$available$page$rules$settings$Status$200 | Response$listZoneRulesets$Status$200 | Response$createZoneRuleset$Status$200 | Response$getZoneRuleset$Status$200 | Response$updateZoneRuleset$Status$200 | Response$createZoneRulesetRule$Status$200 | Response$deleteZoneRulesetRule$Status$200 | Response$updateZoneRulesetRule$Status$200 | Response$listZoneRulesetVersions$Status$200 | Response$getZoneRulesetVersion$Status$200 | Response$getZoneEntrypointRuleset$Status$200 | Response$updateZoneEntrypointRuleset$Status$200 | Response$listZoneEntrypointRulesetVersions$Status$200 | Response$getZoneEntrypointRulesetVersion$Status$200 | Response$zone$settings$get$all$zone$settings$Status$200 | Response$zone$settings$edit$zone$settings$info$Status$200 | Response$zone$settings$get$0$rtt$session$resumption$setting$Status$200 | Response$zone$settings$change$0$rtt$session$resumption$setting$Status$200 | Response$zone$settings$get$advanced$ddos$setting$Status$200 | Response$zone$settings$get$always$online$setting$Status$200 | Response$zone$settings$change$always$online$setting$Status$200 | Response$zone$settings$get$always$use$https$setting$Status$200 | Response$zone$settings$change$always$use$https$setting$Status$200 | Response$zone$settings$get$automatic$https$rewrites$setting$Status$200 | Response$zone$settings$change$automatic$https$rewrites$setting$Status$200 | Response$zone$settings$get$automatic_platform_optimization$setting$Status$200 | Response$zone$settings$change$automatic_platform_optimization$setting$Status$200 | Response$zone$settings$get$brotli$setting$Status$200 | Response$zone$settings$change$brotli$setting$Status$200 | Response$zone$settings$get$browser$cache$ttl$setting$Status$200 | Response$zone$settings$change$browser$cache$ttl$setting$Status$200 | Response$zone$settings$get$browser$check$setting$Status$200 | Response$zone$settings$change$browser$check$setting$Status$200 | Response$zone$settings$get$cache$level$setting$Status$200 | Response$zone$settings$change$cache$level$setting$Status$200 | Response$zone$settings$get$challenge$ttl$setting$Status$200 | Response$zone$settings$change$challenge$ttl$setting$Status$200 | Response$zone$settings$get$ciphers$setting$Status$200 | Response$zone$settings$change$ciphers$setting$Status$200 | Response$zone$settings$get$development$mode$setting$Status$200 | Response$zone$settings$change$development$mode$setting$Status$200 | Response$zone$settings$get$early$hints$setting$Status$200 | Response$zone$settings$change$early$hints$setting$Status$200 | Response$zone$settings$get$email$obfuscation$setting$Status$200 | Response$zone$settings$change$email$obfuscation$setting$Status$200 | Response$zone$settings$get$fonts$setting$Status$200 | Response$zone$settings$change$fonts$setting$Status$200 | Response$zone$settings$get$h2_prioritization$setting$Status$200 | Response$zone$settings$change$h2_prioritization$setting$Status$200 | Response$zone$settings$get$hotlink$protection$setting$Status$200 | Response$zone$settings$change$hotlink$protection$setting$Status$200 | Response$zone$settings$get$h$t$t$p$2$setting$Status$200 | Response$zone$settings$change$h$t$t$p$2$setting$Status$200 | Response$zone$settings$get$h$t$t$p$3$setting$Status$200 | Response$zone$settings$change$h$t$t$p$3$setting$Status$200 | Response$zone$settings$get$image_resizing$setting$Status$200 | Response$zone$settings$change$image_resizing$setting$Status$200 | Response$zone$settings$get$ip$geolocation$setting$Status$200 | Response$zone$settings$change$ip$geolocation$setting$Status$200 | Response$zone$settings$get$i$pv6$setting$Status$200 | Response$zone$settings$change$i$pv6$setting$Status$200 | Response$zone$settings$get$minimum$tls$version$setting$Status$200 | Response$zone$settings$change$minimum$tls$version$setting$Status$200 | Response$zone$settings$get$minify$setting$Status$200 | Response$zone$settings$change$minify$setting$Status$200 | Response$zone$settings$get$mirage$setting$Status$200 | Response$zone$settings$change$web$mirage$setting$Status$200 | Response$zone$settings$get$mobile$redirect$setting$Status$200 | Response$zone$settings$change$mobile$redirect$setting$Status$200 | Response$zone$settings$get$nel$setting$Status$200 | Response$zone$settings$change$nel$setting$Status$200 | Response$zone$settings$get$opportunistic$encryption$setting$Status$200 | Response$zone$settings$change$opportunistic$encryption$setting$Status$200 | Response$zone$settings$get$opportunistic$onion$setting$Status$200 | Response$zone$settings$change$opportunistic$onion$setting$Status$200 | Response$zone$settings$get$orange_to_orange$setting$Status$200 | Response$zone$settings$change$orange_to_orange$setting$Status$200 | Response$zone$settings$get$enable$error$pages$on$setting$Status$200 | Response$zone$settings$change$enable$error$pages$on$setting$Status$200 | Response$zone$settings$get$polish$setting$Status$200 | Response$zone$settings$change$polish$setting$Status$200 | Response$zone$settings$get$prefetch$preload$setting$Status$200 | Response$zone$settings$change$prefetch$preload$setting$Status$200 | Response$zone$settings$get$proxy_read_timeout$setting$Status$200 | Response$zone$settings$change$proxy_read_timeout$setting$Status$200 | Response$zone$settings$get$pseudo$i$pv4$setting$Status$200 | Response$zone$settings$change$pseudo$i$pv4$setting$Status$200 | Response$zone$settings$get$response$buffering$setting$Status$200 | Response$zone$settings$change$response$buffering$setting$Status$200 | Response$zone$settings$get$rocket_loader$setting$Status$200 | Response$zone$settings$change$rocket_loader$setting$Status$200 | Response$zone$settings$get$security$header$$$hsts$$setting$Status$200 | Response$zone$settings$change$security$header$$$hsts$$setting$Status$200 | Response$zone$settings$get$security$level$setting$Status$200 | Response$zone$settings$change$security$level$setting$Status$200 | Response$zone$settings$get$server$side$exclude$setting$Status$200 | Response$zone$settings$change$server$side$exclude$setting$Status$200 | Response$zone$settings$get$enable$query$string$sort$setting$Status$200 | Response$zone$settings$change$enable$query$string$sort$setting$Status$200 | Response$zone$settings$get$ssl$setting$Status$200 | Response$zone$settings$change$ssl$setting$Status$200 | Response$zone$settings$get$ssl_recommender$setting$Status$200 | Response$zone$settings$change$ssl_recommender$setting$Status$200 | Response$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone$Status$200 | Response$zone$settings$change$tls$1$$3$setting$Status$200 | Response$zone$settings$get$tls$client$auth$setting$Status$200 | Response$zone$settings$change$tls$client$auth$setting$Status$200 | Response$zone$settings$get$true$client$ip$setting$Status$200 | Response$zone$settings$change$true$client$ip$setting$Status$200 | Response$zone$settings$get$web$application$firewall$$$waf$$setting$Status$200 | Response$zone$settings$change$web$application$firewall$$$waf$$setting$Status$200 | Response$zone$settings$get$web$p$setting$Status$200 | Response$zone$settings$change$web$p$setting$Status$200 | Response$zone$settings$get$web$sockets$setting$Status$200 | Response$zone$settings$change$web$sockets$setting$Status$200 | Response$get$zones$zone_identifier$zaraz$config$Status$200 | Response$put$zones$zone_identifier$zaraz$config$Status$200 | Response$get$zones$zone_identifier$zaraz$default$Status$200 | Response$get$zones$zone_identifier$zaraz$export$Status$200 | Response$get$zones$zone_identifier$zaraz$history$Status$200 | Response$put$zones$zone_identifier$zaraz$history$Status$200 | Response$get$zones$zone_identifier$zaraz$config$history$Status$200 | Response$post$zones$zone_identifier$zaraz$publish$Status$200 | Response$get$zones$zone_identifier$zaraz$workflow$Status$200 | Response$put$zones$zone_identifier$zaraz$workflow$Status$200 | Response$speed$get$availabilities$Status$200 | Response$speed$list$pages$Status$200 | Response$speed$list$test$history$Status$200 | Response$speed$create$test$Status$200 | Response$speed$delete$tests$Status$200 | Response$speed$get$test$Status$200 | Response$speed$list$page$trend$Status$200 | Response$speed$get$scheduled$test$Status$200 | Response$speed$create$scheduled$test$Status$200 | Response$speed$delete$test$schedule$Status$200 | Response$url$normalization$get$url$normalization$settings$Status$200 | Response$url$normalization$update$url$normalization$settings$Status$200 | Response$worker$filters$$$deprecated$$list$filters$Status$200 | Response$worker$filters$$$deprecated$$create$filter$Status$200 | Response$worker$filters$$$deprecated$$update$filter$Status$200 | Response$worker$filters$$$deprecated$$delete$filter$Status$200 | Response$worker$routes$list$routes$Status$200 | Response$worker$routes$create$route$Status$200 | Response$worker$routes$get$route$Status$200 | Response$worker$routes$update$route$Status$200 | Response$worker$routes$delete$route$Status$200 | Response$worker$script$$$deprecated$$download$worker$Status$200 | Response$worker$script$$$deprecated$$upload$worker$Status$200 | Response$worker$binding$$$deprecated$$list$bindings$Status$200 | Response$total$tls$total$tls$settings$details$Status$200 | Response$total$tls$enable$or$disable$total$tls$Status$200 | Response$zone$analytics$$$deprecated$$get$analytics$by$co$locations$Status$200 | Response$zone$analytics$$$deprecated$$get$dashboard$Status$200 | Response$zone$rate$plan$list$available$plans$Status$200 | Response$zone$rate$plan$available$plan$details$Status$200 | Response$zone$rate$plan$list$available$rate$plans$Status$200 | Response$client$certificate$for$a$zone$list$hostname$associations$Status$200 | Response$client$certificate$for$a$zone$put$hostname$associations$Status$200 | Response$client$certificate$for$a$zone$list$client$certificates$Status$200 | Response$client$certificate$for$a$zone$create$client$certificate$Status$200 | Response$client$certificate$for$a$zone$client$certificate$details$Status$200 | Response$client$certificate$for$a$zone$delete$client$certificate$Status$200 | Response$client$certificate$for$a$zone$edit$client$certificate$Status$200 | Response$custom$ssl$for$a$zone$list$ssl$configurations$Status$200 | Response$custom$ssl$for$a$zone$create$ssl$configuration$Status$200 | Response$custom$ssl$for$a$zone$ssl$configuration$details$Status$200 | Response$custom$ssl$for$a$zone$delete$ssl$configuration$Status$200 | Response$custom$ssl$for$a$zone$edit$ssl$configuration$Status$200 | Response$custom$ssl$for$a$zone$re$prioritize$ssl$certificates$Status$200 | Response$custom$hostname$for$a$zone$list$custom$hostnames$Status$200 | Response$custom$hostname$for$a$zone$create$custom$hostname$Status$200 | Response$custom$hostname$for$a$zone$custom$hostname$details$Status$200 | Response$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$$Status$200 | Response$custom$hostname$for$a$zone$edit$custom$hostname$Status$200 | Response$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames$Status$200 | Response$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames$Status$200 | Response$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames$Status$200 | Response$custom$pages$for$a$zone$list$custom$pages$Status$200 | Response$custom$pages$for$a$zone$get$a$custom$page$Status$200 | Response$custom$pages$for$a$zone$update$a$custom$page$Status$200 | Response$dcv$delegation$uuid$get$Status$200 | Response$email$routing$settings$get$email$routing$settings$Status$200 | Response$email$routing$settings$disable$email$routing$Status$200 | Response$email$routing$settings$email$routing$dns$settings$Status$200 | Response$email$routing$settings$enable$email$routing$Status$200 | Response$email$routing$routing$rules$list$routing$rules$Status$200 | Response$email$routing$routing$rules$create$routing$rule$Status$200 | Response$email$routing$routing$rules$get$routing$rule$Status$200 | Response$email$routing$routing$rules$update$routing$rule$Status$200 | Response$email$routing$routing$rules$delete$routing$rule$Status$200 | Response$email$routing$routing$rules$get$catch$all$rule$Status$200 | Response$email$routing$routing$rules$update$catch$all$rule$Status$200 | Response$filters$list$filters$Status$200 | Response$filters$update$filters$Status$200 | Response$filters$create$filters$Status$200 | Response$filters$delete$filters$Status$200 | Response$filters$get$a$filter$Status$200 | Response$filters$update$a$filter$Status$200 | Response$filters$delete$a$filter$Status$200 | Response$zone$lockdown$list$zone$lockdown$rules$Status$200 | Response$zone$lockdown$create$a$zone$lockdown$rule$Status$200 | Response$zone$lockdown$get$a$zone$lockdown$rule$Status$200 | Response$zone$lockdown$update$a$zone$lockdown$rule$Status$200 | Response$zone$lockdown$delete$a$zone$lockdown$rule$Status$200 | Response$firewall$rules$list$firewall$rules$Status$200 | Response$firewall$rules$update$firewall$rules$Status$200 | Response$firewall$rules$create$firewall$rules$Status$200 | Response$firewall$rules$delete$firewall$rules$Status$200 | Response$firewall$rules$update$priority$of$firewall$rules$Status$200 | Response$firewall$rules$get$a$firewall$rule$Status$200 | Response$firewall$rules$update$a$firewall$rule$Status$200 | Response$firewall$rules$delete$a$firewall$rule$Status$200 | Response$firewall$rules$update$priority$of$a$firewall$rule$Status$200 | Response$user$agent$blocking$rules$list$user$agent$blocking$rules$Status$200 | Response$user$agent$blocking$rules$create$a$user$agent$blocking$rule$Status$200 | Response$user$agent$blocking$rules$get$a$user$agent$blocking$rule$Status$200 | Response$user$agent$blocking$rules$update$a$user$agent$blocking$rule$Status$200 | Response$user$agent$blocking$rules$delete$a$user$agent$blocking$rule$Status$200 | Response$waf$overrides$list$waf$overrides$Status$200 | Response$waf$overrides$create$a$waf$override$Status$200 | Response$waf$overrides$get$a$waf$override$Status$200 | Response$waf$overrides$update$waf$override$Status$200 | Response$waf$overrides$delete$a$waf$override$Status$200 | Response$waf$packages$list$waf$packages$Status$200 | Response$waf$packages$get$a$waf$package$Status$200 | Response$waf$packages$update$a$waf$package$Status$200 | Response$health$checks$list$health$checks$Status$200 | Response$health$checks$create$health$check$Status$200 | Response$health$checks$health$check$details$Status$200 | Response$health$checks$update$health$check$Status$200 | Response$health$checks$delete$health$check$Status$200 | Response$health$checks$patch$health$check$Status$200 | Response$health$checks$create$preview$health$check$Status$200 | Response$health$checks$health$check$preview$details$Status$200 | Response$health$checks$delete$preview$health$check$Status$200 | Response$per$hostname$tls$settings$list$Status$200 | Response$per$hostname$tls$settings$put$Status$200 | Response$per$hostname$tls$settings$delete$Status$200 | Response$keyless$ssl$for$a$zone$list$keyless$ssl$configurations$Status$200 | Response$keyless$ssl$for$a$zone$create$keyless$ssl$configuration$Status$200 | Response$keyless$ssl$for$a$zone$get$keyless$ssl$configuration$Status$200 | Response$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration$Status$200 | Response$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration$Status$200 | Response$logs$received$get$log$retention$flag$Status$200 | Response$logs$received$update$log$retention$flag$Status$200 | Response$logs$received$get$logs$ray$i$ds$Status$200 | Response$logs$received$get$logs$received$Status$200 | Response$logs$received$list$fields$Status$200 | Response$zone$level$authenticated$origin$pulls$list$certificates$Status$200 | Response$zone$level$authenticated$origin$pulls$upload$certificate$Status$200 | Response$zone$level$authenticated$origin$pulls$get$certificate$details$Status$200 | Response$zone$level$authenticated$origin$pulls$delete$certificate$Status$200 | Response$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication$Status$200 | Response$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication$Status$200 | Response$per$hostname$authenticated$origin$pull$list$certificates$Status$200 | Response$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate$Status$200 | Response$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate$Status$200 | Response$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate$Status$200 | Response$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone$Status$200 | Response$zone$level$authenticated$origin$pulls$set$enablement$for$zone$Status$200 | Response$rate$limits$for$a$zone$list$rate$limits$Status$200 | Response$rate$limits$for$a$zone$create$a$rate$limit$Status$200 | Response$rate$limits$for$a$zone$get$a$rate$limit$Status$200 | Response$rate$limits$for$a$zone$update$a$rate$limit$Status$200 | Response$rate$limits$for$a$zone$delete$a$rate$limit$Status$200 | Response$secondary$dns$$$secondary$zone$$force$axfr$Status$200 | Response$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details$Status$200 | Response$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration$Status$200 | Response$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration$Status$200 | Response$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration$Status$200 | Response$secondary$dns$$$primary$zone$$primary$zone$configuration$details$Status$200 | Response$secondary$dns$$$primary$zone$$update$primary$zone$configuration$Status$200 | Response$secondary$dns$$$primary$zone$$create$primary$zone$configuration$Status$200 | Response$secondary$dns$$$primary$zone$$delete$primary$zone$configuration$Status$200 | Response$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers$Status$200 | Response$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers$Status$200 | Response$secondary$dns$$$primary$zone$$force$dns$notify$Status$200 | Response$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status$Status$200 | Response$zone$snippets$Status$200 | Response$zone$snippets$snippet$Status$200 | Response$zone$snippets$snippet$put$Status$200 | Response$zone$snippets$snippet$delete$Status$200 | Response$zone$snippets$snippet$content$Status$200 | Response$zone$snippets$snippet$rules$Status$200 | Response$zone$snippets$snippet$rules$put$Status$200 | Response$certificate$packs$list$certificate$packs$Status$200 | Response$certificate$packs$get$certificate$pack$Status$200 | Response$certificate$packs$delete$advanced$certificate$manager$certificate$pack$Status$200 | Response$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack$Status$200 | Response$certificate$packs$order$advanced$certificate$manager$certificate$pack$Status$200 | Response$certificate$packs$get$certificate$pack$quotas$Status$200 | Response$ssl$$tls$mode$recommendation$ssl$$tls$recommendation$Status$200 | Response$universal$ssl$settings$for$a$zone$universal$ssl$settings$details$Status$200 | Response$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings$Status$200 | Response$ssl$verification$ssl$verification$details$Status$200 | Response$ssl$verification$edit$ssl$certificate$pack$validation$method$Status$200 | Response$waiting$room$list$waiting$rooms$Status$200 | Response$waiting$room$create$waiting$room$Status$200 | Response$waiting$room$waiting$room$details$Status$200 | Response$waiting$room$update$waiting$room$Status$200 | Response$waiting$room$delete$waiting$room$Status$200 | Response$waiting$room$patch$waiting$room$Status$200 | Response$waiting$room$list$events$Status$200 | Response$waiting$room$create$event$Status$200 | Response$waiting$room$event$details$Status$200 | Response$waiting$room$update$event$Status$200 | Response$waiting$room$delete$event$Status$200 | Response$waiting$room$patch$event$Status$200 | Response$waiting$room$preview$active$event$details$Status$200 | Response$waiting$room$list$waiting$room$rules$Status$200 | Response$waiting$room$replace$waiting$room$rules$Status$200 | Response$waiting$room$create$waiting$room$rule$Status$200 | Response$waiting$room$delete$waiting$room$rule$Status$200 | Response$waiting$room$patch$waiting$room$rule$Status$200 | Response$waiting$room$get$waiting$room$status$Status$200 | Response$waiting$room$create$a$custom$waiting$room$page$preview$Status$200 | Response$waiting$room$get$zone$settings$Status$200 | Response$waiting$room$update$zone$settings$Status$200 | Response$waiting$room$patch$zone$settings$Status$200 | Response$web3$hostname$list$web3$hostnames$Status$200 | Response$web3$hostname$create$web3$hostname$Status$200 | Response$web3$hostname$web3$hostname$details$Status$200 | Response$web3$hostname$delete$web3$hostname$Status$200 | Response$web3$hostname$edit$web3$hostname$Status$200 | Response$web3$hostname$ipfs$universal$path$gateway$content$list$details$Status$200 | Response$web3$hostname$update$ipfs$universal$path$gateway$content$list$Status$200 | Response$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries$Status$200 | Response$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry$Status$200 | Response$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details$Status$200 | Response$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry$Status$200 | Response$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry$Status$200 | Response$spectrum$aggregate$analytics$get$current$aggregated$analytics$Status$200 | Response$spectrum$analytics$$$by$time$$get$analytics$by$time$Status$200 | Response$spectrum$analytics$$$summary$$get$analytics$summary$Status$200 | Response$spectrum$applications$list$spectrum$applications$Status$200 | Response$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin$Status$200 | Response$spectrum$applications$get$spectrum$application$configuration$Status$200 | Response$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin$Status$200 | Response$spectrum$applications$delete$spectrum$application$Status$200;
export namespace ErrorResponse {
    export type accounts$list$accounts = void;
    export type notification$alert$types$get$alert$types = void;
    export type notification$mechanism$eligibility$get$delivery$mechanism$eligibility = void;
    export type notification$destinations$with$pager$duty$list$pager$duty$services = void;
    export type notification$destinations$with$pager$duty$delete$pager$duty$services = void;
    export type notification$destinations$with$pager$duty$connect$pager$duty = void;
    export type notification$destinations$with$pager$duty$connect$pager$duty$token = void;
    export type notification$webhooks$list$webhooks = void;
    export type notification$webhooks$create$a$webhook = void;
    export type notification$webhooks$get$a$webhook = void;
    export type notification$webhooks$update$a$webhook = void;
    export type notification$webhooks$delete$a$webhook = void;
    export type notification$history$list$history = void;
    export type notification$policies$list$notification$policies = void;
    export type notification$policies$create$a$notification$policy = void;
    export type notification$policies$get$a$notification$policy = void;
    export type notification$policies$update$a$notification$policy = void;
    export type notification$policies$delete$a$notification$policy = void;
    export type phishing$url$scanner$submit$suspicious$url$for$scanning = void;
    export type phishing$url$information$get$results$for$a$url$scan = void;
    export type cloudflare$tunnel$list$cloudflare$tunnels = void;
    export type cloudflare$tunnel$create$a$cloudflare$tunnel = void;
    export type cloudflare$tunnel$get$a$cloudflare$tunnel = void;
    export type cloudflare$tunnel$delete$a$cloudflare$tunnel = void;
    export type cloudflare$tunnel$update$a$cloudflare$tunnel = void;
    export type cloudflare$tunnel$configuration$get$configuration = void;
    export type cloudflare$tunnel$configuration$put$configuration = void;
    export type cloudflare$tunnel$list$cloudflare$tunnel$connections = void;
    export type cloudflare$tunnel$clean$up$cloudflare$tunnel$connections = void;
    export type cloudflare$tunnel$get$cloudflare$tunnel$connector = void;
    export type cloudflare$tunnel$get$a$cloudflare$tunnel$management$token = void;
    export type cloudflare$tunnel$get$a$cloudflare$tunnel$token = void;
    export type account$level$custom$nameservers$list$account$custom$nameservers = void;
    export type account$level$custom$nameservers$add$account$custom$nameserver = void;
    export type account$level$custom$nameservers$delete$account$custom$nameserver = void;
    export type account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers = void;
    export type account$level$custom$nameservers$verify$account$custom$nameserver$glue$records = void;
    export type cloudflare$d1$list$databases = void;
    export type cloudflare$d1$create$database = void;
    export type dex$endpoints$list$colos = void;
    export type dex$fleet$status$devices = void;
    export type dex$fleet$status$live = void;
    export type dex$fleet$status$over$time = void;
    export type dex$endpoints$http$test$details = void;
    export type dex$endpoints$http$test$percentiles = void;
    export type dex$endpoints$list$tests = void;
    export type dex$endpoints$tests$unique$devices = void;
    export type dex$endpoints$traceroute$test$result$network$path = void;
    export type dex$endpoints$traceroute$test$details = void;
    export type dex$endpoints$traceroute$test$network$path = void;
    export type dex$endpoints$traceroute$test$percentiles = void;
    export type dlp$datasets$read$all = void;
    export type dlp$datasets$create = void;
    export type dlp$datasets$read = void;
    export type dlp$datasets$update = void;
    export type dlp$datasets$delete = void;
    export type dlp$datasets$create$version = void;
    export type dlp$datasets$upload$version = void;
    export type dlp$pattern$validation$validate$pattern = void;
    export type dlp$payload$log$settings$get$settings = void;
    export type dlp$payload$log$settings$update$settings = void;
    export type dlp$profiles$list$all$profiles = void;
    export type dlp$profiles$get$dlp$profile = void;
    export type dlp$profiles$create$custom$profiles = void;
    export type dlp$profiles$get$custom$profile = void;
    export type dlp$profiles$update$custom$profile = void;
    export type dlp$profiles$delete$custom$profile = void;
    export type dlp$profiles$get$predefined$profile = void;
    export type dlp$profiles$update$predefined$profile = void;
    export type dns$firewall$list$dns$firewall$clusters = void;
    export type dns$firewall$create$dns$firewall$cluster = void;
    export type dns$firewall$dns$firewall$cluster$details = void;
    export type dns$firewall$delete$dns$firewall$cluster = void;
    export type dns$firewall$update$dns$firewall$cluster = void;
    export type zero$trust$accounts$get$zero$trust$account$information = void;
    export type zero$trust$accounts$create$zero$trust$account = void;
    export type zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings = void;
    export type zero$trust$get$audit$ssh$settings = void;
    export type zero$trust$update$audit$ssh$settings = void;
    export type zero$trust$gateway$categories$list$categories = void;
    export type zero$trust$accounts$get$zero$trust$account$configuration = void;
    export type zero$trust$accounts$update$zero$trust$account$configuration = void;
    export type zero$trust$accounts$patch$zero$trust$account$configuration = void;
    export type zero$trust$lists$list$zero$trust$lists = void;
    export type zero$trust$lists$create$zero$trust$list = void;
    export type zero$trust$lists$zero$trust$list$details = void;
    export type zero$trust$lists$update$zero$trust$list = void;
    export type zero$trust$lists$delete$zero$trust$list = void;
    export type zero$trust$lists$patch$zero$trust$list = void;
    export type zero$trust$lists$zero$trust$list$items = void;
    export type zero$trust$gateway$locations$list$zero$trust$gateway$locations = void;
    export type zero$trust$gateway$locations$create$zero$trust$gateway$location = void;
    export type zero$trust$gateway$locations$zero$trust$gateway$location$details = void;
    export type zero$trust$gateway$locations$update$zero$trust$gateway$location = void;
    export type zero$trust$gateway$locations$delete$zero$trust$gateway$location = void;
    export type zero$trust$accounts$get$logging$settings$for$the$zero$trust$account = void;
    export type zero$trust$accounts$update$logging$settings$for$the$zero$trust$account = void;
    export type zero$trust$gateway$proxy$endpoints$list$proxy$endpoints = void;
    export type zero$trust$gateway$proxy$endpoints$create$proxy$endpoint = void;
    export type zero$trust$gateway$proxy$endpoints$proxy$endpoint$details = void;
    export type zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint = void;
    export type zero$trust$gateway$proxy$endpoints$update$proxy$endpoint = void;
    export type zero$trust$gateway$rules$list$zero$trust$gateway$rules = void;
    export type zero$trust$gateway$rules$create$zero$trust$gateway$rule = void;
    export type zero$trust$gateway$rules$zero$trust$gateway$rule$details = void;
    export type zero$trust$gateway$rules$update$zero$trust$gateway$rule = void;
    export type zero$trust$gateway$rules$delete$zero$trust$gateway$rule = void;
    export type list$hyperdrive = void;
    export type create$hyperdrive = void;
    export type get$hyperdrive = void;
    export type update$hyperdrive = void;
    export type delete$hyperdrive = void;
    export type cloudflare$images$list$images = void;
    export type cloudflare$images$upload$an$image$via$url = void;
    export type cloudflare$images$image$details = void;
    export type cloudflare$images$delete$image = void;
    export type cloudflare$images$update$image = void;
    export type cloudflare$images$base$image = void;
    export type cloudflare$images$keys$list$signing$keys = void;
    export type cloudflare$images$images$usage$statistics = void;
    export type cloudflare$images$variants$list$variants = void;
    export type cloudflare$images$variants$create$a$variant = void;
    export type cloudflare$images$variants$variant$details = void;
    export type cloudflare$images$variants$delete$a$variant = void;
    export type cloudflare$images$variants$update$a$variant = void;
    export type cloudflare$images$list$images$v2 = void;
    export type cloudflare$images$create$authenticated$direct$upload$url$v$2 = void;
    export type asn$intelligence$get$asn$overview = void;
    export type asn$intelligence$get$asn$subnets = void;
    export type passive$dns$by$ip$get$passive$dns$by$ip = void;
    export type domain$intelligence$get$domain$details = void;
    export type domain$history$get$domain$history = void;
    export type domain$intelligence$get$multiple$domain$details = void;
    export type ip$intelligence$get$ip$overview = void;
    export type ip$list$get$ip$lists = void;
    export type miscategorization$create$miscategorization = void;
    export type whois$record$get$whois$record = void;
    export type get$accounts$account_identifier$logpush$datasets$dataset$fields = void;
    export type get$accounts$account_identifier$logpush$datasets$dataset$jobs = void;
    export type get$accounts$account_identifier$logpush$jobs = void;
    export type post$accounts$account_identifier$logpush$jobs = void;
    export type get$accounts$account_identifier$logpush$jobs$job_identifier = void;
    export type put$accounts$account_identifier$logpush$jobs$job_identifier = void;
    export type delete$accounts$account_identifier$logpush$jobs$job_identifier = void;
    export type post$accounts$account_identifier$logpush$ownership = void;
    export type post$accounts$account_identifier$logpush$ownership$validate = void;
    export type delete$accounts$account_identifier$logpush$validate$destination$exists = void;
    export type post$accounts$account_identifier$logpush$validate$origin = void;
    export type get$accounts$account_identifier$logs$control$cmb$config = void;
    export type put$accounts$account_identifier$logs$control$cmb$config = void;
    export type delete$accounts$account_identifier$logs$control$cmb$config = void;
    export type pages$project$get$projects = void;
    export type pages$project$create$project = void;
    export type pages$project$get$project = void;
    export type pages$project$delete$project = void;
    export type pages$project$update$project = void;
    export type pages$deployment$get$deployments = void;
    export type pages$deployment$create$deployment = void;
    export type pages$deployment$get$deployment$info = void;
    export type pages$deployment$delete$deployment = void;
    export type pages$deployment$get$deployment$logs = void;
    export type pages$deployment$retry$deployment = void;
    export type pages$deployment$rollback$deployment = void;
    export type pages$domains$get$domains = void;
    export type pages$domains$add$domain = void;
    export type pages$domains$get$domain = void;
    export type pages$domains$delete$domain = void;
    export type pages$domains$patch$domain = void;
    export type pages$purge$build$cache = void;
    export type r2$list$buckets = void;
    export type r2$create$bucket = void;
    export type r2$get$bucket = void;
    export type r2$delete$bucket = void;
    export type r2$get$bucket$sippy$config = void;
    export type r2$put$bucket$sippy$config = void;
    export type r2$delete$bucket$sippy$config = void;
    export type registrar$domains$list$domains = void;
    export type registrar$domains$get$domain = void;
    export type registrar$domains$update$domain = void;
    export type lists$get$lists = void;
    export type lists$create$a$list = void;
    export type lists$get$a$list = void;
    export type lists$update$a$list = void;
    export type lists$delete$a$list = void;
    export type lists$get$list$items = void;
    export type lists$update$all$list$items = void;
    export type lists$create$list$items = void;
    export type lists$delete$list$items = void;
    export type listAccountRulesets = void;
    export type createAccountRuleset = void;
    export type getAccountRuleset = void;
    export type updateAccountRuleset = void;
    export type deleteAccountRuleset = void;
    export type createAccountRulesetRule = void;
    export type deleteAccountRulesetRule = void;
    export type updateAccountRulesetRule = void;
    export type listAccountRulesetVersions = void;
    export type getAccountRulesetVersion = void;
    export type deleteAccountRulesetVersion = void;
    export type listAccountRulesetVersionRulesByTag = void;
    export type getAccountEntrypointRuleset = void;
    export type updateAccountEntrypointRuleset = void;
    export type listAccountEntrypointRulesetVersions = void;
    export type getAccountEntrypointRulesetVersion = void;
    export type stream$videos$list$videos = void;
    export type stream$videos$initiate$video$uploads$using$tus = void;
    export type stream$videos$retrieve$video$details = void;
    export type stream$videos$update$video$details = void;
    export type stream$videos$delete$video = void;
    export type list$audio$tracks = void;
    export type delete$audio$tracks = void;
    export type edit$audio$tracks = void;
    export type add$audio$track = void;
    export type stream$subtitles$$captions$list$captions$or$subtitles = void;
    export type stream$subtitles$$captions$upload$captions$or$subtitles = void;
    export type stream$subtitles$$captions$delete$captions$or$subtitles = void;
    export type stream$m$p$4$downloads$list$downloads = void;
    export type stream$m$p$4$downloads$create$downloads = void;
    export type stream$m$p$4$downloads$delete$downloads = void;
    export type stream$videos$retreieve$embed$code$html = void;
    export type stream$videos$create$signed$url$tokens$for$videos = void;
    export type stream$video$clipping$clip$videos$given$a$start$and$end$time = void;
    export type stream$videos$upload$videos$from$a$url = void;
    export type stream$videos$upload$videos$via$direct$upload$ur$ls = void;
    export type stream$signing$keys$list$signing$keys = void;
    export type stream$signing$keys$create$signing$keys = void;
    export type stream$signing$keys$delete$signing$keys = void;
    export type stream$live$inputs$list$live$inputs = void;
    export type stream$live$inputs$create$a$live$input = void;
    export type stream$live$inputs$retrieve$a$live$input = void;
    export type stream$live$inputs$update$a$live$input = void;
    export type stream$live$inputs$delete$a$live$input = void;
    export type stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input = void;
    export type stream$live$inputs$create$a$new$output$$connected$to$a$live$input = void;
    export type stream$live$inputs$update$an$output = void;
    export type stream$live$inputs$delete$an$output = void;
    export type stream$videos$storage$usage = void;
    export type stream$watermark$profile$list$watermark$profiles = void;
    export type stream$watermark$profile$create$watermark$profiles$via$basic$upload = void;
    export type stream$watermark$profile$watermark$profile$details = void;
    export type stream$watermark$profile$delete$watermark$profiles = void;
    export type stream$webhook$view$webhooks = void;
    export type stream$webhook$create$webhooks = void;
    export type stream$webhook$delete$webhooks = void;
    export type tunnel$route$list$tunnel$routes = void;
    export type tunnel$route$create$a$tunnel$route = void;
    export type tunnel$route$delete$a$tunnel$route = void;
    export type tunnel$route$update$a$tunnel$route = void;
    export type tunnel$route$get$tunnel$route$by$ip = void;
    export type tunnel$route$create$a$tunnel$route$with$cidr = void;
    export type tunnel$route$delete$a$tunnel$route$with$cidr = void;
    export type tunnel$route$update$a$tunnel$route$with$cidr = void;
    export type tunnel$virtual$network$list$virtual$networks = void;
    export type tunnel$virtual$network$create$a$virtual$network = void;
    export type tunnel$virtual$network$delete$a$virtual$network = void;
    export type tunnel$virtual$network$update$a$virtual$network = void;
    export type cloudflare$tunnel$list$all$tunnels = void;
    export type argo$tunnel$create$an$argo$tunnel = void;
    export type argo$tunnel$get$an$argo$tunnel = void;
    export type argo$tunnel$delete$an$argo$tunnel = void;
    export type argo$tunnel$clean$up$argo$tunnel$connections = void;
    export type cloudflare$tunnel$list$warp$connector$tunnels = void;
    export type cloudflare$tunnel$create$a$warp$connector$tunnel = void;
    export type cloudflare$tunnel$get$a$warp$connector$tunnel = void;
    export type cloudflare$tunnel$delete$a$warp$connector$tunnel = void;
    export type cloudflare$tunnel$update$a$warp$connector$tunnel = void;
    export type cloudflare$tunnel$get$a$warp$connector$tunnel$token = void;
    export type worker$account$settings$fetch$worker$account$settings = void;
    export type worker$account$settings$create$worker$account$settings = void;
    export type worker$deployments$list$deployments = void;
    export type worker$deployments$get$deployment$detail = void;
    export type namespace$worker$script$worker$details = void;
    export type namespace$worker$script$upload$worker$module = void;
    export type namespace$worker$script$delete$worker = void;
    export type namespace$worker$get$script$content = void;
    export type namespace$worker$put$script$content = void;
    export type namespace$worker$get$script$settings = void;
    export type namespace$worker$patch$script$settings = void;
    export type worker$domain$list$domains = void;
    export type worker$domain$attach$to$domain = void;
    export type worker$domain$get$a$domain = void;
    export type worker$domain$detach$from$domain = void;
    export type durable$objects$namespace$list$namespaces = void;
    export type durable$objects$namespace$list$objects = void;
    export type queue$list$queues = void;
    export type queue$create$queue = void;
    export type queue$queue$details = void;
    export type queue$update$queue = void;
    export type queue$delete$queue = void;
    export type queue$list$queue$consumers = void;
    export type queue$create$queue$consumer = void;
    export type queue$update$queue$consumer = void;
    export type queue$delete$queue$consumer = void;
    export type worker$script$list$workers = void;
    export type worker$script$download$worker = void;
    export type worker$script$upload$worker$module = void;
    export type worker$script$delete$worker = void;
    export type worker$script$put$content = void;
    export type worker$script$get$content = void;
    export type worker$cron$trigger$get$cron$triggers = void;
    export type worker$cron$trigger$update$cron$triggers = void;
    export type worker$script$get$settings = void;
    export type worker$script$patch$settings = void;
    export type worker$tail$logs$list$tails = void;
    export type worker$tail$logs$start$tail = void;
    export type worker$tail$logs$delete$tail = void;
    export type worker$script$fetch$usage$model = void;
    export type worker$script$update$usage$model = void;
    export type worker$environment$get$script$content = void;
    export type worker$environment$put$script$content = void;
    export type worker$script$environment$get$settings = void;
    export type worker$script$environment$patch$settings = void;
    export type worker$subdomain$get$subdomain = void;
    export type worker$subdomain$create$subdomain = void;
    export type zero$trust$accounts$get$connectivity$settings = void;
    export type zero$trust$accounts$patch$connectivity$settings = void;
    export type ip$address$management$address$maps$list$address$maps = void;
    export type ip$address$management$address$maps$create$address$map = void;
    export type ip$address$management$address$maps$address$map$details = void;
    export type ip$address$management$address$maps$delete$address$map = void;
    export type ip$address$management$address$maps$update$address$map = void;
    export type ip$address$management$address$maps$add$an$ip$to$an$address$map = void;
    export type ip$address$management$address$maps$remove$an$ip$from$an$address$map = void;
    export type ip$address$management$address$maps$add$a$zone$membership$to$an$address$map = void;
    export type ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map = void;
    export type ip$address$management$prefixes$upload$loa$document = void;
    export type ip$address$management$prefixes$download$loa$document = void;
    export type ip$address$management$prefixes$list$prefixes = void;
    export type ip$address$management$prefixes$add$prefix = void;
    export type ip$address$management$prefixes$prefix$details = void;
    export type ip$address$management$prefixes$delete$prefix = void;
    export type ip$address$management$prefixes$update$prefix$description = void;
    export type ip$address$management$prefixes$list$bgp$prefixes = void;
    export type ip$address$management$prefixes$fetch$bgp$prefix = void;
    export type ip$address$management$prefixes$update$bgp$prefix = void;
    export type ip$address$management$dynamic$advertisement$get$advertisement$status = void;
    export type ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status = void;
    export type ip$address$management$service$bindings$list$service$bindings = void;
    export type ip$address$management$service$bindings$create$service$binding = void;
    export type ip$address$management$service$bindings$get$service$binding = void;
    export type ip$address$management$service$bindings$delete$service$binding = void;
    export type ip$address$management$prefix$delegation$list$prefix$delegations = void;
    export type ip$address$management$prefix$delegation$create$prefix$delegation = void;
    export type ip$address$management$prefix$delegation$delete$prefix$delegation = void;
    export type ip$address$management$service$bindings$list$services = void;
    export type workers$ai$post$run$model = Response$workers$ai$post$run$model$Status$400;
    export type audit$logs$get$account$audit$logs = void;
    export type account$billing$profile$$$deprecated$$billing$profile$details = void;
    export type accounts$turnstile$widgets$list = void;
    export type accounts$turnstile$widget$create = void;
    export type accounts$turnstile$widget$get = void;
    export type accounts$turnstile$widget$update = void;
    export type accounts$turnstile$widget$delete = void;
    export type accounts$turnstile$widget$rotate$secret = void;
    export type custom$pages$for$an$account$list$custom$pages = void;
    export type custom$pages$for$an$account$get$a$custom$page = void;
    export type custom$pages$for$an$account$update$a$custom$page = void;
    export type cloudflare$d1$get$database = void;
    export type cloudflare$d1$delete$database = void;
    export type cloudflare$d1$query$database = void;
    export type diagnostics$traceroute = void;
    export type dns$firewall$analytics$table = void;
    export type dns$firewall$analytics$by$time = void;
    export type email$routing$destination$addresses$list$destination$addresses = void;
    export type email$routing$destination$addresses$create$a$destination$address = void;
    export type email$routing$destination$addresses$get$a$destination$address = void;
    export type email$routing$destination$addresses$delete$destination$address = void;
    export type ip$access$rules$for$an$account$list$ip$access$rules = void;
    export type ip$access$rules$for$an$account$create$an$ip$access$rule = void;
    export type ip$access$rules$for$an$account$get$an$ip$access$rule = void;
    export type ip$access$rules$for$an$account$delete$an$ip$access$rule = void;
    export type ip$access$rules$for$an$account$update$an$ip$access$rule = void;
    export type custom$indicator$feeds$get$indicator$feeds = void;
    export type custom$indicator$feeds$create$indicator$feeds = void;
    export type custom$indicator$feeds$get$indicator$feed$metadata = void;
    export type custom$indicator$feeds$get$indicator$feed$data = void;
    export type custom$indicator$feeds$update$indicator$feed$data = void;
    export type custom$indicator$feeds$add$permission = void;
    export type custom$indicator$feeds$remove$permission = void;
    export type custom$indicator$feeds$view$permissions = void;
    export type sinkhole$config$get$sinkholes = void;
    export type account$load$balancer$monitors$list$monitors = void;
    export type account$load$balancer$monitors$create$monitor = void;
    export type account$load$balancer$monitors$monitor$details = void;
    export type account$load$balancer$monitors$update$monitor = void;
    export type account$load$balancer$monitors$delete$monitor = void;
    export type account$load$balancer$monitors$patch$monitor = void;
    export type account$load$balancer$monitors$preview$monitor = void;
    export type account$load$balancer$monitors$list$monitor$references = void;
    export type account$load$balancer$pools$list$pools = void;
    export type account$load$balancer$pools$create$pool = void;
    export type account$load$balancer$pools$patch$pools = void;
    export type account$load$balancer$pools$pool$details = void;
    export type account$load$balancer$pools$update$pool = void;
    export type account$load$balancer$pools$delete$pool = void;
    export type account$load$balancer$pools$patch$pool = void;
    export type account$load$balancer$pools$pool$health$details = void;
    export type account$load$balancer$pools$preview$pool = void;
    export type account$load$balancer$pools$list$pool$references = void;
    export type account$load$balancer$monitors$preview$result = void;
    export type load$balancer$regions$list$regions = void;
    export type load$balancer$regions$get$region = void;
    export type account$load$balancer$search$search$resources = void;
    export type magic$interconnects$list$interconnects = void;
    export type magic$interconnects$update$multiple$interconnects = void;
    export type magic$interconnects$list$interconnect$details = void;
    export type magic$interconnects$update$interconnect = void;
    export type magic$gre$tunnels$list$gre$tunnels = void;
    export type magic$gre$tunnels$update$multiple$gre$tunnels = void;
    export type magic$gre$tunnels$create$gre$tunnels = void;
    export type magic$gre$tunnels$list$gre$tunnel$details = void;
    export type magic$gre$tunnels$update$gre$tunnel = void;
    export type magic$gre$tunnels$delete$gre$tunnel = void;
    export type magic$ipsec$tunnels$list$ipsec$tunnels = void;
    export type magic$ipsec$tunnels$update$multiple$ipsec$tunnels = void;
    export type magic$ipsec$tunnels$create$ipsec$tunnels = void;
    export type magic$ipsec$tunnels$list$ipsec$tunnel$details = void;
    export type magic$ipsec$tunnels$update$ipsec$tunnel = void;
    export type magic$ipsec$tunnels$delete$ipsec$tunnel = void;
    export type magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels = void;
    export type magic$static$routes$list$routes = void;
    export type magic$static$routes$update$many$routes = void;
    export type magic$static$routes$create$routes = void;
    export type magic$static$routes$delete$many$routes = void;
    export type magic$static$routes$route$details = void;
    export type magic$static$routes$update$route = void;
    export type magic$static$routes$delete$route = void;
    export type account$members$list$members = void;
    export type account$members$add$member = void;
    export type account$members$member$details = void;
    export type account$members$update$member = void;
    export type account$members$remove$member = void;
    export type magic$network$monitoring$configuration$list$account$configuration = void;
    export type magic$network$monitoring$configuration$update$an$entire$account$configuration = void;
    export type magic$network$monitoring$configuration$create$account$configuration = void;
    export type magic$network$monitoring$configuration$delete$account$configuration = void;
    export type magic$network$monitoring$configuration$update$account$configuration$fields = void;
    export type magic$network$monitoring$configuration$list$rules$and$account$configuration = void;
    export type magic$network$monitoring$rules$list$rules = void;
    export type magic$network$monitoring$rules$update$rules = void;
    export type magic$network$monitoring$rules$create$rules = void;
    export type magic$network$monitoring$rules$get$rule = void;
    export type magic$network$monitoring$rules$delete$rule = void;
    export type magic$network$monitoring$rules$update$rule = void;
    export type magic$network$monitoring$rules$update$advertisement$for$rule = void;
    export type m$tls$certificate$management$list$m$tls$certificates = void;
    export type m$tls$certificate$management$upload$m$tls$certificate = void;
    export type m$tls$certificate$management$get$m$tls$certificate = void;
    export type m$tls$certificate$management$delete$m$tls$certificate = void;
    export type m$tls$certificate$management$list$m$tls$certificate$associations = void;
    export type magic$pcap$collection$list$packet$capture$requests = void;
    export type magic$pcap$collection$create$pcap$request = void;
    export type magic$pcap$collection$get$pcap$request = void;
    export type magic$pcap$collection$download$simple$pcap = void;
    export type magic$pcap$collection$list$pca$ps$bucket$ownership = void;
    export type magic$pcap$collection$add$buckets$for$full$packet$captures = void;
    export type magic$pcap$collection$delete$buckets$for$full$packet$captures = void;
    export type magic$pcap$collection$validate$buckets$for$full$packet$captures = void;
    export type account$request$tracer$request$trace = void;
    export type account$roles$list$roles = void;
    export type account$roles$role$details = void;
    export type lists$get$a$list$item = void;
    export type lists$get$bulk$operation$status = void;
    export type web$analytics$create$site = void;
    export type web$analytics$get$site = void;
    export type web$analytics$update$site = void;
    export type web$analytics$delete$site = void;
    export type web$analytics$list$sites = void;
    export type web$analytics$create$rule = void;
    export type web$analytics$update$rule = void;
    export type web$analytics$delete$rule = void;
    export type web$analytics$list$rules = void;
    export type web$analytics$modify$rules = void;
    export type secondary$dns$$$acl$$list$ac$ls = void;
    export type secondary$dns$$$acl$$create$acl = void;
    export type secondary$dns$$$acl$$acl$details = void;
    export type secondary$dns$$$acl$$update$acl = void;
    export type secondary$dns$$$acl$$delete$acl = void;
    export type secondary$dns$$$peer$$list$peers = void;
    export type secondary$dns$$$peer$$create$peer = void;
    export type secondary$dns$$$peer$$peer$details = void;
    export type secondary$dns$$$peer$$update$peer = void;
    export type secondary$dns$$$peer$$delete$peer = void;
    export type secondary$dns$$$tsig$$list$tsi$gs = void;
    export type secondary$dns$$$tsig$$create$tsig = void;
    export type secondary$dns$$$tsig$$tsig$details = void;
    export type secondary$dns$$$tsig$$update$tsig = void;
    export type secondary$dns$$$tsig$$delete$tsig = void;
    export type workers$kv$request$analytics$query$request$analytics = void;
    export type workers$kv$stored$data$analytics$query$stored$data$analytics = void;
    export type workers$kv$namespace$list$namespaces = void;
    export type workers$kv$namespace$create$a$namespace = void;
    export type workers$kv$namespace$rename$a$namespace = void;
    export type workers$kv$namespace$remove$a$namespace = void;
    export type workers$kv$namespace$write$multiple$key$value$pairs = void;
    export type workers$kv$namespace$delete$multiple$key$value$pairs = void;
    export type workers$kv$namespace$list$a$namespace$$s$keys = void;
    export type workers$kv$namespace$read$the$metadata$for$a$key = void;
    export type workers$kv$namespace$read$key$value$pair = void;
    export type workers$kv$namespace$write$key$value$pair$with$metadata = void;
    export type workers$kv$namespace$delete$key$value$pair = void;
    export type account$subscriptions$list$subscriptions = void;
    export type account$subscriptions$create$subscription = void;
    export type account$subscriptions$update$subscription = void;
    export type account$subscriptions$delete$subscription = void;
    export type vectorize$list$vectorize$indexes = void;
    export type vectorize$create$vectorize$index = void;
    export type vectorize$get$vectorize$index = void;
    export type vectorize$update$vectorize$index = void;
    export type vectorize$delete$vectorize$index = void;
    export type vectorize$delete$vectors$by$id = void;
    export type vectorize$get$vectors$by$id = void;
    export type vectorize$insert$vector = void;
    export type vectorize$query$vector = void;
    export type vectorize$upsert$vector = void;
    export type ip$address$management$address$maps$add$an$account$membership$to$an$address$map = void;
    export type ip$address$management$address$maps$remove$an$account$membership$from$an$address$map = void;
    export type urlscanner$search$scans = Response$urlscanner$search$scans$Status$400;
    export type urlscanner$create$scan = Response$urlscanner$create$scan$Status$400 | Response$urlscanner$create$scan$Status$409 | Response$urlscanner$create$scan$Status$429;
    export type urlscanner$get$scan = Response$urlscanner$get$scan$Status$400 | Response$urlscanner$get$scan$Status$404;
    export type urlscanner$get$scan$har = Response$urlscanner$get$scan$har$Status$400 | Response$urlscanner$get$scan$har$Status$404;
    export type urlscanner$get$scan$screenshot = Response$urlscanner$get$scan$screenshot$Status$400 | Response$urlscanner$get$scan$screenshot$Status$404;
    export type accounts$account$details = void;
    export type accounts$update$account = void;
    export type access$applications$list$access$applications = void;
    export type access$applications$add$an$application = void;
    export type access$applications$get$an$access$application = void;
    export type access$applications$update$a$bookmark$application = void;
    export type access$applications$delete$an$access$application = void;
    export type access$applications$revoke$service$tokens = void;
    export type access$applications$test$access$policies = void;
    export type access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca = void;
    export type access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca = void;
    export type access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca = void;
    export type access$policies$list$access$policies = void;
    export type access$policies$create$an$access$policy = void;
    export type access$policies$get$an$access$policy = void;
    export type access$policies$update$an$access$policy = void;
    export type access$policies$delete$an$access$policy = void;
    export type access$short$lived$certificate$c$as$list$short$lived$certificate$c$as = void;
    export type access$bookmark$applications$$$deprecated$$list$bookmark$applications = void;
    export type access$bookmark$applications$$$deprecated$$get$a$bookmark$application = void;
    export type access$bookmark$applications$$$deprecated$$update$a$bookmark$application = void;
    export type access$bookmark$applications$$$deprecated$$create$a$bookmark$application = void;
    export type access$bookmark$applications$$$deprecated$$delete$a$bookmark$application = void;
    export type access$mtls$authentication$list$mtls$certificates = void;
    export type access$mtls$authentication$add$an$mtls$certificate = void;
    export type access$mtls$authentication$get$an$mtls$certificate = void;
    export type access$mtls$authentication$update$an$mtls$certificate = void;
    export type access$mtls$authentication$delete$an$mtls$certificate = void;
    export type access$mtls$authentication$list$mtls$certificates$hostname$settings = void;
    export type access$mtls$authentication$update$an$mtls$certificate$settings = void;
    export type access$custom$pages$list$custom$pages = void;
    export type access$custom$pages$create$a$custom$page = void;
    export type access$custom$pages$get$a$custom$page = void;
    export type access$custom$pages$update$a$custom$page = void;
    export type access$custom$pages$delete$a$custom$page = void;
    export type access$groups$list$access$groups = void;
    export type access$groups$create$an$access$group = void;
    export type access$groups$get$an$access$group = void;
    export type access$groups$update$an$access$group = void;
    export type access$groups$delete$an$access$group = void;
    export type access$identity$providers$list$access$identity$providers = void;
    export type access$identity$providers$add$an$access$identity$provider = void;
    export type access$identity$providers$get$an$access$identity$provider = void;
    export type access$identity$providers$update$an$access$identity$provider = void;
    export type access$identity$providers$delete$an$access$identity$provider = void;
    export type access$key$configuration$get$the$access$key$configuration = void;
    export type access$key$configuration$update$the$access$key$configuration = void;
    export type access$key$configuration$rotate$access$keys = void;
    export type access$authentication$logs$get$access$authentication$logs = void;
    export type zero$trust$organization$get$your$zero$trust$organization = void;
    export type zero$trust$organization$update$your$zero$trust$organization = void;
    export type zero$trust$organization$create$your$zero$trust$organization = void;
    export type zero$trust$organization$revoke$all$access$tokens$for$a$user = void;
    export type zero$trust$seats$update$a$user$seat = void;
    export type access$service$tokens$list$service$tokens = void;
    export type access$service$tokens$create$a$service$token = void;
    export type access$service$tokens$update$a$service$token = void;
    export type access$service$tokens$delete$a$service$token = void;
    export type access$service$tokens$refresh$a$service$token = void;
    export type access$service$tokens$rotate$a$service$token = void;
    export type access$tags$list$tags = void;
    export type access$tags$create$tag = void;
    export type access$tags$get$a$tag = void;
    export type access$tags$update$a$tag = void;
    export type access$tags$delete$a$tag = void;
    export type zero$trust$users$get$users = void;
    export type zero$trust$users$get$active$sessions = void;
    export type zero$trust$users$get$active$session = void;
    export type zero$trust$users$get$failed$logins = void;
    export type zero$trust$users$get$last$seen$identity = void;
    export type devices$list$devices = void;
    export type devices$device$details = void;
    export type devices$list$admin$override$code$for$device = void;
    export type device$dex$test$details = void;
    export type device$dex$test$create$device$dex$test = void;
    export type device$dex$test$get$device$dex$test = void;
    export type device$dex$test$update$device$dex$test = void;
    export type device$dex$test$delete$device$dex$test = void;
    export type device$managed$networks$list$device$managed$networks = void;
    export type device$managed$networks$create$device$managed$network = void;
    export type device$managed$networks$device$managed$network$details = void;
    export type device$managed$networks$update$device$managed$network = void;
    export type device$managed$networks$delete$device$managed$network = void;
    export type devices$list$device$settings$policies = void;
    export type devices$get$default$device$settings$policy = void;
    export type devices$create$device$settings$policy = void;
    export type devices$update$default$device$settings$policy = void;
    export type devices$get$device$settings$policy$by$id = void;
    export type devices$delete$device$settings$policy = void;
    export type devices$update$device$settings$policy = void;
    export type devices$get$split$tunnel$exclude$list$for$a$device$settings$policy = void;
    export type devices$set$split$tunnel$exclude$list$for$a$device$settings$policy = void;
    export type devices$get$local$domain$fallback$list$for$a$device$settings$policy = void;
    export type devices$set$local$domain$fallback$list$for$a$device$settings$policy = void;
    export type devices$get$split$tunnel$include$list$for$a$device$settings$policy = void;
    export type devices$set$split$tunnel$include$list$for$a$device$settings$policy = void;
    export type devices$get$split$tunnel$exclude$list = void;
    export type devices$set$split$tunnel$exclude$list = void;
    export type devices$get$local$domain$fallback$list = void;
    export type devices$set$local$domain$fallback$list = void;
    export type devices$get$split$tunnel$include$list = void;
    export type devices$set$split$tunnel$include$list = void;
    export type device$posture$rules$list$device$posture$rules = void;
    export type device$posture$rules$create$device$posture$rule = void;
    export type device$posture$rules$device$posture$rules$details = void;
    export type device$posture$rules$update$device$posture$rule = void;
    export type device$posture$rules$delete$device$posture$rule = void;
    export type device$posture$integrations$list$device$posture$integrations = void;
    export type device$posture$integrations$create$device$posture$integration = void;
    export type device$posture$integrations$device$posture$integration$details = void;
    export type device$posture$integrations$delete$device$posture$integration = void;
    export type device$posture$integrations$update$device$posture$integration = void;
    export type devices$revoke$devices = void;
    export type zero$trust$accounts$get$device$settings$for$zero$trust$account = void;
    export type zero$trust$accounts$update$device$settings$for$the$zero$trust$account = void;
    export type devices$unrevoke$devices = void;
    export type origin$ca$list$certificates = void;
    export type origin$ca$create$certificate = void;
    export type origin$ca$get$certificate = void;
    export type origin$ca$revoke$certificate = void;
    export type cloudflare$i$ps$cloudflare$ip$details = void;
    export type user$$s$account$memberships$list$memberships = void;
    export type user$$s$account$memberships$membership$details = void;
    export type user$$s$account$memberships$update$membership = void;
    export type user$$s$account$memberships$delete$membership = void;
    export type organizations$$$deprecated$$organization$details = void;
    export type organizations$$$deprecated$$edit$organization = void;
    export type audit$logs$get$organization$audit$logs = void;
    export type organization$invites$list$invitations = void;
    export type organization$invites$create$invitation = void;
    export type organization$invites$invitation$details = void;
    export type organization$invites$cancel$invitation = void;
    export type organization$invites$edit$invitation$roles = void;
    export type organization$members$list$members = void;
    export type organization$members$member$details = void;
    export type organization$members$remove$member = void;
    export type organization$members$edit$member$roles = void;
    export type organization$roles$list$roles = void;
    export type organization$roles$role$details = void;
    export type radar$get$annotations$outages = Response$radar$get$annotations$outages$Status$400;
    export type radar$get$annotations$outages$top = Response$radar$get$annotations$outages$top$Status$400;
    export type radar$get$dns$as112$timeseries$by$dnssec = Response$radar$get$dns$as112$timeseries$by$dnssec$Status$400;
    export type radar$get$dns$as112$timeseries$by$edns = Response$radar$get$dns$as112$timeseries$by$edns$Status$400;
    export type radar$get$dns$as112$timeseries$by$ip$version = Response$radar$get$dns$as112$timeseries$by$ip$version$Status$400;
    export type radar$get$dns$as112$timeseries$by$protocol = Response$radar$get$dns$as112$timeseries$by$protocol$Status$400;
    export type radar$get$dns$as112$timeseries$by$query$type = Response$radar$get$dns$as112$timeseries$by$query$type$Status$400;
    export type radar$get$dns$as112$timeseries$by$response$codes = Response$radar$get$dns$as112$timeseries$by$response$codes$Status$400;
    export type radar$get$dns$as112$timeseries = Response$radar$get$dns$as112$timeseries$Status$400;
    export type radar$get$dns$as112$timeseries$group$by$dnssec = Response$radar$get$dns$as112$timeseries$group$by$dnssec$Status$400;
    export type radar$get$dns$as112$timeseries$group$by$edns = Response$radar$get$dns$as112$timeseries$group$by$edns$Status$400;
    export type radar$get$dns$as112$timeseries$group$by$ip$version = Response$radar$get$dns$as112$timeseries$group$by$ip$version$Status$400;
    export type radar$get$dns$as112$timeseries$group$by$protocol = Response$radar$get$dns$as112$timeseries$group$by$protocol$Status$400;
    export type radar$get$dns$as112$timeseries$group$by$query$type = Response$radar$get$dns$as112$timeseries$group$by$query$type$Status$400;
    export type radar$get$dns$as112$timeseries$group$by$response$codes = Response$radar$get$dns$as112$timeseries$group$by$response$codes$Status$400;
    export type radar$get$dns$as112$top$locations = Response$radar$get$dns$as112$top$locations$Status$404;
    export type radar$get$dns$as112$top$locations$by$dnssec = Response$radar$get$dns$as112$top$locations$by$dnssec$Status$404;
    export type radar$get$dns$as112$top$locations$by$edns = Response$radar$get$dns$as112$top$locations$by$edns$Status$404;
    export type radar$get$dns$as112$top$locations$by$ip$version = Response$radar$get$dns$as112$top$locations$by$ip$version$Status$404;
    export type radar$get$attacks$layer3$summary = Response$radar$get$attacks$layer3$summary$Status$400;
    export type radar$get$attacks$layer3$summary$by$bitrate = Response$radar$get$attacks$layer3$summary$by$bitrate$Status$400;
    export type radar$get$attacks$layer3$summary$by$duration = Response$radar$get$attacks$layer3$summary$by$duration$Status$400;
    export type radar$get$attacks$layer3$summary$by$ip$version = Response$radar$get$attacks$layer3$summary$by$ip$version$Status$400;
    export type radar$get$attacks$layer3$summary$by$protocol = Response$radar$get$attacks$layer3$summary$by$protocol$Status$400;
    export type radar$get$attacks$layer3$summary$by$vector = Response$radar$get$attacks$layer3$summary$by$vector$Status$400;
    export type radar$get$attacks$layer3$timeseries$by$bytes = Response$radar$get$attacks$layer3$timeseries$by$bytes$Status$400;
    export type radar$get$attacks$layer3$timeseries$groups = Response$radar$get$attacks$layer3$timeseries$groups$Status$400;
    export type radar$get$attacks$layer3$timeseries$group$by$bitrate = Response$radar$get$attacks$layer3$timeseries$group$by$bitrate$Status$400;
    export type radar$get$attacks$layer3$timeseries$group$by$duration = Response$radar$get$attacks$layer3$timeseries$group$by$duration$Status$400;
    export type radar$get$attacks$layer3$timeseries$group$by$industry = Response$radar$get$attacks$layer3$timeseries$group$by$industry$Status$400;
    export type radar$get$attacks$layer3$timeseries$group$by$ip$version = Response$radar$get$attacks$layer3$timeseries$group$by$ip$version$Status$400;
    export type radar$get$attacks$layer3$timeseries$group$by$protocol = Response$radar$get$attacks$layer3$timeseries$group$by$protocol$Status$400;
    export type radar$get$attacks$layer3$timeseries$group$by$vector = Response$radar$get$attacks$layer3$timeseries$group$by$vector$Status$400;
    export type radar$get$attacks$layer3$timeseries$group$by$vertical = Response$radar$get$attacks$layer3$timeseries$group$by$vertical$Status$400;
    export type radar$get$attacks$layer3$top$attacks = Response$radar$get$attacks$layer3$top$attacks$Status$404;
    export type radar$get$attacks$layer3$top$industries = Response$radar$get$attacks$layer3$top$industries$Status$404;
    export type radar$get$attacks$layer3$top$origin$locations = Response$radar$get$attacks$layer3$top$origin$locations$Status$404;
    export type radar$get$attacks$layer3$top$target$locations = Response$radar$get$attacks$layer3$top$target$locations$Status$404;
    export type radar$get$attacks$layer3$top$verticals = Response$radar$get$attacks$layer3$top$verticals$Status$404;
    export type radar$get$attacks$layer7$summary = Response$radar$get$attacks$layer7$summary$Status$400;
    export type radar$get$attacks$layer7$summary$by$http$method = Response$radar$get$attacks$layer7$summary$by$http$method$Status$400;
    export type radar$get$attacks$layer7$summary$by$http$version = Response$radar$get$attacks$layer7$summary$by$http$version$Status$400;
    export type radar$get$attacks$layer7$summary$by$ip$version = Response$radar$get$attacks$layer7$summary$by$ip$version$Status$400;
    export type radar$get$attacks$layer7$summary$by$managed$rules = Response$radar$get$attacks$layer7$summary$by$managed$rules$Status$400;
    export type radar$get$attacks$layer7$summary$by$mitigation$product = Response$radar$get$attacks$layer7$summary$by$mitigation$product$Status$400;
    export type radar$get$attacks$layer7$timeseries = Response$radar$get$attacks$layer7$timeseries$Status$400;
    export type radar$get$attacks$layer7$timeseries$group = Response$radar$get$attacks$layer7$timeseries$group$Status$400;
    export type radar$get$attacks$layer7$timeseries$group$by$http$method = Response$radar$get$attacks$layer7$timeseries$group$by$http$method$Status$400;
    export type radar$get$attacks$layer7$timeseries$group$by$http$version = Response$radar$get$attacks$layer7$timeseries$group$by$http$version$Status$400;
    export type radar$get$attacks$layer7$timeseries$group$by$industry = Response$radar$get$attacks$layer7$timeseries$group$by$industry$Status$400;
    export type radar$get$attacks$layer7$timeseries$group$by$ip$version = Response$radar$get$attacks$layer7$timeseries$group$by$ip$version$Status$400;
    export type radar$get$attacks$layer7$timeseries$group$by$managed$rules = Response$radar$get$attacks$layer7$timeseries$group$by$managed$rules$Status$400;
    export type radar$get$attacks$layer7$timeseries$group$by$mitigation$product = Response$radar$get$attacks$layer7$timeseries$group$by$mitigation$product$Status$400;
    export type radar$get$attacks$layer7$timeseries$group$by$vertical = Response$radar$get$attacks$layer7$timeseries$group$by$vertical$Status$400;
    export type radar$get$attacks$layer7$top$origin$as = Response$radar$get$attacks$layer7$top$origin$as$Status$404;
    export type radar$get$attacks$layer7$top$attacks = Response$radar$get$attacks$layer7$top$attacks$Status$404;
    export type radar$get$attacks$layer7$top$industries = Response$radar$get$attacks$layer7$top$industries$Status$404;
    export type radar$get$attacks$layer7$top$origin$location = Response$radar$get$attacks$layer7$top$origin$location$Status$404;
    export type radar$get$attacks$layer7$top$target$location = Response$radar$get$attacks$layer7$top$target$location$Status$404;
    export type radar$get$attacks$layer7$top$verticals = Response$radar$get$attacks$layer7$top$verticals$Status$404;
    export type radar$get$bgp$hijacks$events = Response$radar$get$bgp$hijacks$events$Status$400;
    export type radar$get$bgp$route$leak$events = Response$radar$get$bgp$route$leak$events$Status$400;
    export type radar$get$bgp$pfx2as$moas = Response$radar$get$bgp$pfx2as$moas$Status$400;
    export type radar$get$bgp$pfx2as = Response$radar$get$bgp$pfx2as$Status$400;
    export type radar$get$bgp$routes$stats = Response$radar$get$bgp$routes$stats$Status$400;
    export type radar$get$bgp$timeseries = Response$radar$get$bgp$timeseries$Status$400;
    export type radar$get$bgp$top$ases = Response$radar$get$bgp$top$ases$Status$400;
    export type radar$get$bgp$top$asns$by$prefixes = Response$radar$get$bgp$top$asns$by$prefixes$Status$404;
    export type radar$get$bgp$top$prefixes = Response$radar$get$bgp$top$prefixes$Status$400;
    export type radar$get$connection$tampering$summary = Response$radar$get$connection$tampering$summary$Status$400;
    export type radar$get$connection$tampering$timeseries$group = Response$radar$get$connection$tampering$timeseries$group$Status$400;
    export type radar$get$reports$datasets = Response$radar$get$reports$datasets$Status$400;
    export type radar$get$reports$dataset$download = Response$radar$get$reports$dataset$download$Status$400;
    export type radar$post$reports$dataset$download$url = Response$radar$post$reports$dataset$download$url$Status$400;
    export type radar$get$dns$top$ases = Response$radar$get$dns$top$ases$Status$404;
    export type radar$get$dns$top$locations = Response$radar$get$dns$top$locations$Status$404;
    export type radar$get$email$security$summary$by$arc = Response$radar$get$email$security$summary$by$arc$Status$400;
    export type radar$get$email$security$summary$by$dkim = Response$radar$get$email$security$summary$by$dkim$Status$400;
    export type radar$get$email$security$summary$by$dmarc = Response$radar$get$email$security$summary$by$dmarc$Status$400;
    export type radar$get$email$security$summary$by$malicious = Response$radar$get$email$security$summary$by$malicious$Status$400;
    export type radar$get$email$security$summary$by$spam = Response$radar$get$email$security$summary$by$spam$Status$400;
    export type radar$get$email$security$summary$by$spf = Response$radar$get$email$security$summary$by$spf$Status$400;
    export type radar$get$email$security$summary$by$threat$category = Response$radar$get$email$security$summary$by$threat$category$Status$400;
    export type radar$get$email$security$timeseries$group$by$arc = Response$radar$get$email$security$timeseries$group$by$arc$Status$400;
    export type radar$get$email$security$timeseries$group$by$dkim = Response$radar$get$email$security$timeseries$group$by$dkim$Status$400;
    export type radar$get$email$security$timeseries$group$by$dmarc = Response$radar$get$email$security$timeseries$group$by$dmarc$Status$400;
    export type radar$get$email$security$timeseries$group$by$malicious = Response$radar$get$email$security$timeseries$group$by$malicious$Status$400;
    export type radar$get$email$security$timeseries$group$by$spam = Response$radar$get$email$security$timeseries$group$by$spam$Status$400;
    export type radar$get$email$security$timeseries$group$by$spf = Response$radar$get$email$security$timeseries$group$by$spf$Status$400;
    export type radar$get$email$security$timeseries$group$by$threat$category = Response$radar$get$email$security$timeseries$group$by$threat$category$Status$400;
    export type radar$get$email$security$top$ases$by$messages = Response$radar$get$email$security$top$ases$by$messages$Status$404;
    export type radar$get$email$security$top$ases$by$arc = Response$radar$get$email$security$top$ases$by$arc$Status$404;
    export type radar$get$email$security$top$ases$by$dkim = Response$radar$get$email$security$top$ases$by$dkim$Status$404;
    export type radar$get$email$security$top$ases$by$dmarc = Response$radar$get$email$security$top$ases$by$dmarc$Status$404;
    export type radar$get$email$security$top$ases$by$malicious = Response$radar$get$email$security$top$ases$by$malicious$Status$404;
    export type radar$get$email$security$top$ases$by$spam = Response$radar$get$email$security$top$ases$by$spam$Status$404;
    export type radar$get$email$security$top$ases$by$spf = Response$radar$get$email$security$top$ases$by$spf$Status$404;
    export type radar$get$email$security$top$locations$by$messages = Response$radar$get$email$security$top$locations$by$messages$Status$404;
    export type radar$get$email$security$top$locations$by$arc = Response$radar$get$email$security$top$locations$by$arc$Status$404;
    export type radar$get$email$security$top$locations$by$dkim = Response$radar$get$email$security$top$locations$by$dkim$Status$404;
    export type radar$get$email$security$top$locations$by$dmarc = Response$radar$get$email$security$top$locations$by$dmarc$Status$404;
    export type radar$get$email$security$top$locations$by$malicious = Response$radar$get$email$security$top$locations$by$malicious$Status$404;
    export type radar$get$email$security$top$locations$by$spam = Response$radar$get$email$security$top$locations$by$spam$Status$404;
    export type radar$get$email$security$top$locations$by$spf = Response$radar$get$email$security$top$locations$by$spf$Status$404;
    export type radar$get$entities$asn$list = Response$radar$get$entities$asn$list$Status$400;
    export type radar$get$entities$asn$by$id = Response$radar$get$entities$asn$by$id$Status$404;
    export type radar$get$asns$rel = Response$radar$get$asns$rel$Status$400;
    export type radar$get$entities$asn$by$ip = Response$radar$get$entities$asn$by$ip$Status$404;
    export type radar$get$entities$ip = Response$radar$get$entities$ip$Status$404;
    export type radar$get$entities$locations = Response$radar$get$entities$locations$Status$400;
    export type radar$get$entities$location$by$alpha2 = Response$radar$get$entities$location$by$alpha2$Status$404;
    export type radar$get$http$summary$by$bot$class = Response$radar$get$http$summary$by$bot$class$Status$400;
    export type radar$get$http$summary$by$device$type = Response$radar$get$http$summary$by$device$type$Status$400;
    export type radar$get$http$summary$by$http$protocol = Response$radar$get$http$summary$by$http$protocol$Status$400;
    export type radar$get$http$summary$by$http$version = Response$radar$get$http$summary$by$http$version$Status$400;
    export type radar$get$http$summary$by$ip$version = Response$radar$get$http$summary$by$ip$version$Status$400;
    export type radar$get$http$summary$by$operating$system = Response$radar$get$http$summary$by$operating$system$Status$400;
    export type radar$get$http$summary$by$tls$version = Response$radar$get$http$summary$by$tls$version$Status$400;
    export type radar$get$http$timeseries$group$by$bot$class = Response$radar$get$http$timeseries$group$by$bot$class$Status$400;
    export type radar$get$http$timeseries$group$by$browsers = Response$radar$get$http$timeseries$group$by$browsers$Status$400;
    export type radar$get$http$timeseries$group$by$browser$families = Response$radar$get$http$timeseries$group$by$browser$families$Status$400;
    export type radar$get$http$timeseries$group$by$device$type = Response$radar$get$http$timeseries$group$by$device$type$Status$400;
    export type radar$get$http$timeseries$group$by$http$protocol = Response$radar$get$http$timeseries$group$by$http$protocol$Status$400;
    export type radar$get$http$timeseries$group$by$http$version = Response$radar$get$http$timeseries$group$by$http$version$Status$400;
    export type radar$get$http$timeseries$group$by$ip$version = Response$radar$get$http$timeseries$group$by$ip$version$Status$400;
    export type radar$get$http$timeseries$group$by$operating$system = Response$radar$get$http$timeseries$group$by$operating$system$Status$400;
    export type radar$get$http$timeseries$group$by$tls$version = Response$radar$get$http$timeseries$group$by$tls$version$Status$400;
    export type radar$get$http$top$ases$by$http$requests = Response$radar$get$http$top$ases$by$http$requests$Status$404;
    export type radar$get$http$top$ases$by$bot$class = Response$radar$get$http$top$ases$by$bot$class$Status$404;
    export type radar$get$http$top$ases$by$device$type = Response$radar$get$http$top$ases$by$device$type$Status$404;
    export type radar$get$http$top$ases$by$http$protocol = Response$radar$get$http$top$ases$by$http$protocol$Status$404;
    export type radar$get$http$top$ases$by$http$version = Response$radar$get$http$top$ases$by$http$version$Status$404;
    export type radar$get$http$top$ases$by$ip$version = Response$radar$get$http$top$ases$by$ip$version$Status$404;
    export type radar$get$http$top$ases$by$operating$system = Response$radar$get$http$top$ases$by$operating$system$Status$404;
    export type radar$get$http$top$ases$by$tls$version = Response$radar$get$http$top$ases$by$tls$version$Status$404;
    export type radar$get$http$top$browser$families = Response$radar$get$http$top$browser$families$Status$404;
    export type radar$get$http$top$browsers = Response$radar$get$http$top$browsers$Status$404;
    export type radar$get$http$top$locations$by$http$requests = Response$radar$get$http$top$locations$by$http$requests$Status$404;
    export type radar$get$http$top$locations$by$bot$class = Response$radar$get$http$top$locations$by$bot$class$Status$404;
    export type radar$get$http$top$locations$by$device$type = Response$radar$get$http$top$locations$by$device$type$Status$404;
    export type radar$get$http$top$locations$by$http$protocol = Response$radar$get$http$top$locations$by$http$protocol$Status$404;
    export type radar$get$http$top$locations$by$http$version = Response$radar$get$http$top$locations$by$http$version$Status$404;
    export type radar$get$http$top$locations$by$ip$version = Response$radar$get$http$top$locations$by$ip$version$Status$404;
    export type radar$get$http$top$locations$by$operating$system = Response$radar$get$http$top$locations$by$operating$system$Status$404;
    export type radar$get$http$top$locations$by$tls$version = Response$radar$get$http$top$locations$by$tls$version$Status$404;
    export type radar$get$netflows$timeseries = Response$radar$get$netflows$timeseries$Status$400;
    export type radar$get$netflows$top$ases = Response$radar$get$netflows$top$ases$Status$400;
    export type radar$get$netflows$top$locations = Response$radar$get$netflows$top$locations$Status$400;
    export type radar$get$quality$index$summary = Response$radar$get$quality$index$summary$Status$400;
    export type radar$get$quality$index$timeseries$group = Response$radar$get$quality$index$timeseries$group$Status$400;
    export type radar$get$quality$speed$histogram = Response$radar$get$quality$speed$histogram$Status$400;
    export type radar$get$quality$speed$summary = Response$radar$get$quality$speed$summary$Status$400;
    export type radar$get$quality$speed$top$ases = Response$radar$get$quality$speed$top$ases$Status$404;
    export type radar$get$quality$speed$top$locations = Response$radar$get$quality$speed$top$locations$Status$404;
    export type radar$get$ranking$domain$details = Response$radar$get$ranking$domain$details$Status$400;
    export type radar$get$ranking$domain$timeseries = Response$radar$get$ranking$domain$timeseries$Status$400;
    export type radar$get$ranking$top$domains = Response$radar$get$ranking$top$domains$Status$400;
    export type radar$get$search$global = Response$radar$get$search$global$Status$400;
    export type radar$get$traffic$anomalies = Response$radar$get$traffic$anomalies$Status$400;
    export type radar$get$traffic$anomalies$top = Response$radar$get$traffic$anomalies$top$Status$400;
    export type radar$get$verified$bots$top$by$http$requests = Response$radar$get$verified$bots$top$by$http$requests$Status$400;
    export type radar$get$verified$bots$top$categories$by$http$requests = Response$radar$get$verified$bots$top$categories$by$http$requests$Status$400;
    export type user$user$details = void;
    export type user$edit$user = void;
    export type audit$logs$get$user$audit$logs = void;
    export type user$billing$history$$$deprecated$$billing$history$details = void;
    export type user$billing$profile$$$deprecated$$billing$profile$details = void;
    export type ip$access$rules$for$a$user$list$ip$access$rules = void;
    export type ip$access$rules$for$a$user$create$an$ip$access$rule = void;
    export type ip$access$rules$for$a$user$delete$an$ip$access$rule = void;
    export type ip$access$rules$for$a$user$update$an$ip$access$rule = void;
    export type user$$s$invites$list$invitations = void;
    export type user$$s$invites$invitation$details = void;
    export type user$$s$invites$respond$to$invitation = void;
    export type load$balancer$monitors$list$monitors = void;
    export type load$balancer$monitors$create$monitor = void;
    export type load$balancer$monitors$monitor$details = void;
    export type load$balancer$monitors$update$monitor = void;
    export type load$balancer$monitors$delete$monitor = void;
    export type load$balancer$monitors$patch$monitor = void;
    export type load$balancer$monitors$preview$monitor = void;
    export type load$balancer$monitors$list$monitor$references = void;
    export type load$balancer$pools$list$pools = void;
    export type load$balancer$pools$create$pool = void;
    export type load$balancer$pools$patch$pools = void;
    export type load$balancer$pools$pool$details = void;
    export type load$balancer$pools$update$pool = void;
    export type load$balancer$pools$delete$pool = void;
    export type load$balancer$pools$patch$pool = void;
    export type load$balancer$pools$pool$health$details = void;
    export type load$balancer$pools$preview$pool = void;
    export type load$balancer$pools$list$pool$references = void;
    export type load$balancer$monitors$preview$result = void;
    export type load$balancer$healthcheck$events$list$healthcheck$events = void;
    export type user$$s$organizations$list$organizations = void;
    export type user$$s$organizations$organization$details = void;
    export type user$$s$organizations$leave$organization = void;
    export type user$subscription$get$user$subscriptions = void;
    export type user$subscription$update$user$subscription = void;
    export type user$subscription$delete$user$subscription = void;
    export type user$api$tokens$list$tokens = void;
    export type user$api$tokens$create$token = void;
    export type user$api$tokens$token$details = void;
    export type user$api$tokens$update$token = void;
    export type user$api$tokens$delete$token = void;
    export type user$api$tokens$roll$token = void;
    export type permission$groups$list$permission$groups = void;
    export type user$api$tokens$verify$token = void;
    export type zones$get = void;
    export type zones$post = void;
    export type zone$level$access$applications$list$access$applications = void;
    export type zone$level$access$applications$add$a$bookmark$application = void;
    export type zone$level$access$applications$get$an$access$application = void;
    export type zone$level$access$applications$update$a$bookmark$application = void;
    export type zone$level$access$applications$delete$an$access$application = void;
    export type zone$level$access$applications$revoke$service$tokens = void;
    export type zone$level$access$applications$test$access$policies = void;
    export type zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca = void;
    export type zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca = void;
    export type zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca = void;
    export type zone$level$access$policies$list$access$policies = void;
    export type zone$level$access$policies$create$an$access$policy = void;
    export type zone$level$access$policies$get$an$access$policy = void;
    export type zone$level$access$policies$update$an$access$policy = void;
    export type zone$level$access$policies$delete$an$access$policy = void;
    export type zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as = void;
    export type zone$level$access$mtls$authentication$list$mtls$certificates = void;
    export type zone$level$access$mtls$authentication$add$an$mtls$certificate = void;
    export type zone$level$access$mtls$authentication$get$an$mtls$certificate = void;
    export type zone$level$access$mtls$authentication$update$an$mtls$certificate = void;
    export type zone$level$access$mtls$authentication$delete$an$mtls$certificate = void;
    export type zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings = void;
    export type zone$level$access$mtls$authentication$update$an$mtls$certificate$settings = void;
    export type zone$level$access$groups$list$access$groups = void;
    export type zone$level$access$groups$create$an$access$group = void;
    export type zone$level$access$groups$get$an$access$group = void;
    export type zone$level$access$groups$update$an$access$group = void;
    export type zone$level$access$groups$delete$an$access$group = void;
    export type zone$level$access$identity$providers$list$access$identity$providers = void;
    export type zone$level$access$identity$providers$add$an$access$identity$provider = void;
    export type zone$level$access$identity$providers$get$an$access$identity$provider = void;
    export type zone$level$access$identity$providers$update$an$access$identity$provider = void;
    export type zone$level$access$identity$providers$delete$an$access$identity$provider = void;
    export type zone$level$zero$trust$organization$get$your$zero$trust$organization = void;
    export type zone$level$zero$trust$organization$update$your$zero$trust$organization = void;
    export type zone$level$zero$trust$organization$create$your$zero$trust$organization = void;
    export type zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user = void;
    export type zone$level$access$service$tokens$list$service$tokens = void;
    export type zone$level$access$service$tokens$create$a$service$token = void;
    export type zone$level$access$service$tokens$update$a$service$token = void;
    export type zone$level$access$service$tokens$delete$a$service$token = void;
    export type dns$analytics$table = void;
    export type dns$analytics$by$time = void;
    export type load$balancers$list$load$balancers = void;
    export type load$balancers$create$load$balancer = void;
    export type zone$purge = void;
    export type analyze$certificate$analyze$certificate = void;
    export type zone$subscription$zone$subscription$details = void;
    export type zone$subscription$update$zone$subscription = void;
    export type zone$subscription$create$zone$subscription = void;
    export type load$balancers$load$balancer$details = void;
    export type load$balancers$update$load$balancer = void;
    export type load$balancers$delete$load$balancer = void;
    export type load$balancers$patch$load$balancer = void;
    export type zones$0$get = void;
    export type zones$0$delete = void;
    export type zones$0$patch = void;
    export type put$zones$zone_id$activation_check = void;
    export type argo$analytics$for$zone$argo$analytics$for$a$zone = void;
    export type argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps = void;
    export type api$shield$settings$retrieve$information$about$specific$configuration$properties = void;
    export type api$shield$settings$set$configuration$properties = void;
    export type api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi = void;
    export type api$shield$api$discovery$retrieve$discovered$operations$on$a$zone = void;
    export type api$shield$api$patch$discovered$operations = void;
    export type api$shield$api$patch$discovered$operation = void;
    export type api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone = void;
    export type api$shield$endpoint$management$add$operations$to$a$zone = void;
    export type api$shield$endpoint$management$retrieve$information$about$an$operation = void;
    export type api$shield$endpoint$management$delete$an$operation = void;
    export type api$shield$schema$validation$retrieve$operation$level$settings = void;
    export type api$shield$schema$validation$update$operation$level$settings = void;
    export type api$shield$schema$validation$update$multiple$operation$level$settings = void;
    export type api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas = void;
    export type api$shield$schema$validation$retrieve$zone$level$settings = void;
    export type api$shield$schema$validation$update$zone$level$settings = void;
    export type api$shield$schema$validation$patch$zone$level$settings = void;
    export type api$shield$schema$validation$retrieve$information$about$all$schemas = void;
    export type api$shield$schema$validation$post$schema = void;
    export type api$shield$schema$validation$retrieve$information$about$specific$schema = void;
    export type api$shield$schema$delete$a$schema = void;
    export type api$shield$schema$validation$enable$validation$for$a$schema = void;
    export type api$shield$schema$validation$extract$operations$from$schema = void;
    export type argo$smart$routing$get$argo$smart$routing$setting = void;
    export type argo$smart$routing$patch$argo$smart$routing$setting = void;
    export type tiered$caching$get$tiered$caching$setting = void;
    export type tiered$caching$patch$tiered$caching$setting = void;
    export type bot$management$for$a$zone$get$config = void;
    export type bot$management$for$a$zone$update$config = void;
    export type zone$cache$settings$get$cache$reserve$setting = void;
    export type zone$cache$settings$change$cache$reserve$setting = void;
    export type zone$cache$settings$get$cache$reserve$clear = void;
    export type zone$cache$settings$start$cache$reserve$clear = void;
    export type zone$cache$settings$get$origin$post$quantum$encryption$setting = void;
    export type zone$cache$settings$change$origin$post$quantum$encryption$setting = void;
    export type zone$cache$settings$get$regional$tiered$cache$setting = void;
    export type zone$cache$settings$change$regional$tiered$cache$setting = void;
    export type smart$tiered$cache$get$smart$tiered$cache$setting = void;
    export type smart$tiered$cache$delete$smart$tiered$cache$setting = void;
    export type smart$tiered$cache$patch$smart$tiered$cache$setting = void;
    export type zone$cache$settings$get$variants$setting = void;
    export type zone$cache$settings$delete$variants$setting = void;
    export type zone$cache$settings$change$variants$setting = void;
    export type account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata = void;
    export type account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata = void;
    export type dns$records$for$a$zone$list$dns$records = void;
    export type dns$records$for$a$zone$create$dns$record = void;
    export type dns$records$for$a$zone$dns$record$details = void;
    export type dns$records$for$a$zone$update$dns$record = void;
    export type dns$records$for$a$zone$delete$dns$record = void;
    export type dns$records$for$a$zone$patch$dns$record = void;
    export type dns$records$for$a$zone$export$dns$records = void;
    export type dns$records$for$a$zone$import$dns$records = void;
    export type dns$records$for$a$zone$scan$dns$records = void;
    export type dnssec$dnssec$details = void;
    export type dnssec$delete$dnssec$records = void;
    export type dnssec$edit$dnssec$status = void;
    export type ip$access$rules$for$a$zone$list$ip$access$rules = void;
    export type ip$access$rules$for$a$zone$create$an$ip$access$rule = void;
    export type ip$access$rules$for$a$zone$delete$an$ip$access$rule = void;
    export type ip$access$rules$for$a$zone$update$an$ip$access$rule = void;
    export type waf$rule$groups$list$waf$rule$groups = void;
    export type waf$rule$groups$get$a$waf$rule$group = void;
    export type waf$rule$groups$update$a$waf$rule$group = void;
    export type waf$rules$list$waf$rules = void;
    export type waf$rules$get$a$waf$rule = void;
    export type waf$rules$update$a$waf$rule = void;
    export type zones$0$hold$get = void;
    export type zones$0$hold$post = void;
    export type zones$0$hold$delete = void;
    export type get$zones$zone_identifier$logpush$datasets$dataset$fields = void;
    export type get$zones$zone_identifier$logpush$datasets$dataset$jobs = void;
    export type get$zones$zone_identifier$logpush$edge$jobs = void;
    export type post$zones$zone_identifier$logpush$edge$jobs = void;
    export type get$zones$zone_identifier$logpush$jobs = void;
    export type post$zones$zone_identifier$logpush$jobs = void;
    export type get$zones$zone_identifier$logpush$jobs$job_identifier = void;
    export type put$zones$zone_identifier$logpush$jobs$job_identifier = void;
    export type delete$zones$zone_identifier$logpush$jobs$job_identifier = void;
    export type post$zones$zone_identifier$logpush$ownership = void;
    export type post$zones$zone_identifier$logpush$ownership$validate = void;
    export type post$zones$zone_identifier$logpush$validate$destination$exists = void;
    export type post$zones$zone_identifier$logpush$validate$origin = void;
    export type managed$transforms$list$managed$transforms = void;
    export type managed$transforms$update$status$of$managed$transforms = void;
    export type page$shield$get$page$shield$settings = void;
    export type page$shield$update$page$shield$settings = void;
    export type page$shield$list$page$shield$connections = void;
    export type page$shield$get$a$page$shield$connection = void;
    export type page$shield$list$page$shield$policies = void;
    export type page$shield$create$a$page$shield$policy = void;
    export type page$shield$get$a$page$shield$policy = void;
    export type page$shield$update$a$page$shield$policy = void;
    export type page$shield$delete$a$page$shield$policy = void;
    export type page$shield$list$page$shield$scripts = void;
    export type page$shield$get$a$page$shield$script = void;
    export type page$rules$list$page$rules = void;
    export type page$rules$create$a$page$rule = void;
    export type page$rules$get$a$page$rule = void;
    export type page$rules$update$a$page$rule = void;
    export type page$rules$delete$a$page$rule = void;
    export type page$rules$edit$a$page$rule = void;
    export type available$page$rules$settings$list$available$page$rules$settings = void;
    export type listZoneRulesets = void;
    export type createZoneRuleset = void;
    export type getZoneRuleset = void;
    export type updateZoneRuleset = void;
    export type deleteZoneRuleset = void;
    export type createZoneRulesetRule = void;
    export type deleteZoneRulesetRule = void;
    export type updateZoneRulesetRule = void;
    export type listZoneRulesetVersions = void;
    export type getZoneRulesetVersion = void;
    export type deleteZoneRulesetVersion = void;
    export type getZoneEntrypointRuleset = void;
    export type updateZoneEntrypointRuleset = void;
    export type listZoneEntrypointRulesetVersions = void;
    export type getZoneEntrypointRulesetVersion = void;
    export type zone$settings$get$all$zone$settings = void;
    export type zone$settings$edit$zone$settings$info = void;
    export type zone$settings$get$0$rtt$session$resumption$setting = void;
    export type zone$settings$change$0$rtt$session$resumption$setting = void;
    export type zone$settings$get$advanced$ddos$setting = void;
    export type zone$settings$get$always$online$setting = void;
    export type zone$settings$change$always$online$setting = void;
    export type zone$settings$get$always$use$https$setting = void;
    export type zone$settings$change$always$use$https$setting = void;
    export type zone$settings$get$automatic$https$rewrites$setting = void;
    export type zone$settings$change$automatic$https$rewrites$setting = void;
    export type zone$settings$get$automatic_platform_optimization$setting = void;
    export type zone$settings$change$automatic_platform_optimization$setting = void;
    export type zone$settings$get$brotli$setting = void;
    export type zone$settings$change$brotli$setting = void;
    export type zone$settings$get$browser$cache$ttl$setting = void;
    export type zone$settings$change$browser$cache$ttl$setting = void;
    export type zone$settings$get$browser$check$setting = void;
    export type zone$settings$change$browser$check$setting = void;
    export type zone$settings$get$cache$level$setting = void;
    export type zone$settings$change$cache$level$setting = void;
    export type zone$settings$get$challenge$ttl$setting = void;
    export type zone$settings$change$challenge$ttl$setting = void;
    export type zone$settings$get$ciphers$setting = void;
    export type zone$settings$change$ciphers$setting = void;
    export type zone$settings$get$development$mode$setting = void;
    export type zone$settings$change$development$mode$setting = void;
    export type zone$settings$get$early$hints$setting = void;
    export type zone$settings$change$early$hints$setting = void;
    export type zone$settings$get$email$obfuscation$setting = void;
    export type zone$settings$change$email$obfuscation$setting = void;
    export type zone$settings$get$fonts$setting = void;
    export type zone$settings$change$fonts$setting = void;
    export type zone$settings$get$h2_prioritization$setting = void;
    export type zone$settings$change$h2_prioritization$setting = void;
    export type zone$settings$get$hotlink$protection$setting = void;
    export type zone$settings$change$hotlink$protection$setting = void;
    export type zone$settings$get$h$t$t$p$2$setting = void;
    export type zone$settings$change$h$t$t$p$2$setting = void;
    export type zone$settings$get$h$t$t$p$3$setting = void;
    export type zone$settings$change$h$t$t$p$3$setting = void;
    export type zone$settings$get$image_resizing$setting = void;
    export type zone$settings$change$image_resizing$setting = void;
    export type zone$settings$get$ip$geolocation$setting = void;
    export type zone$settings$change$ip$geolocation$setting = void;
    export type zone$settings$get$i$pv6$setting = void;
    export type zone$settings$change$i$pv6$setting = void;
    export type zone$settings$get$minimum$tls$version$setting = void;
    export type zone$settings$change$minimum$tls$version$setting = void;
    export type zone$settings$get$minify$setting = void;
    export type zone$settings$change$minify$setting = void;
    export type zone$settings$get$mirage$setting = void;
    export type zone$settings$change$web$mirage$setting = void;
    export type zone$settings$get$mobile$redirect$setting = void;
    export type zone$settings$change$mobile$redirect$setting = void;
    export type zone$settings$get$nel$setting = void;
    export type zone$settings$change$nel$setting = void;
    export type zone$settings$get$opportunistic$encryption$setting = void;
    export type zone$settings$change$opportunistic$encryption$setting = void;
    export type zone$settings$get$opportunistic$onion$setting = void;
    export type zone$settings$change$opportunistic$onion$setting = void;
    export type zone$settings$get$orange_to_orange$setting = void;
    export type zone$settings$change$orange_to_orange$setting = void;
    export type zone$settings$get$enable$error$pages$on$setting = void;
    export type zone$settings$change$enable$error$pages$on$setting = void;
    export type zone$settings$get$polish$setting = void;
    export type zone$settings$change$polish$setting = void;
    export type zone$settings$get$prefetch$preload$setting = void;
    export type zone$settings$change$prefetch$preload$setting = void;
    export type zone$settings$get$proxy_read_timeout$setting = void;
    export type zone$settings$change$proxy_read_timeout$setting = void;
    export type zone$settings$get$pseudo$i$pv4$setting = void;
    export type zone$settings$change$pseudo$i$pv4$setting = void;
    export type zone$settings$get$response$buffering$setting = void;
    export type zone$settings$change$response$buffering$setting = void;
    export type zone$settings$get$rocket_loader$setting = void;
    export type zone$settings$change$rocket_loader$setting = void;
    export type zone$settings$get$security$header$$$hsts$$setting = void;
    export type zone$settings$change$security$header$$$hsts$$setting = void;
    export type zone$settings$get$security$level$setting = void;
    export type zone$settings$change$security$level$setting = void;
    export type zone$settings$get$server$side$exclude$setting = void;
    export type zone$settings$change$server$side$exclude$setting = void;
    export type zone$settings$get$enable$query$string$sort$setting = void;
    export type zone$settings$change$enable$query$string$sort$setting = void;
    export type zone$settings$get$ssl$setting = void;
    export type zone$settings$change$ssl$setting = void;
    export type zone$settings$get$ssl_recommender$setting = void;
    export type zone$settings$change$ssl_recommender$setting = void;
    export type zone$settings$get$tls$1$$3$setting$enabled$for$a$zone = void;
    export type zone$settings$change$tls$1$$3$setting = void;
    export type zone$settings$get$tls$client$auth$setting = void;
    export type zone$settings$change$tls$client$auth$setting = void;
    export type zone$settings$get$true$client$ip$setting = void;
    export type zone$settings$change$true$client$ip$setting = void;
    export type zone$settings$get$web$application$firewall$$$waf$$setting = void;
    export type zone$settings$change$web$application$firewall$$$waf$$setting = void;
    export type zone$settings$get$web$p$setting = void;
    export type zone$settings$change$web$p$setting = void;
    export type zone$settings$get$web$sockets$setting = void;
    export type zone$settings$change$web$sockets$setting = void;
    export type get$zones$zone_identifier$zaraz$config = void;
    export type put$zones$zone_identifier$zaraz$config = void;
    export type get$zones$zone_identifier$zaraz$default = void;
    export type get$zones$zone_identifier$zaraz$export = void;
    export type get$zones$zone_identifier$zaraz$history = void;
    export type put$zones$zone_identifier$zaraz$history = void;
    export type get$zones$zone_identifier$zaraz$config$history = void;
    export type post$zones$zone_identifier$zaraz$publish = void;
    export type get$zones$zone_identifier$zaraz$workflow = void;
    export type put$zones$zone_identifier$zaraz$workflow = void;
    export type speed$get$availabilities = void;
    export type speed$list$pages = void;
    export type speed$list$test$history = void;
    export type speed$create$test = void;
    export type speed$delete$tests = void;
    export type speed$get$test = void;
    export type speed$list$page$trend = void;
    export type speed$get$scheduled$test = void;
    export type speed$create$scheduled$test = void;
    export type speed$delete$test$schedule = void;
    export type url$normalization$get$url$normalization$settings = void;
    export type url$normalization$update$url$normalization$settings = void;
    export type worker$filters$$$deprecated$$list$filters = void;
    export type worker$filters$$$deprecated$$create$filter = void;
    export type worker$filters$$$deprecated$$update$filter = void;
    export type worker$filters$$$deprecated$$delete$filter = void;
    export type worker$routes$list$routes = void;
    export type worker$routes$create$route = void;
    export type worker$routes$get$route = void;
    export type worker$routes$update$route = void;
    export type worker$routes$delete$route = void;
    export type worker$script$$$deprecated$$download$worker = void;
    export type worker$script$$$deprecated$$upload$worker = void;
    export type worker$script$$$deprecated$$delete$worker = void;
    export type worker$binding$$$deprecated$$list$bindings = void;
    export type total$tls$total$tls$settings$details = void;
    export type total$tls$enable$or$disable$total$tls = void;
    export type zone$analytics$$$deprecated$$get$analytics$by$co$locations = void;
    export type zone$analytics$$$deprecated$$get$dashboard = void;
    export type zone$rate$plan$list$available$plans = void;
    export type zone$rate$plan$available$plan$details = void;
    export type zone$rate$plan$list$available$rate$plans = void;
    export type client$certificate$for$a$zone$list$hostname$associations = void;
    export type client$certificate$for$a$zone$put$hostname$associations = void;
    export type client$certificate$for$a$zone$list$client$certificates = void;
    export type client$certificate$for$a$zone$create$client$certificate = void;
    export type client$certificate$for$a$zone$client$certificate$details = void;
    export type client$certificate$for$a$zone$delete$client$certificate = void;
    export type client$certificate$for$a$zone$edit$client$certificate = void;
    export type custom$ssl$for$a$zone$list$ssl$configurations = void;
    export type custom$ssl$for$a$zone$create$ssl$configuration = void;
    export type custom$ssl$for$a$zone$ssl$configuration$details = void;
    export type custom$ssl$for$a$zone$delete$ssl$configuration = void;
    export type custom$ssl$for$a$zone$edit$ssl$configuration = void;
    export type custom$ssl$for$a$zone$re$prioritize$ssl$certificates = void;
    export type custom$hostname$for$a$zone$list$custom$hostnames = void;
    export type custom$hostname$for$a$zone$create$custom$hostname = void;
    export type custom$hostname$for$a$zone$custom$hostname$details = void;
    export type custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$ = void;
    export type custom$hostname$for$a$zone$edit$custom$hostname = void;
    export type custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames = void;
    export type custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames = void;
    export type custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames = void;
    export type custom$pages$for$a$zone$list$custom$pages = void;
    export type custom$pages$for$a$zone$get$a$custom$page = void;
    export type custom$pages$for$a$zone$update$a$custom$page = void;
    export type dcv$delegation$uuid$get = void;
    export type email$routing$settings$get$email$routing$settings = void;
    export type email$routing$settings$disable$email$routing = void;
    export type email$routing$settings$email$routing$dns$settings = void;
    export type email$routing$settings$enable$email$routing = void;
    export type email$routing$routing$rules$list$routing$rules = void;
    export type email$routing$routing$rules$create$routing$rule = void;
    export type email$routing$routing$rules$get$routing$rule = void;
    export type email$routing$routing$rules$update$routing$rule = void;
    export type email$routing$routing$rules$delete$routing$rule = void;
    export type email$routing$routing$rules$get$catch$all$rule = void;
    export type email$routing$routing$rules$update$catch$all$rule = void;
    export type filters$list$filters = void;
    export type filters$update$filters = void;
    export type filters$create$filters = void;
    export type filters$delete$filters = void;
    export type filters$get$a$filter = void;
    export type filters$update$a$filter = void;
    export type filters$delete$a$filter = void;
    export type zone$lockdown$list$zone$lockdown$rules = void;
    export type zone$lockdown$create$a$zone$lockdown$rule = void;
    export type zone$lockdown$get$a$zone$lockdown$rule = void;
    export type zone$lockdown$update$a$zone$lockdown$rule = void;
    export type zone$lockdown$delete$a$zone$lockdown$rule = void;
    export type firewall$rules$list$firewall$rules = void;
    export type firewall$rules$update$firewall$rules = void;
    export type firewall$rules$create$firewall$rules = void;
    export type firewall$rules$delete$firewall$rules = void;
    export type firewall$rules$update$priority$of$firewall$rules = void;
    export type firewall$rules$get$a$firewall$rule = void;
    export type firewall$rules$update$a$firewall$rule = void;
    export type firewall$rules$delete$a$firewall$rule = void;
    export type firewall$rules$update$priority$of$a$firewall$rule = void;
    export type user$agent$blocking$rules$list$user$agent$blocking$rules = void;
    export type user$agent$blocking$rules$create$a$user$agent$blocking$rule = void;
    export type user$agent$blocking$rules$get$a$user$agent$blocking$rule = void;
    export type user$agent$blocking$rules$update$a$user$agent$blocking$rule = void;
    export type user$agent$blocking$rules$delete$a$user$agent$blocking$rule = void;
    export type waf$overrides$list$waf$overrides = void;
    export type waf$overrides$create$a$waf$override = void;
    export type waf$overrides$get$a$waf$override = void;
    export type waf$overrides$update$waf$override = void;
    export type waf$overrides$delete$a$waf$override = void;
    export type waf$packages$list$waf$packages = void;
    export type waf$packages$get$a$waf$package = void;
    export type waf$packages$update$a$waf$package = void;
    export type health$checks$list$health$checks = void;
    export type health$checks$create$health$check = void;
    export type health$checks$health$check$details = void;
    export type health$checks$update$health$check = void;
    export type health$checks$delete$health$check = void;
    export type health$checks$patch$health$check = void;
    export type health$checks$create$preview$health$check = void;
    export type health$checks$health$check$preview$details = void;
    export type health$checks$delete$preview$health$check = void;
    export type per$hostname$tls$settings$list = void;
    export type per$hostname$tls$settings$put = void;
    export type per$hostname$tls$settings$delete = void;
    export type keyless$ssl$for$a$zone$list$keyless$ssl$configurations = void;
    export type keyless$ssl$for$a$zone$create$keyless$ssl$configuration = void;
    export type keyless$ssl$for$a$zone$get$keyless$ssl$configuration = void;
    export type keyless$ssl$for$a$zone$delete$keyless$ssl$configuration = void;
    export type keyless$ssl$for$a$zone$edit$keyless$ssl$configuration = void;
    export type logs$received$get$log$retention$flag = void;
    export type logs$received$update$log$retention$flag = void;
    export type logs$received$get$logs$ray$i$ds = void;
    export type logs$received$get$logs$received = void;
    export type logs$received$list$fields = void;
    export type zone$level$authenticated$origin$pulls$list$certificates = void;
    export type zone$level$authenticated$origin$pulls$upload$certificate = void;
    export type zone$level$authenticated$origin$pulls$get$certificate$details = void;
    export type zone$level$authenticated$origin$pulls$delete$certificate = void;
    export type per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication = void;
    export type per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication = void;
    export type per$hostname$authenticated$origin$pull$list$certificates = void;
    export type per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate = void;
    export type per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate = void;
    export type per$hostname$authenticated$origin$pull$delete$hostname$client$certificate = void;
    export type zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone = void;
    export type zone$level$authenticated$origin$pulls$set$enablement$for$zone = void;
    export type rate$limits$for$a$zone$list$rate$limits = void;
    export type rate$limits$for$a$zone$create$a$rate$limit = void;
    export type rate$limits$for$a$zone$get$a$rate$limit = void;
    export type rate$limits$for$a$zone$update$a$rate$limit = void;
    export type rate$limits$for$a$zone$delete$a$rate$limit = void;
    export type secondary$dns$$$secondary$zone$$force$axfr = void;
    export type secondary$dns$$$secondary$zone$$secondary$zone$configuration$details = void;
    export type secondary$dns$$$secondary$zone$$update$secondary$zone$configuration = void;
    export type secondary$dns$$$secondary$zone$$create$secondary$zone$configuration = void;
    export type secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration = void;
    export type secondary$dns$$$primary$zone$$primary$zone$configuration$details = void;
    export type secondary$dns$$$primary$zone$$update$primary$zone$configuration = void;
    export type secondary$dns$$$primary$zone$$create$primary$zone$configuration = void;
    export type secondary$dns$$$primary$zone$$delete$primary$zone$configuration = void;
    export type secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers = void;
    export type secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers = void;
    export type secondary$dns$$$primary$zone$$force$dns$notify = void;
    export type secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status = void;
    export type zone$snippets = void;
    export type zone$snippets$snippet = void;
    export type zone$snippets$snippet$put = void;
    export type zone$snippets$snippet$delete = void;
    export type zone$snippets$snippet$content = void;
    export type zone$snippets$snippet$rules = void;
    export type zone$snippets$snippet$rules$put = void;
    export type certificate$packs$list$certificate$packs = void;
    export type certificate$packs$get$certificate$pack = void;
    export type certificate$packs$delete$advanced$certificate$manager$certificate$pack = void;
    export type certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack = void;
    export type certificate$packs$order$advanced$certificate$manager$certificate$pack = void;
    export type certificate$packs$get$certificate$pack$quotas = void;
    export type ssl$$tls$mode$recommendation$ssl$$tls$recommendation = void;
    export type universal$ssl$settings$for$a$zone$universal$ssl$settings$details = void;
    export type universal$ssl$settings$for$a$zone$edit$universal$ssl$settings = void;
    export type ssl$verification$ssl$verification$details = void;
    export type ssl$verification$edit$ssl$certificate$pack$validation$method = void;
    export type waiting$room$list$waiting$rooms = void;
    export type waiting$room$create$waiting$room = void;
    export type waiting$room$waiting$room$details = void;
    export type waiting$room$update$waiting$room = void;
    export type waiting$room$delete$waiting$room = void;
    export type waiting$room$patch$waiting$room = void;
    export type waiting$room$list$events = void;
    export type waiting$room$create$event = void;
    export type waiting$room$event$details = void;
    export type waiting$room$update$event = void;
    export type waiting$room$delete$event = void;
    export type waiting$room$patch$event = void;
    export type waiting$room$preview$active$event$details = void;
    export type waiting$room$list$waiting$room$rules = void;
    export type waiting$room$replace$waiting$room$rules = void;
    export type waiting$room$create$waiting$room$rule = void;
    export type waiting$room$delete$waiting$room$rule = void;
    export type waiting$room$patch$waiting$room$rule = void;
    export type waiting$room$get$waiting$room$status = void;
    export type waiting$room$create$a$custom$waiting$room$page$preview = void;
    export type waiting$room$get$zone$settings = void;
    export type waiting$room$update$zone$settings = void;
    export type waiting$room$patch$zone$settings = void;
    export type web3$hostname$list$web3$hostnames = void;
    export type web3$hostname$create$web3$hostname = void;
    export type web3$hostname$web3$hostname$details = void;
    export type web3$hostname$delete$web3$hostname = void;
    export type web3$hostname$edit$web3$hostname = void;
    export type web3$hostname$ipfs$universal$path$gateway$content$list$details = void;
    export type web3$hostname$update$ipfs$universal$path$gateway$content$list = void;
    export type web3$hostname$list$ipfs$universal$path$gateway$content$list$entries = void;
    export type web3$hostname$create$ipfs$universal$path$gateway$content$list$entry = void;
    export type web3$hostname$ipfs$universal$path$gateway$content$list$entry$details = void;
    export type web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry = void;
    export type web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry = void;
    export type spectrum$aggregate$analytics$get$current$aggregated$analytics = void;
    export type spectrum$analytics$$$by$time$$get$analytics$by$time = void;
    export type spectrum$analytics$$$summary$$get$analytics$summary = void;
    export type spectrum$applications$list$spectrum$applications = void;
    export type spectrum$applications$create$spectrum$application$using$a$name$for$the$origin = void;
    export type spectrum$applications$get$spectrum$application$configuration = void;
    export type spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin = void;
    export type spectrum$applications$delete$spectrum$application = void;
}
export interface Encoding {
    readonly contentType?: string;
    headers?: Record<string, any>;
    readonly style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    readonly explode?: boolean;
    readonly allowReserved?: boolean;
}
export interface RequestArgs {
    readonly httpMethod: HttpMethod;
    readonly url: string;
    headers: ObjectLike | any;
    requestBody?: ObjectLike | any;
    requestBodyEncoding?: Record<string, Encoding>;
    queryParameters?: QueryParameters | undefined;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(requestArgs: RequestArgs, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\\/$/, ""); }
    /**
     * List Accounts
     * List all accounts you have ownership or verified access to.
     */
    public async accounts$list$accounts(params: Params$accounts$list$accounts, option?: RequestOption): Promise<Response$accounts$list$accounts$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Alert Types
     * Gets a list of all alert types for which an account is eligible.
     */
    public async notification$alert$types$get$alert$types(params: Params$notification$alert$types$get$alert$types, option?: RequestOption): Promise<Response$notification$alert$types$get$alert$types$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/available_alerts\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get delivery mechanism eligibility
     * Get a list of all delivery mechanism types for which an account is eligible.
     */
    public async notification$mechanism$eligibility$get$delivery$mechanism$eligibility(params: Params$notification$mechanism$eligibility$get$delivery$mechanism$eligibility, option?: RequestOption): Promise<Response$notification$mechanism$eligibility$get$delivery$mechanism$eligibility$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/eligible\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List PagerDuty services
     * Get a list of all configured PagerDuty services.
     */
    public async notification$destinations$with$pager$duty$list$pager$duty$services(params: Params$notification$destinations$with$pager$duty$list$pager$duty$services, option?: RequestOption): Promise<Response$notification$destinations$with$pager$duty$list$pager$duty$services$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/pagerduty\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete PagerDuty Services
     * Deletes all the PagerDuty Services connected to the account.
     */
    public async notification$destinations$with$pager$duty$delete$pager$duty$services(params: Params$notification$destinations$with$pager$duty$delete$pager$duty$services, option?: RequestOption): Promise<Response$notification$destinations$with$pager$duty$delete$pager$duty$services$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/pagerduty\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Create PagerDuty integration token
     * Creates a new token for integrating with PagerDuty.
     */
    public async notification$destinations$with$pager$duty$connect$pager$duty(params: Params$notification$destinations$with$pager$duty$connect$pager$duty, option?: RequestOption): Promise<Response$notification$destinations$with$pager$duty$connect$pager$duty$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/pagerduty/connect\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Connect PagerDuty
     * Links PagerDuty with the account using the integration token.
     */
    public async notification$destinations$with$pager$duty$connect$pager$duty$token(params: Params$notification$destinations$with$pager$duty$connect$pager$duty$token, option?: RequestOption): Promise<Response$notification$destinations$with$pager$duty$connect$pager$duty$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/pagerduty/connect/\${params.parameter.token_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List webhooks
     * Gets a list of all configured webhook destinations.
     */
    public async notification$webhooks$list$webhooks(params: Params$notification$webhooks$list$webhooks, option?: RequestOption): Promise<Response$notification$webhooks$list$webhooks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/webhooks\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a webhook
     * Creates a new webhook destination.
     */
    public async notification$webhooks$create$a$webhook(params: Params$notification$webhooks$create$a$webhook, option?: RequestOption): Promise<Response$notification$webhooks$create$a$webhook$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/webhooks\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a webhook
     * Get details for a single webhooks destination.
     */
    public async notification$webhooks$get$a$webhook(params: Params$notification$webhooks$get$a$webhook, option?: RequestOption): Promise<Response$notification$webhooks$get$a$webhook$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/webhooks/\${params.parameter.webhook_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a webhook
     * Update a webhook destination.
     */
    public async notification$webhooks$update$a$webhook(params: Params$notification$webhooks$update$a$webhook, option?: RequestOption): Promise<Response$notification$webhooks$update$a$webhook$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/webhooks/\${params.parameter.webhook_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a webhook
     * Delete a configured webhook destination.
     */
    public async notification$webhooks$delete$a$webhook(params: Params$notification$webhooks$delete$a$webhook, option?: RequestOption): Promise<Response$notification$webhooks$delete$a$webhook$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/destinations/webhooks/\${params.parameter.webhook_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List History
     * Gets a list of history records for notifications sent to an account. The records are displayed for last \`x\` number of days based on the zone plan (free = 30, pro = 30, biz = 30, ent = 90).
     */
    public async notification$history$list$history(params: Params$notification$history$list$history, option?: RequestOption): Promise<Response$notification$history$list$history$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/history\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            per_page: { value: params.parameter.per_page, explode: false },
            before: { value: params.parameter.before, explode: false },
            page: { value: params.parameter.page, explode: false },
            since: { value: params.parameter.since, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Notification policies
     * Get a list of all Notification policies.
     */
    public async notification$policies$list$notification$policies(params: Params$notification$policies$list$notification$policies, option?: RequestOption): Promise<Response$notification$policies$list$notification$policies$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/policies\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a Notification policy
     * Creates a new Notification policy.
     */
    public async notification$policies$create$a$notification$policy(params: Params$notification$policies$create$a$notification$policy, option?: RequestOption): Promise<Response$notification$policies$create$a$notification$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/policies\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Notification policy
     * Get details for a single policy.
     */
    public async notification$policies$get$a$notification$policy(params: Params$notification$policies$get$a$notification$policy, option?: RequestOption): Promise<Response$notification$policies$get$a$notification$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/policies/\${params.parameter.policy_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a Notification policy
     * Update a Notification policy.
     */
    public async notification$policies$update$a$notification$policy(params: Params$notification$policies$update$a$notification$policy, option?: RequestOption): Promise<Response$notification$policies$update$a$notification$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/policies/\${params.parameter.policy_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Notification policy
     * Delete a Notification policy.
     */
    public async notification$policies$delete$a$notification$policy(params: Params$notification$policies$delete$a$notification$policy, option?: RequestOption): Promise<Response$notification$policies$delete$a$notification$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/alerting/v3/policies/\${params.parameter.policy_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /** Submit suspicious URL for scanning */
    public async phishing$url$scanner$submit$suspicious$url$for$scanning(params: Params$phishing$url$scanner$submit$suspicious$url$for$scanning, option?: RequestOption): Promise<Response$phishing$url$scanner$submit$suspicious$url$for$scanning$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/brand-protection/submit\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get results for a URL scan */
    public async phishing$url$information$get$results$for$a$url$scan(params: Params$phishing$url$information$get$results$for$a$url$scan, option?: RequestOption): Promise<Response$phishing$url$information$get$results$for$a$url$scan$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/brand-protection/url-info\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            url_id_param: { value: params.parameter.url_id_param, explode: false },
            url: { value: params.parameter.url, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Cloudflare Tunnels
     * Lists and filters Cloudflare Tunnels in an account.
     */
    public async cloudflare$tunnel$list$cloudflare$tunnels(params: Params$cloudflare$tunnel$list$cloudflare$tunnels, option?: RequestOption): Promise<Response$cloudflare$tunnel$list$cloudflare$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            is_deleted: { value: params.parameter.is_deleted, explode: false },
            existed_at: { value: params.parameter.existed_at, explode: false },
            uuid: { value: params.parameter.uuid, explode: false },
            was_active_at: { value: params.parameter.was_active_at, explode: false },
            was_inactive_at: { value: params.parameter.was_inactive_at, explode: false },
            include_prefix: { value: params.parameter.include_prefix, explode: false },
            exclude_prefix: { value: params.parameter.exclude_prefix, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            page: { value: params.parameter.page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a Cloudflare Tunnel
     * Creates a new Cloudflare Tunnel in an account.
     */
    public async cloudflare$tunnel$create$a$cloudflare$tunnel(params: Params$cloudflare$tunnel$create$a$cloudflare$tunnel, option?: RequestOption): Promise<Response$cloudflare$tunnel$create$a$cloudflare$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Cloudflare Tunnel
     * Fetches a single Cloudflare Tunnel.
     */
    public async cloudflare$tunnel$get$a$cloudflare$tunnel(params: Params$cloudflare$tunnel$get$a$cloudflare$tunnel, option?: RequestOption): Promise<Response$cloudflare$tunnel$get$a$cloudflare$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete a Cloudflare Tunnel
     * Deletes a Cloudflare Tunnel from an account.
     */
    public async cloudflare$tunnel$delete$a$cloudflare$tunnel(params: Params$cloudflare$tunnel$delete$a$cloudflare$tunnel, option?: RequestOption): Promise<Response$cloudflare$tunnel$delete$a$cloudflare$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update a Cloudflare Tunnel
     * Updates an existing Cloudflare Tunnel.
     */
    public async cloudflare$tunnel$update$a$cloudflare$tunnel(params: Params$cloudflare$tunnel$update$a$cloudflare$tunnel, option?: RequestOption): Promise<Response$cloudflare$tunnel$update$a$cloudflare$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get configuration
     * Gets the configuration for a remotely-managed tunnel
     */
    public async cloudflare$tunnel$configuration$get$configuration(params: Params$cloudflare$tunnel$configuration$get$configuration, option?: RequestOption): Promise<Response$cloudflare$tunnel$configuration$get$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}/configurations\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Put configuration
     * Adds or updates the configuration for a remotely-managed tunnel.
     */
    public async cloudflare$tunnel$configuration$put$configuration(params: Params$cloudflare$tunnel$configuration$put$configuration, option?: RequestOption): Promise<Response$cloudflare$tunnel$configuration$put$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}/configurations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Cloudflare Tunnel connections
     * Fetches connection details for a Cloudflare Tunnel.
     */
    public async cloudflare$tunnel$list$cloudflare$tunnel$connections(params: Params$cloudflare$tunnel$list$cloudflare$tunnel$connections, option?: RequestOption): Promise<Response$cloudflare$tunnel$list$cloudflare$tunnel$connections$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}/connections\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Clean up Cloudflare Tunnel connections
     * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
     */
    public async cloudflare$tunnel$clean$up$cloudflare$tunnel$connections(params: Params$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections, option?: RequestOption): Promise<Response$cloudflare$tunnel$clean$up$cloudflare$tunnel$connections$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}/connections\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            client_id: { value: params.parameter.client_id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Cloudflare Tunnel connector
     * Fetches connector and connection details for a Cloudflare Tunnel.
     */
    public async cloudflare$tunnel$get$cloudflare$tunnel$connector(params: Params$cloudflare$tunnel$get$cloudflare$tunnel$connector, option?: RequestOption): Promise<Response$cloudflare$tunnel$get$cloudflare$tunnel$connector$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}/connectors/\${params.parameter.connector_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get a Cloudflare Tunnel management token
     * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
     */
    public async cloudflare$tunnel$get$a$cloudflare$tunnel$management$token(params: Params$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token, option?: RequestOption): Promise<Response$cloudflare$tunnel$get$a$cloudflare$tunnel$management$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}/management\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Cloudflare Tunnel token
     * Gets the token used to associate cloudflared with a specific tunnel.
     */
    public async cloudflare$tunnel$get$a$cloudflare$tunnel$token(params: Params$cloudflare$tunnel$get$a$cloudflare$tunnel$token, option?: RequestOption): Promise<Response$cloudflare$tunnel$get$a$cloudflare$tunnel$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/cfd_tunnel/\${params.parameter.tunnel_id}/token\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Account Custom Nameservers
     * List an account's custom nameservers.
     */
    public async account$level$custom$nameservers$list$account$custom$nameservers(params: Params$account$level$custom$nameservers$list$account$custom$nameservers, option?: RequestOption): Promise<Response$account$level$custom$nameservers$list$account$custom$nameservers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/custom_ns\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Add Account Custom Nameserver */
    public async account$level$custom$nameservers$add$account$custom$nameserver(params: Params$account$level$custom$nameservers$add$account$custom$nameserver, option?: RequestOption): Promise<Response$account$level$custom$nameservers$add$account$custom$nameserver$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/custom_ns\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Delete Account Custom Nameserver */
    public async account$level$custom$nameservers$delete$account$custom$nameserver(params: Params$account$level$custom$nameservers$delete$account$custom$nameserver, option?: RequestOption): Promise<Response$account$level$custom$nameservers$delete$account$custom$nameserver$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/custom_ns/\${params.parameter.custom_ns_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /** Get Eligible Zones for Account Custom Nameservers */
    public async account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers(params: Params$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers, option?: RequestOption): Promise<Response$account$level$custom$nameservers$get$eligible$zones$for$account$custom$nameservers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/custom_ns/availability\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Verify Account Custom Nameserver Glue Records
     */
    public async account$level$custom$nameservers$verify$account$custom$nameserver$glue$records(params: Params$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records, option?: RequestOption): Promise<Response$account$level$custom$nameservers$verify$account$custom$nameserver$glue$records$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/custom_ns/verify\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * List D1 Databases
     * Returns a list of D1 databases.
     */
    public async cloudflare$d1$list$databases(params: Params$cloudflare$d1$list$databases, option?: RequestOption): Promise<Response$cloudflare$d1$list$databases$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/d1/database\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create D1 Database
     * Returns the created D1 database.
     */
    public async cloudflare$d1$create$database(params: Params$cloudflare$d1$create$database, option?: RequestOption): Promise<Response$cloudflare$d1$create$database$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/d1/database\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Cloudflare colos
     * List Cloudflare colos that account's devices were connected to during a time period, sorted by usage starting from the most used colo. Colos without traffic are also returned and sorted alphabetically.
     */
    public async dex$endpoints$list$colos(params: Params$dex$endpoints$list$colos, option?: RequestOption): Promise<Response$dex$endpoints$list$colos$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/colos\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            timeStart: { value: params.parameter.timeStart, explode: false },
            timeEnd: { value: params.parameter.timeEnd, explode: false },
            sortBy: { value: params.parameter.sortBy, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List fleet status devices
     * List details for devices using WARP
     */
    public async dex$fleet$status$devices(params: Params$dex$fleet$status$devices, option?: RequestOption): Promise<Response$dex$fleet$status$devices$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/fleet-status/devices\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            time_end: { value: params.parameter.time_end, explode: false },
            time_start: { value: params.parameter.time_start, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            sort_by: { value: params.parameter.sort_by, explode: false },
            colo: { value: params.parameter.colo, explode: false },
            device_id: { value: params.parameter.device_id, explode: false },
            mode: { value: params.parameter.mode, explode: false },
            status: { value: params.parameter.status, explode: false },
            platform: { value: params.parameter.platform, explode: false },
            version: { value: params.parameter.version, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List fleet status details by dimension
     * List details for live (up to 60 minutes) devices using WARP
     */
    public async dex$fleet$status$live(params: Params$dex$fleet$status$live, option?: RequestOption): Promise<Response$dex$fleet$status$live$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/fleet-status/live\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            since_minutes: { value: params.parameter.since_minutes, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List fleet status aggregate details by dimension
     * List details for devices using WARP, up to 7 days
     */
    public async dex$fleet$status$over$time(params: Params$dex$fleet$status$over$time, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/fleet-status/over-time\`;
        const headers = {};
        const queryParameters: QueryParameters = {
            time_end: { value: params.parameter.time_end, explode: false },
            time_start: { value: params.parameter.time_start, explode: false },
            colo: { value: params.parameter.colo, explode: false },
            device_id: { value: params.parameter.device_id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get details and aggregate metrics for an http test
     * Get test details and aggregate performance metrics for an http test for a given time period between 1 hour and 7 days.
     */
    public async dex$endpoints$http$test$details(params: Params$dex$endpoints$http$test$details, option?: RequestOption): Promise<Response$dex$endpoints$http$test$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/http-tests/\${params.parameter.test_id}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            deviceId: { value: params.parameter.deviceId, explode: false },
            timeStart: { value: params.parameter.timeStart, explode: false },
            timeEnd: { value: params.parameter.timeEnd, explode: false },
            interval: { value: params.parameter.interval, explode: false },
            colo: { value: params.parameter.colo, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get percentiles for an http test
     * Get percentiles for an http test for a given time period between 1 hour and 7 days.
     */
    public async dex$endpoints$http$test$percentiles(params: Params$dex$endpoints$http$test$percentiles, option?: RequestOption): Promise<Response$dex$endpoints$http$test$percentiles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/http-tests/\${params.parameter.test_id}/percentiles\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            deviceId: { value: params.parameter.deviceId, explode: false },
            timeStart: { value: params.parameter.timeStart, explode: false },
            timeEnd: { value: params.parameter.timeEnd, explode: false },
            colo: { value: params.parameter.colo, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List DEX test analytics
     * List DEX tests
     */
    public async dex$endpoints$list$tests(params: Params$dex$endpoints$list$tests, option?: RequestOption): Promise<Response$dex$endpoints$list$tests$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/tests\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            colo: { value: params.parameter.colo, explode: false },
            testName: { value: params.parameter.testName, explode: false },
            deviceId: { value: params.parameter.deviceId, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get count of devices targeted
     * Returns unique count of devices that have run synthetic application monitoring tests in the past 7 days.
     */
    public async dex$endpoints$tests$unique$devices(params: Params$dex$endpoints$tests$unique$devices, option?: RequestOption): Promise<Response$dex$endpoints$tests$unique$devices$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/tests/unique-devices\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            testName: { value: params.parameter.testName, explode: false },
            deviceId: { value: params.parameter.deviceId, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get details for a specific traceroute test run
     * Get a breakdown of hops and performance metrics for a specific traceroute test run
     */
    public async dex$endpoints$traceroute$test$result$network$path(params: Params$dex$endpoints$traceroute$test$result$network$path, option?: RequestOption): Promise<Response$dex$endpoints$traceroute$test$result$network$path$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/traceroute-test-results/\${params.parameter.test_result_id}/network-path\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get details and aggregate metrics for a traceroute test
     * Get test details and aggregate performance metrics for an traceroute test for a given time period between 1 hour and 7 days.
     */
    public async dex$endpoints$traceroute$test$details(params: Params$dex$endpoints$traceroute$test$details, option?: RequestOption): Promise<Response$dex$endpoints$traceroute$test$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/traceroute-tests/\${params.parameter.test_id}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            deviceId: { value: params.parameter.deviceId, explode: false },
            timeStart: { value: params.parameter.timeStart, explode: false },
            timeEnd: { value: params.parameter.timeEnd, explode: false },
            interval: { value: params.parameter.interval, explode: false },
            colo: { value: params.parameter.colo, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get network path breakdown for a traceroute test
     * Get a breakdown of metrics by hop for individual traceroute test runs
     */
    public async dex$endpoints$traceroute$test$network$path(params: Params$dex$endpoints$traceroute$test$network$path, option?: RequestOption): Promise<Response$dex$endpoints$traceroute$test$network$path$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/traceroute-tests/\${params.parameter.test_id}/network-path\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            deviceId: { value: params.parameter.deviceId, explode: false },
            timeStart: { value: params.parameter.timeStart, explode: false },
            timeEnd: { value: params.parameter.timeEnd, explode: false },
            interval: { value: params.parameter.interval, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get percentiles for a traceroute test
     * Get percentiles for a traceroute test for a given time period between 1 hour and 7 days.
     */
    public async dex$endpoints$traceroute$test$percentiles(params: Params$dex$endpoints$traceroute$test$percentiles, option?: RequestOption): Promise<Response$dex$endpoints$traceroute$test$percentiles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dex/traceroute-tests/\${params.parameter.test_id}/percentiles\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            deviceId: { value: params.parameter.deviceId, explode: false },
            timeStart: { value: params.parameter.timeStart, explode: false },
            timeEnd: { value: params.parameter.timeEnd, explode: false },
            colo: { value: params.parameter.colo, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Fetch all datasets with information about available versions.
     * Fetch all datasets with information about available versions.
     */
    public async dlp$datasets$read$all(params: Params$dlp$datasets$read$all, option?: RequestOption): Promise<Response$dlp$datasets$read$all$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/datasets\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a new dataset.
     * Create a new dataset.
     */
    public async dlp$datasets$create(params: Params$dlp$datasets$create, option?: RequestOption): Promise<Response$dlp$datasets$create$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/datasets\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Fetch a specific dataset with information about available versions.
     * Fetch a specific dataset with information about available versions.
     */
    public async dlp$datasets$read(params: Params$dlp$datasets$read, option?: RequestOption): Promise<Response$dlp$datasets$read$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/datasets/\${params.parameter.dataset_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update details about a dataset.
     * Update details about a dataset.
     */
    public async dlp$datasets$update(params: Params$dlp$datasets$update, option?: RequestOption): Promise<Response$dlp$datasets$update$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/datasets/\${params.parameter.dataset_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a dataset.
     * Delete a dataset.
     *
     * This deletes all versions of the dataset.
     */
    public async dlp$datasets$delete(params: Params$dlp$datasets$delete, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/datasets/\${params.parameter.dataset_id}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Prepare to upload a new version of a dataset.
     * Prepare to upload a new version of a dataset.
     */
    public async dlp$datasets$create$version(params: Params$dlp$datasets$create$version, option?: RequestOption): Promise<Response$dlp$datasets$create$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/datasets/\${params.parameter.dataset_id}/upload\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Upload a new version of a dataset.
     * Upload a new version of a dataset.
     */
    public async dlp$datasets$upload$version(params: Params$dlp$datasets$upload$version, option?: RequestOption): Promise<Response$dlp$datasets$upload$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/datasets/\${params.parameter.dataset_id}/upload/\${params.parameter.version}\`;
        const headers = {
            "Content-Type": "application/octet-stream",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Validate pattern
     * Validates whether this pattern is a valid regular expression. Rejects it if the regular expression is too complex or can match an unbounded-length string. Your regex will be rejected if it uses the Kleene Star -- be sure to bound the maximum number of characters that can be matched.
     */
    public async dlp$pattern$validation$validate$pattern(params: Params$dlp$pattern$validation$validate$pattern, option?: RequestOption): Promise<Response$dlp$pattern$validation$validate$pattern$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/patterns/validate\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get settings
     * Gets the current DLP payload log settings for this account.
     */
    public async dlp$payload$log$settings$get$settings(params: Params$dlp$payload$log$settings$get$settings, option?: RequestOption): Promise<Response$dlp$payload$log$settings$get$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/payload_log\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update settings
     * Updates the DLP payload log settings for this account.
     */
    public async dlp$payload$log$settings$update$settings(params: Params$dlp$payload$log$settings$update$settings, option?: RequestOption): Promise<Response$dlp$payload$log$settings$update$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/payload_log\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List all profiles
     * Lists all DLP profiles in an account.
     */
    public async dlp$profiles$list$all$profiles(params: Params$dlp$profiles$list$all$profiles, option?: RequestOption): Promise<Response$dlp$profiles$list$all$profiles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/profiles\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get DLP Profile
     * Fetches a DLP profile by ID. Supports both predefined and custom profiles
     */
    public async dlp$profiles$get$dlp$profile(params: Params$dlp$profiles$get$dlp$profile, option?: RequestOption): Promise<Response$dlp$profiles$get$dlp$profile$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/profiles/\${params.parameter.profile_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create custom profiles
     * Creates a set of DLP custom profiles.
     */
    public async dlp$profiles$create$custom$profiles(params: Params$dlp$profiles$create$custom$profiles, option?: RequestOption): Promise<Response$dlp$profiles$create$custom$profiles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/profiles/custom\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get custom profile
     * Fetches a custom DLP profile.
     */
    public async dlp$profiles$get$custom$profile(params: Params$dlp$profiles$get$custom$profile, option?: RequestOption): Promise<Response$dlp$profiles$get$custom$profile$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/profiles/custom/\${params.parameter.profile_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update custom profile
     * Updates a DLP custom profile.
     */
    public async dlp$profiles$update$custom$profile(params: Params$dlp$profiles$update$custom$profile, option?: RequestOption): Promise<Response$dlp$profiles$update$custom$profile$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/profiles/custom/\${params.parameter.profile_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete custom profile
     * Deletes a DLP custom profile.
     */
    public async dlp$profiles$delete$custom$profile(params: Params$dlp$profiles$delete$custom$profile, option?: RequestOption): Promise<Response$dlp$profiles$delete$custom$profile$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/profiles/custom/\${params.parameter.profile_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get predefined profile
     * Fetches a predefined DLP profile.
     */
    public async dlp$profiles$get$predefined$profile(params: Params$dlp$profiles$get$predefined$profile, option?: RequestOption): Promise<Response$dlp$profiles$get$predefined$profile$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/profiles/predefined/\${params.parameter.profile_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update predefined profile
     * Updates a DLP predefined profile. Only supports enabling/disabling entries.
     */
    public async dlp$profiles$update$predefined$profile(params: Params$dlp$profiles$update$predefined$profile, option?: RequestOption): Promise<Response$dlp$profiles$update$predefined$profile$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dlp/profiles/predefined/\${params.parameter.profile_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List DNS Firewall Clusters
     * List configured DNS Firewall clusters for an account.
     */
    public async dns$firewall$list$dns$firewall$clusters(params: Params$dns$firewall$list$dns$firewall$clusters, option?: RequestOption): Promise<Response$dns$firewall$list$dns$firewall$clusters$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dns_firewall\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create DNS Firewall Cluster
     * Create a configured DNS Firewall Cluster.
     */
    public async dns$firewall$create$dns$firewall$cluster(params: Params$dns$firewall$create$dns$firewall$cluster, option?: RequestOption): Promise<Response$dns$firewall$create$dns$firewall$cluster$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dns_firewall\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * DNS Firewall Cluster Details
     * Show a single configured DNS Firewall cluster for an account.
     */
    public async dns$firewall$dns$firewall$cluster$details(params: Params$dns$firewall$dns$firewall$cluster$details, option?: RequestOption): Promise<Response$dns$firewall$dns$firewall$cluster$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dns_firewall/\${params.parameter.dns_firewall_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete DNS Firewall Cluster
     * Delete a configured DNS Firewall Cluster.
     */
    public async dns$firewall$delete$dns$firewall$cluster(params: Params$dns$firewall$delete$dns$firewall$cluster, option?: RequestOption): Promise<Response$dns$firewall$delete$dns$firewall$cluster$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dns_firewall/\${params.parameter.dns_firewall_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update DNS Firewall Cluster
     * Modify a DNS Firewall Cluster configuration.
     */
    public async dns$firewall$update$dns$firewall$cluster(params: Params$dns$firewall$update$dns$firewall$cluster, option?: RequestOption): Promise<Response$dns$firewall$update$dns$firewall$cluster$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/dns_firewall/\${params.parameter.dns_firewall_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zero Trust account information
     * Gets information about the current Zero Trust account.
     */
    public async zero$trust$accounts$get$zero$trust$account$information(params: Params$zero$trust$accounts$get$zero$trust$account$information, option?: RequestOption): Promise<Response$zero$trust$accounts$get$zero$trust$account$information$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Zero Trust account
     * Creates a Zero Trust account with an existing Cloudflare account.
     */
    public async zero$trust$accounts$create$zero$trust$account(params: Params$zero$trust$accounts$create$zero$trust$account, option?: RequestOption): Promise<Response$zero$trust$accounts$create$zero$trust$account$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * List application and application type mappings
     * Fetches all application and application type mappings.
     */
    public async zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings(params: Params$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings, option?: RequestOption): Promise<Response$zero$trust$gateway$application$and$application$type$mappings$list$application$and$application$type$mappings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/app_types\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get Zero Trust Audit SSH settings
     * Get all Zero Trust Audit SSH settings for an account.
     */
    public async zero$trust$get$audit$ssh$settings(params: Params$zero$trust$get$audit$ssh$settings, option?: RequestOption): Promise<Response$zero$trust$get$audit$ssh$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/audit_ssh_settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Zero Trust Audit SSH settings
     * Updates Zero Trust Audit SSH settings.
     */
    public async zero$trust$update$audit$ssh$settings(params: Params$zero$trust$update$audit$ssh$settings, option?: RequestOption): Promise<Response$zero$trust$update$audit$ssh$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/audit_ssh_settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List categories
     * Fetches a list of all categories.
     */
    public async zero$trust$gateway$categories$list$categories(params: Params$zero$trust$gateway$categories$list$categories, option?: RequestOption): Promise<Response$zero$trust$gateway$categories$list$categories$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/categories\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get Zero Trust account configuration
     * Fetches the current Zero Trust account configuration.
     */
    public async zero$trust$accounts$get$zero$trust$account$configuration(params: Params$zero$trust$accounts$get$zero$trust$account$configuration, option?: RequestOption): Promise<Response$zero$trust$accounts$get$zero$trust$account$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/configuration\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Zero Trust account configuration
     * Updates the current Zero Trust account configuration.
     */
    public async zero$trust$accounts$update$zero$trust$account$configuration(params: Params$zero$trust$accounts$update$zero$trust$account$configuration, option?: RequestOption): Promise<Response$zero$trust$accounts$update$zero$trust$account$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/configuration\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Patch Zero Trust account configuration
     * Patches the current Zero Trust account configuration. This endpoint can update a single subcollection of settings such as \`antivirus\`, \`tls_decrypt\`, \`activity_log\`, \`block_page\`, \`browser_isolation\`, \`fips\`, \`body_scanning\`, or \`custom_certificate\`, without updating the entire configuration object. Returns an error if any collection of settings is not properly configured.
     */
    public async zero$trust$accounts$patch$zero$trust$account$configuration(params: Params$zero$trust$accounts$patch$zero$trust$account$configuration, option?: RequestOption): Promise<Response$zero$trust$accounts$patch$zero$trust$account$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/configuration\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Zero Trust lists
     * Fetches all Zero Trust lists for an account.
     */
    public async zero$trust$lists$list$zero$trust$lists(params: Params$zero$trust$lists$list$zero$trust$lists, option?: RequestOption): Promise<Response$zero$trust$lists$list$zero$trust$lists$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/lists\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Zero Trust list
     * Creates a new Zero Trust list.
     */
    public async zero$trust$lists$create$zero$trust$list(params: Params$zero$trust$lists$create$zero$trust$list, option?: RequestOption): Promise<Response$zero$trust$lists$create$zero$trust$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/lists\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zero Trust list details
     * Fetches a single Zero Trust list.
     */
    public async zero$trust$lists$zero$trust$list$details(params: Params$zero$trust$lists$zero$trust$list$details, option?: RequestOption): Promise<Response$zero$trust$lists$zero$trust$list$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/lists/\${params.parameter.list_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Zero Trust list
     * Updates a configured Zero Trust list.
     */
    public async zero$trust$lists$update$zero$trust$list(params: Params$zero$trust$lists$update$zero$trust$list, option?: RequestOption): Promise<Response$zero$trust$lists$update$zero$trust$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/lists/\${params.parameter.list_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Zero Trust list
     * Deletes a Zero Trust list.
     */
    public async zero$trust$lists$delete$zero$trust$list(params: Params$zero$trust$lists$delete$zero$trust$list, option?: RequestOption): Promise<Response$zero$trust$lists$delete$zero$trust$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/lists/\${params.parameter.list_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Zero Trust list
     * Appends or removes an item from a configured Zero Trust list.
     */
    public async zero$trust$lists$patch$zero$trust$list(params: Params$zero$trust$lists$patch$zero$trust$list, option?: RequestOption): Promise<Response$zero$trust$lists$patch$zero$trust$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/lists/\${params.parameter.list_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zero Trust list items
     * Fetches all items in a single Zero Trust list.
     */
    public async zero$trust$lists$zero$trust$list$items(params: Params$zero$trust$lists$zero$trust$list$items, option?: RequestOption): Promise<Response$zero$trust$lists$zero$trust$list$items$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/lists/\${params.parameter.list_id}/items\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Zero Trust Gateway locations
     * Fetches Zero Trust Gateway locations for an account.
     */
    public async zero$trust$gateway$locations$list$zero$trust$gateway$locations(params: Params$zero$trust$gateway$locations$list$zero$trust$gateway$locations, option?: RequestOption): Promise<Response$zero$trust$gateway$locations$list$zero$trust$gateway$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/locations\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a Zero Trust Gateway location
     * Creates a new Zero Trust Gateway location.
     */
    public async zero$trust$gateway$locations$create$zero$trust$gateway$location(params: Params$zero$trust$gateway$locations$create$zero$trust$gateway$location, option?: RequestOption): Promise<Response$zero$trust$gateway$locations$create$zero$trust$gateway$location$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/locations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zero Trust Gateway location details
     * Fetches a single Zero Trust Gateway location.
     */
    public async zero$trust$gateway$locations$zero$trust$gateway$location$details(params: Params$zero$trust$gateway$locations$zero$trust$gateway$location$details, option?: RequestOption): Promise<Response$zero$trust$gateway$locations$zero$trust$gateway$location$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/locations/\${params.parameter.location_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a Zero Trust Gateway location
     * Updates a configured Zero Trust Gateway location.
     */
    public async zero$trust$gateway$locations$update$zero$trust$gateway$location(params: Params$zero$trust$gateway$locations$update$zero$trust$gateway$location, option?: RequestOption): Promise<Response$zero$trust$gateway$locations$update$zero$trust$gateway$location$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/locations/\${params.parameter.location_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Zero Trust Gateway location
     * Deletes a configured Zero Trust Gateway location.
     */
    public async zero$trust$gateway$locations$delete$zero$trust$gateway$location(params: Params$zero$trust$gateway$locations$delete$zero$trust$gateway$location, option?: RequestOption): Promise<Response$zero$trust$gateway$locations$delete$zero$trust$gateway$location$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/locations/\${params.parameter.location_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get logging settings for the Zero Trust account
     * Fetches the current logging settings for Zero Trust account.
     */
    public async zero$trust$accounts$get$logging$settings$for$the$zero$trust$account(params: Params$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account, option?: RequestOption): Promise<Response$zero$trust$accounts$get$logging$settings$for$the$zero$trust$account$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/logging\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Zero Trust account logging settings
     * Updates logging settings for the current Zero Trust account.
     */
    public async zero$trust$accounts$update$logging$settings$for$the$zero$trust$account(params: Params$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account, option?: RequestOption): Promise<Response$zero$trust$accounts$update$logging$settings$for$the$zero$trust$account$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/logging\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a proxy endpoint
     * Fetches a single Zero Trust Gateway proxy endpoint.
     */
    public async zero$trust$gateway$proxy$endpoints$list$proxy$endpoints(params: Params$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints, option?: RequestOption): Promise<Response$zero$trust$gateway$proxy$endpoints$list$proxy$endpoints$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/proxy_endpoints\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a proxy endpoint
     * Creates a new Zero Trust Gateway proxy endpoint.
     */
    public async zero$trust$gateway$proxy$endpoints$create$proxy$endpoint(params: Params$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint, option?: RequestOption): Promise<Response$zero$trust$gateway$proxy$endpoints$create$proxy$endpoint$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/proxy_endpoints\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List proxy endpoints
     * Fetches all Zero Trust Gateway proxy endpoints for an account.
     */
    public async zero$trust$gateway$proxy$endpoints$proxy$endpoint$details(params: Params$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details, option?: RequestOption): Promise<Response$zero$trust$gateway$proxy$endpoints$proxy$endpoint$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/proxy_endpoints/\${params.parameter.proxy_endpoint_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete a proxy endpoint
     * Deletes a configured Zero Trust Gateway proxy endpoint.
     */
    public async zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint(params: Params$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint, option?: RequestOption): Promise<Response$zero$trust$gateway$proxy$endpoints$delete$proxy$endpoint$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/proxy_endpoints/\${params.parameter.proxy_endpoint_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update a proxy endpoint
     * Updates a configured Zero Trust Gateway proxy endpoint.
     */
    public async zero$trust$gateway$proxy$endpoints$update$proxy$endpoint(params: Params$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint, option?: RequestOption): Promise<Response$zero$trust$gateway$proxy$endpoints$update$proxy$endpoint$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/proxy_endpoints/\${params.parameter.proxy_endpoint_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Zero Trust Gateway rules
     * Fetches the Zero Trust Gateway rules for an account.
     */
    public async zero$trust$gateway$rules$list$zero$trust$gateway$rules(params: Params$zero$trust$gateway$rules$list$zero$trust$gateway$rules, option?: RequestOption): Promise<Response$zero$trust$gateway$rules$list$zero$trust$gateway$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/rules\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a Zero Trust Gateway rule
     * Creates a new Zero Trust Gateway rule.
     */
    public async zero$trust$gateway$rules$create$zero$trust$gateway$rule(params: Params$zero$trust$gateway$rules$create$zero$trust$gateway$rule, option?: RequestOption): Promise<Response$zero$trust$gateway$rules$create$zero$trust$gateway$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zero Trust Gateway rule details
     * Fetches a single Zero Trust Gateway rule.
     */
    public async zero$trust$gateway$rules$zero$trust$gateway$rule$details(params: Params$zero$trust$gateway$rules$zero$trust$gateway$rule$details, option?: RequestOption): Promise<Response$zero$trust$gateway$rules$zero$trust$gateway$rule$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/rules/\${params.parameter.rule_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a Zero Trust Gateway rule
     * Updates a configured Zero Trust Gateway rule.
     */
    public async zero$trust$gateway$rules$update$zero$trust$gateway$rule(params: Params$zero$trust$gateway$rules$update$zero$trust$gateway$rule, option?: RequestOption): Promise<Response$zero$trust$gateway$rules$update$zero$trust$gateway$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/rules/\${params.parameter.rule_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Zero Trust Gateway rule
     * Deletes a Zero Trust Gateway rule.
     */
    public async zero$trust$gateway$rules$delete$zero$trust$gateway$rule(params: Params$zero$trust$gateway$rules$delete$zero$trust$gateway$rule, option?: RequestOption): Promise<Response$zero$trust$gateway$rules$delete$zero$trust$gateway$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/gateway/rules/\${params.parameter.rule_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Hyperdrives
     * Returns a list of Hyperdrives
     */
    public async list$hyperdrive(params: Params$list$hyperdrive, option?: RequestOption): Promise<Response$list$hyperdrive$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/hyperdrive/configs\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Hyperdrive
     * Creates and returns a new Hyperdrive configuration.
     */
    public async create$hyperdrive(params: Params$create$hyperdrive, option?: RequestOption): Promise<Response$create$hyperdrive$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/hyperdrive/configs\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Hyperdrive
     * Returns the specified Hyperdrive configuration.
     */
    public async get$hyperdrive(params: Params$get$hyperdrive, option?: RequestOption): Promise<Response$get$hyperdrive$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/hyperdrive/configs/\${params.parameter.hyperdrive_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Hyperdrive
     * Updates and returns the specified Hyperdrive configuration.
     */
    public async update$hyperdrive(params: Params$update$hyperdrive, option?: RequestOption): Promise<Response$update$hyperdrive$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/hyperdrive/configs/\${params.parameter.hyperdrive_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Hyperdrive
     * Deletes the specified Hyperdrive.
     */
    public async delete$hyperdrive(params: Params$delete$hyperdrive, option?: RequestOption): Promise<Response$delete$hyperdrive$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/hyperdrive/configs/\${params.parameter.hyperdrive_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * List images
     * List up to 100 images with one request. Use the optional parameters below to get a specific range of images.
     */
    public async cloudflare$images$list$images(params: Params$cloudflare$images$list$images, option?: RequestOption): Promise<Response$cloudflare$images$list$images$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Upload an image
     * Upload an image with up to 10 Megabytes using a single HTTP POST (multipart/form-data) request.
     * An image can be uploaded by sending an image file or passing an accessible to an API url.
     */
    public async cloudflare$images$upload$an$image$via$url(params: Params$cloudflare$images$upload$an$image$via$url, option?: RequestOption): Promise<Response$cloudflare$images$upload$an$image$via$url$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Image details
     * Fetch details for a single image.
     */
    public async cloudflare$images$image$details(params: Params$cloudflare$images$image$details, option?: RequestOption): Promise<Response$cloudflare$images$image$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/\${params.parameter.image_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete image
     * Delete an image on Cloudflare Images. On success, all copies of the image are deleted and purged from cache.
     */
    public async cloudflare$images$delete$image(params: Params$cloudflare$images$delete$image, option?: RequestOption): Promise<Response$cloudflare$images$delete$image$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/\${params.parameter.image_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update image
     * Update image access control. On access control change, all copies of the image are purged from cache.
     */
    public async cloudflare$images$update$image(params: Params$cloudflare$images$update$image, option?: RequestOption): Promise<Response$cloudflare$images$update$image$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/\${params.parameter.image_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Base image
     * Fetch base image. For most images this will be the originally uploaded file. For larger images it can be a near-lossless version of the original.
     */
    public async cloudflare$images$base$image(params: Params$cloudflare$images$base$image, option?: RequestOption): Promise<Response$cloudflare$images$base$image$Status$200["image/*"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/\${params.parameter.image_id}/blob\`;
        const headers = {
            Accept: "image/*"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Signing Keys
     * Lists your signing keys. These can be found on your Cloudflare Images dashboard.
     */
    public async cloudflare$images$keys$list$signing$keys(params: Params$cloudflare$images$keys$list$signing$keys, option?: RequestOption): Promise<Response$cloudflare$images$keys$list$signing$keys$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/keys\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Images usage statistics
     * Fetch usage statistics details for Cloudflare Images.
     */
    public async cloudflare$images$images$usage$statistics(params: Params$cloudflare$images$images$usage$statistics, option?: RequestOption): Promise<Response$cloudflare$images$images$usage$statistics$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/stats\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List variants
     * Lists existing variants.
     */
    public async cloudflare$images$variants$list$variants(params: Params$cloudflare$images$variants$list$variants, option?: RequestOption): Promise<Response$cloudflare$images$variants$list$variants$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/variants\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a variant
     * Specify variants that allow you to resize images for different use cases.
     */
    public async cloudflare$images$variants$create$a$variant(params: Params$cloudflare$images$variants$create$a$variant, option?: RequestOption): Promise<Response$cloudflare$images$variants$create$a$variant$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/variants\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Variant details
     * Fetch details for a single variant.
     */
    public async cloudflare$images$variants$variant$details(params: Params$cloudflare$images$variants$variant$details, option?: RequestOption): Promise<Response$cloudflare$images$variants$variant$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/variants/\${params.parameter.variant_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete a variant
     * Deleting a variant purges the cache for all images associated with the variant.
     */
    public async cloudflare$images$variants$delete$a$variant(params: Params$cloudflare$images$variants$delete$a$variant, option?: RequestOption): Promise<Response$cloudflare$images$variants$delete$a$variant$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/variants/\${params.parameter.variant_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update a variant
     * Updating a variant purges the cache for all images associated with the variant.
     */
    public async cloudflare$images$variants$update$a$variant(params: Params$cloudflare$images$variants$update$a$variant, option?: RequestOption): Promise<Response$cloudflare$images$variants$update$a$variant$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v1/variants/\${params.parameter.variant_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List images V2
     * List up to 10000 images with one request. Use the optional parameters below to get a specific range of images.
     * Endpoint returns continuation_token if more images are present.
     */
    public async cloudflare$images$list$images$v2(params: Params$cloudflare$images$list$images$v2, option?: RequestOption): Promise<Response$cloudflare$images$list$images$v2$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v2\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            continuation_token: { value: params.parameter.continuation_token, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            sort_order: { value: params.parameter.sort_order, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create authenticated direct upload URL V2
     * Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images. This method creates a draft record for a future image. It returns an upload URL and an image identifier. To verify if the image itself has been uploaded, send an image details request (accounts/:account_identifier/images/v1/:identifier), and check that the \`draft: true\` property is not present.
     */
    public async cloudflare$images$create$authenticated$direct$upload$url$v$2(params: Params$cloudflare$images$create$authenticated$direct$upload$url$v$2, option?: RequestOption): Promise<Response$cloudflare$images$create$authenticated$direct$upload$url$v$2$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/images/v2/direct_upload\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get ASN Overview */
    public async asn$intelligence$get$asn$overview(params: Params$asn$intelligence$get$asn$overview, option?: RequestOption): Promise<Response$asn$intelligence$get$asn$overview$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/asn/\${params.parameter.asn}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Get ASN Subnets */
    public async asn$intelligence$get$asn$subnets(params: Params$asn$intelligence$get$asn$subnets, option?: RequestOption): Promise<Response$asn$intelligence$get$asn$subnets$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/asn/\${params.parameter.asn}/subnets\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Get Passive DNS by IP */
    public async passive$dns$by$ip$get$passive$dns$by$ip(params: Params$passive$dns$by$ip$get$passive$dns$by$ip, option?: RequestOption): Promise<Response$passive$dns$by$ip$get$passive$dns$by$ip$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/dns\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            start_end_params: { value: params.parameter.start_end_params, explode: false },
            ipv4: { value: params.parameter.ipv4, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Get Domain Details */
    public async domain$intelligence$get$domain$details(params: Params$domain$intelligence$get$domain$details, option?: RequestOption): Promise<Response$domain$intelligence$get$domain$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/domain\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            domain: { value: params.parameter.domain, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Get Domain History */
    public async domain$history$get$domain$history(params: Params$domain$history$get$domain$history, option?: RequestOption): Promise<Response$domain$history$get$domain$history$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/domain-history\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            domain: { value: params.parameter.domain, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Get Multiple Domain Details */
    public async domain$intelligence$get$multiple$domain$details(params: Params$domain$intelligence$get$multiple$domain$details, option?: RequestOption): Promise<Response$domain$intelligence$get$multiple$domain$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/domain/bulk\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            domain: { value: params.parameter.domain, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Get IP Overview */
    public async ip$intelligence$get$ip$overview(params: Params$ip$intelligence$get$ip$overview, option?: RequestOption): Promise<Response$ip$intelligence$get$ip$overview$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/ip\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ipv4: { value: params.parameter.ipv4, explode: false },
            ipv6: { value: params.parameter.ipv6, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Get IP Lists */
    public async ip$list$get$ip$lists(params: Params$ip$list$get$ip$lists, option?: RequestOption): Promise<Response$ip$list$get$ip$lists$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/ip-list\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Create Miscategorization */
    public async miscategorization$create$miscategorization(params: Params$miscategorization$create$miscategorization, option?: RequestOption): Promise<Response$miscategorization$create$miscategorization$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/miscategorization\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get WHOIS Record */
    public async whois$record$get$whois$record(params: Params$whois$record$get$whois$record, option?: RequestOption): Promise<Response$whois$record$get$whois$record$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/intel/whois\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            domain: { value: params.parameter.domain, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List fields
     * Lists all fields available for a dataset. The response result is an object with key-value pairs, where keys are field names, and values are descriptions.
     */
    public async get$accounts$account_identifier$logpush$datasets$dataset$fields(params: Params$get$accounts$account_identifier$logpush$datasets$dataset$fields, option?: RequestOption): Promise<Response$get$accounts$account_identifier$logpush$datasets$dataset$fields$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/datasets/\${params.parameter.dataset_id}/fields\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Logpush jobs for a dataset
     * Lists Logpush jobs for an account for a dataset.
     */
    public async get$accounts$account_identifier$logpush$datasets$dataset$jobs(params: Params$get$accounts$account_identifier$logpush$datasets$dataset$jobs, option?: RequestOption): Promise<Response$get$accounts$account_identifier$logpush$datasets$dataset$jobs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/datasets/\${params.parameter.dataset_id}/jobs\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Logpush jobs
     * Lists Logpush jobs for an account.
     */
    public async get$accounts$account_identifier$logpush$jobs(params: Params$get$accounts$account_identifier$logpush$jobs, option?: RequestOption): Promise<Response$get$accounts$account_identifier$logpush$jobs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/jobs\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Logpush job
     * Creates a new Logpush job for an account.
     */
    public async post$accounts$account_identifier$logpush$jobs(params: Params$post$accounts$account_identifier$logpush$jobs, option?: RequestOption): Promise<Response$post$accounts$account_identifier$logpush$jobs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/jobs\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Logpush job details
     * Gets the details of a Logpush job.
     */
    public async get$accounts$account_identifier$logpush$jobs$job_identifier(params: Params$get$accounts$account_identifier$logpush$jobs$job_identifier, option?: RequestOption): Promise<Response$get$accounts$account_identifier$logpush$jobs$job_identifier$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/jobs/\${params.parameter.job_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Logpush job
     * Updates a Logpush job.
     */
    public async put$accounts$account_identifier$logpush$jobs$job_identifier(params: Params$put$accounts$account_identifier$logpush$jobs$job_identifier, option?: RequestOption): Promise<Response$put$accounts$account_identifier$logpush$jobs$job_identifier$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/jobs/\${params.parameter.job_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Logpush job
     * Deletes a Logpush job.
     */
    public async delete$accounts$account_identifier$logpush$jobs$job_identifier(params: Params$delete$accounts$account_identifier$logpush$jobs$job_identifier, option?: RequestOption): Promise<Response$delete$accounts$account_identifier$logpush$jobs$job_identifier$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/jobs/\${params.parameter.job_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get ownership challenge
     * Gets a new ownership challenge sent to your destination.
     */
    public async post$accounts$account_identifier$logpush$ownership(params: Params$post$accounts$account_identifier$logpush$ownership, option?: RequestOption): Promise<Response$post$accounts$account_identifier$logpush$ownership$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/ownership\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Validate ownership challenge
     * Validates ownership challenge of the destination.
     */
    public async post$accounts$account_identifier$logpush$ownership$validate(params: Params$post$accounts$account_identifier$logpush$ownership$validate, option?: RequestOption): Promise<Response$post$accounts$account_identifier$logpush$ownership$validate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/ownership/validate\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Check destination exists
     * Checks if there is an existing job with a destination.
     */
    public async delete$accounts$account_identifier$logpush$validate$destination$exists(params: Params$delete$accounts$account_identifier$logpush$validate$destination$exists, option?: RequestOption): Promise<Response$delete$accounts$account_identifier$logpush$validate$destination$exists$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/validate/destination/exists\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Validate origin
     * Validates logpull origin with logpull_options.
     */
    public async post$accounts$account_identifier$logpush$validate$origin(params: Params$post$accounts$account_identifier$logpush$validate$origin, option?: RequestOption): Promise<Response$post$accounts$account_identifier$logpush$validate$origin$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logpush/validate/origin\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get CMB config
     * Gets CMB config.
     */
    public async get$accounts$account_identifier$logs$control$cmb$config(params: Params$get$accounts$account_identifier$logs$control$cmb$config, option?: RequestOption): Promise<Response$get$accounts$account_identifier$logs$control$cmb$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logs/control/cmb/config\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update CMB config
     * Updates CMB config.
     */
    public async put$accounts$account_identifier$logs$control$cmb$config(params: Params$put$accounts$account_identifier$logs$control$cmb$config, option?: RequestOption): Promise<Response$put$accounts$account_identifier$logs$control$cmb$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logs/control/cmb/config\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete CMB config
     * Deletes CMB config.
     */
    public async delete$accounts$account_identifier$logs$control$cmb$config(params: Params$delete$accounts$account_identifier$logs$control$cmb$config, option?: RequestOption): Promise<Response$delete$accounts$account_identifier$logs$control$cmb$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/logs/control/cmb/config\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get projects
     * Fetch a list of all user projects.
     */
    public async pages$project$get$projects(params: Params$pages$project$get$projects, option?: RequestOption): Promise<Response$pages$project$get$projects$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create project
     * Create a new project.
     */
    public async pages$project$create$project(params: Params$pages$project$create$project, option?: RequestOption): Promise<Response$pages$project$create$project$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get project
     * Fetch a project by name.
     */
    public async pages$project$get$project(params: Params$pages$project$get$project, option?: RequestOption): Promise<Response$pages$project$get$project$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete project
     * Delete a project by name.
     */
    public async pages$project$delete$project(params: Params$pages$project$delete$project, option?: RequestOption): Promise<Response$pages$project$delete$project$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update project
     * Set new attributes for an existing project. Modify environment variables. To delete an environment variable, set the key to null.
     */
    public async pages$project$update$project(params: Params$pages$project$update$project, option?: RequestOption): Promise<Response$pages$project$update$project$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get deployments
     * Fetch a list of project deployments.
     */
    public async pages$deployment$get$deployments(params: Params$pages$deployment$get$deployments, option?: RequestOption): Promise<Response$pages$deployment$get$deployments$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/deployments\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create deployment
     * Start a new deployment from production. The repository and account must have already been authorized on the Cloudflare Pages dashboard.
     */
    public async pages$deployment$create$deployment(params: Params$pages$deployment$create$deployment, option?: RequestOption): Promise<Response$pages$deployment$create$deployment$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/deployments\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get deployment info
     * Fetch information about a deployment.
     */
    public async pages$deployment$get$deployment$info(params: Params$pages$deployment$get$deployment$info, option?: RequestOption): Promise<Response$pages$deployment$get$deployment$info$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/deployments/\${params.parameter.deployment_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete deployment
     * Delete a deployment.
     */
    public async pages$deployment$delete$deployment(params: Params$pages$deployment$delete$deployment, option?: RequestOption): Promise<Response$pages$deployment$delete$deployment$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/deployments/\${params.parameter.deployment_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get deployment logs
     * Fetch deployment logs for a project.
     */
    public async pages$deployment$get$deployment$logs(params: Params$pages$deployment$get$deployment$logs, option?: RequestOption): Promise<Response$pages$deployment$get$deployment$logs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/deployments/\${params.parameter.deployment_id}/history/logs\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Retry deployment
     * Retry a previous deployment.
     */
    public async pages$deployment$retry$deployment(params: Params$pages$deployment$retry$deployment, option?: RequestOption): Promise<Response$pages$deployment$retry$deployment$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/deployments/\${params.parameter.deployment_id}/retry\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Rollback deployment
     * Rollback the production deployment to a previous deployment. You can only rollback to succesful builds on production.
     */
    public async pages$deployment$rollback$deployment(params: Params$pages$deployment$rollback$deployment, option?: RequestOption): Promise<Response$pages$deployment$rollback$deployment$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/deployments/\${params.parameter.deployment_id}/rollback\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Get domains
     * Fetch a list of all domains associated with a Pages project.
     */
    public async pages$domains$get$domains(params: Params$pages$domains$get$domains, option?: RequestOption): Promise<Response$pages$domains$get$domains$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/domains\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add domain
     * Add a new domain for the Pages project.
     */
    public async pages$domains$add$domain(params: Params$pages$domains$add$domain, option?: RequestOption): Promise<Response$pages$domains$add$domain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/domains\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get domain
     * Fetch a single domain.
     */
    public async pages$domains$get$domain(params: Params$pages$domains$get$domain, option?: RequestOption): Promise<Response$pages$domains$get$domain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/domains/\${params.parameter.domain_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete domain
     * Delete a Pages project's domain.
     */
    public async pages$domains$delete$domain(params: Params$pages$domains$delete$domain, option?: RequestOption): Promise<Response$pages$domains$delete$domain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/domains/\${params.parameter.domain_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch domain
     * Retry the validation status of a single domain.
     */
    public async pages$domains$patch$domain(params: Params$pages$domains$patch$domain, option?: RequestOption): Promise<Response$pages$domains$patch$domain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/domains/\${params.parameter.domain_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers
        }, option);
    }
    /**
     * Purge build cache
     * Purge all cached build artifacts for a Pages project
     */
    public async pages$purge$build$cache(params: Params$pages$purge$build$cache, option?: RequestOption): Promise<Response$pages$purge$build$cache$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/pages/projects/\${params.parameter.project_name}/purge_build_cache\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * List Buckets
     * Lists all R2 buckets on your account
     */
    public async r2$list$buckets(params: Params$r2$list$buckets, option?: RequestOption): Promise<Response$r2$list$buckets$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/r2/buckets\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name_contains: { value: params.parameter.name_contains, explode: false },
            start_after: { value: params.parameter.start_after, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            cursor: { value: params.parameter.cursor, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create Bucket
     * Creates a new R2 bucket.
     */
    public async r2$create$bucket(params: Params$r2$create$bucket, option?: RequestOption): Promise<Response$r2$create$bucket$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/r2/buckets\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Bucket
     * Gets metadata for an existing R2 bucket.
     */
    public async r2$get$bucket(params: Params$r2$get$bucket, option?: RequestOption): Promise<Response$r2$get$bucket$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/r2/buckets/\${params.parameter.bucket_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete Bucket
     * Deletes an existing R2 bucket.
     */
    public async r2$delete$bucket(params: Params$r2$delete$bucket, option?: RequestOption): Promise<Response$r2$delete$bucket$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/r2/buckets/\${params.parameter.bucket_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get Sippy Configuration
     * Gets configuration for Sippy for an existing R2 bucket.
     */
    public async r2$get$bucket$sippy$config(params: Params$r2$get$bucket$sippy$config, option?: RequestOption): Promise<Response$r2$get$bucket$sippy$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/r2/buckets/\${params.parameter.bucket_name}/sippy\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set Sippy Configuration
     * Sets configuration for Sippy for an existing R2 bucket.
     */
    public async r2$put$bucket$sippy$config(params: Params$r2$put$bucket$sippy$config, option?: RequestOption): Promise<Response$r2$put$bucket$sippy$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/r2/buckets/\${params.parameter.bucket_name}/sippy\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Sippy Configuration
     * Disables Sippy on this bucket
     */
    public async r2$delete$bucket$sippy$config(params: Params$r2$delete$bucket$sippy$config, option?: RequestOption): Promise<Response$r2$delete$bucket$sippy$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/r2/buckets/\${params.parameter.bucket_name}/sippy\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List domains
     * List domains handled by Registrar.
     */
    public async registrar$domains$list$domains(params: Params$registrar$domains$list$domains, option?: RequestOption): Promise<Response$registrar$domains$list$domains$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/registrar/domains\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get domain
     * Show individual domain.
     */
    public async registrar$domains$get$domain(params: Params$registrar$domains$get$domain, option?: RequestOption): Promise<Response$registrar$domains$get$domain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/registrar/domains/\${params.parameter.domain_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update domain
     * Update individual domain.
     */
    public async registrar$domains$update$domain(params: Params$registrar$domains$update$domain, option?: RequestOption): Promise<Response$registrar$domains$update$domain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/registrar/domains/\${params.parameter.domain_name}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get lists
     * Fetches all lists in the account.
     */
    public async lists$get$lists(params: Params$lists$get$lists, option?: RequestOption): Promise<Response$lists$get$lists$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a list
     * Creates a new list of the specified type.
     */
    public async lists$create$a$list(params: Params$lists$create$a$list, option?: RequestOption): Promise<Response$lists$create$a$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a list
     * Fetches the details of a list.
     */
    public async lists$get$a$list(params: Params$lists$get$a$list, option?: RequestOption): Promise<Response$lists$get$a$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists/\${params.parameter.list_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a list
     * Updates the description of a list.
     */
    public async lists$update$a$list(params: Params$lists$update$a$list, option?: RequestOption): Promise<Response$lists$update$a$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists/\${params.parameter.list_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a list
     * Deletes a specific list and all its items.
     */
    public async lists$delete$a$list(params: Params$lists$delete$a$list, option?: RequestOption): Promise<Response$lists$delete$a$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists/\${params.parameter.list_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get list items
     * Fetches all the items in the list.
     */
    public async lists$get$list$items(params: Params$lists$get$list$items, option?: RequestOption): Promise<Response$lists$get$list$items$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists/\${params.parameter.list_id}/items\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            cursor: { value: params.parameter.cursor, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            search: { value: params.parameter.search, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Update all list items
     * Removes all existing items from the list and adds the provided items to the list.
     *
     * This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned \`operation_id\`.
     */
    public async lists$update$all$list$items(params: Params$lists$update$all$list$items, option?: RequestOption): Promise<Response$lists$update$all$list$items$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists/\${params.parameter.list_id}/items\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create list items
     * Appends new items to the list.
     *
     * This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned \`operation_id\`.
     */
    public async lists$create$list$items(params: Params$lists$create$list$items, option?: RequestOption): Promise<Response$lists$create$list$items$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists/\${params.parameter.list_id}/items\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete list items
     * Removes one or more items from a list.
     *
     * This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned \`operation_id\`.
     */
    public async lists$delete$list$items(params: Params$lists$delete$list$items, option?: RequestOption): Promise<Response$lists$delete$list$items$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rules/lists/\${params.parameter.list_id}/items\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List account rulesets
     * Fetches all rulesets at the account level.
     */
    public async listAccountRulesets(params: Params$listAccountRulesets, option?: RequestOption): Promise<Response$listAccountRulesets$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create an account ruleset
     * Creates a ruleset at the account level.
     */
    public async createAccountRuleset(params: Params$createAccountRuleset, option?: RequestOption): Promise<Response$createAccountRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an account ruleset
     * Fetches the latest version of an account ruleset.
     */
    public async getAccountRuleset(params: Params$getAccountRuleset, option?: RequestOption): Promise<Response$getAccountRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an account ruleset
     * Updates an account ruleset, creating a new version.
     */
    public async updateAccountRuleset(params: Params$updateAccountRuleset, option?: RequestOption): Promise<Response$updateAccountRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an account ruleset
     * Deletes all versions of an existing account ruleset.
     */
    public async deleteAccountRuleset(params: Params$deleteAccountRuleset, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Create an account ruleset rule
     * Adds a new rule to an account ruleset. The rule will be added to the end of the existing list of rules in the ruleset by default.
     */
    public async createAccountRulesetRule(params: Params$createAccountRulesetRule, option?: RequestOption): Promise<Response$createAccountRulesetRule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an account ruleset rule
     * Deletes an existing rule from an account ruleset.
     */
    public async deleteAccountRulesetRule(params: Params$deleteAccountRulesetRule, option?: RequestOption): Promise<Response$deleteAccountRulesetRule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}/rules/\${params.parameter.rule_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update an account ruleset rule
     * Updates an existing rule in an account ruleset.
     */
    public async updateAccountRulesetRule(params: Params$updateAccountRulesetRule, option?: RequestOption): Promise<Response$updateAccountRulesetRule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}/rules/\${params.parameter.rule_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List an account ruleset's versions
     * Fetches the versions of an account ruleset.
     */
    public async listAccountRulesetVersions(params: Params$listAccountRulesetVersions, option?: RequestOption): Promise<Response$listAccountRulesetVersions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}/versions\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get an account ruleset version
     * Fetches a specific version of an account ruleset.
     */
    public async getAccountRulesetVersion(params: Params$getAccountRulesetVersion, option?: RequestOption): Promise<Response$getAccountRulesetVersion$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}/versions/\${params.parameter.ruleset_version}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete an account ruleset version
     * Deletes an existing version of an account ruleset.
     */
    public async deleteAccountRulesetVersion(params: Params$deleteAccountRulesetVersion, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}/versions/\${params.parameter.ruleset_version}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List an account ruleset version's rules by tag
     * Fetches the rules of a managed account ruleset version for a given tag.
     */
    public async listAccountRulesetVersionRulesByTag(params: Params$listAccountRulesetVersionRulesByTag, option?: RequestOption): Promise<Response$listAccountRulesetVersionRulesByTag$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/\${params.parameter.ruleset_id}/versions/\${params.parameter.ruleset_version}/by_tag/\${params.parameter.rule_tag}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get an account entry point ruleset
     * Fetches the latest version of the account entry point ruleset for a given phase.
     */
    public async getAccountEntrypointRuleset(params: Params$getAccountEntrypointRuleset, option?: RequestOption): Promise<Response$getAccountEntrypointRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/phases/\${params.parameter.ruleset_phase}/entrypoint\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an account entry point ruleset
     * Updates an account entry point ruleset, creating a new version.
     */
    public async updateAccountEntrypointRuleset(params: Params$updateAccountEntrypointRuleset, option?: RequestOption): Promise<Response$updateAccountEntrypointRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/phases/\${params.parameter.ruleset_phase}/entrypoint\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List an account entry point ruleset's versions
     * Fetches the versions of an account entry point ruleset.
     */
    public async listAccountEntrypointRulesetVersions(params: Params$listAccountEntrypointRulesetVersions, option?: RequestOption): Promise<Response$listAccountEntrypointRulesetVersions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/phases/\${params.parameter.ruleset_phase}/entrypoint/versions\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get an account entry point ruleset version
     * Fetches a specific version of an account entry point ruleset.
     */
    public async getAccountEntrypointRulesetVersion(params: Params$getAccountEntrypointRulesetVersion, option?: RequestOption): Promise<Response$getAccountEntrypointRulesetVersion$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/rulesets/phases/\${params.parameter.ruleset_phase}/entrypoint/versions/\${params.parameter.ruleset_version}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List videos
     * Lists up to 1000 videos from a single request. For a specific range, refer to the optional parameters.
     */
    public async stream$videos$list$videos(params: Params$stream$videos$list$videos, option?: RequestOption): Promise<Response$stream$videos$list$videos$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            status: { value: params.parameter.status, explode: false },
            creator: { value: params.parameter.creator, explode: false },
            type: { value: params.parameter.type, explode: false },
            asc: { value: params.parameter.asc, explode: false },
            search: { value: params.parameter.search, explode: false },
            start: { value: params.parameter.start, explode: false },
            end: { value: params.parameter.end, explode: false },
            include_counts: { value: params.parameter.include_counts, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Initiate video uploads using TUS
     * Initiates a video upload using the TUS protocol. On success, the server responds with a status code 201 (created) and includes a \`location\` header to indicate where the content should be uploaded. Refer to https://tus.io for protocol details.
     */
    public async stream$videos$initiate$video$uploads$using$tus(params: Params$stream$videos$initiate$video$uploads$using$tus, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream\`;
        const headers = {
            "Tus-Resumable": params.parameter["Tus-Resumable"],
            "Upload-Creator": params.parameter["Upload-Creator"],
            "Upload-Length": params.parameter["Upload-Length"],
            "Upload-Metadata": params.parameter["Upload-Metadata"]
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Retrieve video details
     * Fetches details for a single video.
     */
    public async stream$videos$retrieve$video$details(params: Params$stream$videos$retrieve$video$details, option?: RequestOption): Promise<Response$stream$videos$retrieve$video$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Edit video details
     * Edit details for a single video.
     */
    public async stream$videos$update$video$details(params: Params$stream$videos$update$video$details, option?: RequestOption): Promise<Response$stream$videos$update$video$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete video
     * Deletes a video and its copies from Cloudflare Stream.
     */
    public async stream$videos$delete$video(params: Params$stream$videos$delete$video, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List additional audio tracks on a video
     * Lists additional audio tracks on a video. Note this API will not return information for audio attached to the video upload.
     */
    public async list$audio$tracks(params: Params$list$audio$tracks, option?: RequestOption): Promise<Response$list$audio$tracks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/audio\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete additional audio tracks on a video
     * Deletes additional audio tracks on a video. Deleting a default audio track is not allowed. You must assign another audio track as default prior to deletion.
     */
    public async delete$audio$tracks(params: Params$delete$audio$tracks, option?: RequestOption): Promise<Response$delete$audio$tracks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/audio/\${params.parameter.audio_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Edit additional audio tracks on a video
     * Edits additional audio tracks on a video. Editing the default status of an audio track to \`true\` will mark all other audio tracks on the video default status to \`false\`.
     */
    public async edit$audio$tracks(params: Params$edit$audio$tracks, option?: RequestOption): Promise<Response$edit$audio$tracks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/audio/\${params.parameter.audio_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Add audio tracks to a video
     * Adds an additional audio track to a video using the provided audio track URL.
     */
    public async add$audio$track(params: Params$add$audio$track, option?: RequestOption): Promise<Response$add$audio$track$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/audio/copy\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List captions or subtitles
     * Lists the available captions or subtitles for a specific video.
     */
    public async stream$subtitles$$captions$list$captions$or$subtitles(params: Params$stream$subtitles$$captions$list$captions$or$subtitles, option?: RequestOption): Promise<Response$stream$subtitles$$captions$list$captions$or$subtitles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/captions\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Upload captions or subtitles
     * Uploads the caption or subtitle file to the endpoint for a specific BCP47 language. One caption or subtitle file per language is allowed.
     */
    public async stream$subtitles$$captions$upload$captions$or$subtitles(params: Params$stream$subtitles$$captions$upload$captions$or$subtitles, option?: RequestOption): Promise<Response$stream$subtitles$$captions$upload$captions$or$subtitles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/captions/\${params.parameter.language}\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete captions or subtitles
     * Removes the captions or subtitles from a video.
     */
    public async stream$subtitles$$captions$delete$captions$or$subtitles(params: Params$stream$subtitles$$captions$delete$captions$or$subtitles, option?: RequestOption): Promise<Response$stream$subtitles$$captions$delete$captions$or$subtitles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/captions/\${params.parameter.language}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List downloads
     * Lists the downloads created for a video.
     */
    public async stream$m$p$4$downloads$list$downloads(params: Params$stream$m$p$4$downloads$list$downloads, option?: RequestOption): Promise<Response$stream$m$p$4$downloads$list$downloads$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/downloads\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create downloads
     * Creates a download for a video when a video is ready to view.
     */
    public async stream$m$p$4$downloads$create$downloads(params: Params$stream$m$p$4$downloads$create$downloads, option?: RequestOption): Promise<Response$stream$m$p$4$downloads$create$downloads$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/downloads\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Delete downloads
     * Delete the downloads for a video.
     */
    public async stream$m$p$4$downloads$delete$downloads(params: Params$stream$m$p$4$downloads$delete$downloads, option?: RequestOption): Promise<Response$stream$m$p$4$downloads$delete$downloads$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/downloads\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Retrieve embed Code HTML
     * Fetches an HTML code snippet to embed a video in a web page delivered through Cloudflare. On success, returns an HTML fragment for use on web pages to display a video. On failure, returns a JSON response body.
     */
    public async stream$videos$retreieve$embed$code$html(params: Params$stream$videos$retreieve$embed$code$html, option?: RequestOption): Promise<Response$stream$videos$retreieve$embed$code$html$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/embed\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create signed URL tokens for videos
     * Creates a signed URL token for a video. If a body is not provided in the request, a token is created with default values.
     */
    public async stream$videos$create$signed$url$tokens$for$videos(params: Params$stream$videos$create$signed$url$tokens$for$videos, option?: RequestOption): Promise<Response$stream$videos$create$signed$url$tokens$for$videos$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/\${params.parameter.identifier}/token\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Clip videos given a start and end time
     * Clips a video based on the specified start and end times provided in seconds.
     */
    public async stream$video$clipping$clip$videos$given$a$start$and$end$time(params: Params$stream$video$clipping$clip$videos$given$a$start$and$end$time, option?: RequestOption): Promise<Response$stream$video$clipping$clip$videos$given$a$start$and$end$time$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/clip\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Upload videos from a URL
     * Uploads a video to Stream from a provided URL.
     */
    public async stream$videos$upload$videos$from$a$url(params: Params$stream$videos$upload$videos$from$a$url, option?: RequestOption): Promise<Response$stream$videos$upload$videos$from$a$url$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/copy\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json",
            "Upload-Creator": params.parameter["Upload-Creator"],
            "Upload-Metadata": params.parameter["Upload-Metadata"]
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Upload videos via direct upload URLs
     * Creates a direct upload that allows video uploads without an API key.
     */
    public async stream$videos$upload$videos$via$direct$upload$ur$ls(params: Params$stream$videos$upload$videos$via$direct$upload$ur$ls, option?: RequestOption): Promise<Response$stream$videos$upload$videos$via$direct$upload$ur$ls$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/direct_upload\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json",
            "Upload-Creator": params.parameter["Upload-Creator"]
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List signing keys
     * Lists the video ID and creation date and time when a signing key was created.
     */
    public async stream$signing$keys$list$signing$keys(params: Params$stream$signing$keys$list$signing$keys, option?: RequestOption): Promise<Response$stream$signing$keys$list$signing$keys$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/keys\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create signing keys
     * Creates an RSA private key in PEM and JWK formats. Key files are only displayed once after creation. Keys are created, used, and deleted independently of videos, and every key can sign any video.
     */
    public async stream$signing$keys$create$signing$keys(params: Params$stream$signing$keys$create$signing$keys, option?: RequestOption): Promise<Response$stream$signing$keys$create$signing$keys$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/keys\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Delete signing keys
     * Deletes signing keys and revokes all signed URLs generated with the key.
     */
    public async stream$signing$keys$delete$signing$keys(params: Params$stream$signing$keys$delete$signing$keys, option?: RequestOption): Promise<Response$stream$signing$keys$delete$signing$keys$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/keys/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List live inputs
     * Lists the live inputs created for an account. To get the credentials needed to stream to a specific live input, request a single live input.
     */
    public async stream$live$inputs$list$live$inputs(params: Params$stream$live$inputs$list$live$inputs, option?: RequestOption): Promise<Response$stream$live$inputs$list$live$inputs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include_counts: { value: params.parameter.include_counts, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a live input
     * Creates a live input, and returns credentials that you or your users can use to stream live video to Cloudflare Stream.
     */
    public async stream$live$inputs$create$a$live$input(params: Params$stream$live$inputs$create$a$live$input, option?: RequestOption): Promise<Response$stream$live$inputs$create$a$live$input$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Retrieve a live input
     * Retrieves details of an existing live input.
     */
    public async stream$live$inputs$retrieve$a$live$input(params: Params$stream$live$inputs$retrieve$a$live$input, option?: RequestOption): Promise<Response$stream$live$inputs$retrieve$a$live$input$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs/\${params.parameter.live_input_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a live input
     * Updates a specified live input.
     */
    public async stream$live$inputs$update$a$live$input(params: Params$stream$live$inputs$update$a$live$input, option?: RequestOption): Promise<Response$stream$live$inputs$update$a$live$input$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs/\${params.parameter.live_input_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a live input
     * Prevents a live input from being streamed to and makes the live input inaccessible to any future API calls.
     */
    public async stream$live$inputs$delete$a$live$input(params: Params$stream$live$inputs$delete$a$live$input, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs/\${params.parameter.live_input_identifier}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List all outputs associated with a specified live input
     * Retrieves all outputs associated with a specified live input.
     */
    public async stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input(params: Params$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input, option?: RequestOption): Promise<Response$stream$live$inputs$list$all$outputs$associated$with$a$specified$live$input$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs/\${params.parameter.live_input_identifier}/outputs\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a new output, connected to a live input
     * Creates a new output that can be used to simulcast or restream live video to other RTMP or SRT destinations. Outputs are always linked to a specific live input â€” one live input can have many outputs.
     */
    public async stream$live$inputs$create$a$new$output$$connected$to$a$live$input(params: Params$stream$live$inputs$create$a$new$output$$connected$to$a$live$input, option?: RequestOption): Promise<Response$stream$live$inputs$create$a$new$output$$connected$to$a$live$input$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs/\${params.parameter.live_input_identifier}/outputs\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update an output
     * Updates the state of an output.
     */
    public async stream$live$inputs$update$an$output(params: Params$stream$live$inputs$update$an$output, option?: RequestOption): Promise<Response$stream$live$inputs$update$an$output$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs/\${params.parameter.live_input_identifier}/outputs/\${params.parameter.output_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an output
     * Deletes an output and removes it from the associated live input.
     */
    public async stream$live$inputs$delete$an$output(params: Params$stream$live$inputs$delete$an$output, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/live_inputs/\${params.parameter.live_input_identifier}/outputs/\${params.parameter.output_identifier}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Storage use
     * Returns information about an account's storage use.
     */
    public async stream$videos$storage$usage(params: Params$stream$videos$storage$usage, option?: RequestOption): Promise<Response$stream$videos$storage$usage$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/storage-usage\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            creator: { value: params.parameter.creator, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List watermark profiles
     * Lists all watermark profiles for an account.
     */
    public async stream$watermark$profile$list$watermark$profiles(params: Params$stream$watermark$profile$list$watermark$profiles, option?: RequestOption): Promise<Response$stream$watermark$profile$list$watermark$profiles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/watermarks\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create watermark profiles via basic upload
     * Creates watermark profiles using a single \`HTTP POST multipart/form-data\` request.
     */
    public async stream$watermark$profile$create$watermark$profiles$via$basic$upload(params: Params$stream$watermark$profile$create$watermark$profiles$via$basic$upload, option?: RequestOption): Promise<Response$stream$watermark$profile$create$watermark$profiles$via$basic$upload$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/watermarks\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Watermark profile details
     * Retrieves details for a single watermark profile.
     */
    public async stream$watermark$profile$watermark$profile$details(params: Params$stream$watermark$profile$watermark$profile$details, option?: RequestOption): Promise<Response$stream$watermark$profile$watermark$profile$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/watermarks/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete watermark profiles
     * Deletes a watermark profile.
     */
    public async stream$watermark$profile$delete$watermark$profiles(params: Params$stream$watermark$profile$delete$watermark$profiles, option?: RequestOption): Promise<Response$stream$watermark$profile$delete$watermark$profiles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/watermarks/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * View webhooks
     * Retrieves a list of webhooks.
     */
    public async stream$webhook$view$webhooks(params: Params$stream$webhook$view$webhooks, option?: RequestOption): Promise<Response$stream$webhook$view$webhooks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/webhook\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create webhooks
     * Creates a webhook notification.
     */
    public async stream$webhook$create$webhooks(params: Params$stream$webhook$create$webhooks, option?: RequestOption): Promise<Response$stream$webhook$create$webhooks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/webhook\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete webhooks
     * Deletes a webhook.
     */
    public async stream$webhook$delete$webhooks(params: Params$stream$webhook$delete$webhooks, option?: RequestOption): Promise<Response$stream$webhook$delete$webhooks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/stream/webhook\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List tunnel routes
     * Lists and filters private network routes in an account.
     */
    public async tunnel$route$list$tunnel$routes(params: Params$tunnel$route$list$tunnel$routes, option?: RequestOption): Promise<Response$tunnel$route$list$tunnel$routes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/routes\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            comment: { value: params.parameter.comment, explode: false },
            is_deleted: { value: params.parameter.is_deleted, explode: false },
            network_subset: { value: params.parameter.network_subset, explode: false },
            network_superset: { value: params.parameter.network_superset, explode: false },
            existed_at: { value: params.parameter.existed_at, explode: false },
            tunnel_id: { value: params.parameter.tunnel_id, explode: false },
            route_id: { value: params.parameter.route_id, explode: false },
            tun_types: { value: params.parameter.tun_types, explode: false },
            virtual_network_id: { value: params.parameter.virtual_network_id, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            page: { value: params.parameter.page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a tunnel route
     * Routes a private network through a Cloudflare Tunnel.
     */
    public async tunnel$route$create$a$tunnel$route(params: Params$tunnel$route$create$a$tunnel$route, option?: RequestOption): Promise<Response$tunnel$route$create$a$tunnel$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/routes\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a tunnel route
     * Deletes a private network route from an account.
     */
    public async tunnel$route$delete$a$tunnel$route(params: Params$tunnel$route$delete$a$tunnel$route, option?: RequestOption): Promise<Response$tunnel$route$delete$a$tunnel$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/routes/\${params.parameter.route_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update a tunnel route
     * Updates an existing private network route in an account. The fields that are meant to be updated should be provided in the body of the request.
     */
    public async tunnel$route$update$a$tunnel$route(params: Params$tunnel$route$update$a$tunnel$route, option?: RequestOption): Promise<Response$tunnel$route$update$a$tunnel$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/routes/\${params.parameter.route_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get tunnel route by IP
     * Fetches routes that contain the given IP address.
     */
    public async tunnel$route$get$tunnel$route$by$ip(params: Params$tunnel$route$get$tunnel$route$by$ip, option?: RequestOption): Promise<Response$tunnel$route$get$tunnel$route$by$ip$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/routes/ip/\${params.parameter.ip}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            virtual_network_id: { value: params.parameter.virtual_network_id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Create a tunnel route (CIDR Endpoint)
     * Routes a private network through a Cloudflare Tunnel. The CIDR in \`ip_network_encoded\` must be written in URL-encoded format.
     */
    public async tunnel$route$create$a$tunnel$route$with$cidr(params: Params$tunnel$route$create$a$tunnel$route$with$cidr, option?: RequestOption): Promise<Response$tunnel$route$create$a$tunnel$route$with$cidr$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/routes/network/\${params.parameter.ip_network_encoded}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Delete a tunnel route (CIDR Endpoint)
     * Deletes a private network route from an account. The CIDR in \`ip_network_encoded\` must be written in URL-encoded format. If no virtual_network_id is provided it will delete the route from the default vnet. If no tun_type is provided it will fetch the type from the tunnel_id or if that is missing it will assume Cloudflare Tunnel as default. If tunnel_id is provided it will delete the route from that tunnel, otherwise it will delete the route based on the vnet and tun_type.
     */
    public async tunnel$route$delete$a$tunnel$route$with$cidr(params: Params$tunnel$route$delete$a$tunnel$route$with$cidr, option?: RequestOption): Promise<Response$tunnel$route$delete$a$tunnel$route$with$cidr$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/routes/network/\${params.parameter.ip_network_encoded}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            virtual_network_id: { value: params.parameter.virtual_network_id, explode: false },
            tun_type: { value: params.parameter.tun_type, explode: false },
            tunnel_id: { value: params.parameter.tunnel_id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Update a tunnel route (CIDR Endpoint)
     * Updates an existing private network route in an account. The CIDR in \`ip_network_encoded\` must be written in URL-encoded format.
     */
    public async tunnel$route$update$a$tunnel$route$with$cidr(params: Params$tunnel$route$update$a$tunnel$route$with$cidr, option?: RequestOption): Promise<Response$tunnel$route$update$a$tunnel$route$with$cidr$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/routes/network/\${params.parameter.ip_network_encoded}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers
        }, option);
    }
    /**
     * List virtual networks
     * Lists and filters virtual networks in an account.
     */
    public async tunnel$virtual$network$list$virtual$networks(params: Params$tunnel$virtual$network$list$virtual$networks, option?: RequestOption): Promise<Response$tunnel$virtual$network$list$virtual$networks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/virtual_networks\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            is_default: { value: params.parameter.is_default, explode: false },
            is_deleted: { value: params.parameter.is_deleted, explode: false },
            vnet_name: { value: params.parameter.vnet_name, explode: false },
            vnet_id: { value: params.parameter.vnet_id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a virtual network
     * Adds a new virtual network to an account.
     */
    public async tunnel$virtual$network$create$a$virtual$network(params: Params$tunnel$virtual$network$create$a$virtual$network, option?: RequestOption): Promise<Response$tunnel$virtual$network$create$a$virtual$network$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/virtual_networks\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a virtual network
     * Deletes an existing virtual network.
     */
    public async tunnel$virtual$network$delete$a$virtual$network(params: Params$tunnel$virtual$network$delete$a$virtual$network, option?: RequestOption): Promise<Response$tunnel$virtual$network$delete$a$virtual$network$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/virtual_networks/\${params.parameter.virtual_network_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update a virtual network
     * Updates an existing virtual network.
     */
    public async tunnel$virtual$network$update$a$virtual$network(params: Params$tunnel$virtual$network$update$a$virtual$network, option?: RequestOption): Promise<Response$tunnel$virtual$network$update$a$virtual$network$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/teamnet/virtual_networks/\${params.parameter.virtual_network_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List All Tunnels
     * Lists and filters all types of Tunnels in an account.
     */
    public async cloudflare$tunnel$list$all$tunnels(params: Params$cloudflare$tunnel$list$all$tunnels, option?: RequestOption): Promise<Response$cloudflare$tunnel$list$all$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/tunnels\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            is_deleted: { value: params.parameter.is_deleted, explode: false },
            existed_at: { value: params.parameter.existed_at, explode: false },
            uuid: { value: params.parameter.uuid, explode: false },
            was_active_at: { value: params.parameter.was_active_at, explode: false },
            was_inactive_at: { value: params.parameter.was_inactive_at, explode: false },
            include_prefix: { value: params.parameter.include_prefix, explode: false },
            exclude_prefix: { value: params.parameter.exclude_prefix, explode: false },
            tun_types: { value: params.parameter.tun_types, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            page: { value: params.parameter.page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Create an Argo Tunnel
     * Creates a new Argo Tunnel in an account.
     */
    public async argo$tunnel$create$an$argo$tunnel(params: Params$argo$tunnel$create$an$argo$tunnel, option?: RequestOption): Promise<Response$argo$tunnel$create$an$argo$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/tunnels\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Get an Argo Tunnel
     * Fetches a single Argo Tunnel.
     */
    public async argo$tunnel$get$an$argo$tunnel(params: Params$argo$tunnel$get$an$argo$tunnel, option?: RequestOption): Promise<Response$argo$tunnel$get$an$argo$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/tunnels/\${params.parameter.tunnel_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Delete an Argo Tunnel
     * Deletes an Argo Tunnel from an account.
     */
    public async argo$tunnel$delete$an$argo$tunnel(params: Params$argo$tunnel$delete$an$argo$tunnel, option?: RequestOption): Promise<Response$argo$tunnel$delete$an$argo$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/tunnels/\${params.parameter.tunnel_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Clean up Argo Tunnel connections
     * Removes connections that are in a disconnected or pending reconnect state. We recommend running this command after shutting down a tunnel.
     */
    public async argo$tunnel$clean$up$argo$tunnel$connections(params: Params$argo$tunnel$clean$up$argo$tunnel$connections, option?: RequestOption): Promise<Response$argo$tunnel$clean$up$argo$tunnel$connections$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/tunnels/\${params.parameter.tunnel_id}/connections\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Warp Connector Tunnels
     * Lists and filters Warp Connector Tunnels in an account.
     */
    public async cloudflare$tunnel$list$warp$connector$tunnels(params: Params$cloudflare$tunnel$list$warp$connector$tunnels, option?: RequestOption): Promise<Response$cloudflare$tunnel$list$warp$connector$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/warp_connector\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            is_deleted: { value: params.parameter.is_deleted, explode: false },
            existed_at: { value: params.parameter.existed_at, explode: false },
            uuid: { value: params.parameter.uuid, explode: false },
            was_active_at: { value: params.parameter.was_active_at, explode: false },
            was_inactive_at: { value: params.parameter.was_inactive_at, explode: false },
            include_prefix: { value: params.parameter.include_prefix, explode: false },
            exclude_prefix: { value: params.parameter.exclude_prefix, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            page: { value: params.parameter.page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a Warp Connector Tunnel
     * Creates a new Warp Connector Tunnel in an account.
     */
    public async cloudflare$tunnel$create$a$warp$connector$tunnel(params: Params$cloudflare$tunnel$create$a$warp$connector$tunnel, option?: RequestOption): Promise<Response$cloudflare$tunnel$create$a$warp$connector$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/warp_connector\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Warp Connector Tunnel
     * Fetches a single Warp Connector Tunnel.
     */
    public async cloudflare$tunnel$get$a$warp$connector$tunnel(params: Params$cloudflare$tunnel$get$a$warp$connector$tunnel, option?: RequestOption): Promise<Response$cloudflare$tunnel$get$a$warp$connector$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/warp_connector/\${params.parameter.tunnel_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete a Warp Connector Tunnel
     * Deletes a Warp Connector Tunnel from an account.
     */
    public async cloudflare$tunnel$delete$a$warp$connector$tunnel(params: Params$cloudflare$tunnel$delete$a$warp$connector$tunnel, option?: RequestOption): Promise<Response$cloudflare$tunnel$delete$a$warp$connector$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/warp_connector/\${params.parameter.tunnel_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update a Warp Connector Tunnel
     * Updates an existing Warp Connector Tunnel.
     */
    public async cloudflare$tunnel$update$a$warp$connector$tunnel(params: Params$cloudflare$tunnel$update$a$warp$connector$tunnel, option?: RequestOption): Promise<Response$cloudflare$tunnel$update$a$warp$connector$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/warp_connector/\${params.parameter.tunnel_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Warp Connector Tunnel token
     * Gets the token used to associate warp device with a specific Warp Connector tunnel.
     */
    public async cloudflare$tunnel$get$a$warp$connector$tunnel$token(params: Params$cloudflare$tunnel$get$a$warp$connector$tunnel$token, option?: RequestOption): Promise<Response$cloudflare$tunnel$get$a$warp$connector$tunnel$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/warp_connector/\${params.parameter.tunnel_id}/token\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Fetch Worker Account Settings
     * Fetches Worker account settings for an account.
     */
    public async worker$account$settings$fetch$worker$account$settings(params: Params$worker$account$settings$fetch$worker$account$settings, option?: RequestOption): Promise<Response$worker$account$settings$fetch$worker$account$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/account-settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Worker Account Settings
     * Creates Worker account settings for an account.
     */
    public async worker$account$settings$create$worker$account$settings(params: Params$worker$account$settings$create$worker$account$settings, option?: RequestOption): Promise<Response$worker$account$settings$create$worker$account$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/account-settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** List Deployments */
    public async worker$deployments$list$deployments(params: Params$worker$deployments$list$deployments, option?: RequestOption): Promise<Response$worker$deployments$list$deployments$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/deployments/by-script/\${params.parameter.script_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Get Deployment Detail */
    public async worker$deployments$get$deployment$detail(params: Params$worker$deployments$get$deployment$detail, option?: RequestOption): Promise<Response$worker$deployments$get$deployment$detail$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/deployments/by-script/\${params.parameter.script_id}/detail/\${params.parameter.deployment_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Worker Details (Workers for Platforms)
     * Fetch information about a script uploaded to a Workers for Platforms namespace.
     */
    public async namespace$worker$script$worker$details(params: Params$namespace$worker$script$worker$details, option?: RequestOption): Promise<Response$namespace$worker$script$worker$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/dispatch/namespaces/\${params.parameter.dispatch_namespace}/scripts/\${params.parameter.script_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Upload Worker Module (Workers for Platforms)
     * Upload a worker module to a Workers for Platforms namespace.
     */
    public async namespace$worker$script$upload$worker$module<RequestContentType extends RequestContentType$namespace$worker$script$upload$worker$module>(params: Params$namespace$worker$script$upload$worker$module<RequestContentType>, option?: RequestOption): Promise<Response$namespace$worker$script$upload$worker$module$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/dispatch/namespaces/\${params.parameter.dispatch_namespace}/scripts/\${params.parameter.script_name}\`;
        const headers = {
            "Content-Type": params.headers["Content-Type"],
            Accept: "application/json"
        };
        const requestEncodings: Record<string, Record<string, Encoding>> = {
  "multipart/form-data": {
    "<any part name>": {
      "contentType": "application/javascript+module, text/javascript+module, application/javascript, text/javascript, application/wasm, text/plain, application/octet-stream"
    }
  }
};
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody,
            requestBodyEncoding: requestEncodings[params.headers["Content-Type"]]
        }, option);
    }
    /**
     * Delete Worker (Workers for Platforms)
     * Delete a worker from a Workers for Platforms namespace. This call has no response body on a successful delete.
     */
    public async namespace$worker$script$delete$worker(params: Params$namespace$worker$script$delete$worker, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/dispatch/namespaces/\${params.parameter.dispatch_namespace}/scripts/\${params.parameter.script_name}\`;
        const headers = {};
        const queryParameters: QueryParameters = {
            force: { value: params.parameter.force, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Script Content (Workers for Platforms)
     * Fetch script content from a script uploaded to a Workers for Platforms namespace.
     */
    public async namespace$worker$get$script$content(params: Params$namespace$worker$get$script$content, option?: RequestOption): Promise<Response$namespace$worker$get$script$content$Status$200["string"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/dispatch/namespaces/\${params.parameter.dispatch_namespace}/scripts/\${params.parameter.script_name}/content\`;
        const headers = {
            Accept: "string"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Put Script Content (Workers for Platforms)
     * Put script content for a script uploaded to a Workers for Platforms namespace.
     */
    public async namespace$worker$put$script$content(params: Params$namespace$worker$put$script$content, option?: RequestOption): Promise<Response$namespace$worker$put$script$content$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/dispatch/namespaces/\${params.parameter.dispatch_namespace}/scripts/\${params.parameter.script_name}/content\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json",
            "CF-WORKER-BODY-PART": params.parameter["CF-WORKER-BODY-PART"],
            "CF-WORKER-MAIN-MODULE-PART": params.parameter["CF-WORKER-MAIN-MODULE-PART"]
        };
        const requestEncodings: Record<string, Record<string, Encoding>> = {
  "multipart/form-data": {
    "<any part name>": {
      "contentType": "application/javascript+module, text/javascript+module, application/javascript, text/javascript, application/wasm, text/plain, application/octet-stream"
    }
  }
};
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody,
            requestBodyEncoding: requestEncodings["multipart/form-data"]
        }, option);
    }
    /**
     * Get Script Settings
     * Get script settings from a script uploaded to a Workers for Platforms namespace.
     */
    public async namespace$worker$get$script$settings(params: Params$namespace$worker$get$script$settings, option?: RequestOption): Promise<Response$namespace$worker$get$script$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/dispatch/namespaces/\${params.parameter.dispatch_namespace}/scripts/\${params.parameter.script_name}/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Patch Script Settings
     * Patch script metadata, such as bindings
     */
    public async namespace$worker$patch$script$settings(params: Params$namespace$worker$patch$script$settings, option?: RequestOption): Promise<Response$namespace$worker$patch$script$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/dispatch/namespaces/\${params.parameter.dispatch_namespace}/scripts/\${params.parameter.script_name}/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Domains
     * Lists all Worker Domains for an account.
     */
    public async worker$domain$list$domains(params: Params$worker$domain$list$domains, option?: RequestOption): Promise<Response$worker$domain$list$domains$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/domains\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            zone_name: { value: params.parameter.zone_name, explode: false },
            service: { value: params.parameter.service, explode: false },
            zone_id: { value: params.parameter.zone_id, explode: false },
            hostname: { value: params.parameter.hostname, explode: false },
            environment: { value: params.parameter.environment, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Attach to Domain
     * Attaches a Worker to a zone and hostname.
     */
    public async worker$domain$attach$to$domain(params: Params$worker$domain$attach$to$domain, option?: RequestOption): Promise<Response$worker$domain$attach$to$domain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/domains\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Domain
     * Gets a Worker domain.
     */
    public async worker$domain$get$a$domain(params: Params$worker$domain$get$a$domain, option?: RequestOption): Promise<Response$worker$domain$get$a$domain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/domains/\${params.parameter.domain_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Detach from Domain
     * Detaches a Worker from a zone and hostname.
     */
    public async worker$domain$detach$from$domain(params: Params$worker$domain$detach$from$domain, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/domains/\${params.parameter.domain_id}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Namespaces
     * Returns the Durable Object namespaces owned by an account.
     */
    public async durable$objects$namespace$list$namespaces(params: Params$durable$objects$namespace$list$namespaces, option?: RequestOption): Promise<Response$durable$objects$namespace$list$namespaces$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/durable_objects/namespaces\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Objects
     * Returns the Durable Objects in a given namespace.
     */
    public async durable$objects$namespace$list$objects(params: Params$durable$objects$namespace$list$objects, option?: RequestOption): Promise<Response$durable$objects$namespace$list$objects$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/durable_objects/namespaces/\${params.parameter.id}/objects\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            cursor: { value: params.parameter.cursor, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Queues
     * Returns the queues owned by an account.
     */
    public async queue$list$queues(params: Params$queue$list$queues, option?: RequestOption): Promise<Response$queue$list$queues$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Queue
     * Creates a new queue.
     */
    public async queue$create$queue(params: Params$queue$create$queue, option?: RequestOption): Promise<Response$queue$create$queue$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Queue Details
     * Get information about a specific queue.
     */
    public async queue$queue$details(params: Params$queue$queue$details, option?: RequestOption): Promise<Response$queue$queue$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues/\${params.parameter.name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Queue
     * Updates a queue.
     */
    public async queue$update$queue(params: Params$queue$update$queue, option?: RequestOption): Promise<Response$queue$update$queue$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues/\${params.parameter.name}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Queue
     * Deletes a queue.
     */
    public async queue$delete$queue(params: Params$queue$delete$queue, option?: RequestOption): Promise<Response$queue$delete$queue$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues/\${params.parameter.name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Queue Consumers
     * Returns the consumers for a queue.
     */
    public async queue$list$queue$consumers(params: Params$queue$list$queue$consumers, option?: RequestOption): Promise<Response$queue$list$queue$consumers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues/\${params.parameter.name}/consumers\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Queue Consumer
     * Creates a new consumer for a queue.
     */
    public async queue$create$queue$consumer(params: Params$queue$create$queue$consumer, option?: RequestOption): Promise<Response$queue$create$queue$consumer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues/\${params.parameter.name}/consumers\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update Queue Consumer
     * Updates the consumer for a queue, or creates one if it does not exist.
     */
    public async queue$update$queue$consumer(params: Params$queue$update$queue$consumer, option?: RequestOption): Promise<Response$queue$update$queue$consumer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues/\${params.parameter.name}/consumers/\${params.parameter.consumer_name}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Queue Consumer
     * Deletes the consumer for a queue.
     */
    public async queue$delete$queue$consumer(params: Params$queue$delete$queue$consumer, option?: RequestOption): Promise<Response$queue$delete$queue$consumer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/queues/\${params.parameter.name}/consumers/\${params.parameter.consumer_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Workers
     * Fetch a list of uploaded workers.
     */
    public async worker$script$list$workers(params: Params$worker$script$list$workers, option?: RequestOption): Promise<Response$worker$script$list$workers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Download Worker
     * Fetch raw script content for your worker. Note this is the original script content, not JSON encoded.
     */
    public async worker$script$download$worker(params: Params$worker$script$download$worker, option?: RequestOption): Promise<Response$worker$script$download$worker$Status$200["undefined"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}\`;
        const headers = {
            Accept: "undefined"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Upload Worker Module
     * Upload a worker module.
     */
    public async worker$script$upload$worker$module<RequestContentType extends RequestContentType$worker$script$upload$worker$module>(params: Params$worker$script$upload$worker$module<RequestContentType>, option?: RequestOption): Promise<Response$worker$script$upload$worker$module$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}\`;
        const headers = {
            "Content-Type": params.headers["Content-Type"],
            Accept: "application/json"
        };
        const requestEncodings: Record<string, Record<string, Encoding>> = {
  "multipart/form-data": {
    "<any part name>": {
      "contentType": "application/javascript+module, text/javascript+module, application/javascript, text/javascript, application/wasm, text/plain, application/octet-stream"
    }
  }
};
        const queryParameters: QueryParameters = {
            rollback_to: { value: params.parameter.rollback_to, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody,
            requestBodyEncoding: requestEncodings[params.headers["Content-Type"]],
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Delete Worker
     * Delete your worker. This call has no response body on a successful delete.
     */
    public async worker$script$delete$worker(params: Params$worker$script$delete$worker, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}\`;
        const headers = {};
        const queryParameters: QueryParameters = {
            force: { value: params.parameter.force, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Put script content
     * Put script content without touching config or metadata
     */
    public async worker$script$put$content(params: Params$worker$script$put$content, option?: RequestOption): Promise<Response$worker$script$put$content$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/content\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json",
            "CF-WORKER-BODY-PART": params.parameter["CF-WORKER-BODY-PART"],
            "CF-WORKER-MAIN-MODULE-PART": params.parameter["CF-WORKER-MAIN-MODULE-PART"]
        };
        const requestEncodings: Record<string, Record<string, Encoding>> = {
  "multipart/form-data": {
    "<any part name>": {
      "contentType": "application/javascript+module, text/javascript+module, application/javascript, text/javascript, application/wasm, text/plain, application/octet-stream"
    }
  }
};
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody,
            requestBodyEncoding: requestEncodings["multipart/form-data"]
        }, option);
    }
    /**
     * Get script content
     * Fetch script content only
     */
    public async worker$script$get$content(params: Params$worker$script$get$content, option?: RequestOption): Promise<Response$worker$script$get$content$Status$200["string"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/content/v2\`;
        const headers = {
            Accept: "string"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get Cron Triggers
     * Fetches Cron Triggers for a Worker.
     */
    public async worker$cron$trigger$get$cron$triggers(params: Params$worker$cron$trigger$get$cron$triggers, option?: RequestOption): Promise<Response$worker$cron$trigger$get$cron$triggers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/schedules\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Cron Triggers
     * Updates Cron Triggers for a Worker.
     */
    public async worker$cron$trigger$update$cron$triggers(params: Params$worker$cron$trigger$update$cron$triggers, option?: RequestOption): Promise<Response$worker$cron$trigger$update$cron$triggers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/schedules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Script Settings
     * Get script metadata and config, such as bindings or usage model
     */
    public async worker$script$get$settings(params: Params$worker$script$get$settings, option?: RequestOption): Promise<Response$worker$script$get$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Patch Script Settings
     * Patch script metadata or config, such as bindings or usage model
     */
    public async worker$script$patch$settings(params: Params$worker$script$patch$settings, option?: RequestOption): Promise<Response$worker$script$patch$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/settings\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Tails
     * Get list of tails currently deployed on a Worker.
     */
    public async worker$tail$logs$list$tails(params: Params$worker$tail$logs$list$tails, option?: RequestOption): Promise<Response$worker$tail$logs$list$tails$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/tails\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Start Tail
     * Starts a tail that receives logs and exception from a Worker.
     */
    public async worker$tail$logs$start$tail(params: Params$worker$tail$logs$start$tail, option?: RequestOption): Promise<Response$worker$tail$logs$start$tail$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/tails\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Delete Tail
     * Deletes a tail from a Worker.
     */
    public async worker$tail$logs$delete$tail(params: Params$worker$tail$logs$delete$tail, option?: RequestOption): Promise<Response$worker$tail$logs$delete$tail$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/tails/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Fetch Usage Model
     * Fetches the Usage Model for a given Worker.
     */
    public async worker$script$fetch$usage$model(params: Params$worker$script$fetch$usage$model, option?: RequestOption): Promise<Response$worker$script$fetch$usage$model$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/usage-model\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Usage Model
     * Updates the Usage Model for a given Worker. Requires a Workers Paid subscription.
     */
    public async worker$script$update$usage$model(params: Params$worker$script$update$usage$model, option?: RequestOption): Promise<Response$worker$script$update$usage$model$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/scripts/\${params.parameter.script_name}/usage-model\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get script content
     * Get script content from a worker with an environment
     */
    public async worker$environment$get$script$content(params: Params$worker$environment$get$script$content, option?: RequestOption): Promise<Response$worker$environment$get$script$content$Status$200["string"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/services/\${params.parameter.service_name}/environments/\${params.parameter.environment_name}/content\`;
        const headers = {
            Accept: "string"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Put script content
     * Put script content from a worker with an environment
     */
    public async worker$environment$put$script$content(params: Params$worker$environment$put$script$content, option?: RequestOption): Promise<Response$worker$environment$put$script$content$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/services/\${params.parameter.service_name}/environments/\${params.parameter.environment_name}/content\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json",
            "CF-WORKER-BODY-PART": params.parameter["CF-WORKER-BODY-PART"],
            "CF-WORKER-MAIN-MODULE-PART": params.parameter["CF-WORKER-MAIN-MODULE-PART"]
        };
        const requestEncodings: Record<string, Record<string, Encoding>> = {
  "multipart/form-data": {
    "<any part name>": {
      "contentType": "application/javascript+module, text/javascript+module, application/javascript, text/javascript, application/wasm, text/plain, application/octet-stream"
    }
  }
};
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody,
            requestBodyEncoding: requestEncodings["multipart/form-data"]
        }, option);
    }
    /**
     * Get Script Settings
     * Get script settings from a worker with an environment
     */
    public async worker$script$environment$get$settings(params: Params$worker$script$environment$get$settings, option?: RequestOption): Promise<Response$worker$script$environment$get$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/services/\${params.parameter.service_name}/environments/\${params.parameter.environment_name}/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Patch Script Settings
     * Patch script metadata, such as bindings
     */
    public async worker$script$environment$patch$settings(params: Params$worker$script$environment$patch$settings, option?: RequestOption): Promise<Response$worker$script$environment$patch$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/services/\${params.parameter.service_name}/environments/\${params.parameter.environment_name}/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Subdomain
     * Returns a Workers subdomain for an account.
     */
    public async worker$subdomain$get$subdomain(params: Params$worker$subdomain$get$subdomain, option?: RequestOption): Promise<Response$worker$subdomain$get$subdomain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/subdomain\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Subdomain
     * Creates a Workers subdomain for an account.
     */
    public async worker$subdomain$create$subdomain(params: Params$worker$subdomain$create$subdomain, option?: RequestOption): Promise<Response$worker$subdomain$create$subdomain$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/workers/subdomain\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zero Trust Connectivity Settings
     * Gets the Zero Trust Connectivity Settings for the given account.
     */
    public async zero$trust$accounts$get$connectivity$settings(params: Params$zero$trust$accounts$get$connectivity$settings, option?: RequestOption): Promise<Response$zero$trust$accounts$get$connectivity$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/zerotrust/connectivity_settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Updates the Zero Trust Connectivity Settings
     * Updates the Zero Trust Connectivity Settings for the given account.
     */
    public async zero$trust$accounts$patch$connectivity$settings(params: Params$zero$trust$accounts$patch$connectivity$settings, option?: RequestOption): Promise<Response$zero$trust$accounts$patch$connectivity$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_id}/zerotrust/connectivity_settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Address Maps
     * List all address maps owned by the account.
     */
    public async ip$address$management$address$maps$list$address$maps(params: Params$ip$address$management$address$maps$list$address$maps, option?: RequestOption): Promise<Response$ip$address$management$address$maps$list$address$maps$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Address Map
     * Create a new address map under the account.
     */
    public async ip$address$management$address$maps$create$address$map(params: Params$ip$address$management$address$maps$create$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$create$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Address Map Details
     * Show a particular address map owned by the account.
     */
    public async ip$address$management$address$maps$address$map$details(params: Params$ip$address$management$address$maps$address$map$details, option?: RequestOption): Promise<Response$ip$address$management$address$maps$address$map$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps/\${params.parameter.address_map_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete Address Map
     * Delete a particular address map owned by the account. An Address Map must be disabled before it can be deleted.
     */
    public async ip$address$management$address$maps$delete$address$map(params: Params$ip$address$management$address$maps$delete$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$delete$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps/\${params.parameter.address_map_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update Address Map
     * Modify properties of an address map owned by the account.
     */
    public async ip$address$management$address$maps$update$address$map(params: Params$ip$address$management$address$maps$update$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$update$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps/\${params.parameter.address_map_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Add an IP to an Address Map
     * Add an IP from a prefix owned by the account to a particular address map.
     */
    public async ip$address$management$address$maps$add$an$ip$to$an$address$map(params: Params$ip$address$management$address$maps$add$an$ip$to$an$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$add$an$ip$to$an$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps/\${params.parameter.address_map_identifier}/ips/\${params.parameter.ip_address}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers
        }, option);
    }
    /**
     * Remove an IP from an Address Map
     * Remove an IP from a particular address map.
     */
    public async ip$address$management$address$maps$remove$an$ip$from$an$address$map(params: Params$ip$address$management$address$maps$remove$an$ip$from$an$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$remove$an$ip$from$an$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps/\${params.parameter.address_map_identifier}/ips/\${params.parameter.ip_address}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Add a zone membership to an Address Map
     * Add a zone as a member of a particular address map.
     */
    public async ip$address$management$address$maps$add$a$zone$membership$to$an$address$map(params: Params$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$add$a$zone$membership$to$an$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps/\${params.parameter.address_map_identifier}/zones/\${params.parameter.zone_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers
        }, option);
    }
    /**
     * Remove a zone membership from an Address Map
     * Remove a zone as a member of a particular address map.
     */
    public async ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map(params: Params$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$remove$a$zone$membership$from$an$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/address_maps/\${params.parameter.address_map_identifier}/zones/\${params.parameter.zone_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Upload LOA Document
     * Submit LOA document (pdf format) under the account.
     */
    public async ip$address$management$prefixes$upload$loa$document(params: Params$ip$address$management$prefixes$upload$loa$document, option?: RequestOption): Promise<Response$ip$address$management$prefixes$upload$loa$document$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/loa_documents\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Download LOA Document
     * Download specified LOA document under the account.
     */
    public async ip$address$management$prefixes$download$loa$document(params: Params$ip$address$management$prefixes$download$loa$document, option?: RequestOption): Promise<Response$ip$address$management$prefixes$download$loa$document$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/loa_documents/\${params.parameter.loa_document_identifier}/download\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Prefixes
     * List all prefixes owned by the account.
     */
    public async ip$address$management$prefixes$list$prefixes(params: Params$ip$address$management$prefixes$list$prefixes, option?: RequestOption): Promise<Response$ip$address$management$prefixes$list$prefixes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add Prefix
     * Add a new prefix under the account.
     */
    public async ip$address$management$prefixes$add$prefix(params: Params$ip$address$management$prefixes$add$prefix, option?: RequestOption): Promise<Response$ip$address$management$prefixes$add$prefix$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Prefix Details
     * List a particular prefix owned by the account.
     */
    public async ip$address$management$prefixes$prefix$details(params: Params$ip$address$management$prefixes$prefix$details, option?: RequestOption): Promise<Response$ip$address$management$prefixes$prefix$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete Prefix
     * Delete an unapproved prefix owned by the account.
     */
    public async ip$address$management$prefixes$delete$prefix(params: Params$ip$address$management$prefixes$delete$prefix, option?: RequestOption): Promise<Response$ip$address$management$prefixes$delete$prefix$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update Prefix Description
     * Modify the description for a prefix owned by the account.
     */
    public async ip$address$management$prefixes$update$prefix$description(params: Params$ip$address$management$prefixes$update$prefix$description, option?: RequestOption): Promise<Response$ip$address$management$prefixes$update$prefix$description$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List BGP Prefixes
     * List all BGP Prefixes within the specified IP Prefix. BGP Prefixes are used to control which specific subnets are advertised to the Internet. It is possible to advertise subnets more specific than an IP Prefix by creating more specific BGP Prefixes.
     */
    public async ip$address$management$prefixes$list$bgp$prefixes(params: Params$ip$address$management$prefixes$list$bgp$prefixes, option?: RequestOption): Promise<Response$ip$address$management$prefixes$list$bgp$prefixes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bgp/prefixes\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Fetch BGP Prefix
     * Retrieve a single BGP Prefix according to its identifier
     */
    public async ip$address$management$prefixes$fetch$bgp$prefix(params: Params$ip$address$management$prefixes$fetch$bgp$prefix, option?: RequestOption): Promise<Response$ip$address$management$prefixes$fetch$bgp$prefix$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bgp/prefixes/\${params.parameter.bgp_prefix_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update BGP Prefix
     * Update the properties of a BGP Prefix, such as the on demand advertisement status (advertised or withdrawn).
     */
    public async ip$address$management$prefixes$update$bgp$prefix(params: Params$ip$address$management$prefixes$update$bgp$prefix, option?: RequestOption): Promise<Response$ip$address$management$prefixes$update$bgp$prefix$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bgp/prefixes/\${params.parameter.bgp_prefix_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Advertisement Status
     * List the current advertisement state for a prefix.
     */
    public async ip$address$management$dynamic$advertisement$get$advertisement$status(params: Params$ip$address$management$dynamic$advertisement$get$advertisement$status, option?: RequestOption): Promise<Response$ip$address$management$dynamic$advertisement$get$advertisement$status$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bgp/status\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Prefix Dynamic Advertisement Status
     * Advertise or withdraw BGP route for a prefix.
     */
    public async ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status(params: Params$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status, option?: RequestOption): Promise<Response$ip$address$management$dynamic$advertisement$update$prefix$dynamic$advertisement$status$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bgp/status\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Service Bindings
     * List the Cloudflare services this prefix is currently bound to. Traffic sent to an address within an IP prefix will be routed to the Cloudflare service of the most-specific Service Binding matching the address.
     * **Example:** binding \`192.0.2.0/24\` to Cloudflare Magic Transit and \`192.0.2.1/32\` to the Cloudflare CDN would route traffic for \`192.0.2.1\` to the CDN, and traffic for all other IPs in the prefix to Cloudflare Magic Transit.
     */
    public async ip$address$management$service$bindings$list$service$bindings(params: Params$ip$address$management$service$bindings$list$service$bindings, option?: RequestOption): Promise<Response$ip$address$management$service$bindings$list$service$bindings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bindings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Service Binding
     * Creates a new Service Binding, routing traffic to IPs within the given CIDR to a service running on Cloudflare's network.
     * **Note:** This API may only be used on prefixes currently configured with a Magic Transit service binding, and only allows creating service bindings for the Cloudflare CDN or Cloudflare Spectrum.
     */
    public async ip$address$management$service$bindings$create$service$binding(params: Params$ip$address$management$service$bindings$create$service$binding, option?: RequestOption): Promise<Response$ip$address$management$service$bindings$create$service$binding$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bindings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Service Binding
     * Fetch a single Service Binding
     */
    public async ip$address$management$service$bindings$get$service$binding(params: Params$ip$address$management$service$bindings$get$service$binding, option?: RequestOption): Promise<Response$ip$address$management$service$bindings$get$service$binding$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bindings/\${params.parameter.binding_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete Service Binding
     * Delete a Service Binding
     */
    public async ip$address$management$service$bindings$delete$service$binding(params: Params$ip$address$management$service$bindings$delete$service$binding, option?: RequestOption): Promise<Response$ip$address$management$service$bindings$delete$service$binding$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/bindings/\${params.parameter.binding_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Prefix Delegations
     * List all delegations for a given account IP prefix.
     */
    public async ip$address$management$prefix$delegation$list$prefix$delegations(params: Params$ip$address$management$prefix$delegation$list$prefix$delegations, option?: RequestOption): Promise<Response$ip$address$management$prefix$delegation$list$prefix$delegations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/delegations\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Prefix Delegation
     * Create a new account delegation for a given IP prefix.
     */
    public async ip$address$management$prefix$delegation$create$prefix$delegation(params: Params$ip$address$management$prefix$delegation$create$prefix$delegation, option?: RequestOption): Promise<Response$ip$address$management$prefix$delegation$create$prefix$delegation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/delegations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Prefix Delegation
     * Delete an account delegation for a given IP prefix.
     */
    public async ip$address$management$prefix$delegation$delete$prefix$delegation(params: Params$ip$address$management$prefix$delegation$delete$prefix$delegation, option?: RequestOption): Promise<Response$ip$address$management$prefix$delegation$delete$prefix$delegation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/prefixes/\${params.parameter.prefix_identifier}/delegations/\${params.parameter.delegation_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Services
     * Bring-Your-Own IP (BYOIP) prefixes onboarded to Cloudflare must be bound to a service running on the Cloudflare network to enable a Cloudflare product on the IP addresses. This endpoint can be used as a reference of available services on the Cloudflare network, and their service IDs.
     */
    public async ip$address$management$service$bindings$list$services(params: Params$ip$address$management$service$bindings$list$services, option?: RequestOption): Promise<Response$ip$address$management$service$bindings$list$services$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/addressing/services\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Execute AI model
     * This endpoint provides users with the capability to run specific AI models on-demand.
     *
     * By submitting the required input data, users can receive real-time predictions or results generated by the chosen AI
     * model. The endpoint supports various AI model types, ensuring flexibility and adaptability for diverse use cases.
     */
    public async workers$ai$post$run$model<RequestContentType extends RequestContentType$workers$ai$post$run$model>(params: Params$workers$ai$post$run$model<RequestContentType>, option?: RequestOption): Promise<Response$workers$ai$post$run$model$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/ai/run/\${params.parameter.model_name}\`;
        const headers = {
            "Content-Type": params.headers["Content-Type"],
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get account audit logs
     * Gets a list of audit logs for an account. Can be filtered by who made the change, on which zone, and the timeframe of the change.
     */
    public async audit$logs$get$account$audit$logs(params: Params$audit$logs$get$account$audit$logs, option?: RequestOption): Promise<Response$audit$logs$get$account$audit$logs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/audit_logs\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            id: { value: params.parameter.id, explode: false },
            export: { value: params.parameter.export, explode: false },
            "action.type": { value: params.parameter["action.type"], explode: false },
            "actor.ip": { value: params.parameter["actor.ip"], explode: false },
            "actor.email": { value: params.parameter["actor.email"], explode: false },
            since: { value: params.parameter.since, explode: false },
            before: { value: params.parameter.before, explode: false },
            "zone.name": { value: params.parameter["zone.name"], explode: false },
            direction: { value: params.parameter.direction, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            page: { value: params.parameter.page, explode: false },
            hide_user_logs: { value: params.parameter.hide_user_logs, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Billing Profile Details
     * Gets the current billing profile for the account.
     */
    public async account$billing$profile$$$deprecated$$billing$profile$details(params: Params$account$billing$profile$$$deprecated$$billing$profile$details, option?: RequestOption): Promise<Response$account$billing$profile$$$deprecated$$billing$profile$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/billing/profile\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Turnstile Widgets
     * Lists all turnstile widgets of an account.
     */
    public async accounts$turnstile$widgets$list(params: Params$accounts$turnstile$widgets$list, option?: RequestOption): Promise<Response$accounts$turnstile$widgets$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/challenges/widgets\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a Turnstile Widget
     * Lists challenge widgets.
     */
    public async accounts$turnstile$widget$create(params: Params$accounts$turnstile$widget$create, option?: RequestOption): Promise<Response$accounts$turnstile$widget$create$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/challenges/widgets\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Turnstile Widget Details
     * Show a single challenge widget configuration.
     */
    public async accounts$turnstile$widget$get(params: Params$accounts$turnstile$widget$get, option?: RequestOption): Promise<Response$accounts$turnstile$widget$get$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/challenges/widgets/\${params.parameter.sitekey}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a Turnstile Widget
     * Update the configuration of a widget.
     */
    public async accounts$turnstile$widget$update(params: Params$accounts$turnstile$widget$update, option?: RequestOption): Promise<Response$accounts$turnstile$widget$update$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/challenges/widgets/\${params.parameter.sitekey}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Turnstile Widget
     * Destroy a Turnstile Widget.
     */
    public async accounts$turnstile$widget$delete(params: Params$accounts$turnstile$widget$delete, option?: RequestOption): Promise<Response$accounts$turnstile$widget$delete$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/challenges/widgets/\${params.parameter.sitekey}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Rotate Secret for a Turnstile Widget
     * Generate a new secret key for this widget. If \`invalidate_immediately\`
     * is set to \`false\`, the previous secret remains valid for 2 hours.
     *
     * Note that secrets cannot be rotated again during the grace period.
     */
    public async accounts$turnstile$widget$rotate$secret(params: Params$accounts$turnstile$widget$rotate$secret, option?: RequestOption): Promise<Response$accounts$turnstile$widget$rotate$secret$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/challenges/widgets/\${params.parameter.sitekey}/rotate_secret\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List custom pages
     * Fetches all the custom pages at the account level.
     */
    public async custom$pages$for$an$account$list$custom$pages(params: Params$custom$pages$for$an$account$list$custom$pages, option?: RequestOption): Promise<Response$custom$pages$for$an$account$list$custom$pages$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/custom_pages\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get a custom page
     * Fetches the details of a custom page.
     */
    public async custom$pages$for$an$account$get$a$custom$page(params: Params$custom$pages$for$an$account$get$a$custom$page, option?: RequestOption): Promise<Response$custom$pages$for$an$account$get$a$custom$page$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/custom_pages/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a custom page
     * Updates the configuration of an existing custom page.
     */
    public async custom$pages$for$an$account$update$a$custom$page(params: Params$custom$pages$for$an$account$update$a$custom$page, option?: RequestOption): Promise<Response$custom$pages$for$an$account$update$a$custom$page$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/custom_pages/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get D1 Database
     * Returns the specified D1 database.
     */
    public async cloudflare$d1$get$database(params: Params$cloudflare$d1$get$database, option?: RequestOption): Promise<Response$cloudflare$d1$get$database$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/d1/database/\${params.parameter.database_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete D1 Database
     * Deletes the specified D1 database.
     */
    public async cloudflare$d1$delete$database(params: Params$cloudflare$d1$delete$database, option?: RequestOption): Promise<Response$cloudflare$d1$delete$database$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/d1/database/\${params.parameter.database_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Query D1 Database
     * Returns the query result.
     */
    public async cloudflare$d1$query$database(params: Params$cloudflare$d1$query$database, option?: RequestOption): Promise<Response$cloudflare$d1$query$database$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/d1/database/\${params.parameter.database_identifier}/query\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Traceroute
     * Run traceroutes from Cloudflare colos.
     */
    public async diagnostics$traceroute(params: Params$diagnostics$traceroute, option?: RequestOption): Promise<Response$diagnostics$traceroute$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/diagnostics/traceroute\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Table
     * Retrieves a list of summarised aggregate metrics over a given time period.
     *
     * See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.
     */
    public async dns$firewall$analytics$table(params: Params$dns$firewall$analytics$table, option?: RequestOption): Promise<Response$dns$firewall$analytics$table$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/dns_firewall/\${params.parameter.identifier}/dns_analytics/report\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            metrics: { value: params.parameter.metrics, explode: false },
            dimensions: { value: params.parameter.dimensions, explode: false },
            since: { value: params.parameter.since, explode: false },
            until: { value: params.parameter.until, explode: false },
            limit: { value: params.parameter.limit, explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filters: { value: params.parameter.filters, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * By Time
     * Retrieves a list of aggregate metrics grouped by time interval.
     *
     * See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.
     */
    public async dns$firewall$analytics$by$time(params: Params$dns$firewall$analytics$by$time, option?: RequestOption): Promise<Response$dns$firewall$analytics$by$time$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/dns_firewall/\${params.parameter.identifier}/dns_analytics/report/bytime\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            metrics: { value: params.parameter.metrics, explode: false },
            dimensions: { value: params.parameter.dimensions, explode: false },
            since: { value: params.parameter.since, explode: false },
            until: { value: params.parameter.until, explode: false },
            limit: { value: params.parameter.limit, explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filters: { value: params.parameter.filters, explode: false },
            time_delta: { value: params.parameter.time_delta, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List destination addresses
     * Lists existing destination addresses.
     */
    public async email$routing$destination$addresses$list$destination$addresses(params: Params$email$routing$destination$addresses$list$destination$addresses, option?: RequestOption): Promise<Response$email$routing$destination$addresses$list$destination$addresses$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/email/routing/addresses\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            verified: { value: params.parameter.verified, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a destination address
     * Create a destination address to forward your emails to. Destination addresses need to be verified before they can be used.
     */
    public async email$routing$destination$addresses$create$a$destination$address(params: Params$email$routing$destination$addresses$create$a$destination$address, option?: RequestOption): Promise<Response$email$routing$destination$addresses$create$a$destination$address$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/email/routing/addresses\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a destination address
     * Gets information for a specific destination email already created.
     */
    public async email$routing$destination$addresses$get$a$destination$address(params: Params$email$routing$destination$addresses$get$a$destination$address, option?: RequestOption): Promise<Response$email$routing$destination$addresses$get$a$destination$address$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/email/routing/addresses/\${params.parameter.destination_address_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete destination address
     * Deletes a specific destination address.
     */
    public async email$routing$destination$addresses$delete$destination$address(params: Params$email$routing$destination$addresses$delete$destination$address, option?: RequestOption): Promise<Response$email$routing$destination$addresses$delete$destination$address$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/email/routing/addresses/\${params.parameter.destination_address_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List IP Access rules
     * Fetches IP Access rules of an account. These rules apply to all the zones in the account. You can filter the results using several optional parameters.
     */
    public async ip$access$rules$for$an$account$list$ip$access$rules(params: Params$ip$access$rules$for$an$account$list$ip$access$rules, option?: RequestOption): Promise<Response$ip$access$rules$for$an$account$list$ip$access$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/firewall/access_rules/rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            filters: { value: params.parameter.filters, explode: false },
            "egs-pagination.json": { value: params.parameter["egs-pagination.json"], explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create an IP Access rule
     * Creates a new IP Access rule for an account. The rule will apply to all zones in the account.
     *
     * Note: To create an IP Access rule that applies to a single zone, refer to the [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints.
     */
    public async ip$access$rules$for$an$account$create$an$ip$access$rule(params: Params$ip$access$rules$for$an$account$create$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$an$account$create$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/firewall/access_rules/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an IP Access rule
     * Fetches the details of an IP Access rule defined at the account level.
     */
    public async ip$access$rules$for$an$account$get$an$ip$access$rule(params: Params$ip$access$rules$for$an$account$get$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$an$account$get$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/firewall/access_rules/rules/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete an IP Access rule
     * Deletes an existing IP Access rule defined at the account level.
     *
     * Note: This operation will affect all zones in the account.
     */
    public async ip$access$rules$for$an$account$delete$an$ip$access$rule(params: Params$ip$access$rules$for$an$account$delete$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$an$account$delete$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/firewall/access_rules/rules/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update an IP Access rule
     * Updates an IP Access rule defined at the account level.
     *
     * Note: This operation will affect all zones in the account.
     */
    public async ip$access$rules$for$an$account$update$an$ip$access$rule(params: Params$ip$access$rules$for$an$account$update$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$an$account$update$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/firewall/access_rules/rules/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get indicator feeds owned by this account */
    public async custom$indicator$feeds$get$indicator$feeds(params: Params$custom$indicator$feeds$get$indicator$feeds, option?: RequestOption): Promise<Response$custom$indicator$feeds$get$indicator$feeds$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/indicator-feeds\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Create new indicator feed */
    public async custom$indicator$feeds$create$indicator$feeds(params: Params$custom$indicator$feeds$create$indicator$feeds, option?: RequestOption): Promise<Response$custom$indicator$feeds$create$indicator$feeds$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/indicator-feeds\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get indicator feed metadata */
    public async custom$indicator$feeds$get$indicator$feed$metadata(params: Params$custom$indicator$feeds$get$indicator$feed$metadata, option?: RequestOption): Promise<Response$custom$indicator$feeds$get$indicator$feed$metadata$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/indicator-feeds/\${params.parameter.feed_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Get indicator feed data */
    public async custom$indicator$feeds$get$indicator$feed$data(params: Params$custom$indicator$feeds$get$indicator$feed$data, option?: RequestOption): Promise<Response$custom$indicator$feeds$get$indicator$feed$data$Status$200["text/csv"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/indicator-feeds/\${params.parameter.feed_id}/data\`;
        const headers = {
            Accept: "text/csv"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Update indicator feed data */
    public async custom$indicator$feeds$update$indicator$feed$data(params: Params$custom$indicator$feeds$update$indicator$feed$data, option?: RequestOption): Promise<Response$custom$indicator$feeds$update$indicator$feed$data$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/indicator-feeds/\${params.parameter.feed_id}/snapshot\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Grant permission to indicator feed */
    public async custom$indicator$feeds$add$permission(params: Params$custom$indicator$feeds$add$permission, option?: RequestOption): Promise<Response$custom$indicator$feeds$add$permission$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/indicator-feeds/permissions/add\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Revoke permission to indicator feed */
    public async custom$indicator$feeds$remove$permission(params: Params$custom$indicator$feeds$remove$permission, option?: RequestOption): Promise<Response$custom$indicator$feeds$remove$permission$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/indicator-feeds/permissions/remove\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** List indicator feed permissions */
    public async custom$indicator$feeds$view$permissions(params: Params$custom$indicator$feeds$view$permissions, option?: RequestOption): Promise<Response$custom$indicator$feeds$view$permissions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/indicator-feeds/permissions/view\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** List sinkholes owned by this account */
    public async sinkhole$config$get$sinkholes(params: Params$sinkhole$config$get$sinkholes, option?: RequestOption): Promise<Response$sinkhole$config$get$sinkholes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/intel/sinkholes\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Monitors
     * List configured monitors for an account.
     */
    public async account$load$balancer$monitors$list$monitors(params: Params$account$load$balancer$monitors$list$monitors, option?: RequestOption): Promise<Response$account$load$balancer$monitors$list$monitors$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/monitors\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Monitor
     * Create a configured monitor.
     */
    public async account$load$balancer$monitors$create$monitor(params: Params$account$load$balancer$monitors$create$monitor, option?: RequestOption): Promise<Response$account$load$balancer$monitors$create$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/monitors\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Monitor Details
     * List a single configured monitor for an account.
     */
    public async account$load$balancer$monitors$monitor$details(params: Params$account$load$balancer$monitors$monitor$details, option?: RequestOption): Promise<Response$account$load$balancer$monitors$monitor$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/monitors/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Monitor
     * Modify a configured monitor.
     */
    public async account$load$balancer$monitors$update$monitor(params: Params$account$load$balancer$monitors$update$monitor, option?: RequestOption): Promise<Response$account$load$balancer$monitors$update$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/monitors/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Monitor
     * Delete a configured monitor.
     */
    public async account$load$balancer$monitors$delete$monitor(params: Params$account$load$balancer$monitors$delete$monitor, option?: RequestOption): Promise<Response$account$load$balancer$monitors$delete$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/monitors/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Monitor
     * Apply changes to an existing monitor, overwriting the supplied properties.
     */
    public async account$load$balancer$monitors$patch$monitor(params: Params$account$load$balancer$monitors$patch$monitor, option?: RequestOption): Promise<Response$account$load$balancer$monitors$patch$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/monitors/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Preview Monitor
     * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
     */
    public async account$load$balancer$monitors$preview$monitor(params: Params$account$load$balancer$monitors$preview$monitor, option?: RequestOption): Promise<Response$account$load$balancer$monitors$preview$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/monitors/\${params.parameter.identifier}/preview\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Monitor References
     * Get the list of resources that reference the provided monitor.
     */
    public async account$load$balancer$monitors$list$monitor$references(params: Params$account$load$balancer$monitors$list$monitor$references, option?: RequestOption): Promise<Response$account$load$balancer$monitors$list$monitor$references$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/monitors/\${params.parameter.identifier}/references\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Pools
     * List configured pools.
     */
    public async account$load$balancer$pools$list$pools(params: Params$account$load$balancer$pools$list$pools, option?: RequestOption): Promise<Response$account$load$balancer$pools$list$pools$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            monitor: { value: params.parameter.monitor, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create Pool
     * Create a new pool.
     */
    public async account$load$balancer$pools$create$pool(params: Params$account$load$balancer$pools$create$pool, option?: RequestOption): Promise<Response$account$load$balancer$pools$create$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Patch Pools
     * Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending \`name\`. Returns the list of affected pools. Supports the standard pagination query parameters, either \`limit\`/\`offset\` or \`per_page\`/\`page\`.
     */
    public async account$load$balancer$pools$patch$pools(params: Params$account$load$balancer$pools$patch$pools, option?: RequestOption): Promise<Response$account$load$balancer$pools$patch$pools$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Pool Details
     * Fetch a single configured pool.
     */
    public async account$load$balancer$pools$pool$details(params: Params$account$load$balancer$pools$pool$details, option?: RequestOption): Promise<Response$account$load$balancer$pools$pool$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Pool
     * Modify a configured pool.
     */
    public async account$load$balancer$pools$update$pool(params: Params$account$load$balancer$pools$update$pool, option?: RequestOption): Promise<Response$account$load$balancer$pools$update$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Pool
     * Delete a configured pool.
     */
    public async account$load$balancer$pools$delete$pool(params: Params$account$load$balancer$pools$delete$pool, option?: RequestOption): Promise<Response$account$load$balancer$pools$delete$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Pool
     * Apply changes to an existing pool, overwriting the supplied properties.
     */
    public async account$load$balancer$pools$patch$pool(params: Params$account$load$balancer$pools$patch$pool, option?: RequestOption): Promise<Response$account$load$balancer$pools$patch$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Pool Health Details
     * Fetch the latest pool health status for a single pool.
     */
    public async account$load$balancer$pools$pool$health$details(params: Params$account$load$balancer$pools$pool$health$details, option?: RequestOption): Promise<Response$account$load$balancer$pools$pool$health$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools/\${params.parameter.identifier}/health\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Preview Pool
     * Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
     */
    public async account$load$balancer$pools$preview$pool(params: Params$account$load$balancer$pools$preview$pool, option?: RequestOption): Promise<Response$account$load$balancer$pools$preview$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools/\${params.parameter.identifier}/preview\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Pool References
     * Get the list of resources that reference the provided pool.
     */
    public async account$load$balancer$pools$list$pool$references(params: Params$account$load$balancer$pools$list$pool$references, option?: RequestOption): Promise<Response$account$load$balancer$pools$list$pool$references$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/pools/\${params.parameter.identifier}/references\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Preview Result
     * Get the result of a previous preview operation using the provided preview_id.
     */
    public async account$load$balancer$monitors$preview$result(params: Params$account$load$balancer$monitors$preview$result, option?: RequestOption): Promise<Response$account$load$balancer$monitors$preview$result$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/preview/\${params.parameter.preview_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Regions
     * List all region mappings.
     */
    public async load$balancer$regions$list$regions(params: Params$load$balancer$regions$list$regions, option?: RequestOption): Promise<Response$load$balancer$regions$list$regions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/regions\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            subdivision_code: { value: params.parameter.subdivision_code, explode: false },
            subdivision_code_a2: { value: params.parameter.subdivision_code_a2, explode: false },
            country_code_a2: { value: params.parameter.country_code_a2, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Region
     * Get a single region mapping.
     */
    public async load$balancer$regions$get$region(params: Params$load$balancer$regions$get$region, option?: RequestOption): Promise<Response$load$balancer$regions$get$region$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/regions/\${params.parameter.region_code}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Search Resources
     * Search for Load Balancing resources.
     */
    public async account$load$balancer$search$search$resources(params: Params$account$load$balancer$search$search$resources, option?: RequestOption): Promise<Response$account$load$balancer$search$search$resources$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/load_balancers/search\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            search_params: { value: params.parameter.search_params, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List interconnects
     * Lists interconnects associated with an account.
     */
    public async magic$interconnects$list$interconnects(params: Params$magic$interconnects$list$interconnects, option?: RequestOption): Promise<Response$magic$interconnects$list$interconnects$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/cf_interconnects\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update multiple interconnects
     * Updates multiple interconnects associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$interconnects$update$multiple$interconnects(params: Params$magic$interconnects$update$multiple$interconnects, option?: RequestOption): Promise<Response$magic$interconnects$update$multiple$interconnects$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/cf_interconnects\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List interconnect Details
     * Lists details for a specific interconnect.
     */
    public async magic$interconnects$list$interconnect$details(params: Params$magic$interconnects$list$interconnect$details, option?: RequestOption): Promise<Response$magic$interconnects$list$interconnect$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/cf_interconnects/\${params.parameter.tunnel_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update interconnect
     * Updates a specific interconnect associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$interconnects$update$interconnect(params: Params$magic$interconnects$update$interconnect, option?: RequestOption): Promise<Response$magic$interconnects$update$interconnect$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/cf_interconnects/\${params.parameter.tunnel_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List GRE tunnels
     * Lists GRE tunnels associated with an account.
     */
    public async magic$gre$tunnels$list$gre$tunnels(params: Params$magic$gre$tunnels$list$gre$tunnels, option?: RequestOption): Promise<Response$magic$gre$tunnels$list$gre$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/gre_tunnels\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update multiple GRE tunnels
     * Updates multiple GRE tunnels. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$gre$tunnels$update$multiple$gre$tunnels(params: Params$magic$gre$tunnels$update$multiple$gre$tunnels, option?: RequestOption): Promise<Response$magic$gre$tunnels$update$multiple$gre$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/gre_tunnels\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create GRE tunnels
     * Creates new GRE tunnels. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$gre$tunnels$create$gre$tunnels(params: Params$magic$gre$tunnels$create$gre$tunnels, option?: RequestOption): Promise<Response$magic$gre$tunnels$create$gre$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/gre_tunnels\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List GRE Tunnel Details
     * Lists informtion for a specific GRE tunnel.
     */
    public async magic$gre$tunnels$list$gre$tunnel$details(params: Params$magic$gre$tunnels$list$gre$tunnel$details, option?: RequestOption): Promise<Response$magic$gre$tunnels$list$gre$tunnel$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/gre_tunnels/\${params.parameter.tunnel_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update GRE Tunnel
     * Updates a specific GRE tunnel. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$gre$tunnels$update$gre$tunnel(params: Params$magic$gre$tunnels$update$gre$tunnel, option?: RequestOption): Promise<Response$magic$gre$tunnels$update$gre$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/gre_tunnels/\${params.parameter.tunnel_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete GRE Tunnel
     * Disables and removes a specific static GRE tunnel. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$gre$tunnels$delete$gre$tunnel(params: Params$magic$gre$tunnels$delete$gre$tunnel, option?: RequestOption): Promise<Response$magic$gre$tunnels$delete$gre$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/gre_tunnels/\${params.parameter.tunnel_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List IPsec tunnels
     * Lists IPsec tunnels associated with an account.
     */
    public async magic$ipsec$tunnels$list$ipsec$tunnels(params: Params$magic$ipsec$tunnels$list$ipsec$tunnels, option?: RequestOption): Promise<Response$magic$ipsec$tunnels$list$ipsec$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/ipsec_tunnels\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update multiple IPsec tunnels
     * Update multiple IPsec tunnels associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$ipsec$tunnels$update$multiple$ipsec$tunnels(params: Params$magic$ipsec$tunnels$update$multiple$ipsec$tunnels, option?: RequestOption): Promise<Response$magic$ipsec$tunnels$update$multiple$ipsec$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/ipsec_tunnels\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create IPsec tunnels
     * Creates new IPsec tunnels associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$ipsec$tunnels$create$ipsec$tunnels(params: Params$magic$ipsec$tunnels$create$ipsec$tunnels, option?: RequestOption): Promise<Response$magic$ipsec$tunnels$create$ipsec$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/ipsec_tunnels\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List IPsec tunnel details
     * Lists details for a specific IPsec tunnel.
     */
    public async magic$ipsec$tunnels$list$ipsec$tunnel$details(params: Params$magic$ipsec$tunnels$list$ipsec$tunnel$details, option?: RequestOption): Promise<Response$magic$ipsec$tunnels$list$ipsec$tunnel$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/ipsec_tunnels/\${params.parameter.tunnel_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update IPsec Tunnel
     * Updates a specific IPsec tunnel associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$ipsec$tunnels$update$ipsec$tunnel(params: Params$magic$ipsec$tunnels$update$ipsec$tunnel, option?: RequestOption): Promise<Response$magic$ipsec$tunnels$update$ipsec$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/ipsec_tunnels/\${params.parameter.tunnel_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete IPsec Tunnel
     * Disables and removes a specific static IPsec Tunnel associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes.
     */
    public async magic$ipsec$tunnels$delete$ipsec$tunnel(params: Params$magic$ipsec$tunnels$delete$ipsec$tunnel, option?: RequestOption): Promise<Response$magic$ipsec$tunnels$delete$ipsec$tunnel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/ipsec_tunnels/\${params.parameter.tunnel_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Generate Pre Shared Key (PSK) for IPsec tunnels
     * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a safe place.
     */
    public async magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels(params: Params$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels, option?: RequestOption): Promise<Response$magic$ipsec$tunnels$generate$pre$shared$key$$$psk$$for$ipsec$tunnels$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/ipsec_tunnels/\${params.parameter.tunnel_identifier}/psk_generate\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * List Routes
     * List all Magic static routes.
     */
    public async magic$static$routes$list$routes(params: Params$magic$static$routes$list$routes, option?: RequestOption): Promise<Response$magic$static$routes$list$routes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/routes\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Many Routes
     * Update multiple Magic static routes. Use \`?validate_only=true\` as an optional query parameter to run validation only without persisting changes. Only fields for a route that need to be changed need be provided.
     */
    public async magic$static$routes$update$many$routes(params: Params$magic$static$routes$update$many$routes, option?: RequestOption): Promise<Response$magic$static$routes$update$many$routes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/routes\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create Routes
     * Creates a new Magic static route. Use \`?validate_only=true\` as an optional query parameter to run validation only without persisting changes.
     */
    public async magic$static$routes$create$routes(params: Params$magic$static$routes$create$routes, option?: RequestOption): Promise<Response$magic$static$routes$create$routes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/routes\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Many Routes
     * Delete multiple Magic static routes.
     */
    public async magic$static$routes$delete$many$routes(params: Params$magic$static$routes$delete$many$routes, option?: RequestOption): Promise<Response$magic$static$routes$delete$many$routes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/routes\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Route Details
     * Get a specific Magic static route.
     */
    public async magic$static$routes$route$details(params: Params$magic$static$routes$route$details, option?: RequestOption): Promise<Response$magic$static$routes$route$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/routes/\${params.parameter.route_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Route
     * Update a specific Magic static route. Use \`?validate_only=true\` as an optional query parameter to run validation only without persisting changes.
     */
    public async magic$static$routes$update$route(params: Params$magic$static$routes$update$route, option?: RequestOption): Promise<Response$magic$static$routes$update$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/routes/\${params.parameter.route_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Route
     * Disable and remove a specific Magic static route.
     */
    public async magic$static$routes$delete$route(params: Params$magic$static$routes$delete$route, option?: RequestOption): Promise<Response$magic$static$routes$delete$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/magic/routes/\${params.parameter.route_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Members
     * List all members of an account.
     */
    public async account$members$list$members(params: Params$account$members$list$members, option?: RequestOption): Promise<Response$account$members$list$members$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/members\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            order: { value: params.parameter.order, explode: false },
            status: { value: params.parameter.status, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Add Member
     * Add a user to the list of members for this account.
     */
    public async account$members$add$member(params: Params$account$members$add$member, option?: RequestOption): Promise<Response$account$members$add$member$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/members\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Member Details
     * Get information about a specific member of an account.
     */
    public async account$members$member$details(params: Params$account$members$member$details, option?: RequestOption): Promise<Response$account$members$member$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/members/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Member
     * Modify an account member.
     */
    public async account$members$update$member(params: Params$account$members$update$member, option?: RequestOption): Promise<Response$account$members$update$member$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/members/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Remove Member
     * Remove a member from an account.
     */
    public async account$members$remove$member(params: Params$account$members$remove$member, option?: RequestOption): Promise<Response$account$members$remove$member$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/members/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List account configuration
     * Lists default sampling and router IPs for account.
     */
    public async magic$network$monitoring$configuration$list$account$configuration(params: Params$magic$network$monitoring$configuration$list$account$configuration, option?: RequestOption): Promise<Response$magic$network$monitoring$configuration$list$account$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/config\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an entire account configuration
     * Update an existing network monitoring configuration, requires the entire configuration to be updated at once.
     */
    public async magic$network$monitoring$configuration$update$an$entire$account$configuration(params: Params$magic$network$monitoring$configuration$update$an$entire$account$configuration, option?: RequestOption): Promise<Response$magic$network$monitoring$configuration$update$an$entire$account$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/config\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers
        }, option);
    }
    /**
     * Create account configuration
     * Create a new network monitoring configuration.
     */
    public async magic$network$monitoring$configuration$create$account$configuration(params: Params$magic$network$monitoring$configuration$create$account$configuration, option?: RequestOption): Promise<Response$magic$network$monitoring$configuration$create$account$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/config\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Delete account configuration
     * Delete an existing network monitoring configuration.
     */
    public async magic$network$monitoring$configuration$delete$account$configuration(params: Params$magic$network$monitoring$configuration$delete$account$configuration, option?: RequestOption): Promise<Response$magic$network$monitoring$configuration$delete$account$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/config\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update account configuration fields
     * Update fields in an existing network monitoring configuration.
     */
    public async magic$network$monitoring$configuration$update$account$configuration$fields(params: Params$magic$network$monitoring$configuration$update$account$configuration$fields, option?: RequestOption): Promise<Response$magic$network$monitoring$configuration$update$account$configuration$fields$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/config\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers
        }, option);
    }
    /**
     * List rules and account configuration
     * Lists default sampling, router IPs, and rules for account.
     */
    public async magic$network$monitoring$configuration$list$rules$and$account$configuration(params: Params$magic$network$monitoring$configuration$list$rules$and$account$configuration, option?: RequestOption): Promise<Response$magic$network$monitoring$configuration$list$rules$and$account$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/config/full\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List rules
     * Lists network monitoring rules for account.
     */
    public async magic$network$monitoring$rules$list$rules(params: Params$magic$network$monitoring$rules$list$rules, option?: RequestOption): Promise<Response$magic$network$monitoring$rules$list$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/rules\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update rules
     * Update network monitoring rules for account.
     */
    public async magic$network$monitoring$rules$update$rules(params: Params$magic$network$monitoring$rules$update$rules, option?: RequestOption): Promise<Response$magic$network$monitoring$rules$update$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/rules\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers
        }, option);
    }
    /**
     * Create rules
     * Create network monitoring rules for account. Currently only supports creating a single rule per API request.
     */
    public async magic$network$monitoring$rules$create$rules(params: Params$magic$network$monitoring$rules$create$rules, option?: RequestOption): Promise<Response$magic$network$monitoring$rules$create$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/rules\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Get rule
     * List a single network monitoring rule for account.
     */
    public async magic$network$monitoring$rules$get$rule(params: Params$magic$network$monitoring$rules$get$rule, option?: RequestOption): Promise<Response$magic$network$monitoring$rules$get$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/rules/\${params.parameter.rule_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete rule
     * Delete a network monitoring rule for account.
     */
    public async magic$network$monitoring$rules$delete$rule(params: Params$magic$network$monitoring$rules$delete$rule, option?: RequestOption): Promise<Response$magic$network$monitoring$rules$delete$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/rules/\${params.parameter.rule_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update rule
     * Update a network monitoring rule for account.
     */
    public async magic$network$monitoring$rules$update$rule(params: Params$magic$network$monitoring$rules$update$rule, option?: RequestOption): Promise<Response$magic$network$monitoring$rules$update$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/rules/\${params.parameter.rule_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers
        }, option);
    }
    /**
     * Update advertisement for rule
     * Update advertisement for rule.
     */
    public async magic$network$monitoring$rules$update$advertisement$for$rule(params: Params$magic$network$monitoring$rules$update$advertisement$for$rule, option?: RequestOption): Promise<Response$magic$network$monitoring$rules$update$advertisement$for$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mnm/rules/\${params.parameter.rule_identifier}/advertisement\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers
        }, option);
    }
    /**
     * List mTLS certificates
     * Lists all mTLS certificates.
     */
    public async m$tls$certificate$management$list$m$tls$certificates(params: Params$m$tls$certificate$management$list$m$tls$certificates, option?: RequestOption): Promise<Response$m$tls$certificate$management$list$m$tls$certificates$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mtls_certificates\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Upload mTLS certificate
     * Upload a certificate that you want to use with mTLS-enabled Cloudflare services.
     */
    public async m$tls$certificate$management$upload$m$tls$certificate(params: Params$m$tls$certificate$management$upload$m$tls$certificate, option?: RequestOption): Promise<Response$m$tls$certificate$management$upload$m$tls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mtls_certificates\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get mTLS certificate
     * Fetches a single mTLS certificate.
     */
    public async m$tls$certificate$management$get$m$tls$certificate(params: Params$m$tls$certificate$management$get$m$tls$certificate, option?: RequestOption): Promise<Response$m$tls$certificate$management$get$m$tls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mtls_certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete mTLS certificate
     * Deletes the mTLS certificate unless the certificate is in use by one or more Cloudflare services.
     */
    public async m$tls$certificate$management$delete$m$tls$certificate(params: Params$m$tls$certificate$management$delete$m$tls$certificate, option?: RequestOption): Promise<Response$m$tls$certificate$management$delete$m$tls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mtls_certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List mTLS certificate associations
     * Lists all active associations between the certificate and Cloudflare services.
     */
    public async m$tls$certificate$management$list$m$tls$certificate$associations(params: Params$m$tls$certificate$management$list$m$tls$certificate$associations, option?: RequestOption): Promise<Response$m$tls$certificate$management$list$m$tls$certificate$associations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/mtls_certificates/\${params.parameter.identifier}/associations\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List packet capture requests
     * Lists all packet capture requests for an account.
     */
    public async magic$pcap$collection$list$packet$capture$requests(params: Params$magic$pcap$collection$list$packet$capture$requests, option?: RequestOption): Promise<Response$magic$pcap$collection$list$packet$capture$requests$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/pcaps\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create PCAP request
     * Create new PCAP request for account.
     */
    public async magic$pcap$collection$create$pcap$request(params: Params$magic$pcap$collection$create$pcap$request, option?: RequestOption): Promise<Response$magic$pcap$collection$create$pcap$request$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/pcaps\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get PCAP request
     * Get information for a PCAP request by id.
     */
    public async magic$pcap$collection$get$pcap$request(params: Params$magic$pcap$collection$get$pcap$request, option?: RequestOption): Promise<Response$magic$pcap$collection$get$pcap$request$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/pcaps/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Download Simple PCAP
     * Download PCAP information into a file. Response is a binary PCAP file.
     */
    public async magic$pcap$collection$download$simple$pcap(params: Params$magic$pcap$collection$download$simple$pcap, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/pcaps/\${params.parameter.identifier}/download\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List PCAPs Bucket Ownership
     * List all buckets configured for use with PCAPs API.
     */
    public async magic$pcap$collection$list$pca$ps$bucket$ownership(params: Params$magic$pcap$collection$list$pca$ps$bucket$ownership, option?: RequestOption): Promise<Response$magic$pcap$collection$list$pca$ps$bucket$ownership$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/pcaps/ownership\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add buckets for full packet captures
     * Adds an AWS or GCP bucket to use with full packet captures.
     */
    public async magic$pcap$collection$add$buckets$for$full$packet$captures(params: Params$magic$pcap$collection$add$buckets$for$full$packet$captures, option?: RequestOption): Promise<Response$magic$pcap$collection$add$buckets$for$full$packet$captures$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/pcaps/ownership\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete buckets for full packet captures
     * Deletes buckets added to the packet captures API.
     */
    public async magic$pcap$collection$delete$buckets$for$full$packet$captures(params: Params$magic$pcap$collection$delete$buckets$for$full$packet$captures, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/pcaps/ownership/\${params.parameter.identifier}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Validate buckets for full packet captures
     * Validates buckets added to the packet captures API.
     */
    public async magic$pcap$collection$validate$buckets$for$full$packet$captures(params: Params$magic$pcap$collection$validate$buckets$for$full$packet$captures, option?: RequestOption): Promise<Response$magic$pcap$collection$validate$buckets$for$full$packet$captures$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/pcaps/ownership/validate\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Request Trace */
    public async account$request$tracer$request$trace(params: Params$account$request$tracer$request$trace, option?: RequestOption): Promise<Response$account$request$tracer$request$trace$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/request-tracer/trace\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Roles
     * Get all available roles for an account.
     */
    public async account$roles$list$roles(params: Params$account$roles$list$roles, option?: RequestOption): Promise<Response$account$roles$list$roles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/roles\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Role Details
     * Get information about a specific role for an account.
     */
    public async account$roles$role$details(params: Params$account$roles$role$details, option?: RequestOption): Promise<Response$account$roles$role$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/roles/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get a list item
     * Fetches a list item in the list.
     */
    public async lists$get$a$list$item(params: Params$lists$get$a$list$item, option?: RequestOption): Promise<Response$lists$get$a$list$item$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rules/lists/\${params.parameter.list_id}/items/\${params.parameter.item_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get bulk operation status
     * Gets the current status of an asynchronous operation on a list.
     *
     * The \`status\` property can have one of the following values: \`pending\`, \`running\`, \`completed\`, or \`failed\`. If the status is \`failed\`, the \`error\` property will contain a message describing the error.
     */
    public async lists$get$bulk$operation$status(params: Params$lists$get$bulk$operation$status, option?: RequestOption): Promise<Response$lists$get$bulk$operation$status$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rules/lists/bulk_operations/\${params.parameter.operation_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a Web Analytics site
     * Creates a new Web Analytics site.
     */
    public async web$analytics$create$site(params: Params$web$analytics$create$site, option?: RequestOption): Promise<Response$web$analytics$create$site$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/site_info\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Web Analytics site
     * Retrieves a Web Analytics site.
     */
    public async web$analytics$get$site(params: Params$web$analytics$get$site, option?: RequestOption): Promise<Response$web$analytics$get$site$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/site_info/\${params.parameter.site_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a Web Analytics site
     * Updates an existing Web Analytics site.
     */
    public async web$analytics$update$site(params: Params$web$analytics$update$site, option?: RequestOption): Promise<Response$web$analytics$update$site$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/site_info/\${params.parameter.site_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Web Analytics site
     * Deletes an existing Web Analytics site.
     */
    public async web$analytics$delete$site(params: Params$web$analytics$delete$site, option?: RequestOption): Promise<Response$web$analytics$delete$site$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/site_info/\${params.parameter.site_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Web Analytics sites
     * Lists all Web Analytics sites of an account.
     */
    public async web$analytics$list$sites(params: Params$web$analytics$list$sites, option?: RequestOption): Promise<Response$web$analytics$list$sites$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/site_info/list\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            per_page: { value: params.parameter.per_page, explode: false },
            page: { value: params.parameter.page, explode: false },
            order_by: { value: params.parameter.order_by, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a Web Analytics rule
     * Creates a new rule in a Web Analytics ruleset.
     */
    public async web$analytics$create$rule(params: Params$web$analytics$create$rule, option?: RequestOption): Promise<Response$web$analytics$create$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/v2/\${params.parameter.ruleset_identifier}/rule\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update a Web Analytics rule
     * Updates a rule in a Web Analytics ruleset.
     */
    public async web$analytics$update$rule(params: Params$web$analytics$update$rule, option?: RequestOption): Promise<Response$web$analytics$update$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/v2/\${params.parameter.ruleset_identifier}/rule/\${params.parameter.rule_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Web Analytics rule
     * Deletes an existing rule from a Web Analytics ruleset.
     */
    public async web$analytics$delete$rule(params: Params$web$analytics$delete$rule, option?: RequestOption): Promise<Response$web$analytics$delete$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/v2/\${params.parameter.ruleset_identifier}/rule/\${params.parameter.rule_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List rules in Web Analytics ruleset
     * Lists all the rules in a Web Analytics ruleset.
     */
    public async web$analytics$list$rules(params: Params$web$analytics$list$rules, option?: RequestOption): Promise<Response$web$analytics$list$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/v2/\${params.parameter.ruleset_identifier}/rules\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Web Analytics rules
     * Modifies one or more rules in a Web Analytics ruleset with a single request.
     */
    public async web$analytics$modify$rules(params: Params$web$analytics$modify$rules, option?: RequestOption): Promise<Response$web$analytics$modify$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/rum/v2/\${params.parameter.ruleset_identifier}/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List ACLs
     * List ACLs.
     */
    public async secondary$dns$$$acl$$list$ac$ls(params: Params$secondary$dns$$$acl$$list$ac$ls, option?: RequestOption): Promise<Response$secondary$dns$$$acl$$list$ac$ls$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/acls\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create ACL
     * Create ACL.
     */
    public async secondary$dns$$$acl$$create$acl(params: Params$secondary$dns$$$acl$$create$acl, option?: RequestOption): Promise<Response$secondary$dns$$$acl$$create$acl$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/acls\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * ACL Details
     * Get ACL.
     */
    public async secondary$dns$$$acl$$acl$details(params: Params$secondary$dns$$$acl$$acl$details, option?: RequestOption): Promise<Response$secondary$dns$$$acl$$acl$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/acls/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update ACL
     * Modify ACL.
     */
    public async secondary$dns$$$acl$$update$acl(params: Params$secondary$dns$$$acl$$update$acl, option?: RequestOption): Promise<Response$secondary$dns$$$acl$$update$acl$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/acls/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete ACL
     * Delete ACL.
     */
    public async secondary$dns$$$acl$$delete$acl(params: Params$secondary$dns$$$acl$$delete$acl, option?: RequestOption): Promise<Response$secondary$dns$$$acl$$delete$acl$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/acls/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Peers
     * List Peers.
     */
    public async secondary$dns$$$peer$$list$peers(params: Params$secondary$dns$$$peer$$list$peers, option?: RequestOption): Promise<Response$secondary$dns$$$peer$$list$peers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/peers\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Peer
     * Create Peer.
     */
    public async secondary$dns$$$peer$$create$peer(params: Params$secondary$dns$$$peer$$create$peer, option?: RequestOption): Promise<Response$secondary$dns$$$peer$$create$peer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/peers\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Peer Details
     * Get Peer.
     */
    public async secondary$dns$$$peer$$peer$details(params: Params$secondary$dns$$$peer$$peer$details, option?: RequestOption): Promise<Response$secondary$dns$$$peer$$peer$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/peers/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Peer
     * Modify Peer.
     */
    public async secondary$dns$$$peer$$update$peer(params: Params$secondary$dns$$$peer$$update$peer, option?: RequestOption): Promise<Response$secondary$dns$$$peer$$update$peer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/peers/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Peer
     * Delete Peer.
     */
    public async secondary$dns$$$peer$$delete$peer(params: Params$secondary$dns$$$peer$$delete$peer, option?: RequestOption): Promise<Response$secondary$dns$$$peer$$delete$peer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/peers/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List TSIGs
     * List TSIGs.
     */
    public async secondary$dns$$$tsig$$list$tsi$gs(params: Params$secondary$dns$$$tsig$$list$tsi$gs, option?: RequestOption): Promise<Response$secondary$dns$$$tsig$$list$tsi$gs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/tsigs\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create TSIG
     * Create TSIG.
     */
    public async secondary$dns$$$tsig$$create$tsig(params: Params$secondary$dns$$$tsig$$create$tsig, option?: RequestOption): Promise<Response$secondary$dns$$$tsig$$create$tsig$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/tsigs\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * TSIG Details
     * Get TSIG.
     */
    public async secondary$dns$$$tsig$$tsig$details(params: Params$secondary$dns$$$tsig$$tsig$details, option?: RequestOption): Promise<Response$secondary$dns$$$tsig$$tsig$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/tsigs/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update TSIG
     * Modify TSIG.
     */
    public async secondary$dns$$$tsig$$update$tsig(params: Params$secondary$dns$$$tsig$$update$tsig, option?: RequestOption): Promise<Response$secondary$dns$$$tsig$$update$tsig$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/tsigs/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete TSIG
     * Delete TSIG.
     */
    public async secondary$dns$$$tsig$$delete$tsig(params: Params$secondary$dns$$$tsig$$delete$tsig, option?: RequestOption): Promise<Response$secondary$dns$$$tsig$$delete$tsig$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/secondary_dns/tsigs/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Query Request Analytics
     * Retrieves Workers KV request metrics for the given account.
     */
    public async workers$kv$request$analytics$query$request$analytics(params: Params$workers$kv$request$analytics$query$request$analytics, option?: RequestOption): Promise<Response$workers$kv$request$analytics$query$request$analytics$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/analytics\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Query Stored Data Analytics
     * Retrieves Workers KV stored data metrics for the given account.
     */
    public async workers$kv$stored$data$analytics$query$stored$data$analytics(params: Params$workers$kv$stored$data$analytics$query$stored$data$analytics, option?: RequestOption): Promise<Response$workers$kv$stored$data$analytics$query$stored$data$analytics$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/analytics/stored\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Namespaces
     * Returns the namespaces owned by an account.
     */
    public async workers$kv$namespace$list$namespaces(params: Params$workers$kv$namespace$list$namespaces, option?: RequestOption): Promise<Response$workers$kv$namespace$list$namespaces$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a Namespace
     * Creates a namespace under the given title. A \`400\` is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.
     */
    public async workers$kv$namespace$create$a$namespace(params: Params$workers$kv$namespace$create$a$namespace, option?: RequestOption): Promise<Response$workers$kv$namespace$create$a$namespace$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Rename a Namespace
     * Modifies a namespace's title.
     */
    public async workers$kv$namespace$rename$a$namespace(params: Params$workers$kv$namespace$rename$a$namespace, option?: RequestOption): Promise<Response$workers$kv$namespace$rename$a$namespace$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Remove a Namespace
     * Deletes the namespace corresponding to the given ID.
     */
    public async workers$kv$namespace$remove$a$namespace(params: Params$workers$kv$namespace$remove$a$namespace, option?: RequestOption): Promise<Response$workers$kv$namespace$remove$a$namespace$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Write multiple key-value pairs
     * Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither \`expiration\` nor \`expiration_ttl\` is specified, the key-value pair will never expire. If both are set, \`expiration_ttl\` is used and \`expiration\` is ignored. The entire request size must be 100 megabytes or less.
     */
    public async workers$kv$namespace$write$multiple$key$value$pairs(params: Params$workers$kv$namespace$write$multiple$key$value$pairs, option?: RequestOption): Promise<Response$workers$kv$namespace$write$multiple$key$value$pairs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}/bulk\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete multiple key-value pairs
     * Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
     */
    public async workers$kv$namespace$delete$multiple$key$value$pairs(params: Params$workers$kv$namespace$delete$multiple$key$value$pairs, option?: RequestOption): Promise<Response$workers$kv$namespace$delete$multiple$key$value$pairs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}/bulk\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List a Namespace's Keys
     * Lists a namespace's keys.
     */
    public async workers$kv$namespace$list$a$namespace$$s$keys(params: Params$workers$kv$namespace$list$a$namespace$$s$keys, option?: RequestOption): Promise<Response$workers$kv$namespace$list$a$namespace$$s$keys$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}/keys\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            prefix: { value: params.parameter.prefix, explode: false },
            cursor: { value: params.parameter.cursor, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Read the metadata for a key
     * Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, \`:\`, \`!\`, \`%\`) in the key name.
     */
    public async workers$kv$namespace$read$the$metadata$for$a$key(params: Params$workers$kv$namespace$read$the$metadata$for$a$key, option?: RequestOption): Promise<Response$workers$kv$namespace$read$the$metadata$for$a$key$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}/metadata/\${params.parameter.key_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Read key-value pair
     * Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, \`:\`, \`!\`, \`%\`) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the \`expiration\` response header.
     */
    public async workers$kv$namespace$read$key$value$pair(params: Params$workers$kv$namespace$read$key$value$pair, option?: RequestOption): Promise<Response$workers$kv$namespace$read$key$value$pair$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}/values/\${params.parameter.key_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Write key-value pair with metadata
     * Write a value identified by a key. Use URL-encoding to use special characters (for example, \`:\`, \`!\`, \`%\`) in the key name. Body should be the value to be stored along with JSON metadata to be associated with the key/value pair. Existing values, expirations, and metadata will be overwritten. If neither \`expiration\` nor \`expiration_ttl\` is specified, the key-value pair will never expire. If both are set, \`expiration_ttl\` is used and \`expiration\` is ignored.
     */
    public async workers$kv$namespace$write$key$value$pair$with$metadata(params: Params$workers$kv$namespace$write$key$value$pair$with$metadata, option?: RequestOption): Promise<Response$workers$kv$namespace$write$key$value$pair$with$metadata$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}/values/\${params.parameter.key_name}\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete key-value pair
     * Remove a KV pair from the namespace. Use URL-encoding to use special characters (for example, \`:\`, \`!\`, \`%\`) in the key name.
     */
    public async workers$kv$namespace$delete$key$value$pair(params: Params$workers$kv$namespace$delete$key$value$pair, option?: RequestOption): Promise<Response$workers$kv$namespace$delete$key$value$pair$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/storage/kv/namespaces/\${params.parameter.namespace_identifier}/values/\${params.parameter.key_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Subscriptions
     * Lists all of an account's subscriptions.
     */
    public async account$subscriptions$list$subscriptions(params: Params$account$subscriptions$list$subscriptions, option?: RequestOption): Promise<Response$account$subscriptions$list$subscriptions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/subscriptions\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Subscription
     * Creates an account subscription.
     */
    public async account$subscriptions$create$subscription(params: Params$account$subscriptions$create$subscription, option?: RequestOption): Promise<Response$account$subscriptions$create$subscription$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/subscriptions\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update Subscription
     * Updates an account subscription.
     */
    public async account$subscriptions$update$subscription(params: Params$account$subscriptions$update$subscription, option?: RequestOption): Promise<Response$account$subscriptions$update$subscription$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/subscriptions/\${params.parameter.subscription_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Subscription
     * Deletes an account's subscription.
     */
    public async account$subscriptions$delete$subscription(params: Params$account$subscriptions$delete$subscription, option?: RequestOption): Promise<Response$account$subscriptions$delete$subscription$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/subscriptions/\${params.parameter.subscription_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Vectorize Indexes
     * Returns a list of Vectorize Indexes
     */
    public async vectorize$list$vectorize$indexes(params: Params$vectorize$list$vectorize$indexes, option?: RequestOption): Promise<Response$vectorize$list$vectorize$indexes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Vectorize Index
     * Creates and returns a new Vectorize Index.
     */
    public async vectorize$create$vectorize$index(params: Params$vectorize$create$vectorize$index, option?: RequestOption): Promise<Response$vectorize$create$vectorize$index$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Vectorize Index
     * Returns the specified Vectorize Index.
     */
    public async vectorize$get$vectorize$index(params: Params$vectorize$get$vectorize$index, option?: RequestOption): Promise<Response$vectorize$get$vectorize$index$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes/\${params.parameter.index_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Vectorize Index
     * Updates and returns the specified Vectorize Index.
     */
    public async vectorize$update$vectorize$index(params: Params$vectorize$update$vectorize$index, option?: RequestOption): Promise<Response$vectorize$update$vectorize$index$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes/\${params.parameter.index_name}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Vectorize Index
     * Deletes the specified Vectorize Index.
     */
    public async vectorize$delete$vectorize$index(params: Params$vectorize$delete$vectorize$index, option?: RequestOption): Promise<Response$vectorize$delete$vectorize$index$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes/\${params.parameter.index_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Delete Vectors By Identifier
     * Delete a set of vectors from an index by their vector identifiers.
     */
    public async vectorize$delete$vectors$by$id(params: Params$vectorize$delete$vectors$by$id, option?: RequestOption): Promise<Response$vectorize$delete$vectors$by$id$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes/\${params.parameter.index_name}/delete-by-ids\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Vectors By Identifier
     * Get a set of vectors from an index by their vector identifiers.
     */
    public async vectorize$get$vectors$by$id(params: Params$vectorize$get$vectors$by$id, option?: RequestOption): Promise<Response$vectorize$get$vectors$by$id$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes/\${params.parameter.index_name}/get-by-ids\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Insert Vectors
     * Inserts vectors into the specified index and returns the count of the vectors successfully inserted.
     */
    public async vectorize$insert$vector(params: Params$vectorize$insert$vector, option?: RequestOption): Promise<Response$vectorize$insert$vector$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes/\${params.parameter.index_name}/insert\`;
        const headers = {
            "Content-Type": "application/x-ndjson",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Query Vectors
     * Finds vectors closest to a given vector in an index.
     */
    public async vectorize$query$vector(params: Params$vectorize$query$vector, option?: RequestOption): Promise<Response$vectorize$query$vector$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes/\${params.parameter.index_name}/query\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Upsert Vectors
     * Upserts vectors into the specified index, creating them if they do not exist and returns the count of values and ids successfully inserted.
     */
    public async vectorize$upsert$vector(params: Params$vectorize$upsert$vector, option?: RequestOption): Promise<Response$vectorize$upsert$vector$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier}/vectorize/indexes/\${params.parameter.index_name}/upsert\`;
        const headers = {
            "Content-Type": "application/x-ndjson",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Add an account membership to an Address Map
     * Add an account as a member of a particular address map.
     */
    public async ip$address$management$address$maps$add$an$account$membership$to$an$address$map(params: Params$ip$address$management$address$maps$add$an$account$membership$to$an$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$add$an$account$membership$to$an$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier1}/addressing/address_maps/\${params.parameter.address_map_identifier}/accounts/\${params.parameter.account_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers
        }, option);
    }
    /**
     * Remove an account membership from an Address Map
     * Remove an account as a member of a particular address map.
     */
    public async ip$address$management$address$maps$remove$an$account$membership$from$an$address$map(params: Params$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map, option?: RequestOption): Promise<Response$ip$address$management$address$maps$remove$an$account$membership$from$an$address$map$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.account_identifier1}/addressing/address_maps/\${params.parameter.address_map_identifier}/accounts/\${params.parameter.account_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Search URL scans
     * Search scans by date and webpages' requests, including full URL (after redirects), hostname, and path. <br/> A successful scan will appear in search results a few minutes after finishing but may take much longer if the system in under load. By default, only successfully completed scans will appear in search results, unless searching by \`scanId\`. Please take into account that older scans may be removed from the search index at an unspecified time.
     */
    public async urlscanner$search$scans(params: Params$urlscanner$search$scans, option?: RequestOption): Promise<Response$urlscanner$search$scans$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.accountId}/urlscanner/scan\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            scanId: { value: params.parameter.scanId, explode: false },
            limit: { value: params.parameter.limit, explode: false },
            next_cursor: { value: params.parameter.next_cursor, explode: false },
            date_start: { value: params.parameter.date_start, explode: false },
            date_end: { value: params.parameter.date_end, explode: false },
            url: { value: params.parameter.url, explode: false },
            hostname: { value: params.parameter.hostname, explode: false },
            path: { value: params.parameter.path, explode: false },
            page_url: { value: params.parameter.page_url, explode: false },
            page_hostname: { value: params.parameter.page_hostname, explode: false },
            page_path: { value: params.parameter.page_path, explode: false },
            account_scans: { value: params.parameter.account_scans, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create URL Scan
     * Submit a URL to scan. You can also set some options, like the visibility level and custom headers. Accounts are limited to 1 new scan every 10 seconds and 8000 per month. If you need more, please reach out.
     */
    public async urlscanner$create$scan(params: Params$urlscanner$create$scan, option?: RequestOption): Promise<Response$urlscanner$create$scan$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.accountId}/urlscanner/scan\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get URL scan
     * Get URL scan by uuid
     */
    public async urlscanner$get$scan(params: Params$urlscanner$get$scan, option?: RequestOption): Promise<(Response$urlscanner$get$scan$Status$200 | Response$urlscanner$get$scan$Status$202)["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.accountId}/urlscanner/scan/\${params.parameter.scanId}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get URL scan's HAR
     * Get a URL scan's HAR file. See HAR spec at http://www.softwareishard.com/blog/har-12-spec/.
     */
    public async urlscanner$get$scan$har(params: Params$urlscanner$get$scan$har, option?: RequestOption): Promise<(Response$urlscanner$get$scan$har$Status$200 | Response$urlscanner$get$scan$har$Status$202)["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.accountId}/urlscanner/scan/\${params.parameter.scanId}/har\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get screenshot
     * Get scan's screenshot by resolution (desktop/mobile/tablet).
     */
    public async urlscanner$get$scan$screenshot<ResponseContentType extends ResponseContentType$urlscanner$get$scan$screenshot>(params: Params$urlscanner$get$scan$screenshot<ResponseContentType>, option?: RequestOption): Promise<(Response$urlscanner$get$scan$screenshot$Status$200 | Response$urlscanner$get$scan$screenshot$Status$202)[ResponseContentType]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.accountId}/urlscanner/scan/\${params.parameter.scanId}/screenshot\`;
        const headers = {
            Accept: params.headers.Accept
        };
        const queryParameters: QueryParameters = {
            resolution: { value: params.parameter.resolution, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Account Details
     * Get information about a specific account that you are a member of.
     */
    public async accounts$account$details(params: Params$accounts$account$details, option?: RequestOption): Promise<Response$accounts$account$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Account
     * Update an existing account.
     */
    public async accounts$update$account(params: Params$accounts$update$account, option?: RequestOption): Promise<Response$accounts$update$account$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Access applications
     * Lists all Access applications in an account.
     */
    public async access$applications$list$access$applications(params: Params$access$applications$list$access$applications, option?: RequestOption): Promise<Response$access$applications$list$access$applications$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add an Access Application
     * Adds a new application to Access.
     */
    public async access$applications$add$an$application(params: Params$access$applications$add$an$application, option?: RequestOption): Promise<Response$access$applications$add$an$application$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an Access application
     * Fetches information about an Access application.
     */
    public async access$applications$get$an$access$application(params: Params$access$applications$get$an$access$application, option?: RequestOption): Promise<Response$access$applications$get$an$access$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an Access application
     * Updates an Access application.
     */
    public async access$applications$update$a$bookmark$application(params: Params$access$applications$update$a$bookmark$application, option?: RequestOption): Promise<Response$access$applications$update$a$bookmark$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an Access application
     * Deletes an application from Access.
     */
    public async access$applications$delete$an$access$application(params: Params$access$applications$delete$an$access$application, option?: RequestOption): Promise<Response$access$applications$delete$an$access$application$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Revoke application tokens
     * Revokes all tokens issued for an application.
     */
    public async access$applications$revoke$service$tokens(params: Params$access$applications$revoke$service$tokens, option?: RequestOption): Promise<Response$access$applications$revoke$service$tokens$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}/revoke_tokens\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Test Access policies
     * Tests if a specific user has permission to access an application.
     */
    public async access$applications$test$access$policies(params: Params$access$applications$test$access$policies, option?: RequestOption): Promise<Response$access$applications$test$access$policies$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}/user_policy_checks\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get a short-lived certificate CA
     * Fetches a short-lived certificate CA and its public key.
     */
    public async access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca(params: Params$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca, option?: RequestOption): Promise<Response$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/ca\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a short-lived certificate CA
     * Generates a new short-lived certificate CA and public key.
     */
    public async access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca(params: Params$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca, option?: RequestOption): Promise<Response$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/ca\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Delete a short-lived certificate CA
     * Deletes a short-lived certificate CA.
     */
    public async access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca(params: Params$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca, option?: RequestOption): Promise<Response$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/ca\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Access policies
     * Lists Access policies configured for an application.
     */
    public async access$policies$list$access$policies(params: Params$access$policies$list$access$policies, option?: RequestOption): Promise<Response$access$policies$list$access$policies$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/policies\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create an Access policy
     * Create a new Access policy for an application.
     */
    public async access$policies$create$an$access$policy(params: Params$access$policies$create$an$access$policy, option?: RequestOption): Promise<Response$access$policies$create$an$access$policy$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/policies\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an Access policy
     * Fetches a single Access policy.
     */
    public async access$policies$get$an$access$policy(params: Params$access$policies$get$an$access$policy, option?: RequestOption): Promise<Response$access$policies$get$an$access$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid1}/policies/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an Access policy
     * Update a configured Access policy.
     */
    public async access$policies$update$an$access$policy(params: Params$access$policies$update$an$access$policy, option?: RequestOption): Promise<Response$access$policies$update$an$access$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid1}/policies/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an Access policy
     * Delete an Access policy.
     */
    public async access$policies$delete$an$access$policy(params: Params$access$policies$delete$an$access$policy, option?: RequestOption): Promise<Response$access$policies$delete$an$access$policy$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid1}/policies/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List short-lived certificate CAs
     * Lists short-lived certificate CAs and their public keys.
     */
    public async access$short$lived$certificate$c$as$list$short$lived$certificate$c$as(params: Params$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as, option?: RequestOption): Promise<Response$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/apps/ca\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * List Bookmark applications
     * Lists Bookmark applications.
     */
    public async access$bookmark$applications$$$deprecated$$list$bookmark$applications(params: Params$access$bookmark$applications$$$deprecated$$list$bookmark$applications, option?: RequestOption): Promise<Response$access$bookmark$applications$$$deprecated$$list$bookmark$applications$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/bookmarks\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Get a Bookmark application
     * Fetches a single Bookmark application.
     */
    public async access$bookmark$applications$$$deprecated$$get$a$bookmark$application(params: Params$access$bookmark$applications$$$deprecated$$get$a$bookmark$application, option?: RequestOption): Promise<Response$access$bookmark$applications$$$deprecated$$get$a$bookmark$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/bookmarks/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Update a Bookmark application
     * Updates a configured Bookmark application.
     */
    public async access$bookmark$applications$$$deprecated$$update$a$bookmark$application(params: Params$access$bookmark$applications$$$deprecated$$update$a$bookmark$application, option?: RequestOption): Promise<Response$access$bookmark$applications$$$deprecated$$update$a$bookmark$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/bookmarks/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Create a Bookmark application
     * Create a new Bookmark application.
     */
    public async access$bookmark$applications$$$deprecated$$create$a$bookmark$application(params: Params$access$bookmark$applications$$$deprecated$$create$a$bookmark$application, option?: RequestOption): Promise<Response$access$bookmark$applications$$$deprecated$$create$a$bookmark$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/bookmarks/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Delete a Bookmark application
     * Deletes a Bookmark application.
     */
    public async access$bookmark$applications$$$deprecated$$delete$a$bookmark$application(params: Params$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application, option?: RequestOption): Promise<Response$access$bookmark$applications$$$deprecated$$delete$a$bookmark$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/bookmarks/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List mTLS certificates
     * Lists all mTLS root certificates.
     */
    public async access$mtls$authentication$list$mtls$certificates(params: Params$access$mtls$authentication$list$mtls$certificates, option?: RequestOption): Promise<Response$access$mtls$authentication$list$mtls$certificates$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/certificates\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add an mTLS certificate
     * Adds a new mTLS root certificate to Access.
     */
    public async access$mtls$authentication$add$an$mtls$certificate(params: Params$access$mtls$authentication$add$an$mtls$certificate, option?: RequestOption): Promise<Response$access$mtls$authentication$add$an$mtls$certificate$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/certificates\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an mTLS certificate
     * Fetches a single mTLS certificate.
     */
    public async access$mtls$authentication$get$an$mtls$certificate(params: Params$access$mtls$authentication$get$an$mtls$certificate, option?: RequestOption): Promise<Response$access$mtls$authentication$get$an$mtls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/certificates/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an mTLS certificate
     * Updates a configured mTLS certificate.
     */
    public async access$mtls$authentication$update$an$mtls$certificate(params: Params$access$mtls$authentication$update$an$mtls$certificate, option?: RequestOption): Promise<Response$access$mtls$authentication$update$an$mtls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/certificates/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an mTLS certificate
     * Deletes an mTLS certificate.
     */
    public async access$mtls$authentication$delete$an$mtls$certificate(params: Params$access$mtls$authentication$delete$an$mtls$certificate, option?: RequestOption): Promise<Response$access$mtls$authentication$delete$an$mtls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/certificates/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List all mTLS hostname settings
     * List all mTLS hostname settings for this account.
     */
    public async access$mtls$authentication$list$mtls$certificates$hostname$settings(params: Params$access$mtls$authentication$list$mtls$certificates$hostname$settings, option?: RequestOption): Promise<Response$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/certificates/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an mTLS certificate's hostname settings
     * Updates an mTLS certificate's hostname settings.
     */
    public async access$mtls$authentication$update$an$mtls$certificate$settings(params: Params$access$mtls$authentication$update$an$mtls$certificate$settings, option?: RequestOption): Promise<Response$access$mtls$authentication$update$an$mtls$certificate$settings$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/certificates/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List custom pages
     * List custom pages
     */
    public async access$custom$pages$list$custom$pages(params: Params$access$custom$pages$list$custom$pages, option?: RequestOption): Promise<Response$access$custom$pages$list$custom$pages$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/custom_pages\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a custom page
     * Create a custom page
     */
    public async access$custom$pages$create$a$custom$page(params: Params$access$custom$pages$create$a$custom$page, option?: RequestOption): Promise<Response$access$custom$pages$create$a$custom$page$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/custom_pages\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a custom page
     * Fetches a custom page and also returns its HTML.
     */
    public async access$custom$pages$get$a$custom$page(params: Params$access$custom$pages$get$a$custom$page, option?: RequestOption): Promise<Response$access$custom$pages$get$a$custom$page$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/custom_pages/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a custom page
     * Update a custom page
     */
    public async access$custom$pages$update$a$custom$page(params: Params$access$custom$pages$update$a$custom$page, option?: RequestOption): Promise<Response$access$custom$pages$update$a$custom$page$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/custom_pages/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a custom page
     * Delete a custom page
     */
    public async access$custom$pages$delete$a$custom$page(params: Params$access$custom$pages$delete$a$custom$page, option?: RequestOption): Promise<Response$access$custom$pages$delete$a$custom$page$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/custom_pages/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Access groups
     * Lists all Access groups.
     */
    public async access$groups$list$access$groups(params: Params$access$groups$list$access$groups, option?: RequestOption): Promise<Response$access$groups$list$access$groups$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/groups\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create an Access group
     * Creates a new Access group.
     */
    public async access$groups$create$an$access$group(params: Params$access$groups$create$an$access$group, option?: RequestOption): Promise<Response$access$groups$create$an$access$group$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/groups\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an Access group
     * Fetches a single Access group.
     */
    public async access$groups$get$an$access$group(params: Params$access$groups$get$an$access$group, option?: RequestOption): Promise<Response$access$groups$get$an$access$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/groups/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an Access group
     * Updates a configured Access group.
     */
    public async access$groups$update$an$access$group(params: Params$access$groups$update$an$access$group, option?: RequestOption): Promise<Response$access$groups$update$an$access$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/groups/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an Access group
     * Deletes an Access group.
     */
    public async access$groups$delete$an$access$group(params: Params$access$groups$delete$an$access$group, option?: RequestOption): Promise<Response$access$groups$delete$an$access$group$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/groups/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Access identity providers
     * Lists all configured identity providers.
     */
    public async access$identity$providers$list$access$identity$providers(params: Params$access$identity$providers$list$access$identity$providers, option?: RequestOption): Promise<Response$access$identity$providers$list$access$identity$providers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/identity_providers\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add an Access identity provider
     * Adds a new identity provider to Access.
     */
    public async access$identity$providers$add$an$access$identity$provider(params: Params$access$identity$providers$add$an$access$identity$provider, option?: RequestOption): Promise<Response$access$identity$providers$add$an$access$identity$provider$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/identity_providers\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an Access identity provider
     * Fetches a configured identity provider.
     */
    public async access$identity$providers$get$an$access$identity$provider(params: Params$access$identity$providers$get$an$access$identity$provider, option?: RequestOption): Promise<Response$access$identity$providers$get$an$access$identity$provider$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/identity_providers/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an Access identity provider
     * Updates a configured identity provider.
     */
    public async access$identity$providers$update$an$access$identity$provider(params: Params$access$identity$providers$update$an$access$identity$provider, option?: RequestOption): Promise<Response$access$identity$providers$update$an$access$identity$provider$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/identity_providers/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an Access identity provider
     * Deletes an identity provider from Access.
     */
    public async access$identity$providers$delete$an$access$identity$provider(params: Params$access$identity$providers$delete$an$access$identity$provider, option?: RequestOption): Promise<Response$access$identity$providers$delete$an$access$identity$provider$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/identity_providers/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get the Access key configuration
     * Gets the Access key rotation settings for an account.
     */
    public async access$key$configuration$get$the$access$key$configuration(params: Params$access$key$configuration$get$the$access$key$configuration, option?: RequestOption): Promise<Response$access$key$configuration$get$the$access$key$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/keys\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update the Access key configuration
     * Updates the Access key rotation settings for an account.
     */
    public async access$key$configuration$update$the$access$key$configuration(params: Params$access$key$configuration$update$the$access$key$configuration, option?: RequestOption): Promise<Response$access$key$configuration$update$the$access$key$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/keys\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Rotate Access keys
     * Perfoms a key rotation for an account.
     */
    public async access$key$configuration$rotate$access$keys(params: Params$access$key$configuration$rotate$access$keys, option?: RequestOption): Promise<Response$access$key$configuration$rotate$access$keys$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/keys/rotate\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Get Access authentication logs
     * Gets a list of Access authentication audit logs for an account.
     */
    public async access$authentication$logs$get$access$authentication$logs(params: Params$access$authentication$logs$get$access$authentication$logs, option?: RequestOption): Promise<Response$access$authentication$logs$get$access$authentication$logs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/logs/access_requests\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get your Zero Trust organization
     * Returns the configuration for your Zero Trust organization.
     */
    public async zero$trust$organization$get$your$zero$trust$organization(params: Params$zero$trust$organization$get$your$zero$trust$organization, option?: RequestOption): Promise<Response$zero$trust$organization$get$your$zero$trust$organization$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/organizations\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update your Zero Trust organization
     * Updates the configuration for your Zero Trust organization.
     */
    public async zero$trust$organization$update$your$zero$trust$organization(params: Params$zero$trust$organization$update$your$zero$trust$organization, option?: RequestOption): Promise<Response$zero$trust$organization$update$your$zero$trust$organization$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/organizations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create your Zero Trust organization
     * Sets up a Zero Trust organization for your account.
     */
    public async zero$trust$organization$create$your$zero$trust$organization(params: Params$zero$trust$organization$create$your$zero$trust$organization, option?: RequestOption): Promise<Response$zero$trust$organization$create$your$zero$trust$organization$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/organizations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Revoke all Access tokens for a user
     * Revokes a user's access across all applications.
     */
    public async zero$trust$organization$revoke$all$access$tokens$for$a$user(params: Params$zero$trust$organization$revoke$all$access$tokens$for$a$user, option?: RequestOption): Promise<Response$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/organizations/revoke_user\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update a user seat
     * Removes a user from a Zero Trust seat when both \`access_seat\` and \`gateway_seat\` are set to false.
     */
    public async zero$trust$seats$update$a$user$seat(params: Params$zero$trust$seats$update$a$user$seat, option?: RequestOption): Promise<Response$zero$trust$seats$update$a$user$seat$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/seats\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List service tokens
     * Lists all service tokens.
     */
    public async access$service$tokens$list$service$tokens(params: Params$access$service$tokens$list$service$tokens, option?: RequestOption): Promise<Response$access$service$tokens$list$service$tokens$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/service_tokens\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a service token
     * Generates a new service token. **Note:** This is the only time you can get the Client Secret. If you lose the Client Secret, you will have to rotate the Client Secret or create a new service token.
     */
    public async access$service$tokens$create$a$service$token(params: Params$access$service$tokens$create$a$service$token, option?: RequestOption): Promise<Response$access$service$tokens$create$a$service$token$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/service_tokens\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update a service token
     * Updates a configured service token.
     */
    public async access$service$tokens$update$a$service$token(params: Params$access$service$tokens$update$a$service$token, option?: RequestOption): Promise<Response$access$service$tokens$update$a$service$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/service_tokens/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a service token
     * Deletes a service token.
     */
    public async access$service$tokens$delete$a$service$token(params: Params$access$service$tokens$delete$a$service$token, option?: RequestOption): Promise<Response$access$service$tokens$delete$a$service$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/service_tokens/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Refresh a service token
     * Refreshes the expiration of a service token.
     */
    public async access$service$tokens$refresh$a$service$token(params: Params$access$service$tokens$refresh$a$service$token, option?: RequestOption): Promise<Response$access$service$tokens$refresh$a$service$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/service_tokens/\${params.parameter.uuid}/refresh\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Rotate a service token
     * Generates a new Client Secret for a service token and revokes the old one.
     */
    public async access$service$tokens$rotate$a$service$token(params: Params$access$service$tokens$rotate$a$service$token, option?: RequestOption): Promise<Response$access$service$tokens$rotate$a$service$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/service_tokens/\${params.parameter.uuid}/rotate\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * List tags
     * List tags
     */
    public async access$tags$list$tags(params: Params$access$tags$list$tags, option?: RequestOption): Promise<Response$access$tags$list$tags$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/tags\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a tag
     * Create a tag
     */
    public async access$tags$create$tag(params: Params$access$tags$create$tag, option?: RequestOption): Promise<Response$access$tags$create$tag$Status$201["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/tags\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a tag
     * Get a tag
     */
    public async access$tags$get$a$tag(params: Params$access$tags$get$a$tag, option?: RequestOption): Promise<Response$access$tags$get$a$tag$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/tags/\${params.parameter.name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a tag
     * Update a tag
     */
    public async access$tags$update$a$tag(params: Params$access$tags$update$a$tag, option?: RequestOption): Promise<Response$access$tags$update$a$tag$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/tags/\${params.parameter.name}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a tag
     * Delete a tag
     */
    public async access$tags$delete$a$tag(params: Params$access$tags$delete$a$tag, option?: RequestOption): Promise<Response$access$tags$delete$a$tag$Status$202["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/tags/\${params.parameter.name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get users
     * Gets a list of users for an account.
     */
    public async zero$trust$users$get$users(params: Params$zero$trust$users$get$users, option?: RequestOption): Promise<Response$zero$trust$users$get$users$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/users\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get active sessions
     * Get active sessions for a single user.
     */
    public async zero$trust$users$get$active$sessions(params: Params$zero$trust$users$get$active$sessions, option?: RequestOption): Promise<Response$zero$trust$users$get$active$sessions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/users/\${params.parameter.id}/active_sessions\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get single active session
     * Get an active session for a single user.
     */
    public async zero$trust$users$get$active$session(params: Params$zero$trust$users$get$active$session, option?: RequestOption): Promise<Response$zero$trust$users$get$active$session$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/users/\${params.parameter.id}/active_sessions/\${params.parameter.nonce}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get failed logins
     * Get all failed login attempts for a single user.
     */
    public async zero$trust$users$get$failed$logins(params: Params$zero$trust$users$get$failed$logins, option?: RequestOption): Promise<Response$zero$trust$users$get$failed$logins$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/users/\${params.parameter.id}/failed_logins\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get last seen identity
     * Get last seen identity for a single user.
     */
    public async zero$trust$users$get$last$seen$identity(params: Params$zero$trust$users$get$last$seen$identity, option?: RequestOption): Promise<Response$zero$trust$users$get$last$seen$identity$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/access/users/\${params.parameter.id}/last_seen_identity\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List devices
     * Fetches a list of enrolled devices.
     */
    public async devices$list$devices(params: Params$devices$list$devices, option?: RequestOption): Promise<Response$devices$list$devices$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get device details
     * Fetches details for a single device.
     */
    public async devices$device$details(params: Params$devices$device$details, option?: RequestOption): Promise<Response$devices$device$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get an admin override code for a device
     * Fetches a one-time use admin override code for a device. This relies on the **Admin Override** setting being enabled in your device configuration.
     */
    public async devices$list$admin$override$code$for$device(params: Params$devices$list$admin$override$code$for$device, option?: RequestOption): Promise<Response$devices$list$admin$override$code$for$device$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/\${params.parameter.uuid}/override_codes\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Device DEX tests
     * Fetch all DEX tests.
     */
    public async device$dex$test$details(params: Params$device$dex$test$details, option?: RequestOption): Promise<Response$device$dex$test$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/dex_tests\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Device DEX test
     * Create a DEX test.
     */
    public async device$dex$test$create$device$dex$test(params: Params$device$dex$test$create$device$dex$test, option?: RequestOption): Promise<Response$device$dex$test$create$device$dex$test$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/dex_tests\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Device DEX test
     * Fetch a single DEX test.
     */
    public async device$dex$test$get$device$dex$test(params: Params$device$dex$test$get$device$dex$test, option?: RequestOption): Promise<Response$device$dex$test$get$device$dex$test$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/dex_tests/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Device DEX test
     * Update a DEX test.
     */
    public async device$dex$test$update$device$dex$test(params: Params$device$dex$test$update$device$dex$test, option?: RequestOption): Promise<Response$device$dex$test$update$device$dex$test$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/dex_tests/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Device DEX test
     * Delete a Device DEX test. Returns the remaining device dex tests for the account.
     */
    public async device$dex$test$delete$device$dex$test(params: Params$device$dex$test$delete$device$dex$test, option?: RequestOption): Promise<Response$device$dex$test$delete$device$dex$test$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/dex_tests/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List your device managed networks
     * Fetches a list of managed networks for an account.
     */
    public async device$managed$networks$list$device$managed$networks(params: Params$device$managed$networks$list$device$managed$networks, option?: RequestOption): Promise<Response$device$managed$networks$list$device$managed$networks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/networks\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a device managed network
     * Creates a new device managed network.
     */
    public async device$managed$networks$create$device$managed$network(params: Params$device$managed$networks$create$device$managed$network, option?: RequestOption): Promise<Response$device$managed$networks$create$device$managed$network$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/networks\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get device managed network details
     * Fetches details for a single managed network.
     */
    public async device$managed$networks$device$managed$network$details(params: Params$device$managed$networks$device$managed$network$details, option?: RequestOption): Promise<Response$device$managed$networks$device$managed$network$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/networks/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a device managed network
     * Updates a configured device managed network.
     */
    public async device$managed$networks$update$device$managed$network(params: Params$device$managed$networks$update$device$managed$network, option?: RequestOption): Promise<Response$device$managed$networks$update$device$managed$network$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/networks/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a device managed network
     * Deletes a device managed network and fetches a list of the remaining device managed networks for an account.
     */
    public async device$managed$networks$delete$device$managed$network(params: Params$device$managed$networks$delete$device$managed$network, option?: RequestOption): Promise<Response$device$managed$networks$delete$device$managed$network$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/networks/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List device settings profiles
     * Fetches a list of the device settings profiles for an account.
     */
    public async devices$list$device$settings$policies(params: Params$devices$list$device$settings$policies, option?: RequestOption): Promise<Response$devices$list$device$settings$policies$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policies\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get the default device settings profile
     * Fetches the default device settings profile for an account.
     */
    public async devices$get$default$device$settings$policy(params: Params$devices$get$default$device$settings$policy, option?: RequestOption): Promise<Response$devices$get$default$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a device settings profile
     * Creates a device settings profile to be applied to certain devices matching the criteria.
     */
    public async devices$create$device$settings$policy(params: Params$devices$create$device$settings$policy, option?: RequestOption): Promise<Response$devices$create$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update the default device settings profile
     * Updates the default device settings profile for an account.
     */
    public async devices$update$default$device$settings$policy(params: Params$devices$update$default$device$settings$policy, option?: RequestOption): Promise<Response$devices$update$default$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get device settings profile by ID
     * Fetches a device settings profile by ID.
     */
    public async devices$get$device$settings$policy$by$id(params: Params$devices$get$device$settings$policy$by$id, option?: RequestOption): Promise<Response$devices$get$device$settings$policy$by$id$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete a device settings profile
     * Deletes a device settings profile and fetches a list of the remaining profiles for an account.
     */
    public async devices$delete$device$settings$policy(params: Params$devices$delete$device$settings$policy, option?: RequestOption): Promise<Response$devices$delete$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update a device settings profile
     * Updates a configured device settings profile.
     */
    public async devices$update$device$settings$policy(params: Params$devices$update$device$settings$policy, option?: RequestOption): Promise<Response$devices$update$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get the Split Tunnel exclude list for a device settings profile
     * Fetches the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
     */
    public async devices$get$split$tunnel$exclude$list$for$a$device$settings$policy(params: Params$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy, option?: RequestOption): Promise<Response$devices$get$split$tunnel$exclude$list$for$a$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}/exclude\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set the Split Tunnel exclude list for a device settings profile
     * Sets the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
     */
    public async devices$set$split$tunnel$exclude$list$for$a$device$settings$policy(params: Params$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy, option?: RequestOption): Promise<Response$devices$set$split$tunnel$exclude$list$for$a$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}/exclude\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get the Local Domain Fallback list for a device settings profile
     * Fetches the list of domains to bypass Gateway DNS resolution from a specified device settings profile. These domains will use the specified local DNS resolver instead.
     */
    public async devices$get$local$domain$fallback$list$for$a$device$settings$policy(params: Params$devices$get$local$domain$fallback$list$for$a$device$settings$policy, option?: RequestOption): Promise<Response$devices$get$local$domain$fallback$list$for$a$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}/fallback_domains\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set the Local Domain Fallback list for a device settings profile
     * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead. This will only apply to the specified device settings profile.
     */
    public async devices$set$local$domain$fallback$list$for$a$device$settings$policy(params: Params$devices$set$local$domain$fallback$list$for$a$device$settings$policy, option?: RequestOption): Promise<Response$devices$set$local$domain$fallback$list$for$a$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}/fallback_domains\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get the Split Tunnel include list for a device settings profile
     * Fetches the list of routes included in the WARP client's tunnel for a specific device settings profile.
     */
    public async devices$get$split$tunnel$include$list$for$a$device$settings$policy(params: Params$devices$get$split$tunnel$include$list$for$a$device$settings$policy, option?: RequestOption): Promise<Response$devices$get$split$tunnel$include$list$for$a$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}/include\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set the Split Tunnel include list for a device settings profile
     * Sets the list of routes included in the WARP client's tunnel for a specific device settings profile.
     */
    public async devices$set$split$tunnel$include$list$for$a$device$settings$policy(params: Params$devices$set$split$tunnel$include$list$for$a$device$settings$policy, option?: RequestOption): Promise<Response$devices$set$split$tunnel$include$list$for$a$device$settings$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/\${params.parameter.uuid}/include\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get the Split Tunnel exclude list
     * Fetches the list of routes excluded from the WARP client's tunnel.
     */
    public async devices$get$split$tunnel$exclude$list(params: Params$devices$get$split$tunnel$exclude$list, option?: RequestOption): Promise<Response$devices$get$split$tunnel$exclude$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/exclude\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set the Split Tunnel exclude list
     * Sets the list of routes excluded from the WARP client's tunnel.
     */
    public async devices$set$split$tunnel$exclude$list(params: Params$devices$set$split$tunnel$exclude$list, option?: RequestOption): Promise<Response$devices$set$split$tunnel$exclude$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/exclude\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get your Local Domain Fallback list
     * Fetches a list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
     */
    public async devices$get$local$domain$fallback$list(params: Params$devices$get$local$domain$fallback$list, option?: RequestOption): Promise<Response$devices$get$local$domain$fallback$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/fallback_domains\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set your Local Domain Fallback list
     * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
     */
    public async devices$set$local$domain$fallback$list(params: Params$devices$set$local$domain$fallback$list, option?: RequestOption): Promise<Response$devices$set$local$domain$fallback$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/fallback_domains\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get the Split Tunnel include list
     * Fetches the list of routes included in the WARP client's tunnel.
     */
    public async devices$get$split$tunnel$include$list(params: Params$devices$get$split$tunnel$include$list, option?: RequestOption): Promise<Response$devices$get$split$tunnel$include$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/include\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set the Split Tunnel include list
     * Sets the list of routes included in the WARP client's tunnel.
     */
    public async devices$set$split$tunnel$include$list(params: Params$devices$set$split$tunnel$include$list, option?: RequestOption): Promise<Response$devices$set$split$tunnel$include$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/policy/include\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List device posture rules
     * Fetches device posture rules for a Zero Trust account.
     */
    public async device$posture$rules$list$device$posture$rules(params: Params$device$posture$rules$list$device$posture$rules, option?: RequestOption): Promise<Response$device$posture$rules$list$device$posture$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a device posture rule
     * Creates a new device posture rule.
     */
    public async device$posture$rules$create$device$posture$rule(params: Params$device$posture$rules$create$device$posture$rule, option?: RequestOption): Promise<Response$device$posture$rules$create$device$posture$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get device posture rule details
     * Fetches a single device posture rule.
     */
    public async device$posture$rules$device$posture$rules$details(params: Params$device$posture$rules$device$posture$rules$details, option?: RequestOption): Promise<Response$device$posture$rules$device$posture$rules$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a device posture rule
     * Updates a device posture rule.
     */
    public async device$posture$rules$update$device$posture$rule(params: Params$device$posture$rules$update$device$posture$rule, option?: RequestOption): Promise<Response$device$posture$rules$update$device$posture$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a device posture rule
     * Deletes a device posture rule.
     */
    public async device$posture$rules$delete$device$posture$rule(params: Params$device$posture$rules$delete$device$posture$rule, option?: RequestOption): Promise<Response$device$posture$rules$delete$device$posture$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List your device posture integrations
     * Fetches the list of device posture integrations for an account.
     */
    public async device$posture$integrations$list$device$posture$integrations(params: Params$device$posture$integrations$list$device$posture$integrations, option?: RequestOption): Promise<Response$device$posture$integrations$list$device$posture$integrations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture/integration\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a device posture integration
     * Create a new device posture integration.
     */
    public async device$posture$integrations$create$device$posture$integration(params: Params$device$posture$integrations$create$device$posture$integration, option?: RequestOption): Promise<Response$device$posture$integrations$create$device$posture$integration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture/integration\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get device posture integration details
     * Fetches details for a single device posture integration.
     */
    public async device$posture$integrations$device$posture$integration$details(params: Params$device$posture$integrations$device$posture$integration$details, option?: RequestOption): Promise<Response$device$posture$integrations$device$posture$integration$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture/integration/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete a device posture integration
     * Delete a configured device posture integration.
     */
    public async device$posture$integrations$delete$device$posture$integration(params: Params$device$posture$integrations$delete$device$posture$integration, option?: RequestOption): Promise<Response$device$posture$integrations$delete$device$posture$integration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture/integration/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update a device posture integration
     * Updates a configured device posture integration.
     */
    public async device$posture$integrations$update$device$posture$integration(params: Params$device$posture$integrations$update$device$posture$integration, option?: RequestOption): Promise<Response$device$posture$integrations$update$device$posture$integration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/posture/integration/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Revoke devices
     * Revokes a list of devices.
     */
    public async devices$revoke$devices(params: Params$devices$revoke$devices, option?: RequestOption): Promise<Response$devices$revoke$devices$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/revoke\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get device settings for a Zero Trust account
     * Describes the current device settings for a Zero Trust account.
     */
    public async zero$trust$accounts$get$device$settings$for$zero$trust$account(params: Params$zero$trust$accounts$get$device$settings$for$zero$trust$account, option?: RequestOption): Promise<Response$zero$trust$accounts$get$device$settings$for$zero$trust$account$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update device settings for a Zero Trust account
     * Updates the current device settings for a Zero Trust account.
     */
    public async zero$trust$accounts$update$device$settings$for$the$zero$trust$account(params: Params$zero$trust$accounts$update$device$settings$for$the$zero$trust$account, option?: RequestOption): Promise<Response$zero$trust$accounts$update$device$settings$for$the$zero$trust$account$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Unrevoke devices
     * Unrevokes a list of devices.
     */
    public async devices$unrevoke$devices(params: Params$devices$unrevoke$devices, option?: RequestOption): Promise<Response$devices$unrevoke$devices$Status$200["application/json"]> {
        const url = this.baseUrl + \`/accounts/\${params.parameter.identifier}/devices/unrevoke\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Certificates
     * List all existing Origin CA certificates for a given zone. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests)).
     */
    public async origin$ca$list$certificates(params: Params$origin$ca$list$certificates, option?: RequestOption): Promise<Response$origin$ca$list$certificates$Status$200["application/json"]> {
        const url = this.baseUrl + \`/certificates\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            identifier: { value: params.parameter.identifier, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create Certificate
     * Create an Origin CA certificate. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests)).
     */
    public async origin$ca$create$certificate(params: Params$origin$ca$create$certificate, option?: RequestOption): Promise<Response$origin$ca$create$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/certificates\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Certificate
     * Get an existing Origin CA certificate by its serial number. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests)).
     */
    public async origin$ca$get$certificate(params: Params$origin$ca$get$certificate, option?: RequestOption): Promise<Response$origin$ca$get$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Revoke Certificate
     * Revoke an existing Origin CA certificate by its serial number. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests)).
     */
    public async origin$ca$revoke$certificate(params: Params$origin$ca$revoke$certificate, option?: RequestOption): Promise<Response$origin$ca$revoke$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Cloudflare/JD Cloud IP Details
     * Get IPs used on the Cloudflare/JD Cloud network, see https://www.cloudflare.com/ips for Cloudflare IPs or https://developers.cloudflare.com/china-network/reference/infrastructure/ for JD Cloud IPs.
     */
    public async cloudflare$i$ps$cloudflare$ip$details(params: Params$cloudflare$i$ps$cloudflare$ip$details, option?: RequestOption): Promise<Response$cloudflare$i$ps$cloudflare$ip$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/ips\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            networks: { value: params.parameter.networks, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Memberships
     * List memberships of accounts the user can access.
     */
    public async user$$s$account$memberships$list$memberships(params: Params$user$$s$account$memberships$list$memberships, option?: RequestOption): Promise<Response$user$$s$account$memberships$list$memberships$Status$200["application/json"]> {
        const url = this.baseUrl + \`/memberships\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "account.name": { value: params.parameter["account.name"], explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            name: { value: params.parameter.name, explode: false },
            status: { value: params.parameter.status, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Membership Details
     * Get a specific membership.
     */
    public async user$$s$account$memberships$membership$details(params: Params$user$$s$account$memberships$membership$details, option?: RequestOption): Promise<Response$user$$s$account$memberships$membership$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/memberships/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Membership
     * Accept or reject this account invitation.
     */
    public async user$$s$account$memberships$update$membership(params: Params$user$$s$account$memberships$update$membership, option?: RequestOption): Promise<Response$user$$s$account$memberships$update$membership$Status$200["application/json"]> {
        const url = this.baseUrl + \`/memberships/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Membership
     * Remove the associated member from an account.
     */
    public async user$$s$account$memberships$delete$membership(params: Params$user$$s$account$memberships$delete$membership, option?: RequestOption): Promise<Response$user$$s$account$memberships$delete$membership$Status$200["application/json"]> {
        const url = this.baseUrl + \`/memberships/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Organization Details
     * Get information about a specific organization that you are a member of.
     */
    public async organizations$$$deprecated$$organization$details(params: Params$organizations$$$deprecated$$organization$details, option?: RequestOption): Promise<Response$organizations$$$deprecated$$organization$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Edit Organization
     * Update an existing Organization.
     */
    public async organizations$$$deprecated$$edit$organization(params: Params$organizations$$$deprecated$$edit$organization, option?: RequestOption): Promise<Response$organizations$$$deprecated$$edit$organization$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Get organization audit logs
     * Gets a list of audit logs for an organization. Can be filtered by who made the change, on which zone, and the timeframe of the change.
     */
    public async audit$logs$get$organization$audit$logs(params: Params$audit$logs$get$organization$audit$logs, option?: RequestOption): Promise<Response$audit$logs$get$organization$audit$logs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/audit_logs\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            id: { value: params.parameter.id, explode: false },
            export: { value: params.parameter.export, explode: false },
            "action.type": { value: params.parameter["action.type"], explode: false },
            "actor.ip": { value: params.parameter["actor.ip"], explode: false },
            "actor.email": { value: params.parameter["actor.email"], explode: false },
            since: { value: params.parameter.since, explode: false },
            before: { value: params.parameter.before, explode: false },
            "zone.name": { value: params.parameter["zone.name"], explode: false },
            direction: { value: params.parameter.direction, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            page: { value: params.parameter.page, explode: false },
            hide_user_logs: { value: params.parameter.hide_user_logs, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * List Invitations
     * List all invitations associated with an organization.
     */
    public async organization$invites$list$invitations(params: Params$organization$invites$list$invitations, option?: RequestOption): Promise<Response$organization$invites$list$invitations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/invites\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Create Invitation
     * Invite a User to become a Member of an Organization.
     */
    public async organization$invites$create$invitation(params: Params$organization$invites$create$invitation, option?: RequestOption): Promise<Response$organization$invites$create$invitation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/invites\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Invitation Details
     * Get the details of an invitation.
     */
    public async organization$invites$invitation$details(params: Params$organization$invites$invitation$details, option?: RequestOption): Promise<Response$organization$invites$invitation$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/invites/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Cancel Invitation
     * Cancel an existing invitation.
     */
    public async organization$invites$cancel$invitation(params: Params$organization$invites$cancel$invitation, option?: RequestOption): Promise<Response$organization$invites$cancel$invitation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/invites/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Edit Invitation Roles
     * Change the Roles of a Pending Invite.
     */
    public async organization$invites$edit$invitation$roles(params: Params$organization$invites$edit$invitation$roles, option?: RequestOption): Promise<Response$organization$invites$edit$invitation$roles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/invites/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * List Members
     * List all members of a organization.
     */
    public async organization$members$list$members(params: Params$organization$members$list$members, option?: RequestOption): Promise<Response$organization$members$list$members$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/members\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Member Details
     * Get information about a specific member of an organization.
     */
    public async organization$members$member$details(params: Params$organization$members$member$details, option?: RequestOption): Promise<Response$organization$members$member$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/members/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Remove Member
     * Remove a member from an organization.
     */
    public async organization$members$remove$member(params: Params$organization$members$remove$member, option?: RequestOption): Promise<Response$organization$members$remove$member$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/members/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Edit Member Roles
     * Change the Roles of an Organization's Member.
     */
    public async organization$members$edit$member$roles(params: Params$organization$members$edit$member$roles, option?: RequestOption): Promise<Response$organization$members$edit$member$roles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/members/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * List Roles
     * Get all available roles for an organization.
     */
    public async organization$roles$list$roles(params: Params$organization$roles$list$roles, option?: RequestOption): Promise<Response$organization$roles$list$roles$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/roles\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Role Details
     * Get information about a specific role for an organization.
     */
    public async organization$roles$role$details(params: Params$organization$roles$role$details, option?: RequestOption): Promise<Response$organization$roles$role$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/organizations/\${params.parameter.organization_identifier}/roles/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Get latest Internet outages and anomalies. */
    public async radar$get$annotations$outages(params: Params$radar$get$annotations$outages, option?: RequestOption): Promise<Response$radar$get$annotations$outages$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/annotations/outages\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            offset: { value: params.parameter.offset, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Get the number of outages for locations. */
    public async radar$get$annotations$outages$top(params: Params$radar$get$annotations$outages$top, option?: RequestOption): Promise<Response$radar$get$annotations$outages$top$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/annotations/outages/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 DNSSEC Summary
     * Percentage distribution of DNS queries to AS112 by DNSSEC support.
     */
    public async radar$get$dns$as112$timeseries$by$dnssec(params: Params$radar$get$dns$as112$timeseries$by$dnssec, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$by$dnssec$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/summary/dnssec\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 EDNS Summary
     * Percentage distribution of DNS queries, to AS112, by EDNS support.
     */
    public async radar$get$dns$as112$timeseries$by$edns(params: Params$radar$get$dns$as112$timeseries$by$edns, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$by$edns$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/summary/edns\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 IP Version Summary
     * Percentage distribution of DNS queries to AS112 per IP Version.
     */
    public async radar$get$dns$as112$timeseries$by$ip$version(params: Params$radar$get$dns$as112$timeseries$by$ip$version, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/summary/ip_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 DNS Protocol Summary
     * Percentage distribution of DNS queries to AS112 per protocol.
     */
    public async radar$get$dns$as112$timeseries$by$protocol(params: Params$radar$get$dns$as112$timeseries$by$protocol, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$by$protocol$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/summary/protocol\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 Query Types Summary
     * Percentage distribution of DNS queries to AS112 by Query Type.
     */
    public async radar$get$dns$as112$timeseries$by$query$type(params: Params$radar$get$dns$as112$timeseries$by$query$type, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$by$query$type$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/summary/query_type\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a summary of AS112 Response Codes
     * Percentage distribution of AS112 dns requests classified per Response Codes.
     */
    public async radar$get$dns$as112$timeseries$by$response$codes(params: Params$radar$get$dns$as112$timeseries$by$response$codes, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$by$response$codes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/summary/response_codes\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 DNS Queries Time Series
     * Get AS112 queries change over time.
     */
    public async radar$get$dns$as112$timeseries(params: Params$radar$get$dns$as112$timeseries, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/timeseries\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 DNSSEC Support Time Series
     * Percentage distribution of DNS AS112 queries by DNSSEC support over time.
     */
    public async radar$get$dns$as112$timeseries$group$by$dnssec(params: Params$radar$get$dns$as112$timeseries$group$by$dnssec, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$group$by$dnssec$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/timeseries_groups/dnssec\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 EDNS Support Summary
     * Percentage distribution of AS112 DNS queries by EDNS support over time.
     */
    public async radar$get$dns$as112$timeseries$group$by$edns(params: Params$radar$get$dns$as112$timeseries$group$by$edns, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$group$by$edns$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/timeseries_groups/edns\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 IP Version Time Series
     * Percentage distribution of AS112 DNS queries by IP Version over time.
     */
    public async radar$get$dns$as112$timeseries$group$by$ip$version(params: Params$radar$get$dns$as112$timeseries$group$by$ip$version, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$group$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/timeseries_groups/ip_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 DNS Protocol Time Series
     * Percentage distribution of AS112 dns requests classified per Protocol over time.
     */
    public async radar$get$dns$as112$timeseries$group$by$protocol(params: Params$radar$get$dns$as112$timeseries$group$by$protocol, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$group$by$protocol$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/timeseries_groups/protocol\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS112 Query Types Time Series
     * Percentage distribution of AS112 DNS queries by Query Type over time.
     */
    public async radar$get$dns$as112$timeseries$group$by$query$type(params: Params$radar$get$dns$as112$timeseries$group$by$query$type, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$group$by$query$type$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/timeseries_groups/query_type\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a time series of AS112 Response Codes
     * Percentage distribution of AS112 dns requests classified per Response Codes over time.
     */
    public async radar$get$dns$as112$timeseries$group$by$response$codes(params: Params$radar$get$dns$as112$timeseries$group$by$response$codes, option?: RequestOption): Promise<Response$radar$get$dns$as112$timeseries$group$by$response$codes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/timeseries_groups/response_codes\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top autonomous systems by AS112 DNS queries
     * Get the top locations by AS112 DNS queries. Values are a percentage out of the total queries.
     */
    public async radar$get$dns$as112$top$locations(params: Params$radar$get$dns$as112$top$locations, option?: RequestOption): Promise<Response$radar$get$dns$as112$top$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/top/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By DNS Queries DNSSEC Support
     * Get the top locations by DNS queries DNSSEC support to AS112.
     */
    public async radar$get$dns$as112$top$locations$by$dnssec(params: Params$radar$get$dns$as112$top$locations$by$dnssec, option?: RequestOption): Promise<Response$radar$get$dns$as112$top$locations$by$dnssec$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/top/locations/dnssec/\${params.parameter.dnssec}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By EDNS Support
     * Get the top locations, by DNS queries EDNS support to AS112.
     */
    public async radar$get$dns$as112$top$locations$by$edns(params: Params$radar$get$dns$as112$top$locations$by$edns, option?: RequestOption): Promise<Response$radar$get$dns$as112$top$locations$by$edns$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/top/locations/edns/\${params.parameter.edns}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations by DNS Queries IP version
     * Get the top locations by DNS queries IP version to AS112.
     */
    public async radar$get$dns$as112$top$locations$by$ip$version(params: Params$radar$get$dns$as112$top$locations$by$ip$version, option?: RequestOption): Promise<Response$radar$get$dns$as112$top$locations$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/as112/top/locations/ip_version/\${params.parameter.ip_version}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Get Layer 3 Attacks Summary
     * Percentage distribution of network protocols in layer 3/4 attacks over a given time period.
     */
    public async radar$get$attacks$layer3$summary(params: Params$radar$get$attacks$layer3$summary, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$summary$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/summary\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Attack Bitrate Summary
     * Percentage distribution of attacks by bitrate.
     */
    public async radar$get$attacks$layer3$summary$by$bitrate(params: Params$radar$get$attacks$layer3$summary$by$bitrate, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$summary$by$bitrate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/summary/bitrate\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Attack Durations Summary
     * Percentage distribution of attacks by duration.
     */
    public async radar$get$attacks$layer3$summary$by$duration(params: Params$radar$get$attacks$layer3$summary$by$duration, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$summary$by$duration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/summary/duration\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get IP Versions Summary
     * Percentage distribution of attacks by ip version used.
     */
    public async radar$get$attacks$layer3$summary$by$ip$version(params: Params$radar$get$attacks$layer3$summary$by$ip$version, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$summary$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/summary/ip_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 3 Protocols Summary
     * Percentage distribution of attacks by protocol used.
     */
    public async radar$get$attacks$layer3$summary$by$protocol(params: Params$radar$get$attacks$layer3$summary$by$protocol, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$summary$by$protocol$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/summary/protocol\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Attack Vector Summary
     * Percentage distribution of attacks by vector.
     */
    public async radar$get$attacks$layer3$summary$by$vector(params: Params$radar$get$attacks$layer3$summary$by$vector, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$summary$by$vector$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/summary/vector\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Attacks By Bytes Summary
     * Get attacks change over time by bytes.
     */
    public async radar$get$attacks$layer3$timeseries$by$bytes(params: Params$radar$get$attacks$layer3$timeseries$by$bytes, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$by$bytes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            metric: { value: params.parameter.metric, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Get Layer 3 Attacks By Network Protocol Time Series
     * Get a timeseries of the percentage distribution of network protocols in Layer 3/4 attacks.
     */
    public async radar$get$attacks$layer3$timeseries$groups(params: Params$radar$get$attacks$layer3$timeseries$groups, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$groups$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries_groups\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Attacks By Bitrate Time Series
     * Percentage distribution of attacks by bitrate over time.
     */
    public async radar$get$attacks$layer3$timeseries$group$by$bitrate(params: Params$radar$get$attacks$layer3$timeseries$group$by$bitrate, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$group$by$bitrate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries_groups/bitrate\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 3 Attack By Duration Time Series
     * Percentage distribution of attacks by duration over time.
     */
    public async radar$get$attacks$layer3$timeseries$group$by$duration(params: Params$radar$get$attacks$layer3$timeseries$group$by$duration, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$group$by$duration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries_groups/duration\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 3 Attacks By Target Industries Time Series
     * Percentage distribution of attacks by industry used over time.
     */
    public async radar$get$attacks$layer3$timeseries$group$by$industry(params: Params$radar$get$attacks$layer3$timeseries$group$by$industry, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$group$by$industry$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries_groups/industry\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            limitPerGroup: { value: params.parameter.limitPerGroup, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 3 Attacks By IP Version Time Series
     * Percentage distribution of attacks by ip version used over time.
     */
    public async radar$get$attacks$layer3$timeseries$group$by$ip$version(params: Params$radar$get$attacks$layer3$timeseries$group$by$ip$version, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$group$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries_groups/ip_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 3 Attacks By Protocol Timeseries
     * Percentage distribution of attacks by protocol used over time.
     */
    public async radar$get$attacks$layer3$timeseries$group$by$protocol(params: Params$radar$get$attacks$layer3$timeseries$group$by$protocol, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$group$by$protocol$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries_groups/protocol\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 3 Attacks By Vector
     * Percentage distribution of attacks by vector used over time.
     */
    public async radar$get$attacks$layer3$timeseries$group$by$vector(params: Params$radar$get$attacks$layer3$timeseries$group$by$vector, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$group$by$vector$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries_groups/vector\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            limitPerGroup: { value: params.parameter.limitPerGroup, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 3 Attacks By Vertical Time Series
     * Percentage distribution of attacks by vertical used over time.
     */
    public async radar$get$attacks$layer3$timeseries$group$by$vertical(params: Params$radar$get$attacks$layer3$timeseries$group$by$vertical, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$timeseries$group$by$vertical$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/timeseries_groups/vertical\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            limitPerGroup: { value: params.parameter.limitPerGroup, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top attack pairs (origin and target locations) of Layer 3 attacks
     * Get the top attacks from origin to target location. Values are a percentage out of the total layer 3 attacks (with billing country). You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).
     */
    public async radar$get$attacks$layer3$top$attacks(params: Params$radar$get$attacks$layer3$top$attacks, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$top$attacks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/top/attacks\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            limitDirection: { value: params.parameter.limitDirection, explode: false },
            limitPerLocation: { value: params.parameter.limitPerLocation, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top Industry of attack
     * Get the Industry of attacks.
     */
    public async radar$get$attacks$layer3$top$industries(params: Params$radar$get$attacks$layer3$top$industries, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$top$industries$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/top/industry\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top origin locations of attack
     * Get the origin locations of attacks.
     */
    public async radar$get$attacks$layer3$top$origin$locations(params: Params$radar$get$attacks$layer3$top$origin$locations, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$top$origin$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/top/locations/origin\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top target locations of attack
     * Get the target locations of attacks.
     */
    public async radar$get$attacks$layer3$top$target$locations(params: Params$radar$get$attacks$layer3$top$target$locations, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$top$target$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/top/locations/target\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top Verticals of attack
     * Get the Verticals of attacks.
     */
    public async radar$get$attacks$layer3$top$verticals(params: Params$radar$get$attacks$layer3$top$verticals, option?: RequestOption): Promise<Response$radar$get$attacks$layer3$top$verticals$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer3/top/vertical\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            protocol: { value: params.parameter.protocol, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Get Layer 7 Attacks Summary
     * Percentage distribution of mitigation techniques in Layer 7 attacks.
     */
    public async radar$get$attacks$layer7$summary(params: Params$radar$get$attacks$layer7$summary, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$summary$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/summary\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get HTTP Method Summary
     * Percentage distribution of attacks by http method used.
     */
    public async radar$get$attacks$layer7$summary$by$http$method(params: Params$radar$get$attacks$layer7$summary$by$http$method, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$summary$by$http$method$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/summary/http_method\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get HTTP Version Summary
     * Percentage distribution of attacks by http version used.
     */
    public async radar$get$attacks$layer7$summary$by$http$version(params: Params$radar$get$attacks$layer7$summary$by$http$version, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$summary$by$http$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/summary/http_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Ip Version Summary
     * Percentage distribution of attacks by ip version used.
     */
    public async radar$get$attacks$layer7$summary$by$ip$version(params: Params$radar$get$attacks$layer7$summary$by$ip$version, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$summary$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/summary/ip_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Managed Rules Summary
     * Percentage distribution of attacks by managed rules used.
     */
    public async radar$get$attacks$layer7$summary$by$managed$rules(params: Params$radar$get$attacks$layer7$summary$by$managed$rules, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$summary$by$managed$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/summary/managed_rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Mitigation Product Summary
     * Percentage distribution of attacks by mitigation product used.
     */
    public async radar$get$attacks$layer7$summary$by$mitigation$product(params: Params$radar$get$attacks$layer7$summary$by$mitigation$product, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$summary$by$mitigation$product$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/summary/mitigation_product\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 7 Attacks Time Series
     * Get a timeseries of Layer 7 attacks. Values represent HTTP requests and are normalized using min-max by default.
     */
    public async radar$get$attacks$layer7$timeseries(params: Params$radar$get$attacks$layer7$timeseries, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            attack: { value: params.parameter.attack, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Get Layer 7 Attacks By Mitigation Technique Time Series
     * Get a time series of the percentual distribution of mitigation techniques, over time.
     */
    public async radar$get$attacks$layer7$timeseries$group(params: Params$radar$get$attacks$layer7$timeseries$group, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries_groups\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 7 Attacks By HTTP Method Time Series
     * Percentage distribution of attacks by http method used over time.
     */
    public async radar$get$attacks$layer7$timeseries$group$by$http$method(params: Params$radar$get$attacks$layer7$timeseries$group$by$http$method, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$group$by$http$method$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries_groups/http_method\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 7 Attacks By HTTP Version Time Series
     * Percentage distribution of attacks by http version used over time.
     */
    public async radar$get$attacks$layer7$timeseries$group$by$http$version(params: Params$radar$get$attacks$layer7$timeseries$group$by$http$version, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$group$by$http$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries_groups/http_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 7 Attacks By Target Industries Time Series
     * Percentage distribution of attacks by industry used over time.
     */
    public async radar$get$attacks$layer7$timeseries$group$by$industry(params: Params$radar$get$attacks$layer7$timeseries$group$by$industry, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$group$by$industry$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries_groups/industry\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            limitPerGroup: { value: params.parameter.limitPerGroup, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 7 Attacks By IP Version Time Series
     * Percentage distribution of attacks by ip version used over time.
     */
    public async radar$get$attacks$layer7$timeseries$group$by$ip$version(params: Params$radar$get$attacks$layer7$timeseries$group$by$ip$version, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$group$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries_groups/ip_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 7 Attacks By Managed Rules Time Series
     * Percentage distribution of attacks by managed rules used over time.
     */
    public async radar$get$attacks$layer7$timeseries$group$by$managed$rules(params: Params$radar$get$attacks$layer7$timeseries$group$by$managed$rules, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$group$by$managed$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries_groups/managed_rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 7 Attacks By Mitigation Product Time Series
     * Percentage distribution of attacks by mitigation product used over time.
     */
    public async radar$get$attacks$layer7$timeseries$group$by$mitigation$product(params: Params$radar$get$attacks$layer7$timeseries$group$by$mitigation$product, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$group$by$mitigation$product$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries_groups/mitigation_product\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Layer 7 Attacks By Vertical Time Series
     * Percentage distribution of attacks by vertical used over time.
     */
    public async radar$get$attacks$layer7$timeseries$group$by$vertical(params: Params$radar$get$attacks$layer7$timeseries$group$by$vertical, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$timeseries$group$by$vertical$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/timeseries_groups/vertical\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            httpMethod: { value: params.parameter.httpMethod, explode: false },
            mitigationProduct: { value: params.parameter.mitigationProduct, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            limitPerGroup: { value: params.parameter.limitPerGroup, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Origin Autonomous Systems By Layer 7 Attacks
     * Get the top origin Autonomous Systems of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin Autonomous Systems is determined by the client IP.
     */
    public async radar$get$attacks$layer7$top$origin$as(params: Params$radar$get$attacks$layer7$top$origin$as, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$top$origin$as$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/top/ases/origin\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Attack Pairs (origin and target locations) By Layer 7 Attacks
     * Get the top attacks from origin to target location. Values are a percentage out of the total layer 7 attacks (with billing country). The attack magnitude can be defined by the number of mitigated requests or by the number of zones affected. You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).
     */
    public async radar$get$attacks$layer7$top$attacks(params: Params$radar$get$attacks$layer7$top$attacks, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$top$attacks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/top/attacks\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            limitDirection: { value: params.parameter.limitDirection, explode: false },
            limitPerLocation: { value: params.parameter.limitPerLocation, explode: false },
            magnitude: { value: params.parameter.magnitude, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top Industry of attack
     * Get the Industry of attacks.
     */
    public async radar$get$attacks$layer7$top$industries(params: Params$radar$get$attacks$layer7$top$industries, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$top$industries$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/top/industry\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Origin Locations By Layer 7 Attacks
     * Get the top origin locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
     */
    public async radar$get$attacks$layer7$top$origin$location(params: Params$radar$get$attacks$layer7$top$origin$location, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$top$origin$location$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/top/locations/origin\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get layer 7 top target locations
     * Get the top target locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The target location is determined by the attacked zone's billing country, when available.
     */
    public async radar$get$attacks$layer7$top$target$location(params: Params$radar$get$attacks$layer7$top$target$location, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$top$target$location$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/top/locations/target\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top Verticals of attack
     * Get the Verticals of attacks.
     */
    public async radar$get$attacks$layer7$top$verticals(params: Params$radar$get$attacks$layer7$top$verticals, option?: RequestOption): Promise<Response$radar$get$attacks$layer7$top$verticals$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/attacks/layer7/top/vertical\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get BGP hijack events
     * Get the BGP hijack events. (Beta)
     */
    public async radar$get$bgp$hijacks$events(params: Params$radar$get$bgp$hijacks$events, option?: RequestOption): Promise<Response$radar$get$bgp$hijacks$events$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/hijacks/events\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            eventId: { value: params.parameter.eventId, explode: false },
            hijackerAsn: { value: params.parameter.hijackerAsn, explode: false },
            victimAsn: { value: params.parameter.victimAsn, explode: false },
            involvedAsn: { value: params.parameter.involvedAsn, explode: false },
            involvedCountry: { value: params.parameter.involvedCountry, explode: false },
            prefix: { value: params.parameter.prefix, explode: false },
            minConfidence: { value: params.parameter.minConfidence, explode: false },
            maxConfidence: { value: params.parameter.maxConfidence, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            sortBy: { value: params.parameter.sortBy, explode: false },
            sortOrder: { value: params.parameter.sortOrder, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get BGP route leak events
     * Get the BGP route leak events (Beta).
     */
    public async radar$get$bgp$route$leak$events(params: Params$radar$get$bgp$route$leak$events, option?: RequestOption): Promise<Response$radar$get$bgp$route$leak$events$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/leaks/events\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            eventId: { value: params.parameter.eventId, explode: false },
            leakAsn: { value: params.parameter.leakAsn, explode: false },
            involvedAsn: { value: params.parameter.involvedAsn, explode: false },
            involvedCountry: { value: params.parameter.involvedCountry, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            sortBy: { value: params.parameter.sortBy, explode: false },
            sortOrder: { value: params.parameter.sortOrder, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get MOASes
     * List all Multi-origin AS (MOAS) prefixes on the global routing tables.
     */
    public async radar$get$bgp$pfx2as$moas(params: Params$radar$get$bgp$pfx2as$moas, option?: RequestOption): Promise<Response$radar$get$bgp$pfx2as$moas$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/routes/moas\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            origin: { value: params.parameter.origin, explode: false },
            prefix: { value: params.parameter.prefix, explode: false },
            invalid_only: { value: params.parameter.invalid_only, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get prefix-to-origin mapping
     * Lookup prefix-to-origin mapping on global routing tables.
     */
    public async radar$get$bgp$pfx2as(params: Params$radar$get$bgp$pfx2as, option?: RequestOption): Promise<Response$radar$get$bgp$pfx2as$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/routes/pfx2as\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            origin: { value: params.parameter.origin, explode: false },
            prefix: { value: params.parameter.prefix, explode: false },
            rpkiStatus: { value: params.parameter.rpkiStatus, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get BGP routing table stats
     * Get the BGP routing table stats (Beta).
     */
    public async radar$get$bgp$routes$stats(params: Params$radar$get$bgp$routes$stats, option?: RequestOption): Promise<Response$radar$get$bgp$routes$stats$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/routes/stats\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get BGP time series
     * Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.
     */
    public async radar$get$bgp$timeseries(params: Params$radar$get$bgp$timeseries, option?: RequestOption): Promise<Response$radar$get$bgp$timeseries$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/timeseries\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            prefix: { value: params.parameter.prefix, explode: false },
            updateType: { value: params.parameter.updateType, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top autonomous systems
     * Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.
     */
    public async radar$get$bgp$top$ases(params: Params$radar$get$bgp$top$ases, option?: RequestOption): Promise<Response$radar$get$bgp$top$ases$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/top/ases\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            prefix: { value: params.parameter.prefix, explode: false },
            updateType: { value: params.parameter.updateType, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get list of ASNs ordered by prefix count
     * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
     */
    public async radar$get$bgp$top$asns$by$prefixes(params: Params$radar$get$bgp$top$asns$by$prefixes, option?: RequestOption): Promise<Response$radar$get$bgp$top$asns$by$prefixes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/top/ases/prefixes\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            country: { value: params.parameter.country, explode: false },
            limit: { value: params.parameter.limit, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top prefixes
     * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
     */
    public async radar$get$bgp$top$prefixes(params: Params$radar$get$bgp$top$prefixes, option?: RequestOption): Promise<Response$radar$get$bgp$top$prefixes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/bgp/top/prefixes\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            updateType: { value: params.parameter.updateType, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Connection Tampering Summary
     * Distribution of connection tampering types over a given time period.
     */
    public async radar$get$connection$tampering$summary(params: Params$radar$get$connection$tampering$summary, option?: RequestOption): Promise<Response$radar$get$connection$tampering$summary$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/connection_tampering/summary\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Connection Tampering Time Series
     * Distribution of connection tampering types over time.
     */
    public async radar$get$connection$tampering$timeseries$group(params: Params$radar$get$connection$tampering$timeseries$group, option?: RequestOption): Promise<Response$radar$get$connection$tampering$timeseries$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/connection_tampering/timeseries_groups\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Datasets
     * Get a list of datasets.
     */
    public async radar$get$reports$datasets(params: Params$radar$get$reports$datasets, option?: RequestOption): Promise<Response$radar$get$reports$datasets$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/datasets\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            offset: { value: params.parameter.offset, explode: false },
            datasetType: { value: params.parameter.datasetType, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Dataset csv Stream
     * Get the csv content of a given dataset by alias or id. When getting the content by alias the latest dataset is returned, optionally filtered by the latest available at a given date.
     */
    public async radar$get$reports$dataset$download(params: Params$radar$get$reports$dataset$download, option?: RequestOption): Promise<Response$radar$get$reports$dataset$download$Status$200["text/csv"]> {
        const url = this.baseUrl + \`/radar/datasets/\${params.parameter.alias}\`;
        const headers = {
            Accept: "text/csv"
        };
        const queryParameters: QueryParameters = {
            date: { value: params.parameter.date, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Dataset download url
     * Get a url to download a single dataset.
     */
    public async radar$post$reports$dataset$download$url(params: Params$radar$post$reports$dataset$download$url, option?: RequestOption): Promise<Response$radar$post$reports$dataset$download$url$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/datasets/download\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems by DNS queries.
     * Get top autonomous systems by DNS queries made to Cloudflare's public DNS resolver.
     */
    public async radar$get$dns$top$ases(params: Params$radar$get$dns$top$ases, option?: RequestOption): Promise<Response$radar$get$dns$top$ases$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/dns/top/ases\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            domain: { value: params.parameter.domain, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations by DNS queries
     * Get top locations by DNS queries made to Cloudflare's public DNS resolver.
     */
    public async radar$get$dns$top$locations(params: Params$radar$get$dns$top$locations, option?: RequestOption): Promise<Response$radar$get$dns$top$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/dns/top/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            domain: { value: params.parameter.domain, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get ARC Validations Summary
     * Percentage distribution of emails classified per ARC validation.
     */
    public async radar$get$email$security$summary$by$arc(params: Params$radar$get$email$security$summary$by$arc, option?: RequestOption): Promise<Response$radar$get$email$security$summary$by$arc$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/summary/arc\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get DKIM Validations Summary
     * Percentage distribution of emails classified per DKIM validation.
     */
    public async radar$get$email$security$summary$by$dkim(params: Params$radar$get$email$security$summary$by$dkim, option?: RequestOption): Promise<Response$radar$get$email$security$summary$by$dkim$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/summary/dkim\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get DMARC Validations Summary
     * Percentage distribution of emails classified per DMARC validation.
     */
    public async radar$get$email$security$summary$by$dmarc(params: Params$radar$get$email$security$summary$by$dmarc, option?: RequestOption): Promise<Response$radar$get$email$security$summary$by$dmarc$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/summary/dmarc\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get MALICIOUS Validations Summary
     * Percentage distribution of emails classified as MALICIOUS.
     */
    public async radar$get$email$security$summary$by$malicious(params: Params$radar$get$email$security$summary$by$malicious, option?: RequestOption): Promise<Response$radar$get$email$security$summary$by$malicious$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/summary/malicious\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get SPAM Summary
     * Proportion of emails categorized as either spam or legitimate (non-spam).
     */
    public async radar$get$email$security$summary$by$spam(params: Params$radar$get$email$security$summary$by$spam, option?: RequestOption): Promise<Response$radar$get$email$security$summary$by$spam$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/summary/spam\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get SPF Validations Summary
     * Percentage distribution of emails classified per SPF validation.
     */
    public async radar$get$email$security$summary$by$spf(params: Params$radar$get$email$security$summary$by$spf, option?: RequestOption): Promise<Response$radar$get$email$security$summary$by$spf$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/summary/spf\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Threat Categories Summary
     * Percentage distribution of emails classified in Threat Categories.
     */
    public async radar$get$email$security$summary$by$threat$category(params: Params$radar$get$email$security$summary$by$threat$category, option?: RequestOption): Promise<Response$radar$get$email$security$summary$by$threat$category$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/summary/threat_category\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get ARC Validations Time Series
     * Percentage distribution of emails classified per Arc validation over time.
     */
    public async radar$get$email$security$timeseries$group$by$arc(params: Params$radar$get$email$security$timeseries$group$by$arc, option?: RequestOption): Promise<Response$radar$get$email$security$timeseries$group$by$arc$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/timeseries_groups/arc\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get DKIM Validations Time Series
     * Percentage distribution of emails classified per DKIM validation over time.
     */
    public async radar$get$email$security$timeseries$group$by$dkim(params: Params$radar$get$email$security$timeseries$group$by$dkim, option?: RequestOption): Promise<Response$radar$get$email$security$timeseries$group$by$dkim$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/timeseries_groups/dkim\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get DMARC Validations Time Series
     * Percentage distribution of emails classified per DMARC validation over time.
     */
    public async radar$get$email$security$timeseries$group$by$dmarc(params: Params$radar$get$email$security$timeseries$group$by$dmarc, option?: RequestOption): Promise<Response$radar$get$email$security$timeseries$group$by$dmarc$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/timeseries_groups/dmarc\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get MALICIOUS Validations Time Series
     * Percentage distribution of emails classified as MALICIOUS over time.
     */
    public async radar$get$email$security$timeseries$group$by$malicious(params: Params$radar$get$email$security$timeseries$group$by$malicious, option?: RequestOption): Promise<Response$radar$get$email$security$timeseries$group$by$malicious$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/timeseries_groups/malicious\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get SPAM Validations Time Series
     * Percentage distribution of emails classified as SPAM over time.
     */
    public async radar$get$email$security$timeseries$group$by$spam(params: Params$radar$get$email$security$timeseries$group$by$spam, option?: RequestOption): Promise<Response$radar$get$email$security$timeseries$group$by$spam$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/timeseries_groups/spam\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get SPF Validations Time Series
     * Percentage distribution of emails classified per SPF validation over time.
     */
    public async radar$get$email$security$timeseries$group$by$spf(params: Params$radar$get$email$security$timeseries$group$by$spf, option?: RequestOption): Promise<Response$radar$get$email$security$timeseries$group$by$spf$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/timeseries_groups/spf\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Threat Categories Time Series
     * Percentage distribution of emails classified in Threat Categories over time.
     */
    public async radar$get$email$security$timeseries$group$by$threat$category(params: Params$radar$get$email$security$timeseries$group$by$threat$category, option?: RequestOption): Promise<Response$radar$get$email$security$timeseries$group$by$threat$category$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/timeseries_groups/threat_category\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top autonomous systems by email messages
     * Get the top autonomous systems (AS) by email messages. Values are a percentage out of the total emails.
     */
    public async radar$get$email$security$top$ases$by$messages(params: Params$radar$get$email$security$top$ases$by$messages, option?: RequestOption): Promise<Response$radar$get$email$security$top$ases$by$messages$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/ases\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By ARC Validation
     * Get the top autonomous systems (AS) by emails ARC validation.
     */
    public async radar$get$email$security$top$ases$by$arc(params: Params$radar$get$email$security$top$ases$by$arc, option?: RequestOption): Promise<Response$radar$get$email$security$top$ases$by$arc$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/ases/arc/\${params.parameter.arc}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By DKIM Validation
     * Get the top autonomous systems (AS), by email DKIM validation.
     */
    public async radar$get$email$security$top$ases$by$dkim(params: Params$radar$get$email$security$top$ases$by$dkim, option?: RequestOption): Promise<Response$radar$get$email$security$top$ases$by$dkim$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/ases/dkim/\${params.parameter.dkim}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By DMARC Validation
     * Get the top autonomous systems (AS) by emails DMARC validation.
     */
    public async radar$get$email$security$top$ases$by$dmarc(params: Params$radar$get$email$security$top$ases$by$dmarc, option?: RequestOption): Promise<Response$radar$get$email$security$top$ases$by$dmarc$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/ases/dmarc/\${params.parameter.dmarc}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By Malicious Classification
     * Get the top autonomous systems (AS), by emails classified as Malicious or not.
     */
    public async radar$get$email$security$top$ases$by$malicious(params: Params$radar$get$email$security$top$ases$by$malicious, option?: RequestOption): Promise<Response$radar$get$email$security$top$ases$by$malicious$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/ases/malicious/\${params.parameter.malicious}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top autonomous systems by Spam validations
     * Get the top autonomous systems (AS), by emails classified, of Spam validations.
     */
    public async radar$get$email$security$top$ases$by$spam(params: Params$radar$get$email$security$top$ases$by$spam, option?: RequestOption): Promise<Response$radar$get$email$security$top$ases$by$spam$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/ases/spam/\${params.parameter.spam}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By SPF Validation
     * Get the top autonomous systems (AS) by email SPF validation.
     */
    public async radar$get$email$security$top$ases$by$spf(params: Params$radar$get$email$security$top$ases$by$spf, option?: RequestOption): Promise<Response$radar$get$email$security$top$ases$by$spf$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/ases/spf/\${params.parameter.spf}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By Email Messages
     * Get the top locations by email messages. Values are a percentage out of the total emails.
     */
    public async radar$get$email$security$top$locations$by$messages(params: Params$radar$get$email$security$top$locations$by$messages, option?: RequestOption): Promise<Response$radar$get$email$security$top$locations$by$messages$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By ARC Validations
     * Get the locations, by emails ARC validation.
     */
    public async radar$get$email$security$top$locations$by$arc(params: Params$radar$get$email$security$top$locations$by$arc, option?: RequestOption): Promise<Response$radar$get$email$security$top$locations$by$arc$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/locations/arc/\${params.parameter.arc}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By DKIM Validation
     * Get the locations, by email DKIM validation.
     */
    public async radar$get$email$security$top$locations$by$dkim(params: Params$radar$get$email$security$top$locations$by$dkim, option?: RequestOption): Promise<Response$radar$get$email$security$top$locations$by$dkim$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/locations/dkim/\${params.parameter.dkim}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By DMARC Validations
     * Get the locations by email DMARC validation.
     */
    public async radar$get$email$security$top$locations$by$dmarc(params: Params$radar$get$email$security$top$locations$by$dmarc, option?: RequestOption): Promise<Response$radar$get$email$security$top$locations$by$dmarc$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/locations/dmarc/\${params.parameter.dmarc}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By Malicious Classification
     * Get the locations by emails classified as malicious or not.
     */
    public async radar$get$email$security$top$locations$by$malicious(params: Params$radar$get$email$security$top$locations$by$malicious, option?: RequestOption): Promise<Response$radar$get$email$security$top$locations$by$malicious$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/locations/malicious/\${params.parameter.malicious}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By Spam Classification
     * Get the top locations by emails classified as Spam or not.
     */
    public async radar$get$email$security$top$locations$by$spam(params: Params$radar$get$email$security$top$locations$by$spam, option?: RequestOption): Promise<Response$radar$get$email$security$top$locations$by$spam$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/locations/spam/\${params.parameter.spam}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            spf: { value: params.parameter.spf, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top locations by SPF validation
     * Get the top locations by email SPF validation.
     */
    public async radar$get$email$security$top$locations$by$spf(params: Params$radar$get$email$security$top$locations$by$spf, option?: RequestOption): Promise<Response$radar$get$email$security$top$locations$by$spf$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/email/security/top/locations/spf/\${params.parameter.spf}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            arc: { value: params.parameter.arc, explode: false },
            dkim: { value: params.parameter.dkim, explode: false },
            dmarc: { value: params.parameter.dmarc, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get autonomous systems
     * Gets a list of autonomous systems (AS).
     */
    public async radar$get$entities$asn$list(params: Params$radar$get$entities$asn$list, option?: RequestOption): Promise<Response$radar$get$entities$asn$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/entities/asns\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            offset: { value: params.parameter.offset, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            orderBy: { value: params.parameter.orderBy, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get autonomous system information by AS number
     * Get the requested autonomous system information. A confidence level below \`5\` indicates a low level of confidence in the traffic data - normally this happens because Cloudflare has a small amount of traffic from/to this AS). Population estimates come from APNIC (refer to https://labs.apnic.net/?p=526).
     */
    public async radar$get$entities$asn$by$id(params: Params$radar$get$entities$asn$by$id, option?: RequestOption): Promise<Response$radar$get$entities$asn$by$id$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/entities/asns/\${params.parameter.asn}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get AS-level relationships by AS number
     * Get AS-level relationship for given networks.
     */
    public async radar$get$asns$rel(params: Params$radar$get$asns$rel, option?: RequestOption): Promise<Response$radar$get$asns$rel$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/entities/asns/\${params.parameter.asn}/rel\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            asn2: { value: params.parameter.asn2, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get autonomous system information by IP address
     * Get the requested autonomous system information based on IP address. Population estimates come from APNIC (refer to https://labs.apnic.net/?p=526).
     */
    public async radar$get$entities$asn$by$ip(params: Params$radar$get$entities$asn$by$ip, option?: RequestOption): Promise<Response$radar$get$entities$asn$by$ip$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/entities/asns/ip\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ip: { value: params.parameter.ip, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get IP address
     * Get IP address information.
     */
    public async radar$get$entities$ip(params: Params$radar$get$entities$ip, option?: RequestOption): Promise<Response$radar$get$entities$ip$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/entities/ip\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ip: { value: params.parameter.ip, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get locations
     * Get a list of locations.
     */
    public async radar$get$entities$locations(params: Params$radar$get$entities$locations, option?: RequestOption): Promise<Response$radar$get$entities$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/entities/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            offset: { value: params.parameter.offset, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get location
     * Get the requested location information. A confidence level below \`5\` indicates a low level of confidence in the traffic data - normally this happens because Cloudflare has a small amount of traffic from/to this location).
     */
    public async radar$get$entities$location$by$alpha2(params: Params$radar$get$entities$location$by$alpha2, option?: RequestOption): Promise<Response$radar$get$entities$location$by$alpha2$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/entities/locations/\${params.parameter.location}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Bot Class Summary
     * Percentage distribution of bot-generated traffic to genuine human traffic, as classified by Cloudflare. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
     */
    public async radar$get$http$summary$by$bot$class(params: Params$radar$get$http$summary$by$bot$class, option?: RequestOption): Promise<Response$radar$get$http$summary$by$bot$class$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/summary/bot_class\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Device Type Summary
     * Percentage of Internet traffic generated by mobile, desktop, and other types of devices, over a given time period.
     */
    public async radar$get$http$summary$by$device$type(params: Params$radar$get$http$summary$by$device$type, option?: RequestOption): Promise<Response$radar$get$http$summary$by$device$type$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/summary/device_type\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get HTTP protocols summary
     * Percentage distribution of traffic per HTTP protocol over a given time period.
     */
    public async radar$get$http$summary$by$http$protocol(params: Params$radar$get$http$summary$by$http$protocol, option?: RequestOption): Promise<Response$radar$get$http$summary$by$http$protocol$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/summary/http_protocol\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get HTTP Versions Summary
     * Percentage distribution of traffic per HTTP protocol version over a given time period.
     */
    public async radar$get$http$summary$by$http$version(params: Params$radar$get$http$summary$by$http$version, option?: RequestOption): Promise<Response$radar$get$http$summary$by$http$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/summary/http_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get IP Version Summary
     * Percentage distribution of Internet traffic based on IP protocol versions, such as IPv4 and IPv6, over a given time period.
     */
    public async radar$get$http$summary$by$ip$version(params: Params$radar$get$http$summary$by$ip$version, option?: RequestOption): Promise<Response$radar$get$http$summary$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/summary/ip_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Operating Systems Summary
     * Percentage distribution of Internet traffic generated by different operating systems like Windows, macOS, Android, iOS, and others, over a given time period.
     */
    public async radar$get$http$summary$by$operating$system(params: Params$radar$get$http$summary$by$operating$system, option?: RequestOption): Promise<Response$radar$get$http$summary$by$operating$system$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/summary/os\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get TLS Versions Summary
     * Percentage distribution of traffic per TLS protocol version, over a given time period.
     */
    public async radar$get$http$summary$by$tls$version(params: Params$radar$get$http$summary$by$tls$version, option?: RequestOption): Promise<Response$radar$get$http$summary$by$tls$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/summary/tls_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Bot Classes Time Series
     * Get a time series of the percentage distribution of traffic classified as automated or human. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
     */
    public async radar$get$http$timeseries$group$by$bot$class(params: Params$radar$get$http$timeseries$group$by$bot$class, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$bot$class$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/bot_class\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get User Agents Time Series
     * Get a time series of the percentage distribution of traffic of the top user agents.
     */
    public async radar$get$http$timeseries$group$by$browsers(params: Params$radar$get$http$timeseries$group$by$browsers, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$browsers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/browser\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            limitPerGroup: { value: params.parameter.limitPerGroup, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get User Agent Families Time Series
     * Get a time series of the percentage distribution of traffic of the top user agents aggregated in families.
     */
    public async radar$get$http$timeseries$group$by$browser$families(params: Params$radar$get$http$timeseries$group$by$browser$families, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$browser$families$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/browser_family\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Device Types Time Series
     * Get a time series of the percentage distribution of traffic per device type.
     */
    public async radar$get$http$timeseries$group$by$device$type(params: Params$radar$get$http$timeseries$group$by$device$type, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$device$type$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/device_type\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get HTTP protocols Time Series
     * Get a time series of the percentage distribution of traffic per HTTP protocol.
     */
    public async radar$get$http$timeseries$group$by$http$protocol(params: Params$radar$get$http$timeseries$group$by$http$protocol, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$http$protocol$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/http_protocol\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get HTTP Versions Time Series
     * Get a time series of the percentage distribution of traffic per HTTP protocol version.
     */
    public async radar$get$http$timeseries$group$by$http$version(params: Params$radar$get$http$timeseries$group$by$http$version, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$http$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/http_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get IP Versions Time Series
     * Get a time series of the percentage distribution of traffic per IP protocol version.
     */
    public async radar$get$http$timeseries$group$by$ip$version(params: Params$radar$get$http$timeseries$group$by$ip$version, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/ip_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Operating Systems Time Series
     * Get a time series of the percentage distribution of traffic of the top operating systems.
     */
    public async radar$get$http$timeseries$group$by$operating$system(params: Params$radar$get$http$timeseries$group$by$operating$system, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$operating$system$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/os\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get TLS Versions Time Series
     * Get a time series of the percentage distribution of traffic per TLS protocol version.
     */
    public async radar$get$http$timeseries$group$by$tls$version(params: Params$radar$get$http$timeseries$group$by$tls$version, option?: RequestOption): Promise<Response$radar$get$http$timeseries$group$by$tls$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/timeseries_groups/tls_version\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By HTTP Requests
     * Get the top autonomous systems by HTTP traffic. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$ases$by$http$requests(params: Params$radar$get$http$top$ases$by$http$requests, option?: RequestOption): Promise<Response$radar$get$http$top$ases$by$http$requests$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/ases\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By Bot Class
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot Scores](https://developers.cloudflare.com/bots/concepts/bot-score) for more information. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$ases$by$bot$class(params: Params$radar$get$http$top$ases$by$bot$class, option?: RequestOption): Promise<Response$radar$get$http$top$ases$by$bot$class$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/ases/bot_class/\${params.parameter.bot_class}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By Device Type
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$ases$by$device$type(params: Params$radar$get$http$top$ases$by$device$type, option?: RequestOption): Promise<Response$radar$get$http$top$ases$by$device$type$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/ases/device_type/\${params.parameter.device_type}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By HTTP Protocol
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$ases$by$http$protocol(params: Params$radar$get$http$top$ases$by$http$protocol, option?: RequestOption): Promise<Response$radar$get$http$top$ases$by$http$protocol$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/ases/http_protocol/\${params.parameter.http_protocol}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By HTTP Version
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol version. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$ases$by$http$version(params: Params$radar$get$http$top$ases$by$http$version, option?: RequestOption): Promise<Response$radar$get$http$top$ases$by$http$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/ases/http_version/\${params.parameter.http_version}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By IP Version
     * Get the top autonomous systems, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$ases$by$ip$version(params: Params$radar$get$http$top$ases$by$ip$version, option?: RequestOption): Promise<Response$radar$get$http$top$ases$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/ases/ip_version/\${params.parameter.ip_version}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By Operating System
     * Get the top autonomous systems, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$ases$by$operating$system(params: Params$radar$get$http$top$ases$by$operating$system, option?: RequestOption): Promise<Response$radar$get$http$top$ases$by$operating$system$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/ases/os/\${params.parameter.os}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By TLS Version
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$ases$by$tls$version(params: Params$radar$get$http$top$ases$by$tls$version, option?: RequestOption): Promise<Response$radar$get$http$top$ases$by$tls$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/ases/tls_version/\${params.parameter.tls_version}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top User Agents Families by HTTP requests
     * Get the top user agents aggregated in families by HTTP traffic. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$browser$families(params: Params$radar$get$http$top$browser$families, option?: RequestOption): Promise<Response$radar$get$http$top$browser$families$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/browser_families\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top User Agents By HTTP requests
     * Get the top user agents by HTTP traffic. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$browsers(params: Params$radar$get$http$top$browsers, option?: RequestOption): Promise<Response$radar$get$http$top$browsers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/browsers\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By HTTP requests
     * Get the top locations by HTTP traffic. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$locations$by$http$requests(params: Params$radar$get$http$top$locations$by$http$requests, option?: RequestOption): Promise<Response$radar$get$http$top$locations$by$http$requests$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By Bot Class
     * Get the top locations, by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot scores])https://developers.cloudflare.com/bots/concepts/bot-score). Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$locations$by$bot$class(params: Params$radar$get$http$top$locations$by$bot$class, option?: RequestOption): Promise<Response$radar$get$http$top$locations$by$bot$class$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/locations/bot_class/\${params.parameter.bot_class}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By Device Type
     * Get the top locations, by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$locations$by$device$type(params: Params$radar$get$http$top$locations$by$device$type, option?: RequestOption): Promise<Response$radar$get$http$top$locations$by$device$type$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/locations/device_type/\${params.parameter.device_type}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By HTTP Protocol
     * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$locations$by$http$protocol(params: Params$radar$get$http$top$locations$by$http$protocol, option?: RequestOption): Promise<Response$radar$get$http$top$locations$by$http$protocol$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/locations/http_protocol/\${params.parameter.http_protocol}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By HTTP Version
     * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$locations$by$http$version(params: Params$radar$get$http$top$locations$by$http$version, option?: RequestOption): Promise<Response$radar$get$http$top$locations$by$http$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/locations/http_version/\${params.parameter.http_version}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By IP Version
     * Get the top locations, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$locations$by$ip$version(params: Params$radar$get$http$top$locations$by$ip$version, option?: RequestOption): Promise<Response$radar$get$http$top$locations$by$ip$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/locations/ip_version/\${params.parameter.ip_version}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By Operating System
     * Get the top locations, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$locations$by$operating$system(params: Params$radar$get$http$top$locations$by$operating$system, option?: RequestOption): Promise<Response$radar$get$http$top$locations$by$operating$system$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/locations/os/\${params.parameter.os}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            tlsVersion: { value: params.parameter.tlsVersion, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By TLS Version
     * Get the top locations, by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
     */
    public async radar$get$http$top$locations$by$tls$version(params: Params$radar$get$http$top$locations$by$tls$version, option?: RequestOption): Promise<Response$radar$get$http$top$locations$by$tls$version$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/http/top/locations/tls_version/\${params.parameter.tls_version}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            botClass: { value: params.parameter.botClass, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            httpProtocol: { value: params.parameter.httpProtocol, explode: false },
            httpVersion: { value: params.parameter.httpVersion, explode: false },
            ipVersion: { value: params.parameter.ipVersion, explode: false },
            os: { value: params.parameter.os, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get NetFlows Time Series
     * Get network traffic change over time. Visit https://en.wikipedia.org/wiki/NetFlow for more information on NetFlows.
     */
    public async radar$get$netflows$timeseries(params: Params$radar$get$netflows$timeseries, option?: RequestOption): Promise<Response$radar$get$netflows$timeseries$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/netflows/timeseries\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            product: { value: params.parameter.product, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            normalization: { value: params.parameter.normalization, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Autonomous Systems By Network Traffic
     * Get the top autonomous systems (AS) by network traffic (NetFlows) over a given time period. Visit https://en.wikipedia.org/wiki/NetFlow for more information.
     */
    public async radar$get$netflows$top$ases(params: Params$radar$get$netflows$top$ases, option?: RequestOption): Promise<Response$radar$get$netflows$top$ases$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/netflows/top/ases\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Locations By Network Traffic
     * Get the top locations by network traffic (NetFlows) over a given time period. Visit https://en.wikipedia.org/wiki/NetFlow for more information.
     */
    public async radar$get$netflows$top$locations(params: Params$radar$get$netflows$top$locations, option?: RequestOption): Promise<Response$radar$get$netflows$top$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/netflows/top/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get IQI Summary
     * Get a summary (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
     */
    public async radar$get$quality$index$summary(params: Params$radar$get$quality$index$summary, option?: RequestOption): Promise<Response$radar$get$quality$index$summary$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/quality/iqi/summary\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            continent: { value: params.parameter.continent, explode: false },
            metric: { value: params.parameter.metric, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get IQI Time Series
     * Get a time series (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
     */
    public async radar$get$quality$index$timeseries$group(params: Params$radar$get$quality$index$timeseries$group, option?: RequestOption): Promise<Response$radar$get$quality$index$timeseries$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/quality/iqi/timeseries_groups\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            aggInterval: { value: params.parameter.aggInterval, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            continent: { value: params.parameter.continent, explode: false },
            interpolation: { value: params.parameter.interpolation, explode: false },
            metric: { value: params.parameter.metric, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Speed Tests Histogram
     * Get an histogram from the previous 90 days of Cloudflare Speed Test data, split into fixed bandwidth (Mbps), latency (ms) or jitter (ms) buckets.
     */
    public async radar$get$quality$speed$histogram(params: Params$radar$get$quality$speed$histogram, option?: RequestOption): Promise<Response$radar$get$quality$speed$histogram$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/quality/speed/histogram\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            bucketSize: { value: params.parameter.bucketSize, explode: false },
            metricGroup: { value: params.parameter.metricGroup, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Speed Tests Summary
     * Get a summary of bandwidth, latency, jitter and packet loss, from the previous 90 days of Cloudflare Speed Test data.
     */
    public async radar$get$quality$speed$summary(params: Params$radar$get$quality$speed$summary, option?: RequestOption): Promise<Response$radar$get$quality$speed$summary$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/quality/speed/summary\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Speed Test Autonomous Systems
     * Get the top autonomous systems by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
     */
    public async radar$get$quality$speed$top$ases(params: Params$radar$get$quality$speed$top$ases, option?: RequestOption): Promise<Response$radar$get$quality$speed$top$ases$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/quality/speed/top/ases\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            orderBy: { value: params.parameter.orderBy, explode: false },
            reverse: { value: params.parameter.reverse, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Speed Test Locations
     * Get the top locations by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
     */
    public async radar$get$quality$speed$top$locations(params: Params$radar$get$quality$speed$top$locations, option?: RequestOption): Promise<Response$radar$get$quality$speed$top$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/quality/speed/top/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            orderBy: { value: params.parameter.orderBy, explode: false },
            reverse: { value: params.parameter.reverse, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Domains Rank details
     * Gets Domains Rank details.
     *     Cloudflare provides an ordered rank for the top 100 domains, but for the remainder it only provides ranking buckets
     *     like top 200 thousand, top one million, etc.. These are available through Radar datasets endpoints.
     */
    public async radar$get$ranking$domain$details(params: Params$radar$get$ranking$domain$details, option?: RequestOption): Promise<Response$radar$get$ranking$domain$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/ranking/domain/\${params.parameter.domain}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            rankingType: { value: params.parameter.rankingType, explode: false },
            name: { value: params.parameter.name, explode: false },
            date: { value: params.parameter.date, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Domains Rank time series
     * Gets Domains Rank updates change over time. Raw values are returned.
     */
    public async radar$get$ranking$domain$timeseries(params: Params$radar$get$ranking$domain$timeseries, option?: RequestOption): Promise<Response$radar$get$ranking$domain$timeseries$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/ranking/timeseries_groups\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            rankingType: { value: params.parameter.rankingType, explode: false },
            name: { value: params.parameter.name, explode: false },
            location: { value: params.parameter.location, explode: false },
            domains: { value: params.parameter.domains, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top or Trending Domains
     * Get top or trending domains based on their rank. Popular domains are domains of broad appeal based on how people use the Internet. Trending domains are domains that are generating a surge in interest. For more information on top domains, see https://blog.cloudflare.com/radar-domain-rankings/.
     */
    public async radar$get$ranking$top$domains(params: Params$radar$get$ranking$top$domains, option?: RequestOption): Promise<Response$radar$get$ranking$top$domains$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/ranking/top\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            location: { value: params.parameter.location, explode: false },
            date: { value: params.parameter.date, explode: false },
            rankingType: { value: params.parameter.rankingType, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Search for locations, autonomous systems (AS) and reports.
     * Lets you search for locations, autonomous systems (AS) and reports.
     */
    public async radar$get$search$global(params: Params$radar$get$search$global, option?: RequestOption): Promise<Response$radar$get$search$global$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/search/global\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            limitPerGroup: { value: params.parameter.limitPerGroup, explode: false },
            query: { value: params.parameter.query, explode: false },
            include: { value: params.parameter.include, explode: false },
            exclude: { value: params.parameter.exclude, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get latest Internet traffic anomalies.
     * Internet traffic anomalies are signals that might point to an outage,
     *         These alerts are automatically detected by Radar and then manually verified by our team.
     *         This endpoint returns the latest alerts.
     *
     */
    public async radar$get$traffic$anomalies(params: Params$radar$get$traffic$anomalies, option?: RequestOption): Promise<Response$radar$get$traffic$anomalies$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/traffic_anomalies\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            offset: { value: params.parameter.offset, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            status: { value: params.parameter.status, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get top locations by total traffic anomalies generated.
     * Internet traffic anomalies are signals that might point to an outage,
     *         These alerts are automatically detected by Radar and then manually verified by our team.
     *         This endpoint returns the sum of alerts grouped by location.
     *
     */
    public async radar$get$traffic$anomalies$top(params: Params$radar$get$traffic$anomalies$top, option?: RequestOption): Promise<Response$radar$get$traffic$anomalies$top$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/traffic_anomalies/locations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            status: { value: params.parameter.status, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Verified Bots By HTTP Requests
     * Get top verified bots by HTTP requests, with owner and category.
     */
    public async radar$get$verified$bots$top$by$http$requests(params: Params$radar$get$verified$bots$top$by$http$requests, option?: RequestOption): Promise<Response$radar$get$verified$bots$top$by$http$requests$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/verified_bots/top/bots\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Top Verified Bot Categories By HTTP Requests
     * Get top verified bot categories by HTTP requests, along with their corresponding percentage, over the total verified bot HTTP requests.
     */
    public async radar$get$verified$bots$top$categories$by$http$requests(params: Params$radar$get$verified$bots$top$categories$by$http$requests, option?: RequestOption): Promise<Response$radar$get$verified$bots$top$categories$by$http$requests$Status$200["application/json"]> {
        const url = this.baseUrl + \`/radar/verified_bots/top/categories\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            limit: { value: params.parameter.limit, explode: false },
            name: { value: params.parameter.name, explode: false },
            dateRange: { value: params.parameter.dateRange, explode: false },
            dateStart: { value: params.parameter.dateStart, explode: false },
            dateEnd: { value: params.parameter.dateEnd, explode: false },
            asn: { value: params.parameter.asn, explode: false },
            location: { value: params.parameter.location, explode: false },
            format: { value: params.parameter.format, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** User Details */
    public async user$user$details(option?: RequestOption): Promise<Response$user$user$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Edit User
     * Edit part of your user details.
     */
    public async user$edit$user(params: Params$user$edit$user, option?: RequestOption): Promise<Response$user$edit$user$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get user audit logs
     * Gets a list of audit logs for a user account. Can be filtered by who made the change, on which zone, and the timeframe of the change.
     */
    public async audit$logs$get$user$audit$logs(params: Params$audit$logs$get$user$audit$logs, option?: RequestOption): Promise<Response$audit$logs$get$user$audit$logs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/audit_logs\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            id: { value: params.parameter.id, explode: false },
            export: { value: params.parameter.export, explode: false },
            "action.type": { value: params.parameter["action.type"], explode: false },
            "actor.ip": { value: params.parameter["actor.ip"], explode: false },
            "actor.email": { value: params.parameter["actor.email"], explode: false },
            since: { value: params.parameter.since, explode: false },
            before: { value: params.parameter.before, explode: false },
            "zone.name": { value: params.parameter["zone.name"], explode: false },
            direction: { value: params.parameter.direction, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            page: { value: params.parameter.page, explode: false },
            hide_user_logs: { value: params.parameter.hide_user_logs, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Billing History Details
     * Accesses your billing history object.
     */
    public async user$billing$history$$$deprecated$$billing$history$details(params: Params$user$billing$history$$$deprecated$$billing$history$details, option?: RequestOption): Promise<Response$user$billing$history$$$deprecated$$billing$history$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/billing/history\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            occured_at: { value: params.parameter.occured_at, explode: false },
            occurred_at: { value: params.parameter.occurred_at, explode: false },
            type: { value: params.parameter.type, explode: false },
            action: { value: params.parameter.action, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Billing Profile Details
     * Accesses your billing profile object.
     */
    public async user$billing$profile$$$deprecated$$billing$profile$details(option?: RequestOption): Promise<Response$user$billing$profile$$$deprecated$$billing$profile$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/billing/profile\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List IP Access rules
     * Fetches IP Access rules of the user. You can filter the results using several optional parameters.
     */
    public async ip$access$rules$for$a$user$list$ip$access$rules(params: Params$ip$access$rules$for$a$user$list$ip$access$rules, option?: RequestOption): Promise<Response$ip$access$rules$for$a$user$list$ip$access$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/firewall/access_rules/rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            filters: { value: params.parameter.filters, explode: false },
            "egs-pagination.json": { value: params.parameter["egs-pagination.json"], explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create an IP Access rule
     * Creates a new IP Access rule for all zones owned by the current user.
     *
     * Note: To create an IP Access rule that applies to a specific zone, refer to the [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints.
     */
    public async ip$access$rules$for$a$user$create$an$ip$access$rule(params: Params$ip$access$rules$for$a$user$create$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$a$user$create$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/firewall/access_rules/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an IP Access rule
     * Deletes an IP Access rule at the user level.
     *
     * Note: Deleting a user-level rule will affect all zones owned by the user.
     */
    public async ip$access$rules$for$a$user$delete$an$ip$access$rule(params: Params$ip$access$rules$for$a$user$delete$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$a$user$delete$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/firewall/access_rules/rules/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update an IP Access rule
     * Updates an IP Access rule defined at the user level. You can only update the rule action (\`mode\` parameter) and notes.
     */
    public async ip$access$rules$for$a$user$update$an$ip$access$rule(params: Params$ip$access$rules$for$a$user$update$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$a$user$update$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/firewall/access_rules/rules/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Invitations
     * Lists all invitations associated with my user.
     */
    public async user$$s$invites$list$invitations(option?: RequestOption): Promise<Response$user$$s$invites$list$invitations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/invites\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Invitation Details
     * Gets the details of an invitation.
     */
    public async user$$s$invites$invitation$details(params: Params$user$$s$invites$invitation$details, option?: RequestOption): Promise<Response$user$$s$invites$invitation$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/invites/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Respond to Invitation
     * Responds to an invitation.
     */
    public async user$$s$invites$respond$to$invitation(params: Params$user$$s$invites$respond$to$invitation, option?: RequestOption): Promise<Response$user$$s$invites$respond$to$invitation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/invites/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Monitors
     * List configured monitors for a user.
     */
    public async load$balancer$monitors$list$monitors(option?: RequestOption): Promise<Response$load$balancer$monitors$list$monitors$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/monitors\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Monitor
     * Create a configured monitor.
     */
    public async load$balancer$monitors$create$monitor(params: Params$load$balancer$monitors$create$monitor, option?: RequestOption): Promise<Response$load$balancer$monitors$create$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/monitors\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Monitor Details
     * List a single configured monitor for a user.
     */
    public async load$balancer$monitors$monitor$details(params: Params$load$balancer$monitors$monitor$details, option?: RequestOption): Promise<Response$load$balancer$monitors$monitor$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/monitors/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Monitor
     * Modify a configured monitor.
     */
    public async load$balancer$monitors$update$monitor(params: Params$load$balancer$monitors$update$monitor, option?: RequestOption): Promise<Response$load$balancer$monitors$update$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/monitors/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Monitor
     * Delete a configured monitor.
     */
    public async load$balancer$monitors$delete$monitor(params: Params$load$balancer$monitors$delete$monitor, option?: RequestOption): Promise<Response$load$balancer$monitors$delete$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/monitors/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Monitor
     * Apply changes to an existing monitor, overwriting the supplied properties.
     */
    public async load$balancer$monitors$patch$monitor(params: Params$load$balancer$monitors$patch$monitor, option?: RequestOption): Promise<Response$load$balancer$monitors$patch$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/monitors/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Preview Monitor
     * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
     */
    public async load$balancer$monitors$preview$monitor(params: Params$load$balancer$monitors$preview$monitor, option?: RequestOption): Promise<Response$load$balancer$monitors$preview$monitor$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/monitors/\${params.parameter.identifier}/preview\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Monitor References
     * Get the list of resources that reference the provided monitor.
     */
    public async load$balancer$monitors$list$monitor$references(params: Params$load$balancer$monitors$list$monitor$references, option?: RequestOption): Promise<Response$load$balancer$monitors$list$monitor$references$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/monitors/\${params.parameter.identifier}/references\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Pools
     * List configured pools.
     */
    public async load$balancer$pools$list$pools(params: Params$load$balancer$pools$list$pools, option?: RequestOption): Promise<Response$load$balancer$pools$list$pools$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            monitor: { value: params.parameter.monitor, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create Pool
     * Create a new pool.
     */
    public async load$balancer$pools$create$pool(params: Params$load$balancer$pools$create$pool, option?: RequestOption): Promise<Response$load$balancer$pools$create$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Patch Pools
     * Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending \`name\`. Returns the list of affected pools. Supports the standard pagination query parameters, either \`limit\`/\`offset\` or \`per_page\`/\`page\`.
     */
    public async load$balancer$pools$patch$pools(params: Params$load$balancer$pools$patch$pools, option?: RequestOption): Promise<Response$load$balancer$pools$patch$pools$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Pool Details
     * Fetch a single configured pool.
     */
    public async load$balancer$pools$pool$details(params: Params$load$balancer$pools$pool$details, option?: RequestOption): Promise<Response$load$balancer$pools$pool$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Pool
     * Modify a configured pool.
     */
    public async load$balancer$pools$update$pool(params: Params$load$balancer$pools$update$pool, option?: RequestOption): Promise<Response$load$balancer$pools$update$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Pool
     * Delete a configured pool.
     */
    public async load$balancer$pools$delete$pool(params: Params$load$balancer$pools$delete$pool, option?: RequestOption): Promise<Response$load$balancer$pools$delete$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Pool
     * Apply changes to an existing pool, overwriting the supplied properties.
     */
    public async load$balancer$pools$patch$pool(params: Params$load$balancer$pools$patch$pool, option?: RequestOption): Promise<Response$load$balancer$pools$patch$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Pool Health Details
     * Fetch the latest pool health status for a single pool.
     */
    public async load$balancer$pools$pool$health$details(params: Params$load$balancer$pools$pool$health$details, option?: RequestOption): Promise<Response$load$balancer$pools$pool$health$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools/\${params.parameter.identifier}/health\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Preview Pool
     * Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
     */
    public async load$balancer$pools$preview$pool(params: Params$load$balancer$pools$preview$pool, option?: RequestOption): Promise<Response$load$balancer$pools$preview$pool$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools/\${params.parameter.identifier}/preview\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Pool References
     * Get the list of resources that reference the provided pool.
     */
    public async load$balancer$pools$list$pool$references(params: Params$load$balancer$pools$list$pool$references, option?: RequestOption): Promise<Response$load$balancer$pools$list$pool$references$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/pools/\${params.parameter.identifier}/references\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Preview Result
     * Get the result of a previous preview operation using the provided preview_id.
     */
    public async load$balancer$monitors$preview$result(params: Params$load$balancer$monitors$preview$result, option?: RequestOption): Promise<Response$load$balancer$monitors$preview$result$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancers/preview/\${params.parameter.preview_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Healthcheck Events
     * List origin health changes.
     */
    public async load$balancer$healthcheck$events$list$healthcheck$events(params: Params$load$balancer$healthcheck$events$list$healthcheck$events, option?: RequestOption): Promise<Response$load$balancer$healthcheck$events$list$healthcheck$events$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/load_balancing_analytics/events\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            until: { value: params.parameter.until, explode: false },
            pool_name: { value: params.parameter.pool_name, explode: false },
            origin_healthy: { value: params.parameter.origin_healthy, explode: false },
            identifier: { value: params.parameter.identifier, explode: false },
            since: { value: params.parameter.since, explode: false },
            origin_name: { value: params.parameter.origin_name, explode: false },
            pool_healthy: { value: params.parameter.pool_healthy, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Organizations
     * Lists organizations the user is associated with.
     */
    public async user$$s$organizations$list$organizations(params: Params$user$$s$organizations$list$organizations, option?: RequestOption): Promise<Response$user$$s$organizations$list$organizations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/organizations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            match: { value: params.parameter.match, explode: false },
            status: { value: params.parameter.status, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Organization Details
     * Gets a specific organization the user is associated with.
     */
    public async user$$s$organizations$organization$details(params: Params$user$$s$organizations$organization$details, option?: RequestOption): Promise<Response$user$$s$organizations$organization$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/organizations/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Leave Organization
     * Removes association to an organization.
     */
    public async user$$s$organizations$leave$organization(params: Params$user$$s$organizations$leave$organization, option?: RequestOption): Promise<Response$user$$s$organizations$leave$organization$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/organizations/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get User Subscriptions
     * Lists all of a user's subscriptions.
     */
    public async user$subscription$get$user$subscriptions(option?: RequestOption): Promise<Response$user$subscription$get$user$subscriptions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/subscriptions\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update User Subscription
     * Updates a user's subscriptions.
     */
    public async user$subscription$update$user$subscription(params: Params$user$subscription$update$user$subscription, option?: RequestOption): Promise<Response$user$subscription$update$user$subscription$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/subscriptions/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete User Subscription
     * Deletes a user's subscription.
     */
    public async user$subscription$delete$user$subscription(params: Params$user$subscription$delete$user$subscription, option?: RequestOption): Promise<Response$user$subscription$delete$user$subscription$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/subscriptions/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Tokens
     * List all access tokens you created.
     */
    public async user$api$tokens$list$tokens(params: Params$user$api$tokens$list$tokens, option?: RequestOption): Promise<Response$user$api$tokens$list$tokens$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/tokens\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create Token
     * Create a new access token.
     */
    public async user$api$tokens$create$token(params: Params$user$api$tokens$create$token, option?: RequestOption): Promise<Response$user$api$tokens$create$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/tokens\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Token Details
     * Get information about a specific token.
     */
    public async user$api$tokens$token$details(params: Params$user$api$tokens$token$details, option?: RequestOption): Promise<Response$user$api$tokens$token$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/tokens/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Token
     * Update an existing token.
     */
    public async user$api$tokens$update$token(params: Params$user$api$tokens$update$token, option?: RequestOption): Promise<Response$user$api$tokens$update$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/tokens/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Token
     * Destroy a token.
     */
    public async user$api$tokens$delete$token(params: Params$user$api$tokens$delete$token, option?: RequestOption): Promise<Response$user$api$tokens$delete$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/tokens/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Roll Token
     * Roll the token secret.
     */
    public async user$api$tokens$roll$token(params: Params$user$api$tokens$roll$token, option?: RequestOption): Promise<Response$user$api$tokens$roll$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/tokens/\${params.parameter.identifier}/value\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Permission Groups
     * Find all available permission groups.
     */
    public async permission$groups$list$permission$groups(option?: RequestOption): Promise<Response$permission$groups$list$permission$groups$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/tokens/permission_groups\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Verify Token
     * Test whether a token works.
     */
    public async user$api$tokens$verify$token(option?: RequestOption): Promise<Response$user$api$tokens$verify$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/user/tokens/verify\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Zones
     * Lists, searches, sorts, and filters your zones.
     */
    public async zones$get(params: Params$zones$get, option?: RequestOption): Promise<Response$zones$get$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            status: { value: params.parameter.status, explode: false },
            "account.id": { value: params.parameter["account.id"], explode: false },
            "account.name": { value: params.parameter["account.name"], explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            match: { value: params.parameter.match, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Create Zone */
    public async zones$post(params: Params$zones$post, option?: RequestOption): Promise<Response$zones$post$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Access Applications
     * List all Access Applications in a zone.
     */
    public async zone$level$access$applications$list$access$applications(params: Params$zone$level$access$applications$list$access$applications, option?: RequestOption): Promise<Response$zone$level$access$applications$list$access$applications$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add an Access application
     * Adds a new application to Access.
     */
    public async zone$level$access$applications$add$a$bookmark$application(params: Params$zone$level$access$applications$add$a$bookmark$application, option?: RequestOption): Promise<Response$zone$level$access$applications$add$a$bookmark$application$Status$201["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an Access application
     * Fetches information about an Access application.
     */
    public async zone$level$access$applications$get$an$access$application(params: Params$zone$level$access$applications$get$an$access$application, option?: RequestOption): Promise<Response$zone$level$access$applications$get$an$access$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an Access application
     * Updates an Access application.
     */
    public async zone$level$access$applications$update$a$bookmark$application(params: Params$zone$level$access$applications$update$a$bookmark$application, option?: RequestOption): Promise<Response$zone$level$access$applications$update$a$bookmark$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an Access application
     * Deletes an application from Access.
     */
    public async zone$level$access$applications$delete$an$access$application(params: Params$zone$level$access$applications$delete$an$access$application, option?: RequestOption): Promise<Response$zone$level$access$applications$delete$an$access$application$Status$202["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Revoke application tokens
     * Revokes all tokens issued for an application.
     */
    public async zone$level$access$applications$revoke$service$tokens(params: Params$zone$level$access$applications$revoke$service$tokens, option?: RequestOption): Promise<Response$zone$level$access$applications$revoke$service$tokens$Status$202["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}/revoke_tokens\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Test Access policies
     * Tests if a specific user has permission to access an application.
     */
    public async zone$level$access$applications$test$access$policies(params: Params$zone$level$access$applications$test$access$policies, option?: RequestOption): Promise<Response$zone$level$access$applications$test$access$policies$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.app_id}/user_policy_checks\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get a short-lived certificate CA
     * Fetches a short-lived certificate CA and its public key.
     */
    public async zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca(params: Params$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca, option?: RequestOption): Promise<Response$zone$level$access$short$lived$certificate$c$as$get$a$short$lived$certificate$ca$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/ca\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a short-lived certificate CA
     * Generates a new short-lived certificate CA and public key.
     */
    public async zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca(params: Params$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca, option?: RequestOption): Promise<Response$zone$level$access$short$lived$certificate$c$as$create$a$short$lived$certificate$ca$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/ca\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Delete a short-lived certificate CA
     * Deletes a short-lived certificate CA.
     */
    public async zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca(params: Params$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca, option?: RequestOption): Promise<Response$zone$level$access$short$lived$certificate$c$as$delete$a$short$lived$certificate$ca$Status$202["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/ca\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Access policies
     * Lists Access policies configured for an application.
     */
    public async zone$level$access$policies$list$access$policies(params: Params$zone$level$access$policies$list$access$policies, option?: RequestOption): Promise<Response$zone$level$access$policies$list$access$policies$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/policies\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create an Access policy
     * Create a new Access policy for an application.
     */
    public async zone$level$access$policies$create$an$access$policy(params: Params$zone$level$access$policies$create$an$access$policy, option?: RequestOption): Promise<Response$zone$level$access$policies$create$an$access$policy$Status$201["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid}/policies\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an Access policy
     * Fetches a single Access policy.
     */
    public async zone$level$access$policies$get$an$access$policy(params: Params$zone$level$access$policies$get$an$access$policy, option?: RequestOption): Promise<Response$zone$level$access$policies$get$an$access$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid1}/policies/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an Access policy
     * Update a configured Access policy.
     */
    public async zone$level$access$policies$update$an$access$policy(params: Params$zone$level$access$policies$update$an$access$policy, option?: RequestOption): Promise<Response$zone$level$access$policies$update$an$access$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid1}/policies/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an Access policy
     * Delete an Access policy.
     */
    public async zone$level$access$policies$delete$an$access$policy(params: Params$zone$level$access$policies$delete$an$access$policy, option?: RequestOption): Promise<Response$zone$level$access$policies$delete$an$access$policy$Status$202["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/\${params.parameter.uuid1}/policies/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List short-lived certificate CAs
     * Lists short-lived certificate CAs and their public keys.
     */
    public async zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as(params: Params$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as, option?: RequestOption): Promise<Response$zone$level$access$short$lived$certificate$c$as$list$short$lived$certificate$c$as$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/apps/ca\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List mTLS certificates
     * Lists all mTLS certificates.
     */
    public async zone$level$access$mtls$authentication$list$mtls$certificates(params: Params$zone$level$access$mtls$authentication$list$mtls$certificates, option?: RequestOption): Promise<Response$zone$level$access$mtls$authentication$list$mtls$certificates$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/certificates\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add an mTLS certificate
     * Adds a new mTLS root certificate to Access.
     */
    public async zone$level$access$mtls$authentication$add$an$mtls$certificate(params: Params$zone$level$access$mtls$authentication$add$an$mtls$certificate, option?: RequestOption): Promise<Response$zone$level$access$mtls$authentication$add$an$mtls$certificate$Status$201["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/certificates\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an mTLS certificate
     * Fetches a single mTLS certificate.
     */
    public async zone$level$access$mtls$authentication$get$an$mtls$certificate(params: Params$zone$level$access$mtls$authentication$get$an$mtls$certificate, option?: RequestOption): Promise<Response$zone$level$access$mtls$authentication$get$an$mtls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/certificates/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an mTLS certificate
     * Updates a configured mTLS certificate.
     */
    public async zone$level$access$mtls$authentication$update$an$mtls$certificate(params: Params$zone$level$access$mtls$authentication$update$an$mtls$certificate, option?: RequestOption): Promise<Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/certificates/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an mTLS certificate
     * Deletes an mTLS certificate.
     */
    public async zone$level$access$mtls$authentication$delete$an$mtls$certificate(params: Params$zone$level$access$mtls$authentication$delete$an$mtls$certificate, option?: RequestOption): Promise<Response$zone$level$access$mtls$authentication$delete$an$mtls$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/certificates/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List all mTLS hostname settings
     * List all mTLS hostname settings for this zone.
     */
    public async zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings(params: Params$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings, option?: RequestOption): Promise<Response$zone$level$access$mtls$authentication$list$mtls$certificates$hostname$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/certificates/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an mTLS certificate's hostname settings
     * Updates an mTLS certificate's hostname settings.
     */
    public async zone$level$access$mtls$authentication$update$an$mtls$certificate$settings(params: Params$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings, option?: RequestOption): Promise<Response$zone$level$access$mtls$authentication$update$an$mtls$certificate$settings$Status$202["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/certificates/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Access groups
     * Lists all Access groups.
     */
    public async zone$level$access$groups$list$access$groups(params: Params$zone$level$access$groups$list$access$groups, option?: RequestOption): Promise<Response$zone$level$access$groups$list$access$groups$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/groups\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create an Access group
     * Creates a new Access group.
     */
    public async zone$level$access$groups$create$an$access$group(params: Params$zone$level$access$groups$create$an$access$group, option?: RequestOption): Promise<Response$zone$level$access$groups$create$an$access$group$Status$201["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/groups\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an Access group
     * Fetches a single Access group.
     */
    public async zone$level$access$groups$get$an$access$group(params: Params$zone$level$access$groups$get$an$access$group, option?: RequestOption): Promise<Response$zone$level$access$groups$get$an$access$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/groups/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an Access group
     * Updates a configured Access group.
     */
    public async zone$level$access$groups$update$an$access$group(params: Params$zone$level$access$groups$update$an$access$group, option?: RequestOption): Promise<Response$zone$level$access$groups$update$an$access$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/groups/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an Access group
     * Deletes an Access group.
     */
    public async zone$level$access$groups$delete$an$access$group(params: Params$zone$level$access$groups$delete$an$access$group, option?: RequestOption): Promise<Response$zone$level$access$groups$delete$an$access$group$Status$202["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/groups/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Access identity providers
     * Lists all configured identity providers.
     */
    public async zone$level$access$identity$providers$list$access$identity$providers(params: Params$zone$level$access$identity$providers$list$access$identity$providers, option?: RequestOption): Promise<Response$zone$level$access$identity$providers$list$access$identity$providers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/identity_providers\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Add an Access identity provider
     * Adds a new identity provider to Access.
     */
    public async zone$level$access$identity$providers$add$an$access$identity$provider(params: Params$zone$level$access$identity$providers$add$an$access$identity$provider, option?: RequestOption): Promise<Response$zone$level$access$identity$providers$add$an$access$identity$provider$Status$201["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/identity_providers\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get an Access identity provider
     * Fetches a configured identity provider.
     */
    public async zone$level$access$identity$providers$get$an$access$identity$provider(params: Params$zone$level$access$identity$providers$get$an$access$identity$provider, option?: RequestOption): Promise<Response$zone$level$access$identity$providers$get$an$access$identity$provider$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/identity_providers/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update an Access identity provider
     * Updates a configured identity provider.
     */
    public async zone$level$access$identity$providers$update$an$access$identity$provider(params: Params$zone$level$access$identity$providers$update$an$access$identity$provider, option?: RequestOption): Promise<Response$zone$level$access$identity$providers$update$an$access$identity$provider$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/identity_providers/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an Access identity provider
     * Deletes an identity provider from Access.
     */
    public async zone$level$access$identity$providers$delete$an$access$identity$provider(params: Params$zone$level$access$identity$providers$delete$an$access$identity$provider, option?: RequestOption): Promise<Response$zone$level$access$identity$providers$delete$an$access$identity$provider$Status$202["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/identity_providers/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get your Zero Trust organization
     * Returns the configuration for your Zero Trust organization.
     */
    public async zone$level$zero$trust$organization$get$your$zero$trust$organization(params: Params$zone$level$zero$trust$organization$get$your$zero$trust$organization, option?: RequestOption): Promise<Response$zone$level$zero$trust$organization$get$your$zero$trust$organization$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/organizations\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update your Zero Trust organization
     * Updates the configuration for your Zero Trust organization.
     */
    public async zone$level$zero$trust$organization$update$your$zero$trust$organization(params: Params$zone$level$zero$trust$organization$update$your$zero$trust$organization, option?: RequestOption): Promise<Response$zone$level$zero$trust$organization$update$your$zero$trust$organization$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/organizations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create your Zero Trust organization
     * Sets up a Zero Trust organization for your account.
     */
    public async zone$level$zero$trust$organization$create$your$zero$trust$organization(params: Params$zone$level$zero$trust$organization$create$your$zero$trust$organization, option?: RequestOption): Promise<Response$zone$level$zero$trust$organization$create$your$zero$trust$organization$Status$201["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/organizations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Revoke all Access tokens for a user
     * Revokes a user's access across all applications.
     */
    public async zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user(params: Params$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user, option?: RequestOption): Promise<Response$zone$level$zero$trust$organization$revoke$all$access$tokens$for$a$user$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/organizations/revoke_user\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List service tokens
     * Lists all service tokens.
     */
    public async zone$level$access$service$tokens$list$service$tokens(params: Params$zone$level$access$service$tokens$list$service$tokens, option?: RequestOption): Promise<Response$zone$level$access$service$tokens$list$service$tokens$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/service_tokens\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a service token
     * Generates a new service token. **Note:** This is the only time you can get the Client Secret. If you lose the Client Secret, you will have to create a new service token.
     */
    public async zone$level$access$service$tokens$create$a$service$token(params: Params$zone$level$access$service$tokens$create$a$service$token, option?: RequestOption): Promise<Response$zone$level$access$service$tokens$create$a$service$token$Status$201["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/service_tokens\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update a service token
     * Updates a configured service token.
     */
    public async zone$level$access$service$tokens$update$a$service$token(params: Params$zone$level$access$service$tokens$update$a$service$token, option?: RequestOption): Promise<Response$zone$level$access$service$tokens$update$a$service$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/service_tokens/\${params.parameter.uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a service token
     * Deletes a service token.
     */
    public async zone$level$access$service$tokens$delete$a$service$token(params: Params$zone$level$access$service$tokens$delete$a$service$token, option?: RequestOption): Promise<Response$zone$level$access$service$tokens$delete$a$service$token$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/access/service_tokens/\${params.parameter.uuid}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Table
     * Retrieves a list of summarised aggregate metrics over a given time period.
     *
     * See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.
     */
    public async dns$analytics$table(params: Params$dns$analytics$table, option?: RequestOption): Promise<Response$dns$analytics$table$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/dns_analytics/report\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            metrics: { value: params.parameter.metrics, explode: false },
            dimensions: { value: params.parameter.dimensions, explode: false },
            since: { value: params.parameter.since, explode: false },
            until: { value: params.parameter.until, explode: false },
            limit: { value: params.parameter.limit, explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filters: { value: params.parameter.filters, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * By Time
     * Retrieves a list of aggregate metrics grouped by time interval.
     *
     * See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.
     */
    public async dns$analytics$by$time(params: Params$dns$analytics$by$time, option?: RequestOption): Promise<Response$dns$analytics$by$time$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/dns_analytics/report/bytime\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            metrics: { value: params.parameter.metrics, explode: false },
            dimensions: { value: params.parameter.dimensions, explode: false },
            since: { value: params.parameter.since, explode: false },
            until: { value: params.parameter.until, explode: false },
            limit: { value: params.parameter.limit, explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filters: { value: params.parameter.filters, explode: false },
            time_delta: { value: params.parameter.time_delta, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Load Balancers
     * List configured load balancers.
     */
    public async load$balancers$list$load$balancers(params: Params$load$balancers$list$load$balancers, option?: RequestOption): Promise<Response$load$balancers$list$load$balancers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/load_balancers\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Load Balancer
     * Create a new load balancer.
     */
    public async load$balancers$create$load$balancer(params: Params$load$balancers$create$load$balancer, option?: RequestOption): Promise<Response$load$balancers$create$load$balancer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/load_balancers\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Purge Cached Content
     * ### Purge All Cached Content
     * Removes ALL files from Cloudflare's cache. All tiers can purge everything.
     *
     * ### Purge Cached Content by URL
     * Granularly removes one or more files from Cloudflare's cache by specifying URLs. All tiers can purge by URL.
     *
     * To purge files with custom cache keys, include the headers used to compute the cache key as in the example. If you have a device type or geo in your cache key, you will need to include the CF-Device-Type or CF-IPCountry headers. If you have lang in your cache key, you will need to include the Accept-Language header.
     *
     * **NB:** When including the Origin header, be sure to include the **scheme** and **hostname**. The port number can be omitted if it is the default port (80 for http, 443 for https), but must be included otherwise.
     *
     * ### Purge Cached Content by Tag, Host or Prefix
     * Granularly removes one or more files from Cloudflare's cache either by specifying the host, the associated Cache-Tag, or a Prefix. Only Enterprise customers are permitted to purge by Tag, Host or Prefix.
     *
     * **NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000 purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or prefixes in one API call. This rate limit can be raised for customers who need to purge at higher volume.
     */
    public async zone$purge(params: Params$zone$purge, option?: RequestOption): Promise<Response$zone$purge$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/purge_cache\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Analyze Certificate
     * Returns the set of hostnames, the signature algorithm, and the expiration date of the certificate.
     */
    public async analyze$certificate$analyze$certificate(params: Params$analyze$certificate$analyze$certificate, option?: RequestOption): Promise<Response$analyze$certificate$analyze$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/ssl/analyze\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Zone Subscription Details
     * Lists zone subscription details.
     */
    public async zone$subscription$zone$subscription$details(params: Params$zone$subscription$zone$subscription$details, option?: RequestOption): Promise<Response$zone$subscription$zone$subscription$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/subscription\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Zone Subscription
     * Updates zone subscriptions, either plan or add-ons.
     */
    public async zone$subscription$update$zone$subscription(params: Params$zone$subscription$update$zone$subscription, option?: RequestOption): Promise<Response$zone$subscription$update$zone$subscription$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/subscription\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create Zone Subscription
     * Create a zone subscription, either plan or add-ons.
     */
    public async zone$subscription$create$zone$subscription(params: Params$zone$subscription$create$zone$subscription, option?: RequestOption): Promise<Response$zone$subscription$create$zone$subscription$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier}/subscription\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Load Balancer Details
     * Fetch a single configured load balancer.
     */
    public async load$balancers$load$balancer$details(params: Params$load$balancers$load$balancer$details, option?: RequestOption): Promise<Response$load$balancers$load$balancer$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier1}/load_balancers/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Load Balancer
     * Update a configured load balancer.
     */
    public async load$balancers$update$load$balancer(params: Params$load$balancers$update$load$balancer, option?: RequestOption): Promise<Response$load$balancers$update$load$balancer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier1}/load_balancers/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Load Balancer
     * Delete a configured load balancer.
     */
    public async load$balancers$delete$load$balancer(params: Params$load$balancers$delete$load$balancer, option?: RequestOption): Promise<Response$load$balancers$delete$load$balancer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier1}/load_balancers/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Load Balancer
     * Apply changes to an existing load balancer, overwriting the supplied properties.
     */
    public async load$balancers$patch$load$balancer(params: Params$load$balancers$patch$load$balancer, option?: RequestOption): Promise<Response$load$balancers$patch$load$balancer$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.identifier1}/load_balancers/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Zone Details */
    public async zones$0$get(params: Params$zones$0$get, option?: RequestOption): Promise<Response$zones$0$get$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete Zone
     * Deletes an existing zone.
     */
    public async zones$0$delete(params: Params$zones$0$delete, option?: RequestOption): Promise<Response$zones$0$delete$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Edit Zone
     * Edits a zone. Only one zone property can be changed at a time.
     */
    public async zones$0$patch(params: Params$zones$0$patch, option?: RequestOption): Promise<Response$zones$0$patch$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Rerun the Activation Check
     * Triggeres a new activation check for a PENDING Zone. This can be
     * triggered every 5 min for paygo/ent customers, every hour for FREE
     * Zones.
     */
    public async put$zones$zone_id$activation_check(params: Params$put$zones$zone_id$activation_check, option?: RequestOption): Promise<Response$put$zones$zone_id$activation_check$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/activation_check\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers
        }, option);
    }
    /** Argo Analytics for a zone */
    public async argo$analytics$for$zone$argo$analytics$for$a$zone(params: Params$argo$analytics$for$zone$argo$analytics$for$a$zone, option?: RequestOption): Promise<Response$argo$analytics$for$zone$argo$analytics$for$a$zone$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/analytics/latency\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            bins: { value: params.parameter.bins, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Argo Analytics for a zone at different PoPs */
    public async argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps(params: Params$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps, option?: RequestOption): Promise<Response$argo$analytics$for$geolocation$argo$analytics$for$a$zone$at$different$po$ps$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/analytics/latency/colos\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Retrieve information about specific configuration properties */
    public async api$shield$settings$retrieve$information$about$specific$configuration$properties(params: Params$api$shield$settings$retrieve$information$about$specific$configuration$properties, option?: RequestOption): Promise<Response$api$shield$settings$retrieve$information$about$specific$configuration$properties$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/configuration\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            properties: { value: params.parameter.properties, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Set configuration properties */
    public async api$shield$settings$set$configuration$properties(params: Params$api$shield$settings$set$configuration$properties, option?: RequestOption): Promise<Response$api$shield$settings$set$configuration$properties$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/configuration\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Retrieve discovered operations on a zone rendered as OpenAPI schemas
     * Retrieve the most up to date view of discovered operations, rendered as OpenAPI schemas
     */
    public async api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi(params: Params$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi, option?: RequestOption): Promise<Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$as$openapi$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/discovery\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Retrieve discovered operations on a zone
     * Retrieve the most up to date view of discovered operations
     */
    public async api$shield$api$discovery$retrieve$discovered$operations$on$a$zone(params: Params$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone, option?: RequestOption): Promise<Response$api$shield$api$discovery$retrieve$discovered$operations$on$a$zone$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/discovery/operations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            host: { value: params.parameter.host, explode: false },
            method: { value: params.parameter.method, explode: false },
            endpoint: { value: params.parameter.endpoint, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            order: { value: params.parameter.order, explode: false },
            diff: { value: params.parameter.diff, explode: false },
            origin: { value: params.parameter.origin, explode: false },
            state: { value: params.parameter.state, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Patch discovered operations
     * Update the \`state\` on one or more discovered operations
     */
    public async api$shield$api$patch$discovered$operations(params: Params$api$shield$api$patch$discovered$operations, option?: RequestOption): Promise<Response$api$shield$api$patch$discovered$operations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/discovery/operations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Patch discovered operation
     * Update the \`state\` on a discovered operation
     */
    public async api$shield$api$patch$discovered$operation(params: Params$api$shield$api$patch$discovered$operation, option?: RequestOption): Promise<Response$api$shield$api$patch$discovered$operation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/discovery/operations/\${params.parameter.operation_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Retrieve information about all operations on a zone */
    public async api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone(params: Params$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone, option?: RequestOption): Promise<Response$api$shield$endpoint$management$retrieve$information$about$all$operations$on$a$zone$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/operations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            host: { value: params.parameter.host, explode: false },
            method: { value: params.parameter.method, explode: false },
            endpoint: { value: params.parameter.endpoint, explode: false },
            feature: { value: params.parameter.feature, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Add operations to a zone
     * Add one or more operations to a zone. Endpoints can contain path variables. Host, method, endpoint will be normalized to a canoncial form when creating an operation and must be unique on the zone. Inserting an operation that matches an existing one will return the record of the already existing operation and update its last_updated date.
     */
    public async api$shield$endpoint$management$add$operations$to$a$zone(params: Params$api$shield$endpoint$management$add$operations$to$a$zone, option?: RequestOption): Promise<Response$api$shield$endpoint$management$add$operations$to$a$zone$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/operations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Retrieve information about an operation */
    public async api$shield$endpoint$management$retrieve$information$about$an$operation(params: Params$api$shield$endpoint$management$retrieve$information$about$an$operation, option?: RequestOption): Promise<Response$api$shield$endpoint$management$retrieve$information$about$an$operation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/operations/\${params.parameter.operation_id}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            feature: { value: params.parameter.feature, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Delete an operation */
    public async api$shield$endpoint$management$delete$an$operation(params: Params$api$shield$endpoint$management$delete$an$operation, option?: RequestOption): Promise<Response$api$shield$endpoint$management$delete$an$operation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/operations/\${params.parameter.operation_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Retrieve operation-level schema validation settings
     * Retrieves operation-level schema validation settings on the zone
     */
    public async api$shield$schema$validation$retrieve$operation$level$settings(params: Params$api$shield$schema$validation$retrieve$operation$level$settings, option?: RequestOption): Promise<Response$api$shield$schema$validation$retrieve$operation$level$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/operations/\${params.parameter.operation_id}/schema_validation\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update operation-level schema validation settings
     * Updates operation-level schema validation settings on the zone
     */
    public async api$shield$schema$validation$update$operation$level$settings(params: Params$api$shield$schema$validation$update$operation$level$settings, option?: RequestOption): Promise<Response$api$shield$schema$validation$update$operation$level$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/operations/\${params.parameter.operation_id}/schema_validation\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update multiple operation-level schema validation settings
     * Updates multiple operation-level schema validation settings on the zone
     */
    public async api$shield$schema$validation$update$multiple$operation$level$settings(params: Params$api$shield$schema$validation$update$multiple$operation$level$settings, option?: RequestOption): Promise<Response$api$shield$schema$validation$update$multiple$operation$level$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/operations/schema_validation\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Retrieve operations and features as OpenAPI schemas */
    public async api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas(params: Params$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas, option?: RequestOption): Promise<Response$api$shield$endpoint$management$retrieve$operations$and$features$as$open$api$schemas$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/schemas\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            host: { value: params.parameter.host, explode: false },
            feature: { value: params.parameter.feature, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Retrieve zone level schema validation settings
     * Retrieves zone level schema validation settings currently set on the zone
     */
    public async api$shield$schema$validation$retrieve$zone$level$settings(params: Params$api$shield$schema$validation$retrieve$zone$level$settings, option?: RequestOption): Promise<Response$api$shield$schema$validation$retrieve$zone$level$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/settings/schema_validation\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update zone level schema validation settings
     * Updates zone level schema validation settings on the zone
     */
    public async api$shield$schema$validation$update$zone$level$settings(params: Params$api$shield$schema$validation$update$zone$level$settings, option?: RequestOption): Promise<Response$api$shield$schema$validation$update$zone$level$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/settings/schema_validation\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update zone level schema validation settings
     * Updates zone level schema validation settings on the zone
     */
    public async api$shield$schema$validation$patch$zone$level$settings(params: Params$api$shield$schema$validation$patch$zone$level$settings, option?: RequestOption): Promise<Response$api$shield$schema$validation$patch$zone$level$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/settings/schema_validation\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Retrieve information about all schemas on a zone */
    public async api$shield$schema$validation$retrieve$information$about$all$schemas(params: Params$api$shield$schema$validation$retrieve$information$about$all$schemas, option?: RequestOption): Promise<Response$api$shield$schema$validation$retrieve$information$about$all$schemas$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/user_schemas\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            omit_source: { value: params.parameter.omit_source, explode: false },
            validation_enabled: { value: params.parameter.validation_enabled, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Upload a schema to a zone */
    public async api$shield$schema$validation$post$schema(params: Params$api$shield$schema$validation$post$schema, option?: RequestOption): Promise<Response$api$shield$schema$validation$post$schema$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/user_schemas\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Retrieve information about a specific schema on a zone */
    public async api$shield$schema$validation$retrieve$information$about$specific$schema(params: Params$api$shield$schema$validation$retrieve$information$about$specific$schema, option?: RequestOption): Promise<Response$api$shield$schema$validation$retrieve$information$about$specific$schema$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/user_schemas/\${params.parameter.schema_id}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            omit_source: { value: params.parameter.omit_source, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Delete a schema */
    public async api$shield$schema$delete$a$schema(params: Params$api$shield$schema$delete$a$schema, option?: RequestOption): Promise<Response$api$shield$schema$delete$a$schema$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/user_schemas/\${params.parameter.schema_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /** Enable validation for a schema */
    public async api$shield$schema$validation$enable$validation$for$a$schema(params: Params$api$shield$schema$validation$enable$validation$for$a$schema, option?: RequestOption): Promise<Response$api$shield$schema$validation$enable$validation$for$a$schema$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/user_schemas/\${params.parameter.schema_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Retrieve all operations from a schema.
     * Retrieves all operations from the schema. Operations that already exist in API Shield Endpoint Management will be returned as full operations.
     */
    public async api$shield$schema$validation$extract$operations$from$schema(params: Params$api$shield$schema$validation$extract$operations$from$schema, option?: RequestOption): Promise<Response$api$shield$schema$validation$extract$operations$from$schema$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/api_gateway/user_schemas/\${params.parameter.schema_id}/operations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            feature: { value: params.parameter.feature, explode: false },
            host: { value: params.parameter.host, explode: false },
            method: { value: params.parameter.method, explode: false },
            endpoint: { value: params.parameter.endpoint, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            operation_status: { value: params.parameter.operation_status, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /** Get Argo Smart Routing setting */
    public async argo$smart$routing$get$argo$smart$routing$setting(params: Params$argo$smart$routing$get$argo$smart$routing$setting, option?: RequestOption): Promise<Response$argo$smart$routing$get$argo$smart$routing$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/argo/smart_routing\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Patch Argo Smart Routing setting
     * Updates enablement of Argo Smart Routing.
     */
    public async argo$smart$routing$patch$argo$smart$routing$setting(params: Params$argo$smart$routing$patch$argo$smart$routing$setting, option?: RequestOption): Promise<Response$argo$smart$routing$patch$argo$smart$routing$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/argo/smart_routing\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get Tiered Caching setting */
    public async tiered$caching$get$tiered$caching$setting(params: Params$tiered$caching$get$tiered$caching$setting, option?: RequestOption): Promise<Response$tiered$caching$get$tiered$caching$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/argo/tiered_caching\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Patch Tiered Caching setting
     * Updates enablement of Tiered Caching
     */
    public async tiered$caching$patch$tiered$caching$setting(params: Params$tiered$caching$patch$tiered$caching$setting, option?: RequestOption): Promise<Response$tiered$caching$patch$tiered$caching$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/argo/tiered_caching\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zone Bot Management Config
     * Retrieve a zone's Bot Management Config
     */
    public async bot$management$for$a$zone$get$config(params: Params$bot$management$for$a$zone$get$config, option?: RequestOption): Promise<Response$bot$management$for$a$zone$get$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/bot_management\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Zone Bot Management Config
     * Updates the Bot Management configuration for a zone.
     *
     * This API is used to update:
     * - **Bot Fight Mode**
     * - **Super Bot Fight Mode**
     * - **Bot Management for Enterprise**
     *
     * See [Bot Plans](https://developers.cloudflare.com/bots/plans/) for more information on the different plans
     */
    public async bot$management$for$a$zone$update$config(params: Params$bot$management$for$a$zone$update$config, option?: RequestOption): Promise<Response$bot$management$for$a$zone$update$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/bot_management\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Cache Reserve setting
     * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
     */
    public async zone$cache$settings$get$cache$reserve$setting(params: Params$zone$cache$settings$get$cache$reserve$setting, option?: RequestOption): Promise<Response$zone$cache$settings$get$cache$reserve$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/cache_reserve\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Cache Reserve setting
     * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
     */
    public async zone$cache$settings$change$cache$reserve$setting(params: Params$zone$cache$settings$change$cache$reserve$setting, option?: RequestOption): Promise<Response$zone$cache$settings$change$cache$reserve$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/cache_reserve\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Cache Reserve Clear
     * You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.
     */
    public async zone$cache$settings$get$cache$reserve$clear(params: Params$zone$cache$settings$get$cache$reserve$clear, option?: RequestOption): Promise<Response$zone$cache$settings$get$cache$reserve$clear$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/cache_reserve_clear\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Start Cache Reserve Clear
     * You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.
     */
    public async zone$cache$settings$start$cache$reserve$clear(params: Params$zone$cache$settings$start$cache$reserve$clear, option?: RequestOption): Promise<Response$zone$cache$settings$start$cache$reserve$clear$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/cache_reserve_clear\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Origin Post-Quantum Encryption setting
     * Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when connecting to your origin. Preferred instructs Cloudflare to opportunistically send a Post-Quantum keyshare in the first message to the origin (for fastest connections when the origin supports and prefers PQ), supported means that PQ algorithms are advertised but only used when requested by the origin, and off means that PQ algorithms are not advertised
     */
    public async zone$cache$settings$get$origin$post$quantum$encryption$setting(params: Params$zone$cache$settings$get$origin$post$quantum$encryption$setting, option?: RequestOption): Promise<Response$zone$cache$settings$get$origin$post$quantum$encryption$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/origin_post_quantum_encryption\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Origin Post-Quantum Encryption setting
     * Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when connecting to your origin. Preferred instructs Cloudflare to opportunistically send a Post-Quantum keyshare in the first message to the origin (for fastest connections when the origin supports and prefers PQ), supported means that PQ algorithms are advertised but only used when requested by the origin, and off means that PQ algorithms are not advertised
     */
    public async zone$cache$settings$change$origin$post$quantum$encryption$setting(params: Params$zone$cache$settings$change$origin$post$quantum$encryption$setting, option?: RequestOption): Promise<Response$zone$cache$settings$change$origin$post$quantum$encryption$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/origin_post_quantum_encryption\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Regional Tiered Cache setting
     * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
     */
    public async zone$cache$settings$get$regional$tiered$cache$setting(params: Params$zone$cache$settings$get$regional$tiered$cache$setting, option?: RequestOption): Promise<Response$zone$cache$settings$get$regional$tiered$cache$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/regional_tiered_cache\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Regional Tiered Cache setting
     * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
     */
    public async zone$cache$settings$change$regional$tiered$cache$setting(params: Params$zone$cache$settings$change$regional$tiered$cache$setting, option?: RequestOption): Promise<Response$zone$cache$settings$change$regional$tiered$cache$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/regional_tiered_cache\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get Smart Tiered Cache setting */
    public async smart$tiered$cache$get$smart$tiered$cache$setting(params: Params$smart$tiered$cache$get$smart$tiered$cache$setting, option?: RequestOption): Promise<Response$smart$tiered$cache$get$smart$tiered$cache$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/tiered_cache_smart_topology_enable\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete Smart Tiered Cache setting
     * Remvoves enablement of Smart Tiered Cache
     */
    public async smart$tiered$cache$delete$smart$tiered$cache$setting(params: Params$smart$tiered$cache$delete$smart$tiered$cache$setting, option?: RequestOption): Promise<Response$smart$tiered$cache$delete$smart$tiered$cache$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/tiered_cache_smart_topology_enable\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Smart Tiered Cache setting
     * Updates enablement of Tiered Cache
     */
    public async smart$tiered$cache$patch$smart$tiered$cache$setting(params: Params$smart$tiered$cache$patch$smart$tiered$cache$setting, option?: RequestOption): Promise<Response$smart$tiered$cache$patch$smart$tiered$cache$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/tiered_cache_smart_topology_enable\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get variants setting
     * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
     */
    public async zone$cache$settings$get$variants$setting(params: Params$zone$cache$settings$get$variants$setting, option?: RequestOption): Promise<Response$zone$cache$settings$get$variants$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/variants\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete variants setting
     * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
     */
    public async zone$cache$settings$delete$variants$setting(params: Params$zone$cache$settings$delete$variants$setting, option?: RequestOption): Promise<Response$zone$cache$settings$delete$variants$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/variants\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Change variants setting
     * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
     */
    public async zone$cache$settings$change$variants$setting(params: Params$zone$cache$settings$change$variants$setting, option?: RequestOption): Promise<Response$zone$cache$settings$change$variants$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/cache/variants\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Account Custom Nameserver Related Zone Metadata
     * Get metadata for account-level custom nameservers on a zone.
     */
    public async account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata(params: Params$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata, option?: RequestOption): Promise<Response$account$level$custom$nameservers$usage$for$a$zone$get$account$custom$nameserver$related$zone$metadata$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/custom_ns\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set Account Custom Nameserver Related Zone Metadata
     * Set metadata for account-level custom nameservers on a zone.
     *
     * If you would like new zones in the account to use account custom nameservers by default, use PUT /accounts/:identifier to set the account setting use_account_custom_ns_by_default to true.
     */
    public async account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata(params: Params$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata, option?: RequestOption): Promise<Response$account$level$custom$nameservers$usage$for$a$zone$set$account$custom$nameserver$related$zone$metadata$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/custom_ns\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List DNS Records
     * List, search, sort, and filter a zones' DNS records.
     */
    public async dns$records$for$a$zone$list$dns$records(params: Params$dns$records$for$a$zone$list$dns$records, option?: RequestOption): Promise<Response$dns$records$for$a$zone$list$dns$records$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            name: { value: params.parameter.name, explode: false },
            type: { value: params.parameter.type, explode: false },
            content: { value: params.parameter.content, explode: false },
            proxied: { value: params.parameter.proxied, explode: false },
            match: { value: params.parameter.match, explode: false },
            comment: { value: params.parameter.comment, explode: false },
            "comment.present": { value: params.parameter["comment.present"], explode: false },
            "comment.absent": { value: params.parameter["comment.absent"], explode: false },
            "comment.exact": { value: params.parameter["comment.exact"], explode: false },
            "comment.contains": { value: params.parameter["comment.contains"], explode: false },
            "comment.startswith": { value: params.parameter["comment.startswith"], explode: false },
            "comment.endswith": { value: params.parameter["comment.endswith"], explode: false },
            tag: { value: params.parameter.tag, explode: false },
            "tag.present": { value: params.parameter["tag.present"], explode: false },
            "tag.absent": { value: params.parameter["tag.absent"], explode: false },
            "tag.exact": { value: params.parameter["tag.exact"], explode: false },
            "tag.contains": { value: params.parameter["tag.contains"], explode: false },
            "tag.startswith": { value: params.parameter["tag.startswith"], explode: false },
            "tag.endswith": { value: params.parameter["tag.endswith"], explode: false },
            search: { value: params.parameter.search, explode: false },
            tag_match: { value: params.parameter.tag_match, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create DNS Record
     * Create a new DNS record for a zone.
     *
     * Notes:
     * - A/AAAA records cannot exist on the same name as CNAME records.
     * - NS records cannot exist on the same name as any other record type.
     * - Domain names are always represented in Punycode, even if Unicode
     *   characters were used when creating the record.
     */
    public async dns$records$for$a$zone$create$dns$record(params: Params$dns$records$for$a$zone$create$dns$record, option?: RequestOption): Promise<Response$dns$records$for$a$zone$create$dns$record$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** DNS Record Details */
    public async dns$records$for$a$zone$dns$record$details(params: Params$dns$records$for$a$zone$dns$record$details, option?: RequestOption): Promise<Response$dns$records$for$a$zone$dns$record$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records/\${params.parameter.dns_record_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Overwrite DNS Record
     * Overwrite an existing DNS record.
     * Notes:
     * - A/AAAA records cannot exist on the same name as CNAME records.
     * - NS records cannot exist on the same name as any other record type.
     * - Domain names are always represented in Punycode, even if Unicode
     *   characters were used when creating the record.
     */
    public async dns$records$for$a$zone$update$dns$record(params: Params$dns$records$for$a$zone$update$dns$record, option?: RequestOption): Promise<Response$dns$records$for$a$zone$update$dns$record$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records/\${params.parameter.dns_record_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Delete DNS Record */
    public async dns$records$for$a$zone$delete$dns$record(params: Params$dns$records$for$a$zone$delete$dns$record, option?: RequestOption): Promise<Response$dns$records$for$a$zone$delete$dns$record$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records/\${params.parameter.dns_record_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update DNS Record
     * Update an existing DNS record.
     * Notes:
     * - A/AAAA records cannot exist on the same name as CNAME records.
     * - NS records cannot exist on the same name as any other record type.
     * - Domain names are always represented in Punycode, even if Unicode
     *   characters were used when creating the record.
     */
    public async dns$records$for$a$zone$patch$dns$record(params: Params$dns$records$for$a$zone$patch$dns$record, option?: RequestOption): Promise<Response$dns$records$for$a$zone$patch$dns$record$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records/\${params.parameter.dns_record_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Export DNS Records
     * You can export your [BIND config](https://en.wikipedia.org/wiki/Zone_file "Zone file") through this endpoint.
     *
     * See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ "Import and export records") for more information.
     */
    public async dns$records$for$a$zone$export$dns$records(params: Params$dns$records$for$a$zone$export$dns$records, option?: RequestOption): Promise<Response$dns$records$for$a$zone$export$dns$records$Status$200["text/plain"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records/export\`;
        const headers = {
            Accept: "text/plain"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Import DNS Records
     * You can upload your [BIND config](https://en.wikipedia.org/wiki/Zone_file "Zone file") through this endpoint. It assumes that cURL is called from a location with bind_config.txt (valid BIND config) present.
     *
     * See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ "Import and export records") for more information.
     */
    public async dns$records$for$a$zone$import$dns$records(params: Params$dns$records$for$a$zone$import$dns$records, option?: RequestOption): Promise<Response$dns$records$for$a$zone$import$dns$records$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records/import\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Scan DNS Records
     * Scan for common DNS records on your domain and automatically add them to your zone. Useful if you haven't updated your nameservers yet.
     */
    public async dns$records$for$a$zone$scan$dns$records(params: Params$dns$records$for$a$zone$scan$dns$records, option?: RequestOption): Promise<Response$dns$records$for$a$zone$scan$dns$records$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dns_records/scan\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * DNSSEC Details
     * Details about DNSSEC status and configuration.
     */
    public async dnssec$dnssec$details(params: Params$dnssec$dnssec$details, option?: RequestOption): Promise<Response$dnssec$dnssec$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dnssec\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete DNSSEC records
     * Delete DNSSEC.
     */
    public async dnssec$delete$dnssec$records(params: Params$dnssec$delete$dnssec$records, option?: RequestOption): Promise<Response$dnssec$delete$dnssec$records$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dnssec\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Edit DNSSEC Status
     * Enable or disable DNSSEC.
     */
    public async dnssec$edit$dnssec$status(params: Params$dnssec$edit$dnssec$status, option?: RequestOption): Promise<Response$dnssec$edit$dnssec$status$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/dnssec\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List IP Access rules
     * Fetches IP Access rules of a zone. You can filter the results using several optional parameters.
     */
    public async ip$access$rules$for$a$zone$list$ip$access$rules(params: Params$ip$access$rules$for$a$zone$list$ip$access$rules, option?: RequestOption): Promise<Response$ip$access$rules$for$a$zone$list$ip$access$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/access_rules/rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            filters: { value: params.parameter.filters, explode: false },
            "egs-pagination.json": { value: params.parameter["egs-pagination.json"], explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create an IP Access rule
     * Creates a new IP Access rule for a zone.
     *
     * Note: To create an IP Access rule that applies to multiple zones, refer to [IP Access rules for a user](#ip-access-rules-for-a-user) or [IP Access rules for an account](#ip-access-rules-for-an-account) as appropriate.
     */
    public async ip$access$rules$for$a$zone$create$an$ip$access$rule(params: Params$ip$access$rules$for$a$zone$create$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$a$zone$create$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/access_rules/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete an IP Access rule
     * Deletes an IP Access rule defined at the zone level.
     *
     * Optionally, you can use the \`cascade\` property to specify that you wish to delete similar rules in other zones managed by the same zone owner.
     */
    public async ip$access$rules$for$a$zone$delete$an$ip$access$rule(params: Params$ip$access$rules$for$a$zone$delete$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$a$zone$delete$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/access_rules/rules/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update an IP Access rule
     * Updates an IP Access rule defined at the zone level. You can only update the rule action (\`mode\` parameter) and notes.
     */
    public async ip$access$rules$for$a$zone$update$an$ip$access$rule(params: Params$ip$access$rules$for$a$zone$update$an$ip$access$rule, option?: RequestOption): Promise<Response$ip$access$rules$for$a$zone$update$an$ip$access$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/access_rules/rules/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List WAF rule groups
     * Fetches the WAF rule groups in a WAF package.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$rule$groups$list$waf$rule$groups(params: Params$waf$rule$groups$list$waf$rule$groups, option?: RequestOption): Promise<Response$waf$rule$groups$list$waf$rule$groups$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/waf/packages/\${params.parameter.package_id}/groups\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            mode: { value: params.parameter.mode, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            match: { value: params.parameter.match, explode: false },
            name: { value: params.parameter.name, explode: false },
            rules_count: { value: params.parameter.rules_count, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a WAF rule group
     * Fetches the details of a WAF rule group.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$rule$groups$get$a$waf$rule$group(params: Params$waf$rule$groups$get$a$waf$rule$group, option?: RequestOption): Promise<Response$waf$rule$groups$get$a$waf$rule$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/waf/packages/\${params.parameter.package_id}/groups/\${params.parameter.group_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a WAF rule group
     * Updates a WAF rule group. You can update the state (\`mode\` parameter) of a rule group.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$rule$groups$update$a$waf$rule$group(params: Params$waf$rule$groups$update$a$waf$rule$group, option?: RequestOption): Promise<Response$waf$rule$groups$update$a$waf$rule$group$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/waf/packages/\${params.parameter.package_id}/groups/\${params.parameter.group_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List WAF rules
     * Fetches WAF rules in a WAF package.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$rules$list$waf$rules(params: Params$waf$rules$list$waf$rules, option?: RequestOption): Promise<Response$waf$rules$list$waf$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/waf/packages/\${params.parameter.package_id}/rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            mode: { value: params.parameter.mode, explode: false },
            group_id: { value: params.parameter.group_id, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            match: { value: params.parameter.match, explode: false },
            description: { value: params.parameter.description, explode: false },
            priority: { value: params.parameter.priority, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a WAF rule
     * Fetches the details of a WAF rule in a WAF package.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$rules$get$a$waf$rule(params: Params$waf$rules$get$a$waf$rule, option?: RequestOption): Promise<Response$waf$rules$get$a$waf$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/waf/packages/\${params.parameter.package_id}/rules/\${params.parameter.rule_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a WAF rule
     * Updates a WAF rule. You can only update the mode/action of the rule.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$rules$update$a$waf$rule(params: Params$waf$rules$update$a$waf$rule, option?: RequestOption): Promise<Response$waf$rules$update$a$waf$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/firewall/waf/packages/\${params.parameter.package_id}/rules/\${params.parameter.rule_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zone Hold
     * Retrieve whether the zone is subject to a zone hold, and metadata about the hold.
     */
    public async zones$0$hold$get(params: Params$zones$0$hold$get, option?: RequestOption): Promise<Response$zones$0$hold$get$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/hold\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Zone Hold
     * Enforce a zone hold on the zone, blocking the creation and activation of zones with this zone's hostname.
     */
    public async zones$0$hold$post(params: Params$zones$0$hold$post, option?: RequestOption): Promise<Response$zones$0$hold$post$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/hold\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include_subdomains: { value: params.parameter.include_subdomains, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Remove Zone Hold
     * Stop enforcement of a zone hold on the zone, permanently or temporarily, allowing the
     * creation and activation of zones with this zone's hostname.
     */
    public async zones$0$hold$delete(params: Params$zones$0$hold$delete, option?: RequestOption): Promise<Response$zones$0$hold$delete$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/hold\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            hold_after: { value: params.parameter.hold_after, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List fields
     * Lists all fields available for a dataset. The response result is an object with key-value pairs, where keys are field names, and values are descriptions.
     */
    public async get$zones$zone_identifier$logpush$datasets$dataset$fields(params: Params$get$zones$zone_identifier$logpush$datasets$dataset$fields, option?: RequestOption): Promise<Response$get$zones$zone_identifier$logpush$datasets$dataset$fields$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/datasets/\${params.parameter.dataset_id}/fields\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Logpush jobs for a dataset
     * Lists Logpush jobs for a zone for a dataset.
     */
    public async get$zones$zone_identifier$logpush$datasets$dataset$jobs(params: Params$get$zones$zone_identifier$logpush$datasets$dataset$jobs, option?: RequestOption): Promise<Response$get$zones$zone_identifier$logpush$datasets$dataset$jobs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/datasets/\${params.parameter.dataset_id}/jobs\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Instant Logs jobs
     * Lists Instant Logs jobs for a zone.
     */
    public async get$zones$zone_identifier$logpush$edge$jobs(params: Params$get$zones$zone_identifier$logpush$edge$jobs, option?: RequestOption): Promise<Response$get$zones$zone_identifier$logpush$edge$jobs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/edge\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Instant Logs job
     * Creates a new Instant Logs job for a zone.
     */
    public async post$zones$zone_identifier$logpush$edge$jobs(params: Params$post$zones$zone_identifier$logpush$edge$jobs, option?: RequestOption): Promise<Response$post$zones$zone_identifier$logpush$edge$jobs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/edge\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Logpush jobs
     * Lists Logpush jobs for a zone.
     */
    public async get$zones$zone_identifier$logpush$jobs(params: Params$get$zones$zone_identifier$logpush$jobs, option?: RequestOption): Promise<Response$get$zones$zone_identifier$logpush$jobs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/jobs\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Logpush job
     * Creates a new Logpush job for a zone.
     */
    public async post$zones$zone_identifier$logpush$jobs(params: Params$post$zones$zone_identifier$logpush$jobs, option?: RequestOption): Promise<Response$post$zones$zone_identifier$logpush$jobs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/jobs\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Logpush job details
     * Gets the details of a Logpush job.
     */
    public async get$zones$zone_identifier$logpush$jobs$job_identifier(params: Params$get$zones$zone_identifier$logpush$jobs$job_identifier, option?: RequestOption): Promise<Response$get$zones$zone_identifier$logpush$jobs$job_identifier$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/jobs/\${params.parameter.job_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Logpush job
     * Updates a Logpush job.
     */
    public async put$zones$zone_identifier$logpush$jobs$job_identifier(params: Params$put$zones$zone_identifier$logpush$jobs$job_identifier, option?: RequestOption): Promise<Response$put$zones$zone_identifier$logpush$jobs$job_identifier$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/jobs/\${params.parameter.job_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Logpush job
     * Deletes a Logpush job.
     */
    public async delete$zones$zone_identifier$logpush$jobs$job_identifier(params: Params$delete$zones$zone_identifier$logpush$jobs$job_identifier, option?: RequestOption): Promise<Response$delete$zones$zone_identifier$logpush$jobs$job_identifier$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/jobs/\${params.parameter.job_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get ownership challenge
     * Gets a new ownership challenge sent to your destination.
     */
    public async post$zones$zone_identifier$logpush$ownership(params: Params$post$zones$zone_identifier$logpush$ownership, option?: RequestOption): Promise<Response$post$zones$zone_identifier$logpush$ownership$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/ownership\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Validate ownership challenge
     * Validates ownership challenge of the destination.
     */
    public async post$zones$zone_identifier$logpush$ownership$validate(params: Params$post$zones$zone_identifier$logpush$ownership$validate, option?: RequestOption): Promise<Response$post$zones$zone_identifier$logpush$ownership$validate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/ownership/validate\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Check destination exists
     * Checks if there is an existing job with a destination.
     */
    public async post$zones$zone_identifier$logpush$validate$destination$exists(params: Params$post$zones$zone_identifier$logpush$validate$destination$exists, option?: RequestOption): Promise<Response$post$zones$zone_identifier$logpush$validate$destination$exists$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/validate/destination/exists\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Validate origin
     * Validates logpull origin with logpull_options.
     */
    public async post$zones$zone_identifier$logpush$validate$origin(params: Params$post$zones$zone_identifier$logpush$validate$origin, option?: RequestOption): Promise<Response$post$zones$zone_identifier$logpush$validate$origin$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/logpush/validate/origin\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Managed Transforms
     * Fetches a list of all Managed Transforms.
     */
    public async managed$transforms$list$managed$transforms(params: Params$managed$transforms$list$managed$transforms, option?: RequestOption): Promise<Response$managed$transforms$list$managed$transforms$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/managed_headers\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update status of Managed Transforms
     * Updates the status of one or more Managed Transforms.
     */
    public async managed$transforms$update$status$of$managed$transforms(params: Params$managed$transforms$update$status$of$managed$transforms, option?: RequestOption): Promise<Response$managed$transforms$update$status$of$managed$transforms$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/managed_headers\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Page Shield settings
     * Fetches the Page Shield settings.
     */
    public async page$shield$get$page$shield$settings(params: Params$page$shield$get$page$shield$settings, option?: RequestOption): Promise<Response$page$shield$get$page$shield$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Page Shield settings
     * Updates Page Shield settings.
     */
    public async page$shield$update$page$shield$settings(params: Params$page$shield$update$page$shield$settings, option?: RequestOption): Promise<Response$page$shield$update$page$shield$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Page Shield connections
     * Lists all connections detected by Page Shield.
     */
    public async page$shield$list$page$shield$connections(params: Params$page$shield$list$page$shield$connections, option?: RequestOption): Promise<Response$page$shield$list$page$shield$connections$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/connections\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            exclude_urls: { value: params.parameter.exclude_urls, explode: false },
            urls: { value: params.parameter.urls, explode: false },
            hosts: { value: params.parameter.hosts, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order_by: { value: params.parameter.order_by, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            prioritize_malicious: { value: params.parameter.prioritize_malicious, explode: false },
            exclude_cdn_cgi: { value: params.parameter.exclude_cdn_cgi, explode: false },
            status: { value: params.parameter.status, explode: false },
            page_url: { value: params.parameter.page_url, explode: false },
            export: { value: params.parameter.export, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a Page Shield connection
     * Fetches a connection detected by Page Shield by connection ID.
     */
    public async page$shield$get$a$page$shield$connection(params: Params$page$shield$get$a$page$shield$connection, option?: RequestOption): Promise<Response$page$shield$get$a$page$shield$connection$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/connections/\${params.parameter.connection_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Page Shield policies
     * Lists all Page Shield policies.
     */
    public async page$shield$list$page$shield$policies(params: Params$page$shield$list$page$shield$policies, option?: RequestOption): Promise<Response$page$shield$list$page$shield$policies$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/policies\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a Page Shield policy
     * Create a Page Shield policy.
     */
    public async page$shield$create$a$page$shield$policy(params: Params$page$shield$create$a$page$shield$policy, option?: RequestOption): Promise<Response$page$shield$create$a$page$shield$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/policies\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Page Shield policy
     * Fetches a Page Shield policy by ID.
     */
    public async page$shield$get$a$page$shield$policy(params: Params$page$shield$get$a$page$shield$policy, option?: RequestOption): Promise<Response$page$shield$get$a$page$shield$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/policies/\${params.parameter.policy_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a Page Shield policy
     * Update a Page Shield policy by ID.
     */
    public async page$shield$update$a$page$shield$policy(params: Params$page$shield$update$a$page$shield$policy, option?: RequestOption): Promise<Response$page$shield$update$a$page$shield$policy$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/policies/\${params.parameter.policy_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Page Shield policy
     * Delete a Page Shield policy by ID.
     */
    public async page$shield$delete$a$page$shield$policy(params: Params$page$shield$delete$a$page$shield$policy, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/policies/\${params.parameter.policy_id}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Page Shield scripts
     * Lists all scripts detected by Page Shield.
     */
    public async page$shield$list$page$shield$scripts(params: Params$page$shield$list$page$shield$scripts, option?: RequestOption): Promise<Response$page$shield$list$page$shield$scripts$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/scripts\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            exclude_urls: { value: params.parameter.exclude_urls, explode: false },
            urls: { value: params.parameter.urls, explode: false },
            hosts: { value: params.parameter.hosts, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order_by: { value: params.parameter.order_by, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            prioritize_malicious: { value: params.parameter.prioritize_malicious, explode: false },
            exclude_cdn_cgi: { value: params.parameter.exclude_cdn_cgi, explode: false },
            exclude_duplicates: { value: params.parameter.exclude_duplicates, explode: false },
            status: { value: params.parameter.status, explode: false },
            page_url: { value: params.parameter.page_url, explode: false },
            export: { value: params.parameter.export, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a Page Shield script
     * Fetches a script detected by Page Shield by script ID.
     */
    public async page$shield$get$a$page$shield$script(params: Params$page$shield$get$a$page$shield$script, option?: RequestOption): Promise<Response$page$shield$get$a$page$shield$script$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/page_shield/scripts/\${params.parameter.script_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Page Rules
     * Fetches Page Rules in a zone.
     */
    public async page$rules$list$page$rules(params: Params$page$rules$list$page$rules, option?: RequestOption): Promise<Response$page$rules$list$page$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/pagerules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            match: { value: params.parameter.match, explode: false },
            status: { value: params.parameter.status, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a Page Rule
     * Creates a new Page Rule.
     */
    public async page$rules$create$a$page$rule(params: Params$page$rules$create$a$page$rule, option?: RequestOption): Promise<Response$page$rules$create$a$page$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/pagerules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Page Rule
     * Fetches the details of a Page Rule.
     */
    public async page$rules$get$a$page$rule(params: Params$page$rules$get$a$page$rule, option?: RequestOption): Promise<Response$page$rules$get$a$page$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/pagerules/\${params.parameter.pagerule_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a Page Rule
     * Replaces the configuration of an existing Page Rule. The configuration of the updated Page Rule will exactly match the data passed in the API request.
     */
    public async page$rules$update$a$page$rule(params: Params$page$rules$update$a$page$rule, option?: RequestOption): Promise<Response$page$rules$update$a$page$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/pagerules/\${params.parameter.pagerule_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Page Rule
     * Deletes an existing Page Rule.
     */
    public async page$rules$delete$a$page$rule(params: Params$page$rules$delete$a$page$rule, option?: RequestOption): Promise<Response$page$rules$delete$a$page$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/pagerules/\${params.parameter.pagerule_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Edit a Page Rule
     * Updates one or more fields of an existing Page Rule.
     */
    public async page$rules$edit$a$page$rule(params: Params$page$rules$edit$a$page$rule, option?: RequestOption): Promise<Response$page$rules$edit$a$page$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/pagerules/\${params.parameter.pagerule_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List available Page Rules settings
     * Returns a list of settings (and their details) that Page Rules can apply to matching requests.
     */
    public async available$page$rules$settings$list$available$page$rules$settings(params: Params$available$page$rules$settings$list$available$page$rules$settings, option?: RequestOption): Promise<Response$available$page$rules$settings$list$available$page$rules$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/pagerules/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List zone rulesets
     * Fetches all rulesets at the zone level.
     */
    public async listZoneRulesets(params: Params$listZoneRulesets, option?: RequestOption): Promise<Response$listZoneRulesets$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a zone ruleset
     * Creates a ruleset at the zone level.
     */
    public async createZoneRuleset(params: Params$createZoneRuleset, option?: RequestOption): Promise<Response$createZoneRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a zone ruleset
     * Fetches the latest version of a zone ruleset.
     */
    public async getZoneRuleset(params: Params$getZoneRuleset, option?: RequestOption): Promise<Response$getZoneRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a zone ruleset
     * Updates a zone ruleset, creating a new version.
     */
    public async updateZoneRuleset(params: Params$updateZoneRuleset, option?: RequestOption): Promise<Response$updateZoneRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a zone ruleset
     * Deletes all versions of an existing zone ruleset.
     */
    public async deleteZoneRuleset(params: Params$deleteZoneRuleset, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Create a zone ruleset rule
     * Adds a new rule to a zone ruleset. The rule will be added to the end of the existing list of rules in the ruleset by default.
     */
    public async createZoneRulesetRule(params: Params$createZoneRulesetRule, option?: RequestOption): Promise<Response$createZoneRulesetRule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a zone ruleset rule
     * Deletes an existing rule from a zone ruleset.
     */
    public async deleteZoneRulesetRule(params: Params$deleteZoneRulesetRule, option?: RequestOption): Promise<Response$deleteZoneRulesetRule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}/rules/\${params.parameter.rule_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Update a zone ruleset rule
     * Updates an existing rule in a zone ruleset.
     */
    public async updateZoneRulesetRule(params: Params$updateZoneRulesetRule, option?: RequestOption): Promise<Response$updateZoneRulesetRule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}/rules/\${params.parameter.rule_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List a zone ruleset's versions
     * Fetches the versions of a zone ruleset.
     */
    public async listZoneRulesetVersions(params: Params$listZoneRulesetVersions, option?: RequestOption): Promise<Response$listZoneRulesetVersions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}/versions\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get a zone ruleset version
     * Fetches a specific version of a zone ruleset.
     */
    public async getZoneRulesetVersion(params: Params$getZoneRulesetVersion, option?: RequestOption): Promise<Response$getZoneRulesetVersion$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}/versions/\${params.parameter.ruleset_version}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete a zone ruleset version
     * Deletes an existing version of a zone ruleset.
     */
    public async deleteZoneRulesetVersion(params: Params$deleteZoneRulesetVersion, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/\${params.parameter.ruleset_id}/versions/\${params.parameter.ruleset_version}\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get a zone entry point ruleset
     * Fetches the latest version of the zone entry point ruleset for a given phase.
     */
    public async getZoneEntrypointRuleset(params: Params$getZoneEntrypointRuleset, option?: RequestOption): Promise<Response$getZoneEntrypointRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/phases/\${params.parameter.ruleset_phase}/entrypoint\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a zone entry point ruleset
     * Updates a zone entry point ruleset, creating a new version.
     */
    public async updateZoneEntrypointRuleset(params: Params$updateZoneEntrypointRuleset, option?: RequestOption): Promise<Response$updateZoneEntrypointRuleset$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/phases/\${params.parameter.ruleset_phase}/entrypoint\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List a zone entry point ruleset's versions
     * Fetches the versions of a zone entry point ruleset.
     */
    public async listZoneEntrypointRulesetVersions(params: Params$listZoneEntrypointRulesetVersions, option?: RequestOption): Promise<Response$listZoneEntrypointRulesetVersions$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/phases/\${params.parameter.ruleset_phase}/entrypoint/versions\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get a zone entry point ruleset version
     * Fetches a specific version of a zone entry point ruleset.
     */
    public async getZoneEntrypointRulesetVersion(params: Params$getZoneEntrypointRulesetVersion, option?: RequestOption): Promise<Response$getZoneEntrypointRulesetVersion$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/rulesets/phases/\${params.parameter.ruleset_phase}/entrypoint/versions/\${params.parameter.ruleset_version}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get all Zone settings
     * Available settings for your user in relation to a zone.
     */
    public async zone$settings$get$all$zone$settings(params: Params$zone$settings$get$all$zone$settings, option?: RequestOption): Promise<Response$zone$settings$get$all$zone$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Edit zone settings info
     * Edit settings for a zone.
     */
    public async zone$settings$edit$zone$settings$info(params: Params$zone$settings$edit$zone$settings$info, option?: RequestOption): Promise<Response$zone$settings$edit$zone$settings$info$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get 0-RTT session resumption setting
     * Gets 0-RTT session resumption setting.
     */
    public async zone$settings$get$0$rtt$session$resumption$setting(params: Params$zone$settings$get$0$rtt$session$resumption$setting, option?: RequestOption): Promise<Response$zone$settings$get$0$rtt$session$resumption$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/0rtt\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change 0-RTT session resumption setting
     * Changes the 0-RTT session resumption setting.
     */
    public async zone$settings$change$0$rtt$session$resumption$setting(params: Params$zone$settings$change$0$rtt$session$resumption$setting, option?: RequestOption): Promise<Response$zone$settings$change$0$rtt$session$resumption$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/0rtt\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Advanced DDOS setting
     * Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones.
     */
    public async zone$settings$get$advanced$ddos$setting(params: Params$zone$settings$get$advanced$ddos$setting, option?: RequestOption): Promise<Response$zone$settings$get$advanced$ddos$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/advanced_ddos\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get Always Online setting
     * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
     */
    public async zone$settings$get$always$online$setting(params: Params$zone$settings$get$always$online$setting, option?: RequestOption): Promise<Response$zone$settings$get$always$online$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/always_online\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Always Online setting
     * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
     */
    public async zone$settings$change$always$online$setting(params: Params$zone$settings$change$always$online$setting, option?: RequestOption): Promise<Response$zone$settings$change$always$online$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/always_online\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Always Use HTTPS setting
     * Reply to all requests for URLs that use "http" with a 301 redirect to the equivalent "https" URL. If you only want to redirect for a subset of requests, consider creating an "Always use HTTPS" page rule.
     */
    public async zone$settings$get$always$use$https$setting(params: Params$zone$settings$get$always$use$https$setting, option?: RequestOption): Promise<Response$zone$settings$get$always$use$https$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/always_use_https\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Always Use HTTPS setting
     * Reply to all requests for URLs that use "http" with a 301 redirect to the equivalent "https" URL. If you only want to redirect for a subset of requests, consider creating an "Always use HTTPS" page rule.
     */
    public async zone$settings$change$always$use$https$setting(params: Params$zone$settings$change$always$use$https$setting, option?: RequestOption): Promise<Response$zone$settings$change$always$use$https$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/always_use_https\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Automatic HTTPS Rewrites setting
     * Enable the Automatic HTTPS Rewrites feature for this zone.
     */
    public async zone$settings$get$automatic$https$rewrites$setting(params: Params$zone$settings$get$automatic$https$rewrites$setting, option?: RequestOption): Promise<Response$zone$settings$get$automatic$https$rewrites$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/automatic_https_rewrites\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Automatic HTTPS Rewrites setting
     * Enable the Automatic HTTPS Rewrites feature for this zone.
     */
    public async zone$settings$change$automatic$https$rewrites$setting(params: Params$zone$settings$change$automatic$https$rewrites$setting, option?: RequestOption): Promise<Response$zone$settings$change$automatic$https$rewrites$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/automatic_https_rewrites\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Automatic Platform Optimization for WordPress setting
     * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/)
     * serves your WordPress site from Cloudflare's edge network and caches
     * third-party fonts.
     */
    public async zone$settings$get$automatic_platform_optimization$setting(params: Params$zone$settings$get$automatic_platform_optimization$setting, option?: RequestOption): Promise<Response$zone$settings$get$automatic_platform_optimization$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/automatic_platform_optimization\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Automatic Platform Optimization for WordPress setting
     * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/)
     * serves your WordPress site from Cloudflare's edge network and caches
     * third-party fonts.
     */
    public async zone$settings$change$automatic_platform_optimization$setting(params: Params$zone$settings$change$automatic_platform_optimization$setting, option?: RequestOption): Promise<Response$zone$settings$change$automatic_platform_optimization$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/automatic_platform_optimization\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Brotli setting
     * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
     */
    public async zone$settings$get$brotli$setting(params: Params$zone$settings$get$brotli$setting, option?: RequestOption): Promise<Response$zone$settings$get$brotli$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/brotli\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Brotli setting
     * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
     */
    public async zone$settings$change$brotli$setting(params: Params$zone$settings$change$brotli$setting, option?: RequestOption): Promise<Response$zone$settings$change$brotli$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/brotli\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Browser Cache TTL setting
     * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
     */
    public async zone$settings$get$browser$cache$ttl$setting(params: Params$zone$settings$get$browser$cache$ttl$setting, option?: RequestOption): Promise<Response$zone$settings$get$browser$cache$ttl$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/browser_cache_ttl\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Browser Cache TTL setting
     * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
     */
    public async zone$settings$change$browser$cache$ttl$setting(params: Params$zone$settings$change$browser$cache$ttl$setting, option?: RequestOption): Promise<Response$zone$settings$change$browser$cache$ttl$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/browser_cache_ttl\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Browser Check setting
     * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
     */
    public async zone$settings$get$browser$check$setting(params: Params$zone$settings$get$browser$check$setting, option?: RequestOption): Promise<Response$zone$settings$get$browser$check$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/browser_check\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Browser Check setting
     * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
     */
    public async zone$settings$change$browser$check$setting(params: Params$zone$settings$change$browser$check$setting, option?: RequestOption): Promise<Response$zone$settings$change$browser$check$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/browser_check\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Cache Level setting
     * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
     */
    public async zone$settings$get$cache$level$setting(params: Params$zone$settings$get$cache$level$setting, option?: RequestOption): Promise<Response$zone$settings$get$cache$level$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/cache_level\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Cache Level setting
     * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
     */
    public async zone$settings$change$cache$level$setting(params: Params$zone$settings$change$cache$level$setting, option?: RequestOption): Promise<Response$zone$settings$change$cache$level$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/cache_level\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Challenge TTL setting
     * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
     */
    public async zone$settings$get$challenge$ttl$setting(params: Params$zone$settings$get$challenge$ttl$setting, option?: RequestOption): Promise<Response$zone$settings$get$challenge$ttl$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/challenge_ttl\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Challenge TTL setting
     * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
     */
    public async zone$settings$change$challenge$ttl$setting(params: Params$zone$settings$change$challenge$ttl$setting, option?: RequestOption): Promise<Response$zone$settings$change$challenge$ttl$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/challenge_ttl\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get ciphers setting
     * Gets ciphers setting.
     */
    public async zone$settings$get$ciphers$setting(params: Params$zone$settings$get$ciphers$setting, option?: RequestOption): Promise<Response$zone$settings$get$ciphers$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ciphers\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change ciphers setting
     * Changes ciphers setting.
     */
    public async zone$settings$change$ciphers$setting(params: Params$zone$settings$change$ciphers$setting, option?: RequestOption): Promise<Response$zone$settings$change$ciphers$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ciphers\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Development Mode setting
     * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
     */
    public async zone$settings$get$development$mode$setting(params: Params$zone$settings$get$development$mode$setting, option?: RequestOption): Promise<Response$zone$settings$get$development$mode$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/development_mode\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Development Mode setting
     * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
     */
    public async zone$settings$change$development$mode$setting(params: Params$zone$settings$change$development$mode$setting, option?: RequestOption): Promise<Response$zone$settings$change$development$mode$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/development_mode\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Early Hints setting
     * When enabled, Cloudflare will attempt to speed up overall page loads by serving \`103\` responses with \`Link\` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
     */
    public async zone$settings$get$early$hints$setting(params: Params$zone$settings$get$early$hints$setting, option?: RequestOption): Promise<Response$zone$settings$get$early$hints$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/early_hints\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Early Hints setting
     * When enabled, Cloudflare will attempt to speed up overall page loads by serving \`103\` responses with \`Link\` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
     */
    public async zone$settings$change$early$hints$setting(params: Params$zone$settings$change$early$hints$setting, option?: RequestOption): Promise<Response$zone$settings$change$early$hints$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/early_hints\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Email Obfuscation setting
     * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
     */
    public async zone$settings$get$email$obfuscation$setting(params: Params$zone$settings$get$email$obfuscation$setting, option?: RequestOption): Promise<Response$zone$settings$get$email$obfuscation$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/email_obfuscation\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Email Obfuscation setting
     * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
     */
    public async zone$settings$change$email$obfuscation$setting(params: Params$zone$settings$change$email$obfuscation$setting, option?: RequestOption): Promise<Response$zone$settings$change$email$obfuscation$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/email_obfuscation\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Cloudflare Fonts setting
     * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
     * boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
     */
    public async zone$settings$get$fonts$setting(params: Params$zone$settings$get$fonts$setting, option?: RequestOption): Promise<Response$zone$settings$get$fonts$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/fonts\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Cloudflare Fonts setting
     * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
     * boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
     */
    public async zone$settings$change$fonts$setting(params: Params$zone$settings$change$fonts$setting, option?: RequestOption): Promise<Response$zone$settings$change$fonts$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/fonts\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get HTTP/2 Edge Prioritization setting
     * Gets HTTP/2 Edge Prioritization setting.
     */
    public async zone$settings$get$h2_prioritization$setting(params: Params$zone$settings$get$h2_prioritization$setting, option?: RequestOption): Promise<Response$zone$settings$get$h2_prioritization$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/h2_prioritization\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change HTTP/2 Edge Prioritization setting
     * Gets HTTP/2 Edge Prioritization setting.
     */
    public async zone$settings$change$h2_prioritization$setting(params: Params$zone$settings$change$h2_prioritization$setting, option?: RequestOption): Promise<Response$zone$settings$change$h2_prioritization$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/h2_prioritization\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Hotlink Protection setting
     * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
     */
    public async zone$settings$get$hotlink$protection$setting(params: Params$zone$settings$get$hotlink$protection$setting, option?: RequestOption): Promise<Response$zone$settings$get$hotlink$protection$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/hotlink_protection\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Hotlink Protection setting
     * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
     */
    public async zone$settings$change$hotlink$protection$setting(params: Params$zone$settings$change$hotlink$protection$setting, option?: RequestOption): Promise<Response$zone$settings$change$hotlink$protection$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/hotlink_protection\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get HTTP2 setting
     * Value of the HTTP2 setting.
     */
    public async zone$settings$get$h$t$t$p$2$setting(params: Params$zone$settings$get$h$t$t$p$2$setting, option?: RequestOption): Promise<Response$zone$settings$get$h$t$t$p$2$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/http2\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change HTTP2 setting
     * Value of the HTTP2 setting.
     */
    public async zone$settings$change$h$t$t$p$2$setting(params: Params$zone$settings$change$h$t$t$p$2$setting, option?: RequestOption): Promise<Response$zone$settings$change$h$t$t$p$2$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/http2\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get HTTP3 setting
     * Value of the HTTP3 setting.
     */
    public async zone$settings$get$h$t$t$p$3$setting(params: Params$zone$settings$get$h$t$t$p$3$setting, option?: RequestOption): Promise<Response$zone$settings$get$h$t$t$p$3$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/http3\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change HTTP3 setting
     * Value of the HTTP3 setting.
     */
    public async zone$settings$change$h$t$t$p$3$setting(params: Params$zone$settings$change$h$t$t$p$3$setting, option?: RequestOption): Promise<Response$zone$settings$change$h$t$t$p$3$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/http3\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Image Resizing setting
     * Image Resizing provides on-demand resizing, conversion and optimisation
     * for images served through Cloudflare's network. Refer to the
     * [Image Resizing documentation](https://developers.cloudflare.com/images/)
     * for more information.
     */
    public async zone$settings$get$image_resizing$setting(params: Params$zone$settings$get$image_resizing$setting, option?: RequestOption): Promise<Response$zone$settings$get$image_resizing$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/image_resizing\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Image Resizing setting
     * Image Resizing provides on-demand resizing, conversion and optimisation
     * for images served through Cloudflare's network. Refer to the
     * [Image Resizing documentation](https://developers.cloudflare.com/images/)
     * for more information.
     */
    public async zone$settings$change$image_resizing$setting(params: Params$zone$settings$change$image_resizing$setting, option?: RequestOption): Promise<Response$zone$settings$change$image_resizing$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/image_resizing\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get IP Geolocation setting
     * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
     */
    public async zone$settings$get$ip$geolocation$setting(params: Params$zone$settings$get$ip$geolocation$setting, option?: RequestOption): Promise<Response$zone$settings$get$ip$geolocation$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ip_geolocation\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change IP Geolocation setting
     * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
     */
    public async zone$settings$change$ip$geolocation$setting(params: Params$zone$settings$change$ip$geolocation$setting, option?: RequestOption): Promise<Response$zone$settings$change$ip$geolocation$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ip_geolocation\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get IPv6 setting
     * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
     */
    public async zone$settings$get$i$pv6$setting(params: Params$zone$settings$get$i$pv6$setting, option?: RequestOption): Promise<Response$zone$settings$get$i$pv6$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ipv6\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change IPv6 setting
     * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
     */
    public async zone$settings$change$i$pv6$setting(params: Params$zone$settings$change$i$pv6$setting, option?: RequestOption): Promise<Response$zone$settings$change$i$pv6$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ipv6\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Minimum TLS Version setting
     * Gets Minimum TLS Version setting.
     */
    public async zone$settings$get$minimum$tls$version$setting(params: Params$zone$settings$get$minimum$tls$version$setting, option?: RequestOption): Promise<Response$zone$settings$get$minimum$tls$version$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/min_tls_version\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Minimum TLS Version setting
     * Changes Minimum TLS Version setting.
     */
    public async zone$settings$change$minimum$tls$version$setting(params: Params$zone$settings$change$minimum$tls$version$setting, option?: RequestOption): Promise<Response$zone$settings$change$minimum$tls$version$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/min_tls_version\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Minify setting
     * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
     */
    public async zone$settings$get$minify$setting(params: Params$zone$settings$get$minify$setting, option?: RequestOption): Promise<Response$zone$settings$get$minify$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/minify\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Minify setting
     * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
     */
    public async zone$settings$change$minify$setting(params: Params$zone$settings$change$minify$setting, option?: RequestOption): Promise<Response$zone$settings$change$minify$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/minify\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Mirage setting
     * Automatically optimize image loading for website visitors on mobile
     * devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed)
     * for more information.
     */
    public async zone$settings$get$mirage$setting(params: Params$zone$settings$get$mirage$setting, option?: RequestOption): Promise<Response$zone$settings$get$mirage$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/mirage\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Mirage setting
     * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information.
     */
    public async zone$settings$change$web$mirage$setting(params: Params$zone$settings$change$web$mirage$setting, option?: RequestOption): Promise<Response$zone$settings$change$web$mirage$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/mirage\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Mobile Redirect setting
     * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
     */
    public async zone$settings$get$mobile$redirect$setting(params: Params$zone$settings$get$mobile$redirect$setting, option?: RequestOption): Promise<Response$zone$settings$get$mobile$redirect$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/mobile_redirect\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Mobile Redirect setting
     * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
     */
    public async zone$settings$change$mobile$redirect$setting(params: Params$zone$settings$change$mobile$redirect$setting, option?: RequestOption): Promise<Response$zone$settings$change$mobile$redirect$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/mobile_redirect\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Network Error Logging setting
     * Enable Network Error Logging reporting on your zone. (Beta)
     */
    public async zone$settings$get$nel$setting(params: Params$zone$settings$get$nel$setting, option?: RequestOption): Promise<Response$zone$settings$get$nel$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/nel\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Network Error Logging setting
     * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/nel-solving-mobile-speed) for more information.
     */
    public async zone$settings$change$nel$setting(params: Params$zone$settings$change$nel$setting, option?: RequestOption): Promise<Response$zone$settings$change$nel$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/nel\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Opportunistic Encryption setting
     * Gets Opportunistic Encryption setting.
     */
    public async zone$settings$get$opportunistic$encryption$setting(params: Params$zone$settings$get$opportunistic$encryption$setting, option?: RequestOption): Promise<Response$zone$settings$get$opportunistic$encryption$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/opportunistic_encryption\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Opportunistic Encryption setting
     * Changes Opportunistic Encryption setting.
     */
    public async zone$settings$change$opportunistic$encryption$setting(params: Params$zone$settings$change$opportunistic$encryption$setting, option?: RequestOption): Promise<Response$zone$settings$change$opportunistic$encryption$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/opportunistic_encryption\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Opportunistic Onion setting
     * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
     */
    public async zone$settings$get$opportunistic$onion$setting(params: Params$zone$settings$get$opportunistic$onion$setting, option?: RequestOption): Promise<Response$zone$settings$get$opportunistic$onion$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/opportunistic_onion\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Opportunistic Onion setting
     * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
     */
    public async zone$settings$change$opportunistic$onion$setting(params: Params$zone$settings$change$opportunistic$onion$setting, option?: RequestOption): Promise<Response$zone$settings$change$opportunistic$onion$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/opportunistic_onion\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Orange to Orange (O2O) setting
     * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other
     * zones also on Cloudflare.
     */
    public async zone$settings$get$orange_to_orange$setting(params: Params$zone$settings$get$orange_to_orange$setting, option?: RequestOption): Promise<Response$zone$settings$get$orange_to_orange$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/orange_to_orange\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Orange to Orange (O2O) setting
     * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other
     * zones also on Cloudflare.
     */
    public async zone$settings$change$orange_to_orange$setting(params: Params$zone$settings$change$orange_to_orange$setting, option?: RequestOption): Promise<Response$zone$settings$change$orange_to_orange$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/orange_to_orange\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Enable Error Pages On setting
     * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
     */
    public async zone$settings$get$enable$error$pages$on$setting(params: Params$zone$settings$get$enable$error$pages$on$setting, option?: RequestOption): Promise<Response$zone$settings$get$enable$error$pages$on$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/origin_error_page_pass_thru\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Enable Error Pages On setting
     * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
     */
    public async zone$settings$change$enable$error$pages$on$setting(params: Params$zone$settings$change$enable$error$pages$on$setting, option?: RequestOption): Promise<Response$zone$settings$change$enable$error$pages$on$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/origin_error_page_pass_thru\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Polish setting
     * Automatically optimize image loading for website visitors on mobile
     * devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed)
     * for more information.
     */
    public async zone$settings$get$polish$setting(params: Params$zone$settings$get$polish$setting, option?: RequestOption): Promise<Response$zone$settings$get$polish$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/polish\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Polish setting
     * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information.
     */
    public async zone$settings$change$polish$setting(params: Params$zone$settings$change$polish$setting, option?: RequestOption): Promise<Response$zone$settings$change$polish$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/polish\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get prefetch preload setting
     * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
     */
    public async zone$settings$get$prefetch$preload$setting(params: Params$zone$settings$get$prefetch$preload$setting, option?: RequestOption): Promise<Response$zone$settings$get$prefetch$preload$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/prefetch_preload\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change prefetch preload setting
     * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
     */
    public async zone$settings$change$prefetch$preload$setting(params: Params$zone$settings$change$prefetch$preload$setting, option?: RequestOption): Promise<Response$zone$settings$change$prefetch$preload$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/prefetch_preload\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Proxy Read Timeout setting
     * Maximum time between two read operations from origin.
     */
    public async zone$settings$get$proxy_read_timeout$setting(params: Params$zone$settings$get$proxy_read_timeout$setting, option?: RequestOption): Promise<Response$zone$settings$get$proxy_read_timeout$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/proxy_read_timeout\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Proxy Read Timeout setting
     * Maximum time between two read operations from origin.
     */
    public async zone$settings$change$proxy_read_timeout$setting(params: Params$zone$settings$change$proxy_read_timeout$setting, option?: RequestOption): Promise<Response$zone$settings$change$proxy_read_timeout$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/proxy_read_timeout\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Pseudo IPv4 setting
     * Value of the Pseudo IPv4 setting.
     */
    public async zone$settings$get$pseudo$i$pv4$setting(params: Params$zone$settings$get$pseudo$i$pv4$setting, option?: RequestOption): Promise<Response$zone$settings$get$pseudo$i$pv4$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/pseudo_ipv4\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Pseudo IPv4 setting
     * Value of the Pseudo IPv4 setting.
     */
    public async zone$settings$change$pseudo$i$pv4$setting(params: Params$zone$settings$change$pseudo$i$pv4$setting, option?: RequestOption): Promise<Response$zone$settings$change$pseudo$i$pv4$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/pseudo_ipv4\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Response Buffering setting
     * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
     */
    public async zone$settings$get$response$buffering$setting(params: Params$zone$settings$get$response$buffering$setting, option?: RequestOption): Promise<Response$zone$settings$get$response$buffering$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/response_buffering\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Response Buffering setting
     * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
     */
    public async zone$settings$change$response$buffering$setting(params: Params$zone$settings$change$response$buffering$setting, option?: RequestOption): Promise<Response$zone$settings$change$response$buffering$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/response_buffering\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Rocket Loader setting
     * Rocket Loader is a general-purpose asynchronous JavaScript optimisation
     * that prioritises rendering your content while loading your site's
     * Javascript asynchronously. Turning on Rocket Loader will immediately
     * improve a web page's rendering time sometimes measured as Time to First
     * Paint (TTFP), and also the \`window.onload\` time (assuming there is
     * JavaScript on the page). This can have a positive impact on your Google
     * search ranking. When turned on, Rocket Loader will automatically defer
     * the loading of all Javascript referenced in your HTML, with no
     * configuration required. Refer to
     * [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056)
     * for more information.
     */
    public async zone$settings$get$rocket_loader$setting(params: Params$zone$settings$get$rocket_loader$setting, option?: RequestOption): Promise<Response$zone$settings$get$rocket_loader$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/rocket_loader\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Rocket Loader setting
     * Rocket Loader is a general-purpose asynchronous JavaScript optimisation
     * that prioritises rendering your content while loading your site's
     * Javascript asynchronously. Turning on Rocket Loader will immediately
     * improve a web page's rendering time sometimes measured as Time to First
     * Paint (TTFP), and also the \`window.onload\` time (assuming there is
     * JavaScript on the page). This can have a positive impact on your Google
     * search ranking. When turned on, Rocket Loader will automatically defer
     * the loading of all Javascript referenced in your HTML, with no
     * configuration required. Refer to
     * [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056)
     * for more information.
     */
    public async zone$settings$change$rocket_loader$setting(params: Params$zone$settings$change$rocket_loader$setting, option?: RequestOption): Promise<Response$zone$settings$change$rocket_loader$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/rocket_loader\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Security Header (HSTS) setting
     * Cloudflare security header for a zone.
     */
    public async zone$settings$get$security$header$$$hsts$$setting(params: Params$zone$settings$get$security$header$$$hsts$$setting, option?: RequestOption): Promise<Response$zone$settings$get$security$header$$$hsts$$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/security_header\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Security Header (HSTS) setting
     * Cloudflare security header for a zone.
     */
    public async zone$settings$change$security$header$$$hsts$$setting(params: Params$zone$settings$change$security$header$$$hsts$$setting, option?: RequestOption): Promise<Response$zone$settings$change$security$header$$$hsts$$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/security_header\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Security Level setting
     * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
     */
    public async zone$settings$get$security$level$setting(params: Params$zone$settings$get$security$level$setting, option?: RequestOption): Promise<Response$zone$settings$get$security$level$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/security_level\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Security Level setting
     * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
     */
    public async zone$settings$change$security$level$setting(params: Params$zone$settings$change$security$level$setting, option?: RequestOption): Promise<Response$zone$settings$change$security$level$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/security_level\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Server Side Exclude setting
     * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
     */
    public async zone$settings$get$server$side$exclude$setting(params: Params$zone$settings$get$server$side$exclude$setting, option?: RequestOption): Promise<Response$zone$settings$get$server$side$exclude$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/server_side_exclude\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Server Side Exclude setting
     * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
     */
    public async zone$settings$change$server$side$exclude$setting(params: Params$zone$settings$change$server$side$exclude$setting, option?: RequestOption): Promise<Response$zone$settings$change$server$side$exclude$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/server_side_exclude\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Enable Query String Sort setting
     * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
     */
    public async zone$settings$get$enable$query$string$sort$setting(params: Params$zone$settings$get$enable$query$string$sort$setting, option?: RequestOption): Promise<Response$zone$settings$get$enable$query$string$sort$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/sort_query_string_for_cache\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Enable Query String Sort setting
     * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
     */
    public async zone$settings$change$enable$query$string$sort$setting(params: Params$zone$settings$change$enable$query$string$sort$setting, option?: RequestOption): Promise<Response$zone$settings$change$enable$query$string$sort$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/sort_query_string_for_cache\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get SSL setting
     * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
     */
    public async zone$settings$get$ssl$setting(params: Params$zone$settings$get$ssl$setting, option?: RequestOption): Promise<Response$zone$settings$get$ssl$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ssl\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change SSL setting
     * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
     */
    public async zone$settings$change$ssl$setting(params: Params$zone$settings$change$ssl$setting, option?: RequestOption): Promise<Response$zone$settings$change$ssl$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ssl\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get SSL/TLS Recommender enrollment setting
     * Enrollment in the SSL/TLS Recommender service which tries to detect and
     * recommend (by sending periodic emails) the most secure SSL/TLS setting
     * your origin servers support.
     */
    public async zone$settings$get$ssl_recommender$setting(params: Params$zone$settings$get$ssl_recommender$setting, option?: RequestOption): Promise<Response$zone$settings$get$ssl_recommender$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ssl_recommender\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change SSL/TLS Recommender enrollment setting
     * Enrollment in the SSL/TLS Recommender service which tries to detect and
     * recommend (by sending periodic emails) the most secure SSL/TLS setting
     * your origin servers support.
     */
    public async zone$settings$change$ssl_recommender$setting(params: Params$zone$settings$change$ssl_recommender$setting, option?: RequestOption): Promise<Response$zone$settings$change$ssl_recommender$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/ssl_recommender\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get TLS 1.3 setting enabled for a zone
     * Gets TLS 1.3 setting enabled for a zone.
     */
    public async zone$settings$get$tls$1$$3$setting$enabled$for$a$zone(params: Params$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone, option?: RequestOption): Promise<Response$zone$settings$get$tls$1$$3$setting$enabled$for$a$zone$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/tls_1_3\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change TLS 1.3 setting
     * Changes TLS 1.3 setting.
     */
    public async zone$settings$change$tls$1$$3$setting(params: Params$zone$settings$change$tls$1$$3$setting, option?: RequestOption): Promise<Response$zone$settings$change$tls$1$$3$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/tls_1_3\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get TLS Client Auth setting
     * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
     */
    public async zone$settings$get$tls$client$auth$setting(params: Params$zone$settings$get$tls$client$auth$setting, option?: RequestOption): Promise<Response$zone$settings$get$tls$client$auth$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/tls_client_auth\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change TLS Client Auth setting
     * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
     */
    public async zone$settings$change$tls$client$auth$setting(params: Params$zone$settings$change$tls$client$auth$setting, option?: RequestOption): Promise<Response$zone$settings$change$tls$client$auth$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/tls_client_auth\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get True Client IP setting
     * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
     */
    public async zone$settings$get$true$client$ip$setting(params: Params$zone$settings$get$true$client$ip$setting, option?: RequestOption): Promise<Response$zone$settings$get$true$client$ip$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/true_client_ip_header\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change True Client IP setting
     * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
     */
    public async zone$settings$change$true$client$ip$setting(params: Params$zone$settings$change$true$client$ip$setting, option?: RequestOption): Promise<Response$zone$settings$change$true$client$ip$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/true_client_ip_header\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Web Application Firewall (WAF) setting
     * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
     */
    public async zone$settings$get$web$application$firewall$$$waf$$setting(params: Params$zone$settings$get$web$application$firewall$$$waf$$setting, option?: RequestOption): Promise<Response$zone$settings$get$web$application$firewall$$$waf$$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/waf\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change Web Application Firewall (WAF) setting
     * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
     */
    public async zone$settings$change$web$application$firewall$$$waf$$setting(params: Params$zone$settings$change$web$application$firewall$$$waf$$setting, option?: RequestOption): Promise<Response$zone$settings$change$web$application$firewall$$$waf$$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/waf\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get WebP setting
     * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
     */
    public async zone$settings$get$web$p$setting(params: Params$zone$settings$get$web$p$setting, option?: RequestOption): Promise<Response$zone$settings$get$web$p$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/webp\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change WebP setting
     * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
     */
    public async zone$settings$change$web$p$setting(params: Params$zone$settings$change$web$p$setting, option?: RequestOption): Promise<Response$zone$settings$change$web$p$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/webp\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get WebSockets setting
     * Gets Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
     */
    public async zone$settings$get$web$sockets$setting(params: Params$zone$settings$get$web$sockets$setting, option?: RequestOption): Promise<Response$zone$settings$get$web$sockets$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/websockets\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Change WebSockets setting
     * Changes Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
     */
    public async zone$settings$change$web$sockets$setting(params: Params$zone$settings$change$web$sockets$setting, option?: RequestOption): Promise<Response$zone$settings$change$web$sockets$setting$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/websockets\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zaraz configuration
     * Gets latest Zaraz configuration for a zone. It can be preview or published configuration, whichever was the last updated. Secret variables values will not be included.
     */
    public async get$zones$zone_identifier$zaraz$config(params: Params$get$zones$zone_identifier$zaraz$config, option?: RequestOption): Promise<Response$get$zones$zone_identifier$zaraz$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/config\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Zaraz configuration
     * Updates Zaraz configuration for a zone.
     */
    public async put$zones$zone_identifier$zaraz$config(params: Params$put$zones$zone_identifier$zaraz$config, option?: RequestOption): Promise<Response$put$zones$zone_identifier$zaraz$config$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/config\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get default Zaraz configuration
     * Gets default Zaraz configuration for a zone.
     */
    public async get$zones$zone_identifier$zaraz$default(params: Params$get$zones$zone_identifier$zaraz$default, option?: RequestOption): Promise<Response$get$zones$zone_identifier$zaraz$default$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/default\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Export Zaraz configuration
     * Exports full current published Zaraz configuration for a zone, secret variables included.
     */
    public async get$zones$zone_identifier$zaraz$export(params: Params$get$zones$zone_identifier$zaraz$export, option?: RequestOption): Promise<Response$get$zones$zone_identifier$zaraz$export$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/export\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Zaraz historical configuration records
     * Lists a history of published Zaraz configuration records for a zone.
     */
    public async get$zones$zone_identifier$zaraz$history(params: Params$get$zones$zone_identifier$zaraz$history, option?: RequestOption): Promise<Response$get$zones$zone_identifier$zaraz$history$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/history\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            offset: { value: params.parameter.offset, explode: false },
            limit: { value: params.parameter.limit, explode: false },
            sortField: { value: params.parameter.sortField, explode: false },
            sortOrder: { value: params.parameter.sortOrder, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Restore Zaraz historical configuration by ID
     * Restores a historical published Zaraz configuration by ID for a zone.
     */
    public async put$zones$zone_identifier$zaraz$history(params: Params$put$zones$zone_identifier$zaraz$history, option?: RequestOption): Promise<Response$put$zones$zone_identifier$zaraz$history$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/history\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zaraz historical configurations by ID(s)
     * Gets a history of published Zaraz configurations by ID(s) for a zone.
     */
    public async get$zones$zone_identifier$zaraz$config$history(params: Params$get$zones$zone_identifier$zaraz$config$history, option?: RequestOption): Promise<Response$get$zones$zone_identifier$zaraz$config$history$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/history/configs\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ids: { value: params.parameter.ids, style: "form", explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Publish Zaraz preview configuration
     * Publish current Zaraz preview configuration for a zone.
     */
    public async post$zones$zone_identifier$zaraz$publish(params: Params$post$zones$zone_identifier$zaraz$publish, option?: RequestOption): Promise<Response$post$zones$zone_identifier$zaraz$publish$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/publish\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Zaraz workflow
     * Gets Zaraz workflow for a zone.
     */
    public async get$zones$zone_identifier$zaraz$workflow(params: Params$get$zones$zone_identifier$zaraz$workflow, option?: RequestOption): Promise<Response$get$zones$zone_identifier$zaraz$workflow$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/workflow\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Zaraz workflow
     * Updates Zaraz workflow for a zone.
     */
    public async put$zones$zone_identifier$zaraz$workflow(params: Params$put$zones$zone_identifier$zaraz$workflow, option?: RequestOption): Promise<Response$put$zones$zone_identifier$zaraz$workflow$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/settings/zaraz/workflow\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get quota and availability
     * Retrieves quota for all plans, as well as the current zone quota.
     */
    public async speed$get$availabilities(params: Params$speed$get$availabilities, option?: RequestOption): Promise<Response$speed$get$availabilities$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/availabilities\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List tested webpages
     * Lists all webpages which have been tested.
     */
    public async speed$list$pages(params: Params$speed$list$pages, option?: RequestOption): Promise<Response$speed$list$pages$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/pages\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List page test history
     * Test history (list of tests) for a specific webpage.
     */
    public async speed$list$test$history(params: Params$speed$list$test$history, option?: RequestOption): Promise<Response$speed$list$test$history$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/pages/\${params.parameter.url}/tests\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            region: { value: params.parameter.region, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Start page test
     * Starts a test for a specific webpage, in a specific region.
     */
    public async speed$create$test(params: Params$speed$create$test, option?: RequestOption): Promise<Response$speed$create$test$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/pages/\${params.parameter.url}/tests\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete all page tests
     * Deletes all tests for a specific webpage from a specific region. Deleted tests are still counted as part of the quota.
     */
    public async speed$delete$tests(params: Params$speed$delete$tests, option?: RequestOption): Promise<Response$speed$delete$tests$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/pages/\${params.parameter.url}/tests\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            region: { value: params.parameter.region, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a page test result
     * Retrieves the result of a specific test.
     */
    public async speed$get$test(params: Params$speed$get$test, option?: RequestOption): Promise<Response$speed$get$test$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/pages/\${params.parameter.url}/tests/\${params.parameter.test_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List core web vital metrics trend
     * Lists the core web vital metrics trend over time for a specific page.
     */
    public async speed$list$page$trend(params: Params$speed$list$page$trend, option?: RequestOption): Promise<Response$speed$list$page$trend$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/pages/\${params.parameter.url}/trend\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            region: { value: params.parameter.region, explode: false },
            deviceType: { value: params.parameter.deviceType, explode: false },
            start: { value: params.parameter.start, explode: false },
            end: { value: params.parameter.end, explode: false },
            tz: { value: params.parameter.tz, explode: false },
            metrics: { value: params.parameter.metrics, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a page test schedule
     * Retrieves the test schedule for a page in a specific region.
     */
    public async speed$get$scheduled$test(params: Params$speed$get$scheduled$test, option?: RequestOption): Promise<Response$speed$get$scheduled$test$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/schedule/\${params.parameter.url}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            region: { value: params.parameter.region, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create scheduled page test
     * Creates a scheduled test for a page.
     */
    public async speed$create$scheduled$test(params: Params$speed$create$scheduled$test, option?: RequestOption): Promise<Response$speed$create$scheduled$test$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/schedule/\${params.parameter.url}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            region: { value: params.parameter.region, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Delete scheduled page test
     * Deletes a scheduled test for a page.
     */
    public async speed$delete$test$schedule(params: Params$speed$delete$test$schedule, option?: RequestOption): Promise<Response$speed$delete$test$schedule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/speed_api/schedule/\${params.parameter.url}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            region: { value: params.parameter.region, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get URL normalization settings
     * Fetches the current URL normalization settings.
     */
    public async url$normalization$get$url$normalization$settings(params: Params$url$normalization$get$url$normalization$settings, option?: RequestOption): Promise<Response$url$normalization$get$url$normalization$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/url_normalization\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update URL normalization settings
     * Updates the URL normalization settings.
     */
    public async url$normalization$update$url$normalization$settings(params: Params$url$normalization$update$url$normalization$settings, option?: RequestOption): Promise<Response$url$normalization$update$url$normalization$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/url_normalization\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * List Filters
     */
    public async worker$filters$$$deprecated$$list$filters(params: Params$worker$filters$$$deprecated$$list$filters, option?: RequestOption): Promise<Response$worker$filters$$$deprecated$$list$filters$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/filters\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Create Filter
     */
    public async worker$filters$$$deprecated$$create$filter(params: Params$worker$filters$$$deprecated$$create$filter, option?: RequestOption): Promise<Response$worker$filters$$$deprecated$$create$filter$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/filters\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Update Filter
     */
    public async worker$filters$$$deprecated$$update$filter(params: Params$worker$filters$$$deprecated$$update$filter, option?: RequestOption): Promise<Response$worker$filters$$$deprecated$$update$filter$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/filters/\${params.parameter.filter_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Delete Filter
     */
    public async worker$filters$$$deprecated$$delete$filter(params: Params$worker$filters$$$deprecated$$delete$filter, option?: RequestOption): Promise<Response$worker$filters$$$deprecated$$delete$filter$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/filters/\${params.parameter.filter_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Routes
     * Returns routes for a zone.
     */
    public async worker$routes$list$routes(params: Params$worker$routes$list$routes, option?: RequestOption): Promise<Response$worker$routes$list$routes$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/routes\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Route
     * Creates a route that maps a URL pattern to a Worker.
     */
    public async worker$routes$create$route(params: Params$worker$routes$create$route, option?: RequestOption): Promise<Response$worker$routes$create$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/routes\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Route
     * Returns information about a route, including URL pattern and Worker.
     */
    public async worker$routes$get$route(params: Params$worker$routes$get$route, option?: RequestOption): Promise<Response$worker$routes$get$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/routes/\${params.parameter.route_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Route
     * Updates the URL pattern or Worker associated with a route.
     */
    public async worker$routes$update$route(params: Params$worker$routes$update$route, option?: RequestOption): Promise<Response$worker$routes$update$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/routes/\${params.parameter.route_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Route
     * Deletes a route.
     */
    public async worker$routes$delete$route(params: Params$worker$routes$delete$route, option?: RequestOption): Promise<Response$worker$routes$delete$route$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/routes/\${params.parameter.route_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Download Worker
     * Fetch raw script content for your worker. Note this is the original script content, not JSON encoded.
     */
    public async worker$script$$$deprecated$$download$worker(params: Params$worker$script$$$deprecated$$download$worker, option?: RequestOption): Promise<Response$worker$script$$$deprecated$$download$worker$Status$200["undefined"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/script\`;
        const headers = {
            Accept: "undefined"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * Upload Worker
     * Upload a worker, or a new version of a worker.
     */
    public async worker$script$$$deprecated$$upload$worker(params: Params$worker$script$$$deprecated$$upload$worker, option?: RequestOption): Promise<Response$worker$script$$$deprecated$$upload$worker$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/script\`;
        const headers = {
            "Content-Type": "application/javascript",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Delete Worker
     * Delete your Worker. This call has no response body on a successful delete.
     */
    public async worker$script$$$deprecated$$delete$worker(params: Params$worker$script$$$deprecated$$delete$worker, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/script\`;
        const headers = {};
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * @deprecated
     * List Bindings
     * List the bindings for a Workers script.
     */
    public async worker$binding$$$deprecated$$list$bindings(params: Params$worker$binding$$$deprecated$$list$bindings, option?: RequestOption): Promise<Response$worker$binding$$$deprecated$$list$bindings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_id}/workers/script/bindings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Total TLS Settings Details
     * Get Total TLS Settings for a Zone.
     */
    public async total$tls$total$tls$settings$details(params: Params$total$tls$total$tls$settings$details, option?: RequestOption): Promise<Response$total$tls$total$tls$settings$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/acm/total_tls\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Enable or Disable Total TLS
     * Set Total TLS Settings or disable the feature for a Zone.
     */
    public async total$tls$enable$or$disable$total$tls(params: Params$total$tls$enable$or$disable$total$tls, option?: RequestOption): Promise<Response$total$tls$enable$or$disable$total$tls$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/acm/total_tls\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * @deprecated
     * Get analytics by Co-locations
     * This view provides a breakdown of analytics data by datacenter. Note: This is available to Enterprise customers only.
     */
    public async zone$analytics$$$deprecated$$get$analytics$by$co$locations(params: Params$zone$analytics$$$deprecated$$get$analytics$by$co$locations, option?: RequestOption): Promise<Response$zone$analytics$$$deprecated$$get$analytics$by$co$locations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/analytics/colos\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            until: { value: params.parameter.until, explode: false },
            since: { value: params.parameter.since, explode: false },
            continuous: { value: params.parameter.continuous, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * @deprecated
     * Get dashboard
     * The dashboard view provides both totals and timeseries data for the given zone and time period across the entire Cloudflare network.
     */
    public async zone$analytics$$$deprecated$$get$dashboard(params: Params$zone$analytics$$$deprecated$$get$dashboard, option?: RequestOption): Promise<Response$zone$analytics$$$deprecated$$get$dashboard$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/analytics/dashboard\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            until: { value: params.parameter.until, explode: false },
            since: { value: params.parameter.since, explode: false },
            continuous: { value: params.parameter.continuous, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Available Plans
     * Lists available plans the zone can subscribe to.
     */
    public async zone$rate$plan$list$available$plans(params: Params$zone$rate$plan$list$available$plans, option?: RequestOption): Promise<Response$zone$rate$plan$list$available$plans$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/available_plans\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Available Plan Details
     * Details of the available plan that the zone can subscribe to.
     */
    public async zone$rate$plan$available$plan$details(params: Params$zone$rate$plan$available$plan$details, option?: RequestOption): Promise<Response$zone$rate$plan$available$plan$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/available_plans/\${params.parameter.plan_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Available Rate Plans
     * Lists all rate plans the zone can subscribe to.
     */
    public async zone$rate$plan$list$available$rate$plans(params: Params$zone$rate$plan$list$available$rate$plans, option?: RequestOption): Promise<Response$zone$rate$plan$list$available$rate$plans$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/available_rate_plans\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Hostname Associations
     * List Hostname Associations
     */
    public async client$certificate$for$a$zone$list$hostname$associations(params: Params$client$certificate$for$a$zone$list$hostname$associations, option?: RequestOption): Promise<Response$client$certificate$for$a$zone$list$hostname$associations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/certificate_authorities/hostname_associations\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            mtls_certificate_id: { value: params.parameter.mtls_certificate_id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Replace Hostname Associations
     * Replace Hostname Associations
     */
    public async client$certificate$for$a$zone$put$hostname$associations(params: Params$client$certificate$for$a$zone$put$hostname$associations, option?: RequestOption): Promise<Response$client$certificate$for$a$zone$put$hostname$associations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/certificate_authorities/hostname_associations\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Client Certificates
     * List all of your Zone's API Shield mTLS Client Certificates by Status and/or using Pagination
     */
    public async client$certificate$for$a$zone$list$client$certificates(params: Params$client$certificate$for$a$zone$list$client$certificates, option?: RequestOption): Promise<Response$client$certificate$for$a$zone$list$client$certificates$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/client_certificates\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            status: { value: params.parameter.status, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            limit: { value: params.parameter.limit, explode: false },
            offset: { value: params.parameter.offset, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create Client Certificate
     * Create a new API Shield mTLS Client Certificate
     */
    public async client$certificate$for$a$zone$create$client$certificate(params: Params$client$certificate$for$a$zone$create$client$certificate, option?: RequestOption): Promise<Response$client$certificate$for$a$zone$create$client$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/client_certificates\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Client Certificate Details
     * Get Details for a single mTLS API Shield Client Certificate
     */
    public async client$certificate$for$a$zone$client$certificate$details(params: Params$client$certificate$for$a$zone$client$certificate$details, option?: RequestOption): Promise<Response$client$certificate$for$a$zone$client$certificate$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/client_certificates/\${params.parameter.client_certificate_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Revoke Client Certificate
     * Set a API Shield mTLS Client Certificate to pending_revocation status for processing to revoked status.
     */
    public async client$certificate$for$a$zone$delete$client$certificate(params: Params$client$certificate$for$a$zone$delete$client$certificate, option?: RequestOption): Promise<Response$client$certificate$for$a$zone$delete$client$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/client_certificates/\${params.parameter.client_certificate_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Reactivate Client Certificate
     * If a API Shield mTLS Client Certificate is in a pending_revocation state, you may reactivate it with this endpoint.
     */
    public async client$certificate$for$a$zone$edit$client$certificate(params: Params$client$certificate$for$a$zone$edit$client$certificate, option?: RequestOption): Promise<Response$client$certificate$for$a$zone$edit$client$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/client_certificates/\${params.parameter.client_certificate_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers
        }, option);
    }
    /**
     * List SSL Configurations
     * List, search, and filter all of your custom SSL certificates. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
     */
    public async custom$ssl$for$a$zone$list$ssl$configurations(params: Params$custom$ssl$for$a$zone$list$ssl$configurations, option?: RequestOption): Promise<Response$custom$ssl$for$a$zone$list$ssl$configurations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_certificates\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            match: { value: params.parameter.match, explode: false },
            status: { value: params.parameter.status, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create SSL Configuration
     * Upload a new SSL certificate for a zone.
     */
    public async custom$ssl$for$a$zone$create$ssl$configuration(params: Params$custom$ssl$for$a$zone$create$ssl$configuration, option?: RequestOption): Promise<Response$custom$ssl$for$a$zone$create$ssl$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_certificates\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** SSL Configuration Details */
    public async custom$ssl$for$a$zone$ssl$configuration$details(params: Params$custom$ssl$for$a$zone$ssl$configuration$details, option?: RequestOption): Promise<Response$custom$ssl$for$a$zone$ssl$configuration$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete SSL Configuration
     * Remove a SSL certificate from a zone.
     */
    public async custom$ssl$for$a$zone$delete$ssl$configuration(params: Params$custom$ssl$for$a$zone$delete$ssl$configuration, option?: RequestOption): Promise<Response$custom$ssl$for$a$zone$delete$ssl$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Edit SSL Configuration
     * Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing a configuration for sni_custom certificates will result in a new resource id being returned, and the previous one being deleted.
     */
    public async custom$ssl$for$a$zone$edit$ssl$configuration(params: Params$custom$ssl$for$a$zone$edit$ssl$configuration, option?: RequestOption): Promise<Response$custom$ssl$for$a$zone$edit$ssl$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_certificates/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Re-prioritize SSL Certificates
     * If a zone has multiple SSL certificates, you can set the order in which they should be used during a request. The higher priority will break ties across overlapping 'legacy_custom' certificates.
     */
    public async custom$ssl$for$a$zone$re$prioritize$ssl$certificates(params: Params$custom$ssl$for$a$zone$re$prioritize$ssl$certificates, option?: RequestOption): Promise<Response$custom$ssl$for$a$zone$re$prioritize$ssl$certificates$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_certificates/prioritize\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Custom Hostnames
     * List, search, sort, and filter all of your custom hostnames.
     */
    public async custom$hostname$for$a$zone$list$custom$hostnames(params: Params$custom$hostname$for$a$zone$list$custom$hostnames, option?: RequestOption): Promise<Response$custom$hostname$for$a$zone$list$custom$hostnames$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_hostnames\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            hostname: { value: params.parameter.hostname, explode: false },
            id: { value: params.parameter.id, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            ssl: { value: params.parameter.ssl, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create Custom Hostname
     * Add a new custom hostname and request that an SSL certificate be issued for it. One of three validation methodsâ€”http, txt, emailâ€”should be used, with 'http' recommended if the CNAME is already in place (or will be soon). Specifying 'email' will send an email to the WHOIS contacts on file for the base domain plus hostmaster, postmaster, webmaster, admin, administrator. If http is used and the domain is not already pointing to the Managed CNAME host, the PATCH method must be used once it is (to complete validation).
     */
    public async custom$hostname$for$a$zone$create$custom$hostname(params: Params$custom$hostname$for$a$zone$create$custom$hostname, option?: RequestOption): Promise<Response$custom$hostname$for$a$zone$create$custom$hostname$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_hostnames\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Custom Hostname Details */
    public async custom$hostname$for$a$zone$custom$hostname$details(params: Params$custom$hostname$for$a$zone$custom$hostname$details, option?: RequestOption): Promise<Response$custom$hostname$for$a$zone$custom$hostname$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_hostnames/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Delete Custom Hostname (and any issued SSL certificates) */
    public async custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$(params: Params$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$, option?: RequestOption): Promise<Response$custom$hostname$for$a$zone$delete$custom$hostname$$$and$any$issued$ssl$certificates$$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_hostnames/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Edit Custom Hostname
     * Modify SSL configuration for a custom hostname. When sent with SSL config that matches existing config, used to indicate that hostname should pass domain control validation (DCV). Can also be used to change validation type, e.g., from 'http' to 'email'.
     */
    public async custom$hostname$for$a$zone$edit$custom$hostname(params: Params$custom$hostname$for$a$zone$edit$custom$hostname, option?: RequestOption): Promise<Response$custom$hostname$for$a$zone$edit$custom$hostname$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_hostnames/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get Fallback Origin for Custom Hostnames */
    public async custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames(params: Params$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames, option?: RequestOption): Promise<Response$custom$hostname$fallback$origin$for$a$zone$get$fallback$origin$for$custom$hostnames$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_hostnames/fallback_origin\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Update Fallback Origin for Custom Hostnames */
    public async custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames(params: Params$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames, option?: RequestOption): Promise<Response$custom$hostname$fallback$origin$for$a$zone$update$fallback$origin$for$custom$hostnames$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_hostnames/fallback_origin\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Delete Fallback Origin for Custom Hostnames */
    public async custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames(params: Params$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames, option?: RequestOption): Promise<Response$custom$hostname$fallback$origin$for$a$zone$delete$fallback$origin$for$custom$hostnames$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_hostnames/fallback_origin\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List custom pages
     * Fetches all the custom pages at the zone level.
     */
    public async custom$pages$for$a$zone$list$custom$pages(params: Params$custom$pages$for$a$zone$list$custom$pages, option?: RequestOption): Promise<Response$custom$pages$for$a$zone$list$custom$pages$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_pages\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get a custom page
     * Fetches the details of a custom page.
     */
    public async custom$pages$for$a$zone$get$a$custom$page(params: Params$custom$pages$for$a$zone$get$a$custom$page, option?: RequestOption): Promise<Response$custom$pages$for$a$zone$get$a$custom$page$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_pages/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a custom page
     * Updates the configuration of an existing custom page.
     */
    public async custom$pages$for$a$zone$update$a$custom$page(params: Params$custom$pages$for$a$zone$update$a$custom$page, option?: RequestOption): Promise<Response$custom$pages$for$a$zone$update$a$custom$page$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/custom_pages/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Retrieve the DCV Delegation unique identifier.
     * Retrieve the account and zone specific unique identifier used as part of the CNAME target for DCV Delegation.
     */
    public async dcv$delegation$uuid$get(params: Params$dcv$delegation$uuid$get, option?: RequestOption): Promise<Response$dcv$delegation$uuid$get$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/dcv_delegation/uuid\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Get Email Routing settings
     * Get information about the settings for your Email Routing zone.
     */
    public async email$routing$settings$get$email$routing$settings(params: Params$email$routing$settings$get$email$routing$settings, option?: RequestOption): Promise<Response$email$routing$settings$get$email$routing$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Disable Email Routing
     * Disable your Email Routing zone. Also removes additional MX records previously required for Email Routing to work.
     */
    public async email$routing$settings$disable$email$routing(params: Params$email$routing$settings$disable$email$routing, option?: RequestOption): Promise<Response$email$routing$settings$disable$email$routing$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/disable\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Email Routing - DNS settings
     * Show the DNS records needed to configure your Email Routing zone.
     */
    public async email$routing$settings$email$routing$dns$settings(params: Params$email$routing$settings$email$routing$dns$settings, option?: RequestOption): Promise<Response$email$routing$settings$email$routing$dns$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/dns\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Enable Email Routing
     * Enable you Email Routing zone. Add and lock the necessary MX and SPF records.
     */
    public async email$routing$settings$enable$email$routing(params: Params$email$routing$settings$enable$email$routing, option?: RequestOption): Promise<Response$email$routing$settings$enable$email$routing$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/enable\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * List routing rules
     * Lists existing routing rules.
     */
    public async email$routing$routing$rules$list$routing$rules(params: Params$email$routing$routing$rules$list$routing$rules, option?: RequestOption): Promise<Response$email$routing$routing$rules$list$routing$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            enabled: { value: params.parameter.enabled, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create routing rule
     * Rules consist of a set of criteria for matching emails (such as an email being sent to a specific custom email address) plus a set of actions to take on the email (like forwarding it to a specific destination address).
     */
    public async email$routing$routing$rules$create$routing$rule(params: Params$email$routing$routing$rules$create$routing$rule, option?: RequestOption): Promise<Response$email$routing$routing$rules$create$routing$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get routing rule
     * Get information for a specific routing rule already created.
     */
    public async email$routing$routing$rules$get$routing$rule(params: Params$email$routing$routing$rules$get$routing$rule, option?: RequestOption): Promise<Response$email$routing$routing$rules$get$routing$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/rules/\${params.parameter.rule_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update routing rule
     * Update actions and matches, or enable/disable specific routing rules.
     */
    public async email$routing$routing$rules$update$routing$rule(params: Params$email$routing$routing$rules$update$routing$rule, option?: RequestOption): Promise<Response$email$routing$routing$rules$update$routing$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/rules/\${params.parameter.rule_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete routing rule
     * Delete a specific routing rule.
     */
    public async email$routing$routing$rules$delete$routing$rule(params: Params$email$routing$routing$rules$delete$routing$rule, option?: RequestOption): Promise<Response$email$routing$routing$rules$delete$routing$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/rules/\${params.parameter.rule_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get catch-all rule
     * Get information on the default catch-all routing rule.
     */
    public async email$routing$routing$rules$get$catch$all$rule(params: Params$email$routing$routing$rules$get$catch$all$rule, option?: RequestOption): Promise<Response$email$routing$routing$rules$get$catch$all$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/rules/catch_all\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update catch-all rule
     * Enable or disable catch-all routing rule, or change action to forward to specific destination address.
     */
    public async email$routing$routing$rules$update$catch$all$rule(params: Params$email$routing$routing$rules$update$catch$all$rule, option?: RequestOption): Promise<Response$email$routing$routing$rules$update$catch$all$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/email/routing/rules/catch_all\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List filters
     * Fetches filters in a zone. You can filter the results using several optional parameters.
     */
    public async filters$list$filters(params: Params$filters$list$filters, option?: RequestOption): Promise<Response$filters$list$filters$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/filters\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            paused: { value: params.parameter.paused, explode: false },
            expression: { value: params.parameter.expression, explode: false },
            description: { value: params.parameter.description, explode: false },
            ref: { value: params.parameter.ref, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            id: { value: params.parameter.id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Update filters
     * Updates one or more existing filters.
     */
    public async filters$update$filters(params: Params$filters$update$filters, option?: RequestOption): Promise<Response$filters$update$filters$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/filters\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create filters
     * Creates one or more filters.
     */
    public async filters$create$filters(params: Params$filters$create$filters, option?: RequestOption): Promise<Response$filters$create$filters$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/filters\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete filters
     * Deletes one or more existing filters.
     */
    public async filters$delete$filters(params: Params$filters$delete$filters, option?: RequestOption): Promise<Response$filters$delete$filters$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/filters\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a filter
     * Fetches the details of a filter.
     */
    public async filters$get$a$filter(params: Params$filters$get$a$filter, option?: RequestOption): Promise<Response$filters$get$a$filter$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/filters/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a filter
     * Updates an existing filter.
     */
    public async filters$update$a$filter(params: Params$filters$update$a$filter, option?: RequestOption): Promise<Response$filters$update$a$filter$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/filters/\${params.parameter.id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a filter
     * Deletes an existing filter.
     */
    public async filters$delete$a$filter(params: Params$filters$delete$a$filter, option?: RequestOption): Promise<Response$filters$delete$a$filter$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/filters/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Zone Lockdown rules
     * Fetches Zone Lockdown rules. You can filter the results using several optional parameters.
     */
    public async zone$lockdown$list$zone$lockdown$rules(params: Params$zone$lockdown$list$zone$lockdown$rules, option?: RequestOption): Promise<Response$zone$lockdown$list$zone$lockdown$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/lockdowns\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            description: { value: params.parameter.description, explode: false },
            modified_on: { value: params.parameter.modified_on, explode: false },
            ip: { value: params.parameter.ip, explode: false },
            priority: { value: params.parameter.priority, explode: false },
            uri_search: { value: params.parameter.uri_search, explode: false },
            ip_range_search: { value: params.parameter.ip_range_search, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            created_on: { value: params.parameter.created_on, explode: false },
            description_search: { value: params.parameter.description_search, explode: false },
            ip_search: { value: params.parameter.ip_search, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a Zone Lockdown rule
     * Creates a new Zone Lockdown rule.
     */
    public async zone$lockdown$create$a$zone$lockdown$rule(params: Params$zone$lockdown$create$a$zone$lockdown$rule, option?: RequestOption): Promise<Response$zone$lockdown$create$a$zone$lockdown$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/lockdowns\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a Zone Lockdown rule
     * Fetches the details of a Zone Lockdown rule.
     */
    public async zone$lockdown$get$a$zone$lockdown$rule(params: Params$zone$lockdown$get$a$zone$lockdown$rule, option?: RequestOption): Promise<Response$zone$lockdown$get$a$zone$lockdown$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/lockdowns/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a Zone Lockdown rule
     * Updates an existing Zone Lockdown rule.
     */
    public async zone$lockdown$update$a$zone$lockdown$rule(params: Params$zone$lockdown$update$a$zone$lockdown$rule, option?: RequestOption): Promise<Response$zone$lockdown$update$a$zone$lockdown$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/lockdowns/\${params.parameter.id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a Zone Lockdown rule
     * Deletes an existing Zone Lockdown rule.
     */
    public async zone$lockdown$delete$a$zone$lockdown$rule(params: Params$zone$lockdown$delete$a$zone$lockdown$rule, option?: RequestOption): Promise<Response$zone$lockdown$delete$a$zone$lockdown$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/lockdowns/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List firewall rules
     * Fetches firewall rules in a zone. You can filter the results using several optional parameters.
     */
    public async firewall$rules$list$firewall$rules(params: Params$firewall$rules$list$firewall$rules, option?: RequestOption): Promise<Response$firewall$rules$list$firewall$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            description: { value: params.parameter.description, explode: false },
            action: { value: params.parameter.action, explode: false },
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            id: { value: params.parameter.id, explode: false },
            paused: { value: params.parameter.paused, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Update firewall rules
     * Updates one or more existing firewall rules.
     */
    public async firewall$rules$update$firewall$rules(params: Params$firewall$rules$update$firewall$rules, option?: RequestOption): Promise<Response$firewall$rules$update$firewall$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create firewall rules
     * Create one or more firewall rules.
     */
    public async firewall$rules$create$firewall$rules(params: Params$firewall$rules$create$firewall$rules, option?: RequestOption): Promise<Response$firewall$rules$create$firewall$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete firewall rules
     * Deletes existing firewall rules.
     */
    public async firewall$rules$delete$firewall$rules(params: Params$firewall$rules$delete$firewall$rules, option?: RequestOption): Promise<Response$firewall$rules$delete$firewall$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update priority of firewall rules
     * Updates the priority of existing firewall rules.
     */
    public async firewall$rules$update$priority$of$firewall$rules(params: Params$firewall$rules$update$priority$of$firewall$rules, option?: RequestOption): Promise<Response$firewall$rules$update$priority$of$firewall$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a firewall rule
     * Fetches the details of a firewall rule.
     */
    public async firewall$rules$get$a$firewall$rule(params: Params$firewall$rules$get$a$firewall$rule, option?: RequestOption): Promise<Response$firewall$rules$get$a$firewall$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            id: { value: params.parameter.id, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Update a firewall rule
     * Updates an existing firewall rule.
     */
    public async firewall$rules$update$a$firewall$rule(params: Params$firewall$rules$update$a$firewall$rule, option?: RequestOption): Promise<Response$firewall$rules$update$a$firewall$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules/\${params.parameter.id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a firewall rule
     * Deletes an existing firewall rule.
     */
    public async firewall$rules$delete$a$firewall$rule(params: Params$firewall$rules$delete$a$firewall$rule, option?: RequestOption): Promise<Response$firewall$rules$delete$a$firewall$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules/\${params.parameter.id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Update priority of a firewall rule
     * Updates the priority of an existing firewall rule.
     */
    public async firewall$rules$update$priority$of$a$firewall$rule(params: Params$firewall$rules$update$priority$of$a$firewall$rule, option?: RequestOption): Promise<Response$firewall$rules$update$priority$of$a$firewall$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/rules/\${params.parameter.id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List User Agent Blocking rules
     * Fetches User Agent Blocking rules in a zone. You can filter the results using several optional parameters.
     */
    public async user$agent$blocking$rules$list$user$agent$blocking$rules(params: Params$user$agent$blocking$rules$list$user$agent$blocking$rules, option?: RequestOption): Promise<Response$user$agent$blocking$rules$list$user$agent$blocking$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/ua_rules\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            description: { value: params.parameter.description, explode: false },
            description_search: { value: params.parameter.description_search, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            ua_search: { value: params.parameter.ua_search, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a User Agent Blocking rule
     * Creates a new User Agent Blocking rule in a zone.
     */
    public async user$agent$blocking$rules$create$a$user$agent$blocking$rule(params: Params$user$agent$blocking$rules$create$a$user$agent$blocking$rule, option?: RequestOption): Promise<Response$user$agent$blocking$rules$create$a$user$agent$blocking$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/ua_rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a User Agent Blocking rule
     * Fetches the details of a User Agent Blocking rule.
     */
    public async user$agent$blocking$rules$get$a$user$agent$blocking$rule(params: Params$user$agent$blocking$rules$get$a$user$agent$blocking$rule, option?: RequestOption): Promise<Response$user$agent$blocking$rules$get$a$user$agent$blocking$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/ua_rules/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a User Agent Blocking rule
     * Updates an existing User Agent Blocking rule.
     */
    public async user$agent$blocking$rules$update$a$user$agent$blocking$rule(params: Params$user$agent$blocking$rules$update$a$user$agent$blocking$rule, option?: RequestOption): Promise<Response$user$agent$blocking$rules$update$a$user$agent$blocking$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/ua_rules/\${params.parameter.id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a User Agent Blocking rule
     * Deletes an existing User Agent Blocking rule.
     */
    public async user$agent$blocking$rules$delete$a$user$agent$blocking$rule(params: Params$user$agent$blocking$rules$delete$a$user$agent$blocking$rule, option?: RequestOption): Promise<Response$user$agent$blocking$rules$delete$a$user$agent$blocking$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/ua_rules/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List WAF overrides
     * Fetches the URI-based WAF overrides in a zone.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$overrides$list$waf$overrides(params: Params$waf$overrides$list$waf$overrides, option?: RequestOption): Promise<Response$waf$overrides$list$waf$overrides$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/waf/overrides\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a WAF override
     * Creates a URI-based WAF override for a zone.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$overrides$create$a$waf$override(params: Params$waf$overrides$create$a$waf$override, option?: RequestOption): Promise<Response$waf$overrides$create$a$waf$override$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/waf/overrides\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a WAF override
     * Fetches the details of a URI-based WAF override.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$overrides$get$a$waf$override(params: Params$waf$overrides$get$a$waf$override, option?: RequestOption): Promise<Response$waf$overrides$get$a$waf$override$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/waf/overrides/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update WAF override
     * Updates an existing URI-based WAF override.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$overrides$update$waf$override(params: Params$waf$overrides$update$waf$override, option?: RequestOption): Promise<Response$waf$overrides$update$waf$override$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/waf/overrides/\${params.parameter.id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a WAF override
     * Deletes an existing URI-based WAF override.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$overrides$delete$a$waf$override(params: Params$waf$overrides$delete$a$waf$override, option?: RequestOption): Promise<Response$waf$overrides$delete$a$waf$override$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/waf/overrides/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List WAF packages
     * Fetches WAF packages for a zone.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$packages$list$waf$packages(params: Params$waf$packages$list$waf$packages, option?: RequestOption): Promise<Response$waf$packages$list$waf$packages$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/waf/packages\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            order: { value: params.parameter.order, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            match: { value: params.parameter.match, explode: false },
            name: { value: params.parameter.name, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get a WAF package
     * Fetches the details of a WAF package.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$packages$get$a$waf$package(params: Params$waf$packages$get$a$waf$package, option?: RequestOption): Promise<Response$waf$packages$get$a$waf$package$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/waf/packages/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a WAF package
     * Updates a WAF package. You can update the sensitivity and the action of an anomaly detection WAF package.
     *
     * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
     */
    public async waf$packages$update$a$waf$package(params: Params$waf$packages$update$a$waf$package, option?: RequestOption): Promise<Response$waf$packages$update$a$waf$package$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/firewall/waf/packages/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Health Checks
     * List configured health checks.
     */
    public async health$checks$list$health$checks(params: Params$health$checks$list$health$checks, option?: RequestOption): Promise<Response$health$checks$list$health$checks$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create Health Check
     * Create a new health check.
     */
    public async health$checks$create$health$check(params: Params$health$checks$create$health$check, option?: RequestOption): Promise<Response$health$checks$create$health$check$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Health Check Details
     * Fetch a single configured health check.
     */
    public async health$checks$health$check$details(params: Params$health$checks$health$check$details, option?: RequestOption): Promise<Response$health$checks$health$check$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Health Check
     * Update a configured health check.
     */
    public async health$checks$update$health$check(params: Params$health$checks$update$health$check, option?: RequestOption): Promise<Response$health$checks$update$health$check$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Health Check
     * Delete a health check.
     */
    public async health$checks$delete$health$check(params: Params$health$checks$delete$health$check, option?: RequestOption): Promise<Response$health$checks$delete$health$check$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Health Check
     * Patch a configured health check.
     */
    public async health$checks$patch$health$check(params: Params$health$checks$patch$health$check, option?: RequestOption): Promise<Response$health$checks$patch$health$check$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create Preview Health Check
     * Create a new preview health check.
     */
    public async health$checks$create$preview$health$check(params: Params$health$checks$create$preview$health$check, option?: RequestOption): Promise<Response$health$checks$create$preview$health$check$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks/preview\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Health Check Preview Details
     * Fetch a single configured health check preview.
     */
    public async health$checks$health$check$preview$details(params: Params$health$checks$health$check$preview$details, option?: RequestOption): Promise<Response$health$checks$health$check$preview$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks/preview/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete Preview Health Check
     * Delete a health check.
     */
    public async health$checks$delete$preview$health$check(params: Params$health$checks$delete$preview$health$check, option?: RequestOption): Promise<Response$health$checks$delete$preview$health$check$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/healthchecks/preview/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List TLS setting for hostnames
     * List the requested TLS setting for the hostnames under this zone.
     */
    public async per$hostname$tls$settings$list(params: Params$per$hostname$tls$settings$list, option?: RequestOption): Promise<Response$per$hostname$tls$settings$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/hostnames/settings/\${params.parameter.tls_setting}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Edit TLS setting for hostname
     * Update the tls setting value for the hostname.
     */
    public async per$hostname$tls$settings$put(params: Params$per$hostname$tls$settings$put, option?: RequestOption): Promise<Response$per$hostname$tls$settings$put$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/hostnames/settings/\${params.parameter.tls_setting}/\${params.parameter.hostname}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete TLS setting for hostname
     * Delete the tls setting value for the hostname.
     */
    public async per$hostname$tls$settings$delete(params: Params$per$hostname$tls$settings$delete, option?: RequestOption): Promise<Response$per$hostname$tls$settings$delete$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/hostnames/settings/\${params.parameter.tls_setting}/\${params.parameter.hostname}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * List Keyless SSL Configurations
     * List all Keyless SSL configurations for a given zone.
     */
    public async keyless$ssl$for$a$zone$list$keyless$ssl$configurations(params: Params$keyless$ssl$for$a$zone$list$keyless$ssl$configurations, option?: RequestOption): Promise<Response$keyless$ssl$for$a$zone$list$keyless$ssl$configurations$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/keyless_certificates\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Create Keyless SSL Configuration */
    public async keyless$ssl$for$a$zone$create$keyless$ssl$configuration(params: Params$keyless$ssl$for$a$zone$create$keyless$ssl$configuration, option?: RequestOption): Promise<Response$keyless$ssl$for$a$zone$create$keyless$ssl$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/keyless_certificates\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Keyless SSL Configuration
     * Get details for one Keyless SSL configuration.
     */
    public async keyless$ssl$for$a$zone$get$keyless$ssl$configuration(params: Params$keyless$ssl$for$a$zone$get$keyless$ssl$configuration, option?: RequestOption): Promise<Response$keyless$ssl$for$a$zone$get$keyless$ssl$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/keyless_certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Delete Keyless SSL Configuration */
    public async keyless$ssl$for$a$zone$delete$keyless$ssl$configuration(params: Params$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration, option?: RequestOption): Promise<Response$keyless$ssl$for$a$zone$delete$keyless$ssl$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/keyless_certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Edit Keyless SSL Configuration
     * This will update attributes of a Keyless SSL. Consists of one or more of the following:  host,name,port.
     */
    public async keyless$ssl$for$a$zone$edit$keyless$ssl$configuration(params: Params$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration, option?: RequestOption): Promise<Response$keyless$ssl$for$a$zone$edit$keyless$ssl$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/keyless_certificates/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get log retention flag
     * Gets log retention flag for Logpull API.
     */
    public async logs$received$get$log$retention$flag(params: Params$logs$received$get$log$retention$flag, option?: RequestOption): Promise<Response$logs$received$get$log$retention$flag$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/logs/control/retention/flag\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update log retention flag
     * Updates log retention flag for Logpull API.
     */
    public async logs$received$update$log$retention$flag(params: Params$logs$received$update$log$retention$flag, option?: RequestOption): Promise<Response$logs$received$update$log$retention$flag$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/logs/control/retention/flag\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get logs RayIDs
     * The \`/rayids\` api route allows lookups by specific rayid. The rayids route will return zero, one, or more records (ray ids are not unique).
     */
    public async logs$received$get$logs$ray$i$ds(params: Params$logs$received$get$logs$ray$i$ds, option?: RequestOption): Promise<Response$logs$received$get$logs$ray$i$ds$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/logs/rayids/\${params.parameter.ray_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            timestamps: { value: params.parameter.timestamps, explode: false },
            fields: { value: params.parameter.fields, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get logs received
     * The \`/received\` api route allows customers to retrieve their edge HTTP logs. The basic access pattern is "give me all the logs for zone Z for minute M", where the minute M refers to the time records were received at Cloudflare's central data center. \`start\` is inclusive, and \`end\` is exclusive. Because of that, to get all data, at minutely cadence, starting at 10AM, the proper values are: \`start=2018-05-20T10:00:00Z&end=2018-05-20T10:01:00Z\`, then \`start=2018-05-20T10:01:00Z&end=2018-05-20T10:02:00Z\` and so on; the overlap will be handled properly.
     */
    public async logs$received$get$logs$received(params: Params$logs$received$get$logs$received, option?: RequestOption): Promise<Response$logs$received$get$logs$received$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/logs/received\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            end: { value: params.parameter.end, explode: false },
            sample: { value: params.parameter.sample, explode: false },
            timestamps: { value: params.parameter.timestamps, explode: false },
            count: { value: params.parameter.count, explode: false },
            fields: { value: params.parameter.fields, explode: false },
            start: { value: params.parameter.start, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List fields
     * Lists all fields available. The response is json object with key-value pairs, where keys are field names, and values are descriptions.
     */
    public async logs$received$list$fields(params: Params$logs$received$list$fields, option?: RequestOption): Promise<Response$logs$received$list$fields$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/logs/received/fields\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** List Certificates */
    public async zone$level$authenticated$origin$pulls$list$certificates(params: Params$zone$level$authenticated$origin$pulls$list$certificates, option?: RequestOption): Promise<Response$zone$level$authenticated$origin$pulls$list$certificates$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Upload Certificate
     * Upload your own certificate you want Cloudflare to use for edge-to-origin communication to override the shared certificate. Please note that it is important to keep only one certificate active. Also, make sure to enable zone-level authenticated origin pulls by making a PUT call to settings endpoint to see the uploaded certificate in use.
     */
    public async zone$level$authenticated$origin$pulls$upload$certificate(params: Params$zone$level$authenticated$origin$pulls$upload$certificate, option?: RequestOption): Promise<Response$zone$level$authenticated$origin$pulls$upload$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get Certificate Details */
    public async zone$level$authenticated$origin$pulls$get$certificate$details(params: Params$zone$level$authenticated$origin$pulls$get$certificate$details, option?: RequestOption): Promise<Response$zone$level$authenticated$origin$pulls$get$certificate$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Delete Certificate */
    public async zone$level$authenticated$origin$pulls$delete$certificate(params: Params$zone$level$authenticated$origin$pulls$delete$certificate, option?: RequestOption): Promise<Response$zone$level$authenticated$origin$pulls$delete$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Enable or Disable a Hostname for Client Authentication
     * Associate a hostname to a certificate and enable, disable or invalidate the association. If disabled, client certificate will not be sent to the hostname even if activated at the zone level. 100 maximum associations on a single certificate are allowed. Note: Use a null value for parameter *enabled* to invalidate the association.
     */
    public async per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication(params: Params$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication, option?: RequestOption): Promise<Response$per$hostname$authenticated$origin$pull$enable$or$disable$a$hostname$for$client$authentication$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/hostnames\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get the Hostname Status for Client Authentication */
    public async per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication(params: Params$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication, option?: RequestOption): Promise<Response$per$hostname$authenticated$origin$pull$get$the$hostname$status$for$client$authentication$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/hostnames/\${params.parameter.hostname}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** List Certificates */
    public async per$hostname$authenticated$origin$pull$list$certificates(params: Params$per$hostname$authenticated$origin$pull$list$certificates, option?: RequestOption): Promise<Response$per$hostname$authenticated$origin$pull$list$certificates$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/hostnames/certificates\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Upload a Hostname Client Certificate
     * Upload a certificate to be used for client authentication on a hostname. 10 hostname certificates per zone are allowed.
     */
    public async per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate(params: Params$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate, option?: RequestOption): Promise<Response$per$hostname$authenticated$origin$pull$upload$a$hostname$client$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/hostnames/certificates\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get the Hostname Client Certificate
     * Get the certificate by ID to be used for client authentication on a hostname.
     */
    public async per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate(params: Params$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate, option?: RequestOption): Promise<Response$per$hostname$authenticated$origin$pull$get$the$hostname$client$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/hostnames/certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Delete Hostname Client Certificate */
    public async per$hostname$authenticated$origin$pull$delete$hostname$client$certificate(params: Params$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate, option?: RequestOption): Promise<Response$per$hostname$authenticated$origin$pull$delete$hostname$client$certificate$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/hostnames/certificates/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get Enablement Setting for Zone
     * Get whether zone-level authenticated origin pulls is enabled or not. It is false by default.
     */
    public async zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone(params: Params$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone, option?: RequestOption): Promise<Response$zone$level$authenticated$origin$pulls$get$enablement$setting$for$zone$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Set Enablement for Zone
     * Enable or disable zone-level authenticated origin pulls. 'enabled' should be set true either before/after the certificate is uploaded to see the certificate in use.
     */
    public async zone$level$authenticated$origin$pulls$set$enablement$for$zone(params: Params$zone$level$authenticated$origin$pulls$set$enablement$for$zone, option?: RequestOption): Promise<Response$zone$level$authenticated$origin$pulls$set$enablement$for$zone$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/origin_tls_client_auth/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List rate limits
     * Fetches the rate limits for a zone.
     */
    public async rate$limits$for$a$zone$list$rate$limits(params: Params$rate$limits$for$a$zone$list$rate$limits, option?: RequestOption): Promise<Response$rate$limits$for$a$zone$list$rate$limits$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/rate_limits\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create a rate limit
     * Creates a new rate limit for a zone. Refer to the object definition for a list of required attributes.
     */
    public async rate$limits$for$a$zone$create$a$rate$limit(params: Params$rate$limits$for$a$zone$create$a$rate$limit, option?: RequestOption): Promise<Response$rate$limits$for$a$zone$create$a$rate$limit$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/rate_limits\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get a rate limit
     * Fetches the details of a rate limit.
     */
    public async rate$limits$for$a$zone$get$a$rate$limit(params: Params$rate$limits$for$a$zone$get$a$rate$limit, option?: RequestOption): Promise<Response$rate$limits$for$a$zone$get$a$rate$limit$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/rate_limits/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update a rate limit
     * Updates an existing rate limit.
     */
    public async rate$limits$for$a$zone$update$a$rate$limit(params: Params$rate$limits$for$a$zone$update$a$rate$limit, option?: RequestOption): Promise<Response$rate$limits$for$a$zone$update$a$rate$limit$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/rate_limits/\${params.parameter.id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete a rate limit
     * Deletes an existing rate limit.
     */
    public async rate$limits$for$a$zone$delete$a$rate$limit(params: Params$rate$limits$for$a$zone$delete$a$rate$limit, option?: RequestOption): Promise<Response$rate$limits$for$a$zone$delete$a$rate$limit$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/rate_limits/\${params.parameter.id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Force AXFR
     * Sends AXFR zone transfer request to primary nameserver(s).
     */
    public async secondary$dns$$$secondary$zone$$force$axfr(params: Params$secondary$dns$$$secondary$zone$$force$axfr, option?: RequestOption): Promise<Response$secondary$dns$$$secondary$zone$$force$axfr$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/force_axfr\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Secondary Zone Configuration Details
     * Get secondary zone configuration for incoming zone transfers.
     */
    public async secondary$dns$$$secondary$zone$$secondary$zone$configuration$details(params: Params$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details, option?: RequestOption): Promise<Response$secondary$dns$$$secondary$zone$$secondary$zone$configuration$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/incoming\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Secondary Zone Configuration
     * Update secondary zone configuration for incoming zone transfers.
     */
    public async secondary$dns$$$secondary$zone$$update$secondary$zone$configuration(params: Params$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration, option?: RequestOption): Promise<Response$secondary$dns$$$secondary$zone$$update$secondary$zone$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/incoming\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create Secondary Zone Configuration
     * Create secondary zone configuration for incoming zone transfers.
     */
    public async secondary$dns$$$secondary$zone$$create$secondary$zone$configuration(params: Params$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration, option?: RequestOption): Promise<Response$secondary$dns$$$secondary$zone$$create$secondary$zone$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/incoming\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Secondary Zone Configuration
     * Delete secondary zone configuration for incoming zone transfers.
     */
    public async secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration(params: Params$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration, option?: RequestOption): Promise<Response$secondary$dns$$$secondary$zone$$delete$secondary$zone$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/incoming\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Primary Zone Configuration Details
     * Get primary zone configuration for outgoing zone transfers.
     */
    public async secondary$dns$$$primary$zone$$primary$zone$configuration$details(params: Params$secondary$dns$$$primary$zone$$primary$zone$configuration$details, option?: RequestOption): Promise<Response$secondary$dns$$$primary$zone$$primary$zone$configuration$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/outgoing\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Primary Zone Configuration
     * Update primary zone configuration for outgoing zone transfers.
     */
    public async secondary$dns$$$primary$zone$$update$primary$zone$configuration(params: Params$secondary$dns$$$primary$zone$$update$primary$zone$configuration, option?: RequestOption): Promise<Response$secondary$dns$$$primary$zone$$update$primary$zone$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/outgoing\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create Primary Zone Configuration
     * Create primary zone configuration for outgoing zone transfers.
     */
    public async secondary$dns$$$primary$zone$$create$primary$zone$configuration(params: Params$secondary$dns$$$primary$zone$$create$primary$zone$configuration, option?: RequestOption): Promise<Response$secondary$dns$$$primary$zone$$create$primary$zone$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/outgoing\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Primary Zone Configuration
     * Delete primary zone configuration for outgoing zone transfers.
     */
    public async secondary$dns$$$primary$zone$$delete$primary$zone$configuration(params: Params$secondary$dns$$$primary$zone$$delete$primary$zone$configuration, option?: RequestOption): Promise<Response$secondary$dns$$$primary$zone$$delete$primary$zone$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/outgoing\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Disable Outgoing Zone Transfers
     * Disable outgoing zone transfers for primary zone and clears IXFR backlog of primary zone.
     */
    public async secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers(params: Params$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers, option?: RequestOption): Promise<Response$secondary$dns$$$primary$zone$$disable$outgoing$zone$transfers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/outgoing/disable\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Enable Outgoing Zone Transfers
     * Enable outgoing zone transfers for primary zone.
     */
    public async secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers(params: Params$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers, option?: RequestOption): Promise<Response$secondary$dns$$$primary$zone$$enable$outgoing$zone$transfers$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/outgoing/enable\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Force DNS NOTIFY
     * Notifies the secondary nameserver(s) and clears IXFR backlog of primary zone.
     */
    public async secondary$dns$$$primary$zone$$force$dns$notify(params: Params$secondary$dns$$$primary$zone$$force$dns$notify, option?: RequestOption): Promise<Response$secondary$dns$$$primary$zone$$force$dns$notify$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/outgoing/force_notify\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers
        }, option);
    }
    /**
     * Get Outgoing Zone Transfer Status
     * Get primary zone transfer status.
     */
    public async secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status(params: Params$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status, option?: RequestOption): Promise<Response$secondary$dns$$$primary$zone$$get$outgoing$zone$transfer$status$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/secondary_dns/outgoing/status\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** All Snippets */
    public async zone$snippets(params: Params$zone$snippets, option?: RequestOption): Promise<Response$zone$snippets$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/snippets\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Snippet */
    public async zone$snippets$snippet(params: Params$zone$snippets$snippet, option?: RequestOption): Promise<Response$zone$snippets$snippet$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/snippets/\${params.parameter.snippet_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Put Snippet */
    public async zone$snippets$snippet$put(params: Params$zone$snippets$snippet$put, option?: RequestOption): Promise<Response$zone$snippets$snippet$put$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/snippets/\${params.parameter.snippet_name}\`;
        const headers = {
            "Content-Type": "multipart/form-data",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Delete Snippet */
    public async zone$snippets$snippet$delete(params: Params$zone$snippets$snippet$delete, option?: RequestOption): Promise<Response$zone$snippets$snippet$delete$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/snippets/\${params.parameter.snippet_name}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /** Snippet Content */
    public async zone$snippets$snippet$content(params: Params$zone$snippets$snippet$content, option?: RequestOption): Promise<Response$zone$snippets$snippet$content$Status$200["multipart/form-data"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/snippets/\${params.parameter.snippet_name}/content\`;
        const headers = {
            Accept: "multipart/form-data"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Rules */
    public async zone$snippets$snippet$rules(params: Params$zone$snippets$snippet$rules, option?: RequestOption): Promise<Response$zone$snippets$snippet$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/snippets/snippet_rules\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Put Rules */
    public async zone$snippets$snippet$rules$put(params: Params$zone$snippets$snippet$rules$put, option?: RequestOption): Promise<Response$zone$snippets$snippet$rules$put$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/snippets/snippet_rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List Certificate Packs
     * For a given zone, list all active certificate packs.
     */
    public async certificate$packs$list$certificate$packs(params: Params$certificate$packs$list$certificate$packs, option?: RequestOption): Promise<Response$certificate$packs$list$certificate$packs$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/certificate_packs\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            status: { value: params.parameter.status, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get Certificate Pack
     * For a given zone, get a certificate pack.
     */
    public async certificate$packs$get$certificate$pack(params: Params$certificate$packs$get$certificate$pack, option?: RequestOption): Promise<Response$certificate$packs$get$certificate$pack$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/certificate_packs/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Delete Advanced Certificate Manager Certificate Pack
     * For a given zone, delete an advanced certificate pack.
     */
    public async certificate$packs$delete$advanced$certificate$manager$certificate$pack(params: Params$certificate$packs$delete$advanced$certificate$manager$certificate$pack, option?: RequestOption): Promise<Response$certificate$packs$delete$advanced$certificate$manager$certificate$pack$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/certificate_packs/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Restart Validation for Advanced Certificate Manager Certificate Pack
     * For a given zone, restart validation for an advanced certificate pack.  This is only a validation operation for a Certificate Pack in a validation_timed_out status.
     */
    public async certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack(params: Params$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack, option?: RequestOption): Promise<Response$certificate$packs$restart$validation$for$advanced$certificate$manager$certificate$pack$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/certificate_packs/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers
        }, option);
    }
    /**
     * Order Advanced Certificate Manager Certificate Pack
     * For a given zone, order an advanced certificate pack.
     */
    public async certificate$packs$order$advanced$certificate$manager$certificate$pack(params: Params$certificate$packs$order$advanced$certificate$manager$certificate$pack, option?: RequestOption): Promise<Response$certificate$packs$order$advanced$certificate$manager$certificate$pack$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/certificate_packs/order\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Certificate Pack Quotas
     * For a given zone, list certificate pack quotas.
     */
    public async certificate$packs$get$certificate$pack$quotas(params: Params$certificate$packs$get$certificate$pack$quotas, option?: RequestOption): Promise<Response$certificate$packs$get$certificate$pack$quotas$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/certificate_packs/quota\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * SSL/TLS Recommendation
     * Retrieve the SSL/TLS Recommender's recommendation for a zone.
     */
    public async ssl$$tls$mode$recommendation$ssl$$tls$recommendation(params: Params$ssl$$tls$mode$recommendation$ssl$$tls$recommendation, option?: RequestOption): Promise<Response$ssl$$tls$mode$recommendation$ssl$$tls$recommendation$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/recommendation\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Universal SSL Settings Details
     * Get Universal SSL Settings for a Zone.
     */
    public async universal$ssl$settings$for$a$zone$universal$ssl$settings$details(params: Params$universal$ssl$settings$for$a$zone$universal$ssl$settings$details, option?: RequestOption): Promise<Response$universal$ssl$settings$for$a$zone$universal$ssl$settings$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/universal/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Edit Universal SSL Settings
     * Patch Universal SSL Settings for a Zone.
     */
    public async universal$ssl$settings$for$a$zone$edit$universal$ssl$settings(params: Params$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings, option?: RequestOption): Promise<Response$universal$ssl$settings$for$a$zone$edit$universal$ssl$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/universal/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * SSL Verification Details
     * Get SSL Verification Info for a Zone.
     */
    public async ssl$verification$ssl$verification$details(params: Params$ssl$verification$ssl$verification$details, option?: RequestOption): Promise<Response$ssl$verification$ssl$verification$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/verification\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            retry: { value: params.parameter.retry, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Edit SSL Certificate Pack Validation Method
     * Edit SSL validation method for a certificate pack. A PATCH request will request an immediate validation check on any certificate, and return the updated status. If a validation method is provided, the validation will be immediately attempted using that method.
     */
    public async ssl$verification$edit$ssl$certificate$pack$validation$method(params: Params$ssl$verification$edit$ssl$certificate$pack$validation$method, option?: RequestOption): Promise<Response$ssl$verification$edit$ssl$certificate$pack$validation$method$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/ssl/verification/\${params.parameter.cert_pack_uuid}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List waiting rooms
     * Lists waiting rooms.
     */
    public async waiting$room$list$waiting$rooms(params: Params$waiting$room$list$waiting$rooms, option?: RequestOption): Promise<Response$waiting$room$list$waiting$rooms$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create waiting room
     * Creates a new waiting room.
     */
    public async waiting$room$create$waiting$room(params: Params$waiting$room$create$waiting$room, option?: RequestOption): Promise<Response$waiting$room$create$waiting$room$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Waiting room details
     * Fetches a single configured waiting room.
     */
    public async waiting$room$waiting$room$details(params: Params$waiting$room$waiting$room$details, option?: RequestOption): Promise<Response$waiting$room$waiting$room$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update waiting room
     * Updates a configured waiting room.
     */
    public async waiting$room$update$waiting$room(params: Params$waiting$room$update$waiting$room, option?: RequestOption): Promise<Response$waiting$room$update$waiting$room$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete waiting room
     * Deletes a waiting room.
     */
    public async waiting$room$delete$waiting$room(params: Params$waiting$room$delete$waiting$room, option?: RequestOption): Promise<Response$waiting$room$delete$waiting$room$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch waiting room
     * Patches a configured waiting room.
     */
    public async waiting$room$patch$waiting$room(params: Params$waiting$room$patch$waiting$room, option?: RequestOption): Promise<Response$waiting$room$patch$waiting$room$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * List events
     * Lists events for a waiting room.
     */
    public async waiting$room$list$events(params: Params$waiting$room$list$events, option?: RequestOption): Promise<Response$waiting$room$list$events$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/events\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create event
     * Only available for the Waiting Room Advanced subscription. Creates an event for a waiting room. An event takes place during a specified period of time, temporarily changing the behavior of a waiting room. While the event is active, some of the properties in the event's configuration may either override or inherit from the waiting room's configuration. Note that events cannot overlap with each other, so only one event can be active at a time.
     */
    public async waiting$room$create$event(params: Params$waiting$room$create$event, option?: RequestOption): Promise<Response$waiting$room$create$event$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/events\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Event details
     * Fetches a single configured event for a waiting room.
     */
    public async waiting$room$event$details(params: Params$waiting$room$event$details, option?: RequestOption): Promise<Response$waiting$room$event$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/events/\${params.parameter.event_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update event
     * Updates a configured event for a waiting room.
     */
    public async waiting$room$update$event(params: Params$waiting$room$update$event, option?: RequestOption): Promise<Response$waiting$room$update$event$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/events/\${params.parameter.event_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete event
     * Deletes an event for a waiting room.
     */
    public async waiting$room$delete$event(params: Params$waiting$room$delete$event, option?: RequestOption): Promise<Response$waiting$room$delete$event$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/events/\${params.parameter.event_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch event
     * Patches a configured event for a waiting room.
     */
    public async waiting$room$patch$event(params: Params$waiting$room$patch$event, option?: RequestOption): Promise<Response$waiting$room$patch$event$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/events/\${params.parameter.event_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Preview active event details
     * Previews an event's configuration as if it was active. Inherited fields from the waiting room will be displayed with their current values.
     */
    public async waiting$room$preview$active$event$details(params: Params$waiting$room$preview$active$event$details, option?: RequestOption): Promise<Response$waiting$room$preview$active$event$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/events/\${params.parameter.event_id}/details\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * List Waiting Room Rules
     * Lists rules for a waiting room.
     */
    public async waiting$room$list$waiting$room$rules(params: Params$waiting$room$list$waiting$room$rules, option?: RequestOption): Promise<Response$waiting$room$list$waiting$room$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/rules\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Replace Waiting Room Rules
     * Only available for the Waiting Room Advanced subscription. Replaces all rules for a waiting room.
     */
    public async waiting$room$replace$waiting$room$rules(params: Params$waiting$room$replace$waiting$room$rules, option?: RequestOption): Promise<Response$waiting$room$replace$waiting$room$rules$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Create Waiting Room Rule
     * Only available for the Waiting Room Advanced subscription. Creates a rule for a waiting room.
     */
    public async waiting$room$create$waiting$room$rule(params: Params$waiting$room$create$waiting$room$rule, option?: RequestOption): Promise<Response$waiting$room$create$waiting$room$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/rules\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Waiting Room Rule
     * Deletes a rule for a waiting room.
     */
    public async waiting$room$delete$waiting$room$rule(params: Params$waiting$room$delete$waiting$room$rule, option?: RequestOption): Promise<Response$waiting$room$delete$waiting$room$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/rules/\${params.parameter.rule_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Patch Waiting Room Rule
     * Patches a rule for a waiting room.
     */
    public async waiting$room$patch$waiting$room$rule(params: Params$waiting$room$patch$waiting$room$rule, option?: RequestOption): Promise<Response$waiting$room$patch$waiting$room$rule$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/rules/\${params.parameter.rule_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get waiting room status
     * Fetches the status of a configured waiting room. Response fields include:
     * 1. \`status\`: String indicating the status of the waiting room. The possible status are:
     * 	- **not_queueing** indicates that the configured thresholds have not been met and all users are going through to the origin.
     * 	- **queueing** indicates that the thresholds have been met and some users are held in the waiting room.
     * 	- **event_prequeueing** indicates that an event is active and is currently prequeueing users before it starts.
     * 2. \`event_id\`: String of the current event's \`id\` if an event is active, otherwise an empty string.
     * 3. \`estimated_queued_users\`: Integer of the estimated number of users currently waiting in the queue.
     * 4. \`estimated_total_active_users\`: Integer of the estimated number of users currently active on the origin.
     * 5. \`max_estimated_time_minutes\`: Integer of the maximum estimated time currently presented to the users.
     */
    public async waiting$room$get$waiting$room$status(params: Params$waiting$room$get$waiting$room$status, option?: RequestOption): Promise<Response$waiting$room$get$waiting$room$status$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/\${params.parameter.waiting_room_id}/status\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Create a custom waiting room page preview
     * Creates a waiting room page preview. Upload a custom waiting room page for preview. You will receive a preview URL in the form \`http://waitingrooms.dev/preview/<uuid>\`. You can use the following query parameters to change the state of the preview:
     * 1. \`force_queue\`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website (also known as queueAll).
     * 2. \`queue_is_full\`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.
     * 3. \`queueing_method\`: The queueing method currently used by the waiting room.
     * 	- **fifo** indicates a FIFO queue.
     * 	- **random** indicates a Random queue.
     * 	- **passthrough** indicates a Passthrough queue. Keep in mind that the waiting room page will only be displayed if \`force_queue=true\` or \`event=prequeueing\` â€” for other cases the request will pass through to the origin. For our preview, this will be a fake origin website returning "Welcome".
     * 	- **reject** indicates a Reject queue.
     * 4. \`event\`: Used to preview a waiting room event.
     * 	- **none** indicates no event is occurring.
     * 	- **prequeueing** indicates that an event is prequeueing (between \`prequeue_start_time\` and \`event_start_time\`).
     * 	- **started** indicates that an event has started (between \`event_start_time\` and \`event_end_time\`).
     * 5. \`shuffle_at_event_start\`: Boolean indicating if the event will shuffle users in the prequeue when it starts. This can only be set to **true** if an event is active (\`event\` is not **none**).
     *
     * For example, you can make a request to \`http://waitingrooms.dev/preview/<uuid>?force_queue=false&queue_is_full=false&queueing_method=random&event=started&shuffle_at_event_start=true\`
     * 6. \`waitTime\`: Non-zero, positive integer indicating the estimated wait time in minutes. The default value is 10 minutes.
     *
     * For example, you can make a request to \`http://waitingrooms.dev/preview/<uuid>?waitTime=50\` to configure the estimated wait time as 50 minutes.
     */
    public async waiting$room$create$a$custom$waiting$room$page$preview(params: Params$waiting$room$create$a$custom$waiting$room$page$preview, option?: RequestOption): Promise<Response$waiting$room$create$a$custom$waiting$room$page$preview$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/preview\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Get zone-level Waiting Room settings */
    public async waiting$room$get$zone$settings(params: Params$waiting$room$get$zone$settings, option?: RequestOption): Promise<Response$waiting$room$get$zone$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/settings\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Update zone-level Waiting Room settings */
    public async waiting$room$update$zone$settings(params: Params$waiting$room$update$zone$settings, option?: RequestOption): Promise<Response$waiting$room$update$zone$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Patch zone-level Waiting Room settings */
    public async waiting$room$patch$zone$settings(params: Params$waiting$room$patch$zone$settings, option?: RequestOption): Promise<Response$waiting$room$patch$zone$settings$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/waiting_rooms/settings\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** List Web3 Hostnames */
    public async web3$hostname$list$web3$hostnames(params: Params$web3$hostname$list$web3$hostnames, option?: RequestOption): Promise<Response$web3$hostname$list$web3$hostnames$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Create Web3 Hostname */
    public async web3$hostname$create$web3$hostname(params: Params$web3$hostname$create$web3$hostname, option?: RequestOption): Promise<Response$web3$hostname$create$web3$hostname$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Web3 Hostname Details */
    public async web3$hostname$web3$hostname$details(params: Params$web3$hostname$web3$hostname$details, option?: RequestOption): Promise<Response$web3$hostname$web3$hostname$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Delete Web3 Hostname */
    public async web3$hostname$delete$web3$hostname(params: Params$web3$hostname$delete$web3$hostname, option?: RequestOption): Promise<Response$web3$hostname$delete$web3$hostname$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /** Edit Web3 Hostname */
    public async web3$hostname$edit$web3$hostname(params: Params$web3$hostname$edit$web3$hostname, option?: RequestOption): Promise<Response$web3$hostname$edit$web3$hostname$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PATCH",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** IPFS Universal Path Gateway Content List Details */
    public async web3$hostname$ipfs$universal$path$gateway$content$list$details(params: Params$web3$hostname$ipfs$universal$path$gateway$content$list$details, option?: RequestOption): Promise<Response$web3$hostname$ipfs$universal$path$gateway$content$list$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}/ipfs_universal_path/content_list\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Update IPFS Universal Path Gateway Content List */
    public async web3$hostname$update$ipfs$universal$path$gateway$content$list(params: Params$web3$hostname$update$ipfs$universal$path$gateway$content$list, option?: RequestOption): Promise<Response$web3$hostname$update$ipfs$universal$path$gateway$content$list$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}/ipfs_universal_path/content_list\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** List IPFS Universal Path Gateway Content List Entries */
    public async web3$hostname$list$ipfs$universal$path$gateway$content$list$entries(params: Params$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries, option?: RequestOption): Promise<Response$web3$hostname$list$ipfs$universal$path$gateway$content$list$entries$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}/ipfs_universal_path/content_list/entries\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Create IPFS Universal Path Gateway Content List Entry */
    public async web3$hostname$create$ipfs$universal$path$gateway$content$list$entry(params: Params$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry, option?: RequestOption): Promise<Response$web3$hostname$create$ipfs$universal$path$gateway$content$list$entry$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}/ipfs_universal_path/content_list/entries\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** IPFS Universal Path Gateway Content List Entry Details */
    public async web3$hostname$ipfs$universal$path$gateway$content$list$entry$details(params: Params$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details, option?: RequestOption): Promise<Response$web3$hostname$ipfs$universal$path$gateway$content$list$entry$details$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}/ipfs_universal_path/content_list/entries/\${params.parameter.content_list_entry_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /** Edit IPFS Universal Path Gateway Content List Entry */
    public async web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry(params: Params$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry, option?: RequestOption): Promise<Response$web3$hostname$edit$ipfs$universal$path$gateway$content$list$entry$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}/ipfs_universal_path/content_list/entries/\${params.parameter.content_list_entry_identifier}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /** Delete IPFS Universal Path Gateway Content List Entry */
    public async web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry(params: Params$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry, option?: RequestOption): Promise<Response$web3$hostname$delete$ipfs$universal$path$gateway$content$list$entry$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone_identifier}/web3/hostnames/\${params.parameter.identifier}/ipfs_universal_path/content_list/entries/\${params.parameter.content_list_entry_identifier}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
    /**
     * Get current aggregated analytics
     * Retrieves analytics aggregated from the last minute of usage on Spectrum applications underneath a given zone.
     */
    public async spectrum$aggregate$analytics$get$current$aggregated$analytics(params: Params$spectrum$aggregate$analytics$get$current$aggregated$analytics, option?: RequestOption): Promise<Response$spectrum$aggregate$analytics$get$current$aggregated$analytics$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone}/spectrum/analytics/aggregate/current\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            appID: { value: params.parameter.appID, explode: false },
            app_id_param: { value: params.parameter.app_id_param, explode: false },
            colo_name: { value: params.parameter.colo_name, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get analytics by time
     * Retrieves a list of aggregate metrics grouped by time interval.
     */
    public async spectrum$analytics$$$by$time$$get$analytics$by$time(params: Params$spectrum$analytics$$$by$time$$get$analytics$by$time, option?: RequestOption): Promise<Response$spectrum$analytics$$$by$time$$get$analytics$by$time$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone}/spectrum/analytics/events/bytime\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            dimensions: { value: params.parameter.dimensions, explode: false },
            sort: { value: params.parameter.sort, explode: false },
            until: { value: params.parameter.until, explode: false },
            metrics: { value: params.parameter.metrics, explode: false },
            filters: { value: params.parameter.filters, explode: false },
            since: { value: params.parameter.since, explode: false },
            time_delta: { value: params.parameter.time_delta, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Get analytics summary
     * Retrieves a list of summarised aggregate metrics over a given time period.
     */
    public async spectrum$analytics$$$summary$$get$analytics$summary(params: Params$spectrum$analytics$$$summary$$get$analytics$summary, option?: RequestOption): Promise<Response$spectrum$analytics$$$summary$$get$analytics$summary$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone}/spectrum/analytics/events/summary\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            dimensions: { value: params.parameter.dimensions, explode: false },
            sort: { value: params.parameter.sort, explode: false },
            until: { value: params.parameter.until, explode: false },
            metrics: { value: params.parameter.metrics, explode: false },
            filters: { value: params.parameter.filters, explode: false },
            since: { value: params.parameter.since, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * List Spectrum applications
     * Retrieves a list of currently existing Spectrum applications inside a zone.
     */
    public async spectrum$applications$list$spectrum$applications(params: Params$spectrum$applications$list$spectrum$applications, option?: RequestOption): Promise<Response$spectrum$applications$list$spectrum$applications$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone}/spectrum/apps\`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            page: { value: params.parameter.page, explode: false },
            per_page: { value: params.parameter.per_page, explode: false },
            direction: { value: params.parameter.direction, explode: false },
            order: { value: params.parameter.order, explode: false }
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers,
            queryParameters: queryParameters
        }, option);
    }
    /**
     * Create Spectrum application using a name for the origin
     * Creates a new Spectrum application from a configuration using a name for the origin.
     */
    public async spectrum$applications$create$spectrum$application$using$a$name$for$the$origin(params: Params$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin, option?: RequestOption): Promise<Response$spectrum$applications$create$spectrum$application$using$a$name$for$the$origin$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone}/spectrum/apps\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "POST",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Get Spectrum application configuration
     * Gets the application configuration of a specific application inside a zone.
     */
    public async spectrum$applications$get$spectrum$application$configuration(params: Params$spectrum$applications$get$spectrum$application$configuration, option?: RequestOption): Promise<Response$spectrum$applications$get$spectrum$application$configuration$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone}/spectrum/apps/\${params.parameter.app_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "GET",
            url,
            headers
        }, option);
    }
    /**
     * Update Spectrum application configuration using a name for the origin
     * Updates a previously existing application's configuration that uses a name for the origin.
     */
    public async spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin(params: Params$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin, option?: RequestOption): Promise<Response$spectrum$applications$update$spectrum$application$configuration$using$a$name$for$the$origin$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone}/spectrum/apps/\${params.parameter.app_id}\`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "PUT",
            url,
            headers,
            requestBody: params.requestBody
        }, option);
    }
    /**
     * Delete Spectrum application
     * Deletes a previously existing application.
     */
    public async spectrum$applications$delete$spectrum$application(params: Params$spectrum$applications$delete$spectrum$application, option?: RequestOption): Promise<Response$spectrum$applications$delete$spectrum$application$Status$200["application/json"]> {
        const url = this.baseUrl + \`/zones/\${params.parameter.zone}/spectrum/apps/\${params.parameter.app_id}\`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request({
            httpMethod: "DELETE",
            url,
            headers
        }, option);
    }
}
"
`;
