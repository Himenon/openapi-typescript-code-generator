// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Argo Rollout client.ts 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.0.0
// 
// 


export namespace Schemas {
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ALBTrafficRouting {
        ingress?: string;
        servicePort?: number;
        rootService?: string;
        annotationPrefix?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AmbassadorTrafficRouting {
        mappings?: string[];
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunArgument {
        name?: string;
        value?: string;
        valueFrom?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ArgumentValueFrom;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunStrategy {
        successfulRunHistoryLimit?: number;
        unsuccessfulRunHistoryLimit?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AntiAffinity {
        preferredDuringSchedulingIgnoredDuringExecution?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PreferredDuringSchedulingIgnoredDuringExecution;
        requiredDuringSchedulingIgnoredDuringExecution?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RequiredDuringSchedulingIgnoredDuringExecution;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ArgumentValueFrom {
        podTemplateHashValue?: string;
        fieldRef?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$FieldRef;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$BlueGreenStatus {
        previewSelector?: string;
        activeSelector?: string;
        scaleUpPreviewCheckPoint?: boolean;
        prePromotionAnalysisRunStatus?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus;
        postPromotionAnalysisRunStatus?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$BlueGreenStrategy {
        /** Name of the service that the rollout modifies as the active service. */
        activeService?: string;
        previewService?: string;
        previewReplicaCount?: number;
        autoPromotionEnabled?: boolean;
        autoPromotionSeconds?: number;
        maxUnavailable?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        scaleDownDelaySeconds?: number;
        scaleDownDelayRevisionLimit?: number;
        prePromotionAnalysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis;
        antiAffinity?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AntiAffinity;
        postPromotionAnalysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis;
        previewMetadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        activeMetadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        abortScaleDownDelaySeconds?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStatus {
        currentStepAnalysisRunStatus?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus;
        currentBackgroundAnalysisRunStatus?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus;
        currentExperiment?: string;
    }
    /** CanaryStep defines a step of a canary deployment. */
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStep {
        setWeight?: number;
        pause?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutPause;
        experiment?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentStep;
        analysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis;
        setCanaryScale?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$SetCanaryScale;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStrategy {
        canaryService?: string;
        stableService?: string;
        steps?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStep[];
        trafficRouting?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutTrafficRouting;
        maxUnavailable?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        maxSurge?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        analysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisBackground;
        antiAffinity?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AntiAffinity;
        canaryMetadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        stableMetadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        scaleDownDelaySeconds?: number;
        scaleDownDelayRevisionLimit?: number;
        abortScaleDownDelaySeconds?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$FieldRef {
        fieldPath?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioDestinationRule {
        name?: string;
        canarySubsetName?: string;
        stableSubsetName?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioTrafficRouting {
        virtualService?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioVirtualService;
        destinationRule?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioDestinationRule;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioVirtualService {
        name?: string;
        routes?: string[];
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$NginxTrafficRouting {
        annotationPrefix?: string;
        stableIngress?: string;
        additionalIngressAnnotations?: {
            [key: string]: string;
        };
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ObjectRef {
        apiVersion?: string;
        kind?: string;
        name?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PauseCondition {
        reason?: string;
        startTime?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata {
        labels?: {
            [key: string]: string;
        };
        annotations?: {
            [key: string]: string;
        };
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PreferredDuringSchedulingIgnoredDuringExecution {
        /** Weight associated with matching the corresponding podAffinityTerm, in the range 1-100. */
        weight?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RequiredDuringSchedulingIgnoredDuringExecution {
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout {
        metadata?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        spec?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutSpec;
        status?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutStatus;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis {
        templates?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisTemplate[];
        args?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunArgument[];
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisBackground {
        rolloutAnalysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis;
        startingStep?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus {
        name?: string;
        status?: string;
        message?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisTemplate {
        templateName?: string;
        clusterScope?: boolean;
    }
    /** RolloutCondition describes the state of a rollout at a certain point. */
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutCondition {
        /** Type of deployment condition. */
        type?: string;
        /** Phase of the condition, one of True, False, Unknown. */
        status?: string;
        lastUpdateTime?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        lastTransitionTime?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        /** The reason for the condition's last transition. */
        reason?: string;
        /** A human readable message indicating details about the transition. */
        message?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentStep {
        templates?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentTemplate[];
        duration?: string;
        analyses?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentStepAnalysisTemplateRef[];
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentStepAnalysisTemplateRef {
        name?: string;
        templateName?: string;
        clusterScope?: boolean;
        args?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunArgument[];
        requiredForCompletion?: boolean;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentTemplate {
        name?: string;
        specRef?: string;
        replicas?: number;
        metadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        selector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutPause {
        duration?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutSpec {
        replicas?: number;
        selector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
        template?: Schemas.k8s$io$api$core$v1$PodTemplateSpec;
        workloadRef?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ObjectRef;
        minReadySeconds?: number;
        strategy?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutStrategy;
        revisionHistoryLimit?: number;
        /** Paused pauses the rollout at its current step. */
        paused?: boolean;
        /**
         * ProgressDeadlineSeconds The maximum time in seconds for a rollout to
         * make progress before it is considered to be failed. Argo Rollouts will
         * continue to process failed rollouts and a condition with a
         * ProgressDeadlineExceeded reason will be surfaced in the rollout status.
         * Note that progress will not be estimated during the time a rollout is paused.
         * Defaults to 600s.
         */
        progressDeadlineSeconds?: number;
        restartAt?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        analysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunStrategy;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutStatus {
        abort?: boolean;
        pauseConditions?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PauseCondition[];
        /**
         * ControllerPause indicates the controller has paused the rollout. It is set to true when
         * the controller adds a pause condition. This field helps to discern the scenario where a
         * rollout was resumed after being paused by the controller (e.g. via the plugin). In that
         * situation, the pauseConditions would have been cleared , but controllerPause would still be
         * set to true.
         */
        controllerPause?: boolean;
        abortedAt?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        currentPodHash?: string;
        currentStepHash?: string;
        replicas?: number;
        updatedReplicas?: number;
        readyReplicas?: number;
        availableReplicas?: number;
        currentStepIndex?: number;
        collisionCount?: number;
        observedGeneration?: string;
        workloadObservedGeneration?: string;
        conditions?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutCondition[];
        canary?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStatus;
        blueGreen?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$BlueGreenStatus;
        HPAReplicas?: number;
        selector?: string;
        stableRS?: string;
        restartedAt?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        /** PromoteFull indicates if the rollout should perform a full promotion, skipping analysis and pauses. */
        promoteFull?: boolean;
        phase?: string;
        message?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutStrategy {
        blueGreen?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$BlueGreenStrategy;
        canary?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStrategy;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutTrafficRouting {
        istio?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioTrafficRouting;
        nginx?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$NginxTrafficRouting;
        alb?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ALBTrafficRouting;
        smi?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$SMITrafficRouting;
        ambassador?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AmbassadorTrafficRouting;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$SMITrafficRouting {
        rootService?: string;
        trafficSplitName?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$SetCanaryScale {
        weight?: number;
        replicas?: number;
        matchTrafficWeight?: boolean;
    }
    export interface google$protobuf$Any {
        type_url?: string;
        value?: string;
    }
    export interface grpc$gateway$runtime$Error {
        error?: string;
        code?: number;
        message?: string;
        details?: Schemas.google$protobuf$Any[];
    }
    export interface grpc$gateway$runtime$StreamError {
        grpc_code?: number;
        http_code?: number;
        message?: string;
        http_status?: string;
        details?: Schemas.google$protobuf$Any[];
    }
    /**
     * Represents a Persistent Disk resource in AWS.
     *
     * An AWS EBS disk must exist before mounting to a container. The disk
     * must also be in the same AWS zone as the kubelet. An AWS EBS disk
     * can only be mounted as read/write once. AWS EBS volumes support
     * ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$AWSElasticBlockStoreVolumeSource {
        volumeID?: string;
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
    }
    /** Affinity is a group of affinity scheduling rules. */
    export interface k8s$io$api$core$v1$Affinity {
        nodeAffinity?: Schemas.k8s$io$api$core$v1$NodeAffinity;
        podAffinity?: Schemas.k8s$io$api$core$v1$PodAffinity;
        podAntiAffinity?: Schemas.k8s$io$api$core$v1$PodAntiAffinity;
    }
    /** AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. */
    export interface k8s$io$api$core$v1$AzureDiskVolumeSource {
        diskName?: string;
        diskURI?: string;
        cachingMode?: string;
        fsType?: string;
        readOnly?: boolean;
        kind?: string;
    }
    /** AzureFile represents an Azure File Service mount on the host and bind mount to the pod. */
    export interface k8s$io$api$core$v1$AzureFileVolumeSource {
        secretName?: string;
        shareName?: string;
        readOnly?: boolean;
    }
    export interface k8s$io$api$core$v1$CSIVolumeSource {
        /**
         * Driver is the name of the CSI driver that handles this volume.
         * Consult with your admin for the correct name as registered in the cluster.
         */
        driver?: string;
        readOnly?: boolean;
        fsType?: string;
        volumeAttributes?: {
            [key: string]: string;
        };
        nodePublishSecretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
    }
    /** Adds and removes POSIX capabilities from running containers. */
    export interface k8s$io$api$core$v1$Capabilities {
        add?: string[];
        drop?: string[];
    }
    /**
     * Represents a Ceph Filesystem mount that lasts the lifetime of a pod
     * Cephfs volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$CephFSVolumeSource {
        monitors?: string[];
        path?: string;
        user?: string;
        secretFile?: string;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        readOnly?: boolean;
    }
    /**
     * Represents a cinder volume resource in Openstack.
     * A Cinder volume must exist before mounting to a container.
     * The volume must also be in the same region as the kubelet.
     * Cinder volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$CinderVolumeSource {
        volumeID?: string;
        fsType?: string;
        readOnly?: boolean;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
    }
    /**
     * ConfigMapEnvSource selects a ConfigMap to populate the environment
     * variables with.
     *
     * The contents of the target ConfigMap's Data field will represent the
     * key-value pairs as environment variables.
     */
    export interface k8s$io$api$core$v1$ConfigMapEnvSource {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        optional?: boolean;
    }
    /** Selects a key from a ConfigMap. */
    export interface k8s$io$api$core$v1$ConfigMapKeySelector {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /** The key to select. */
        key?: string;
        optional?: boolean;
    }
    /**
     * Adapts a ConfigMap into a projected volume.
     *
     * The contents of the target ConfigMap's Data field will be presented in a
     * projected volume as files using the keys in the Data field as the file names,
     * unless the items element is populated with specific mappings of keys to paths.
     * Note that this is identical to a configmap volume source without the default
     * mode.
     */
    export interface k8s$io$api$core$v1$ConfigMapProjection {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        items?: Schemas.k8s$io$api$core$v1$KeyToPath[];
        optional?: boolean;
    }
    /**
     * Adapts a ConfigMap into a volume.
     *
     * The contents of the target ConfigMap's Data field will be presented in a
     * volume as files using the keys in the Data field as the file names, unless
     * the items element is populated with specific mappings of keys to paths.
     * ConfigMap volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$ConfigMapVolumeSource {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        items?: Schemas.k8s$io$api$core$v1$KeyToPath[];
        defaultMode?: number;
        optional?: boolean;
    }
    /** A single application container that you want to run within a pod. */
    export interface k8s$io$api$core$v1$Container {
        /**
         * Name of the container specified as a DNS_LABEL.
         * Each container in a pod must have a unique name (DNS_LABEL).
         * Cannot be updated.
         */
        name?: string;
        image?: string;
        command?: string[];
        args?: string[];
        workingDir?: string;
        ports?: Schemas.k8s$io$api$core$v1$ContainerPort[];
        envFrom?: Schemas.k8s$io$api$core$v1$EnvFromSource[];
        env?: Schemas.k8s$io$api$core$v1$EnvVar[];
        resources?: Schemas.k8s$io$api$core$v1$ResourceRequirements;
        volumeMounts?: Schemas.k8s$io$api$core$v1$VolumeMount[];
        volumeDevices?: Schemas.k8s$io$api$core$v1$VolumeDevice[];
        livenessProbe?: Schemas.k8s$io$api$core$v1$Probe;
        readinessProbe?: Schemas.k8s$io$api$core$v1$Probe;
        startupProbe?: Schemas.k8s$io$api$core$v1$Probe;
        lifecycle?: Schemas.k8s$io$api$core$v1$Lifecycle;
        terminationMessagePath?: string;
        terminationMessagePolicy?: string;
        imagePullPolicy?: string;
        securityContext?: Schemas.k8s$io$api$core$v1$SecurityContext;
        stdin?: boolean;
        stdinOnce?: boolean;
        tty?: boolean;
    }
    /** ContainerPort represents a network port in a single container. */
    export interface k8s$io$api$core$v1$ContainerPort {
        name?: string;
        hostPort?: number;
        /**
         * Number of port to expose on the pod's IP address.
         * This must be a valid port number, 0 < x < 65536.
         */
        containerPort?: number;
        protocol?: string;
        hostIP?: string;
    }
    /**
     * Represents downward API info for projecting into a projected volume.
     * Note that this is identical to a downwardAPI volume source without the default
     * mode.
     */
    export interface k8s$io$api$core$v1$DownwardAPIProjection {
        items?: Schemas.k8s$io$api$core$v1$DownwardAPIVolumeFile[];
    }
    export interface k8s$io$api$core$v1$DownwardAPIVolumeFile {
        path?: string;
        fieldRef?: Schemas.k8s$io$api$core$v1$ObjectFieldSelector;
        resourceFieldRef?: Schemas.k8s$io$api$core$v1$ResourceFieldSelector;
        mode?: number;
    }
    /**
     * DownwardAPIVolumeSource represents a volume containing downward API info.
     * Downward API volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$DownwardAPIVolumeSource {
        items?: Schemas.k8s$io$api$core$v1$DownwardAPIVolumeFile[];
        defaultMode?: number;
    }
    /**
     * Represents an empty directory for a pod.
     * Empty directory volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$EmptyDirVolumeSource {
        medium?: string;
        sizeLimit?: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
    }
    export interface k8s$io$api$core$v1$EnvFromSource {
        prefix?: string;
        configMapRef?: Schemas.k8s$io$api$core$v1$ConfigMapEnvSource;
        secretRef?: Schemas.k8s$io$api$core$v1$SecretEnvSource;
    }
    /** EnvVar represents an environment variable present in a Container. */
    export interface k8s$io$api$core$v1$EnvVar {
        /** Name of the environment variable. Must be a C_IDENTIFIER. */
        name?: string;
        value?: string;
        valueFrom?: Schemas.k8s$io$api$core$v1$EnvVarSource;
    }
    /** EnvVarSource represents a source for the value of an EnvVar. */
    export interface k8s$io$api$core$v1$EnvVarSource {
        fieldRef?: Schemas.k8s$io$api$core$v1$ObjectFieldSelector;
        resourceFieldRef?: Schemas.k8s$io$api$core$v1$ResourceFieldSelector;
        configMapKeyRef?: Schemas.k8s$io$api$core$v1$ConfigMapKeySelector;
        secretKeyRef?: Schemas.k8s$io$api$core$v1$SecretKeySelector;
    }
    /**
     * An EphemeralContainer is a container that may be added temporarily to an existing pod for
     * user-initiated activities such as debugging. Ephemeral containers have no resource or
     * scheduling guarantees, and they will not be restarted when they exit or when a pod is
     * removed or restarted. If an ephemeral container causes a pod to exceed its resource
     * allocation, the pod may be evicted.
     * Ephemeral containers may not be added by directly updating the pod spec. They must be added
     * via the pod's ephemeralcontainers subresource, and they will appear in the pod spec
     * once added.
     * This is an alpha feature enabled by the EphemeralContainers feature flag.
     */
    export interface k8s$io$api$core$v1$EphemeralContainer {
        ephemeralContainerCommon?: Schemas.k8s$io$api$core$v1$EphemeralContainerCommon;
        targetContainerName?: string;
    }
    /**
     * EphemeralContainerCommon is a copy of all fields in Container to be inlined in
     * EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
     * to Container and allows separate documentation for the fields of EphemeralContainer.
     * When a new field is added to Container it must be added here as well.
     */
    export interface k8s$io$api$core$v1$EphemeralContainerCommon {
        /**
         * Name of the ephemeral container specified as a DNS_LABEL.
         * This name must be unique among all containers, init containers and ephemeral containers.
         */
        name?: string;
        image?: string;
        command?: string[];
        args?: string[];
        workingDir?: string;
        /** Ports are not allowed for ephemeral containers. */
        ports?: Schemas.k8s$io$api$core$v1$ContainerPort[];
        envFrom?: Schemas.k8s$io$api$core$v1$EnvFromSource[];
        env?: Schemas.k8s$io$api$core$v1$EnvVar[];
        resources?: Schemas.k8s$io$api$core$v1$ResourceRequirements;
        volumeMounts?: Schemas.k8s$io$api$core$v1$VolumeMount[];
        volumeDevices?: Schemas.k8s$io$api$core$v1$VolumeDevice[];
        livenessProbe?: Schemas.k8s$io$api$core$v1$Probe;
        readinessProbe?: Schemas.k8s$io$api$core$v1$Probe;
        startupProbe?: Schemas.k8s$io$api$core$v1$Probe;
        lifecycle?: Schemas.k8s$io$api$core$v1$Lifecycle;
        terminationMessagePath?: string;
        terminationMessagePolicy?: string;
        imagePullPolicy?: string;
        securityContext?: Schemas.k8s$io$api$core$v1$SecurityContext;
        stdin?: boolean;
        stdinOnce?: boolean;
        tty?: boolean;
    }
    /** Represents an ephemeral volume that is handled by a normal storage driver. */
    export interface k8s$io$api$core$v1$EphemeralVolumeSource {
        volumeClaimTemplate?: Schemas.k8s$io$api$core$v1$PersistentVolumeClaimTemplate;
        readOnly?: boolean;
    }
    /** ExecAction describes a \\"run in container\\" action. */
    export interface k8s$io$api$core$v1$ExecAction {
        command?: string[];
    }
    /**
     * Represents a Fibre Channel volume.
     * Fibre Channel volumes can only be mounted as read/write once.
     * Fibre Channel volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$FCVolumeSource {
        targetWWNs?: string[];
        lun?: number;
        fsType?: string;
        readOnly?: boolean;
        wwids?: string[];
    }
    /**
     * FlexVolume represents a generic volume resource that is
     * provisioned/attached using an exec based plugin.
     */
    export interface k8s$io$api$core$v1$FlexVolumeSource {
        /** Driver is the name of the driver to use for this volume. */
        driver?: string;
        fsType?: string;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        readOnly?: boolean;
        options?: {
            [key: string]: string;
        };
    }
    /**
     * Represents a Flocker volume mounted by the Flocker agent.
     * One and only one of datasetName and datasetUUID should be set.
     * Flocker volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$FlockerVolumeSource {
        datasetName?: string;
        datasetUUID?: string;
    }
    /**
     * Represents a Persistent Disk resource in Google Compute Engine.
     *
     * A GCE PD must exist before mounting to a container. The disk must
     * also be in the same GCE project and zone as the kubelet. A GCE PD
     * can only be mounted as read/write once or read-only many times. GCE
     * PDs support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$GCEPersistentDiskVolumeSource {
        pdName?: string;
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
    }
    /**
     * Represents a volume that is populated with the contents of a git repository.
     * Git repo volumes do not support ownership management.
     * Git repo volumes support SELinux relabeling.
     *
     * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
     * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
     * into the Pod's container.
     */
    export interface k8s$io$api$core$v1$GitRepoVolumeSource {
        repository?: string;
        revision?: string;
        directory?: string;
    }
    /**
     * Represents a Glusterfs mount that lasts the lifetime of a pod.
     * Glusterfs volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$GlusterfsVolumeSource {
        endpoints?: string;
        path?: string;
        readOnly?: boolean;
    }
    /** HTTPGetAction describes an action based on HTTP Get requests. */
    export interface k8s$io$api$core$v1$HTTPGetAction {
        path?: string;
        port?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        host?: string;
        scheme?: string;
        httpHeaders?: Schemas.k8s$io$api$core$v1$HTTPHeader[];
    }
    export interface k8s$io$api$core$v1$HTTPHeader {
        name?: string;
        value?: string;
    }
    /**
     * Handler defines a specific action that should be taken
     * TODO: pass structured data to these actions, and document that data here.
     */
    export interface k8s$io$api$core$v1$Handler {
        exec?: Schemas.k8s$io$api$core$v1$ExecAction;
        httpGet?: Schemas.k8s$io$api$core$v1$HTTPGetAction;
        tcpSocket?: Schemas.k8s$io$api$core$v1$TCPSocketAction;
    }
    /**
     * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
     * pod's hosts file.
     */
    export interface k8s$io$api$core$v1$HostAlias {
        /** IP address of the host file entry. */
        ip?: string;
        /** Hostnames for the above IP address. */
        hostnames?: string[];
    }
    /**
     * Represents a host path mapped into a pod.
     * Host path volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$HostPathVolumeSource {
        path?: string;
        type?: string;
    }
    /**
     * Represents an ISCSI disk.
     * ISCSI volumes can only be mounted as read/write once.
     * ISCSI volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$ISCSIVolumeSource {
        /**
         * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
         * is other than default (typically TCP ports 860 and 3260).
         */
        targetPortal?: string;
        /** Target iSCSI Qualified Name. */
        iqn?: string;
        /** iSCSI Target Lun number. */
        lun?: number;
        iscsiInterface?: string;
        fsType?: string;
        readOnly?: boolean;
        portals?: string[];
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        initiatorName?: string;
    }
    /** Maps a string key to a path within a volume. */
    export interface k8s$io$api$core$v1$KeyToPath {
        /** The key to project. */
        key?: string;
        /**
         * The relative path of the file to map the key to.
         * May not be an absolute path.
         * May not contain the path element '..'.
         * May not start with the string '..'.
         */
        path?: string;
        mode?: number;
    }
    /**
     * Lifecycle describes actions that the management system should take in response to container lifecycle
     * events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
     * until the action is complete, unless the container process fails, in which case the handler is aborted.
     */
    export interface k8s$io$api$core$v1$Lifecycle {
        postStart?: Schemas.k8s$io$api$core$v1$Handler;
        preStop?: Schemas.k8s$io$api$core$v1$Handler;
    }
    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface k8s$io$api$core$v1$LocalObjectReference {
        name?: string;
    }
    /**
     * Represents an NFS mount that lasts the lifetime of a pod.
     * NFS volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$NFSVolumeSource {
        server?: string;
        path?: string;
        readOnly?: boolean;
    }
    /** Node affinity is a group of node affinity scheduling rules. */
    export interface k8s$io$api$core$v1$NodeAffinity {
        requiredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$NodeSelector;
        preferredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$PreferredSchedulingTerm[];
    }
    /**
     * A node selector represents the union of the results of one or more label queries
     * over a set of nodes; that is, it represents the OR of the selectors represented
     * by the node selector terms.
     */
    export interface k8s$io$api$core$v1$NodeSelector {
        /** Required. A list of node selector terms. The terms are ORed. */
        nodeSelectorTerms?: Schemas.k8s$io$api$core$v1$NodeSelectorTerm[];
    }
    /**
     * A node selector requirement is a selector that contains values, a key, and an operator
     * that relates the key and values.
     */
    export interface k8s$io$api$core$v1$NodeSelectorRequirement {
        /** The label key that the selector applies to. */
        key?: string;
        /**
         * Represents a key's relationship to a set of values.
         * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
         */
        operator?: string;
        values?: string[];
    }
    /**
     * A null or empty node selector term matches no objects. The requirements of
     * them are ANDed.
     * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
     */
    export interface k8s$io$api$core$v1$NodeSelectorTerm {
        matchExpressions?: Schemas.k8s$io$api$core$v1$NodeSelectorRequirement[];
        matchFields?: Schemas.k8s$io$api$core$v1$NodeSelectorRequirement[];
    }
    /** ObjectFieldSelector selects an APIVersioned field of an object. */
    export interface k8s$io$api$core$v1$ObjectFieldSelector {
        apiVersion?: string;
        /** Path of the field to select in the specified API version. */
        fieldPath?: string;
    }
    export interface k8s$io$api$core$v1$PersistentVolumeClaimSpec {
        accessModes?: string[];
        selector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
        resources?: Schemas.k8s$io$api$core$v1$ResourceRequirements;
        volumeName?: string;
        storageClassName?: string;
        volumeMode?: string;
        dataSource?: Schemas.k8s$io$api$core$v1$TypedLocalObjectReference;
    }
    /**
     * PersistentVolumeClaimTemplate is used to produce
     * PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
     */
    export interface k8s$io$api$core$v1$PersistentVolumeClaimTemplate {
        metadata?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        spec?: Schemas.k8s$io$api$core$v1$PersistentVolumeClaimSpec;
    }
    /**
     * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
     * This volume finds the bound PV and mounts that volume for the pod. A
     * PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
     * type of volume that is owned by someone else (the system).
     */
    export interface k8s$io$api$core$v1$PersistentVolumeClaimVolumeSource {
        claimName?: string;
        readOnly?: boolean;
    }
    /** Represents a Photon Controller persistent disk resource. */
    export interface k8s$io$api$core$v1$PhotonPersistentDiskVolumeSource {
        pdID?: string;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         */
        fsType?: string;
    }
    /** Pod affinity is a group of inter pod affinity scheduling rules. */
    export interface k8s$io$api$core$v1$PodAffinity {
        requiredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$PodAffinityTerm[];
        preferredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$WeightedPodAffinityTerm[];
    }
    export interface k8s$io$api$core$v1$PodAffinityTerm {
        labelSelector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
        namespaces?: string[];
        /**
         * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
         * the labelSelector in the specified namespaces, where co-located is defined as running on a node
         * whose value of the label with key topologyKey matches that of any node on which any of the
         * selected pods is running.
         * Empty topologyKey is not allowed.
         */
        topologyKey?: string;
    }
    /** Pod anti affinity is a group of inter pod anti affinity scheduling rules. */
    export interface k8s$io$api$core$v1$PodAntiAffinity {
        requiredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$PodAffinityTerm[];
        preferredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$WeightedPodAffinityTerm[];
    }
    /**
     * PodDNSConfig defines the DNS parameters of a pod in addition to
     * those generated from DNSPolicy.
     */
    export interface k8s$io$api$core$v1$PodDNSConfig {
        nameservers?: string[];
        searches?: string[];
        options?: Schemas.k8s$io$api$core$v1$PodDNSConfigOption[];
    }
    /** PodDNSConfigOption defines DNS resolver options of a pod. */
    export interface k8s$io$api$core$v1$PodDNSConfigOption {
        /** Required. */
        name?: string;
        value?: string;
    }
    export interface k8s$io$api$core$v1$PodReadinessGate {
        /** ConditionType refers to a condition in the pod's condition list with matching type. */
        conditionType?: string;
    }
    /**
     * PodSecurityContext holds pod-level security attributes and common container settings.
     * Some fields are also present in container.securityContext.  Field values of
     * container.securityContext take precedence over field values of PodSecurityContext.
     */
    export interface k8s$io$api$core$v1$PodSecurityContext {
        seLinuxOptions?: Schemas.k8s$io$api$core$v1$SELinuxOptions;
        windowsOptions?: Schemas.k8s$io$api$core$v1$WindowsSecurityContextOptions;
        runAsUser?: string;
        runAsGroup?: string;
        runAsNonRoot?: boolean;
        supplementalGroups?: string[];
        /**
         * 1. The owning GID will be the FSGroup
         * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
         * 3. The permission bits are OR'd with rw-rw----
         *
         * If unset, the Kubelet will not modify the ownership and permissions of any volume.
         * +optional
         */
        fsGroup?: string;
        sysctls?: Schemas.k8s$io$api$core$v1$Sysctl[];
        fsGroupChangePolicy?: string;
        seccompProfile?: Schemas.k8s$io$api$core$v1$SeccompProfile;
    }
    /** PodSpec is a description of a pod. */
    export interface k8s$io$api$core$v1$PodSpec {
        volumes?: Schemas.k8s$io$api$core$v1$Volume[];
        initContainers?: Schemas.k8s$io$api$core$v1$Container[];
        containers?: Schemas.k8s$io$api$core$v1$Container[];
        ephemeralContainers?: Schemas.k8s$io$api$core$v1$EphemeralContainer[];
        restartPolicy?: string;
        terminationGracePeriodSeconds?: string;
        activeDeadlineSeconds?: string;
        dnsPolicy?: string;
        nodeSelector?: {
            [key: string]: string;
        };
        serviceAccountName?: string;
        serviceAccount?: string;
        automountServiceAccountToken?: boolean;
        nodeName?: string;
        hostNetwork?: boolean;
        hostPID?: boolean;
        hostIPC?: boolean;
        shareProcessNamespace?: boolean;
        securityContext?: Schemas.k8s$io$api$core$v1$PodSecurityContext;
        imagePullSecrets?: Schemas.k8s$io$api$core$v1$LocalObjectReference[];
        hostname?: string;
        subdomain?: string;
        affinity?: Schemas.k8s$io$api$core$v1$Affinity;
        schedulerName?: string;
        tolerations?: Schemas.k8s$io$api$core$v1$Toleration[];
        hostAliases?: Schemas.k8s$io$api$core$v1$HostAlias[];
        priorityClassName?: string;
        priority?: number;
        dnsConfig?: Schemas.k8s$io$api$core$v1$PodDNSConfig;
        readinessGates?: Schemas.k8s$io$api$core$v1$PodReadinessGate[];
        runtimeClassName?: string;
        enableServiceLinks?: boolean;
        preemptionPolicy?: string;
        overhead?: {
            [key: string]: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
        };
        topologySpreadConstraints?: Schemas.k8s$io$api$core$v1$TopologySpreadConstraint[];
        setHostnameAsFQDN?: boolean;
    }
    export interface k8s$io$api$core$v1$PodTemplateSpec {
        metadata?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        spec?: Schemas.k8s$io$api$core$v1$PodSpec;
    }
    /** PortworxVolumeSource represents a Portworx volume resource. */
    export interface k8s$io$api$core$v1$PortworxVolumeSource {
        volumeID?: string;
        /**
         * FSType represents the filesystem type to mount
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         */
        fsType?: string;
        readOnly?: boolean;
    }
    /**
     * An empty preferred scheduling term matches all objects with implicit weight 0
     * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
     */
    export interface k8s$io$api$core$v1$PreferredSchedulingTerm {
        /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
        weight?: number;
        preference?: Schemas.k8s$io$api$core$v1$NodeSelectorTerm;
    }
    /**
     * Probe describes a health check to be performed against a container to determine whether it is
     * alive or ready to receive traffic.
     */
    export interface k8s$io$api$core$v1$Probe {
        handler?: Schemas.k8s$io$api$core$v1$Handler;
        initialDelaySeconds?: number;
        timeoutSeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        failureThreshold?: number;
    }
    export interface k8s$io$api$core$v1$ProjectedVolumeSource {
        sources?: Schemas.k8s$io$api$core$v1$VolumeProjection[];
        defaultMode?: number;
    }
    /**
     * Represents a Quobyte mount that lasts the lifetime of a pod.
     * Quobyte volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$QuobyteVolumeSource {
        registry?: string;
        /** Volume is a string that references an already created Quobyte volume by name. */
        volume?: string;
        readOnly?: boolean;
        user?: string;
        group?: string;
        tenant?: string;
    }
    /**
     * Represents a Rados Block Device mount that lasts the lifetime of a pod.
     * RBD volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$RBDVolumeSource {
        monitors?: string[];
        image?: string;
        fsType?: string;
        pool?: string;
        user?: string;
        keyring?: string;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        readOnly?: boolean;
    }
    export interface k8s$io$api$core$v1$ResourceFieldSelector {
        containerName?: string;
        resource?: string;
        divisor?: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
    }
    /** ResourceRequirements describes the compute resource requirements. */
    export interface k8s$io$api$core$v1$ResourceRequirements {
        limits?: {
            [key: string]: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
        };
        requests?: {
            [key: string]: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
        };
    }
    export interface k8s$io$api$core$v1$SELinuxOptions {
        user?: string;
        role?: string;
        type?: string;
        level?: string;
    }
    export interface k8s$io$api$core$v1$ScaleIOVolumeSource {
        /** The host address of the ScaleIO API Gateway. */
        gateway?: string;
        /** The name of the storage system as configured in ScaleIO. */
        system?: string;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        sslEnabled?: boolean;
        protectionDomain?: string;
        storagePool?: string;
        storageMode?: string;
        /**
         * The name of a volume already created in the ScaleIO system
         * that is associated with this volume source.
         */
        volumeName?: string;
        fsType?: string;
        readOnly?: boolean;
    }
    export interface k8s$io$api$core$v1$SeccompProfile {
        /**
         * Localhost - a profile defined in a file on the node should be used.
         * RuntimeDefault - the container runtime default profile should be used.
         * Unconfined - no profile should be applied.
         * +unionDiscriminator
         */
        type?: string;
        localhostProfile?: string;
    }
    /**
     * SecretEnvSource selects a Secret to populate the environment
     * variables with.
     *
     * The contents of the target Secret's Data field will represent the
     * key-value pairs as environment variables.
     */
    export interface k8s$io$api$core$v1$SecretEnvSource {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        optional?: boolean;
    }
    /** SecretKeySelector selects a key of a Secret. */
    export interface k8s$io$api$core$v1$SecretKeySelector {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /** The key of the secret to select from.  Must be a valid secret key. */
        key?: string;
        optional?: boolean;
    }
    /**
     * Adapts a secret into a projected volume.
     *
     * The contents of the target Secret's Data field will be presented in a
     * projected volume as files using the keys in the Data field as the file names.
     * Note that this is identical to a secret volume source without the default
     * mode.
     */
    export interface k8s$io$api$core$v1$SecretProjection {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        items?: Schemas.k8s$io$api$core$v1$KeyToPath[];
        optional?: boolean;
    }
    /**
     * Adapts a Secret into a volume.
     *
     * The contents of the target Secret's Data field will be presented in a volume
     * as files using the keys in the Data field as the file names.
     * Secret volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$SecretVolumeSource {
        secretName?: string;
        items?: Schemas.k8s$io$api$core$v1$KeyToPath[];
        defaultMode?: number;
        optional?: boolean;
    }
    /**
     * SecurityContext holds security configuration that will be applied to a container.
     * Some fields are present in both SecurityContext and PodSecurityContext.  When both
     * are set, the values in SecurityContext take precedence.
     */
    export interface k8s$io$api$core$v1$SecurityContext {
        capabilities?: Schemas.k8s$io$api$core$v1$Capabilities;
        privileged?: boolean;
        seLinuxOptions?: Schemas.k8s$io$api$core$v1$SELinuxOptions;
        windowsOptions?: Schemas.k8s$io$api$core$v1$WindowsSecurityContextOptions;
        runAsUser?: string;
        runAsGroup?: string;
        runAsNonRoot?: boolean;
        readOnlyRootFilesystem?: boolean;
        allowPrivilegeEscalation?: boolean;
        procMount?: string;
        seccompProfile?: Schemas.k8s$io$api$core$v1$SeccompProfile;
    }
    /**
     * ServiceAccountTokenProjection represents a projected service account token
     * volume. This projection can be used to insert a service account token into
     * the pods runtime filesystem for use against APIs (Kubernetes API Server or
     * otherwise).
     */
    export interface k8s$io$api$core$v1$ServiceAccountTokenProjection {
        audience?: string;
        expirationSeconds?: string;
        /**
         * Path is the path relative to the mount point of the file to project the
         * token into.
         */
        path?: string;
    }
    /** Represents a StorageOS persistent volume resource. */
    export interface k8s$io$api$core$v1$StorageOSVolumeSource {
        /**
         * VolumeName is the human-readable name of the StorageOS volume.  Volume
         * names are only unique within a namespace.
         */
        volumeName?: string;
        volumeNamespace?: string;
        fsType?: string;
        readOnly?: boolean;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
    }
    export interface k8s$io$api$core$v1$Sysctl {
        name?: string;
        value?: string;
    }
    export interface k8s$io$api$core$v1$TCPSocketAction {
        port?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        host?: string;
    }
    /**
     * The pod this Toleration is attached to tolerates any taint that matches
     * the triple <key,value,effect> using the matching operator <operator>.
     */
    export interface k8s$io$api$core$v1$Toleration {
        key?: string;
        operator?: string;
        value?: string;
        effect?: string;
        tolerationSeconds?: string;
    }
    /** TopologySpreadConstraint specifies how to spread matching pods among the given topology. */
    export interface k8s$io$api$core$v1$TopologySpreadConstraint {
        /**
         * MaxSkew describes the degree to which pods may be unevenly distributed.
         * When \`whenUnsatisfiable=DoNotSchedule\`, it is the maximum permitted difference
         * between the number of matching pods in the target topology and the global minimum.
         * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
         * labelSelector spread as 1/1/0:
         * +-------+-------+-------+
         * | zone1 | zone2 | zone3 |
         * +-------+-------+-------+
         * |   P   |   P   |       |
         * +-------+-------+-------+
         * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
         * scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
         * violate MaxSkew(1).
         * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
         * When \`whenUnsatisfiable=ScheduleAnyway\`, it is used to give higher precedence
         * to topologies that satisfy it.
         * It's a required field. Default value is 1 and 0 is not allowed.
         */
        maxSkew?: number;
        /**
         * TopologyKey is the key of node labels. Nodes that have a label with this key
         * and identical values are considered to be in the same topology.
         * We consider each <key, value> as a \\"bucket\\", and try to put balanced number
         * of pods into each bucket.
         * It's a required field.
         */
        topologyKey?: string;
        /**
         * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
         * the spread constraint.
         * - DoNotSchedule (default) tells the scheduler not to schedule it.
         * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
         *   but giving higher precedence to topologies that would help reduce the
         *   skew.
         * A constraint is considered \\"Unsatisfiable\\" for an incoming pod
         * if and only if every possible node assigment for that pod would violate
         * \\"MaxSkew\\" on some topology.
         * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
         * labelSelector spread as 3/1/1:
         * +-------+-------+-------+
         * | zone1 | zone2 | zone3 |
         * +-------+-------+-------+
         * | P P P |   P   |   P   |
         * +-------+-------+-------+
         * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
         * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
         * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
         * won't make it *more* imbalanced.
         * It's a required field.
         */
        whenUnsatisfiable?: string;
        labelSelector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
    }
    /**
     * TypedLocalObjectReference contains enough information to let you locate the
     * typed referenced object inside the same namespace.
     */
    export interface k8s$io$api$core$v1$TypedLocalObjectReference {
        apiGroup?: string;
        kind?: string;
        name?: string;
    }
    /** Volume represents a named volume in a pod that may be accessed by any container in the pod. */
    export interface k8s$io$api$core$v1$Volume {
        name?: string;
        volumeSource?: Schemas.k8s$io$api$core$v1$VolumeSource;
    }
    /** volumeDevice describes a mapping of a raw block device within a container. */
    export interface k8s$io$api$core$v1$VolumeDevice {
        name?: string;
        /** devicePath is the path inside of the container that the device will be mapped to. */
        devicePath?: string;
    }
    /** VolumeMount describes a mounting of a Volume within a container. */
    export interface k8s$io$api$core$v1$VolumeMount {
        /** This must match the Name of a Volume. */
        name?: string;
        readOnly?: boolean;
        /**
         * Path within the container at which the volume should be mounted.  Must
         * not contain ':'.
         */
        mountPath?: string;
        subPath?: string;
        mountPropagation?: string;
        subPathExpr?: string;
    }
    export interface k8s$io$api$core$v1$VolumeProjection {
        secret?: Schemas.k8s$io$api$core$v1$SecretProjection;
        downwardAPI?: Schemas.k8s$io$api$core$v1$DownwardAPIProjection;
        configMap?: Schemas.k8s$io$api$core$v1$ConfigMapProjection;
        serviceAccountToken?: Schemas.k8s$io$api$core$v1$ServiceAccountTokenProjection;
    }
    /**
     * Represents the source of a volume to mount.
     * Only one of its members may be specified.
     */
    export interface k8s$io$api$core$v1$VolumeSource {
        hostPath?: Schemas.k8s$io$api$core$v1$HostPathVolumeSource;
        emptyDir?: Schemas.k8s$io$api$core$v1$EmptyDirVolumeSource;
        gcePersistentDisk?: Schemas.k8s$io$api$core$v1$GCEPersistentDiskVolumeSource;
        awsElasticBlockStore?: Schemas.k8s$io$api$core$v1$AWSElasticBlockStoreVolumeSource;
        gitRepo?: Schemas.k8s$io$api$core$v1$GitRepoVolumeSource;
        secret?: Schemas.k8s$io$api$core$v1$SecretVolumeSource;
        nfs?: Schemas.k8s$io$api$core$v1$NFSVolumeSource;
        iscsi?: Schemas.k8s$io$api$core$v1$ISCSIVolumeSource;
        glusterfs?: Schemas.k8s$io$api$core$v1$GlusterfsVolumeSource;
        persistentVolumeClaim?: Schemas.k8s$io$api$core$v1$PersistentVolumeClaimVolumeSource;
        rbd?: Schemas.k8s$io$api$core$v1$RBDVolumeSource;
        flexVolume?: Schemas.k8s$io$api$core$v1$FlexVolumeSource;
        cinder?: Schemas.k8s$io$api$core$v1$CinderVolumeSource;
        cephfs?: Schemas.k8s$io$api$core$v1$CephFSVolumeSource;
        flocker?: Schemas.k8s$io$api$core$v1$FlockerVolumeSource;
        downwardAPI?: Schemas.k8s$io$api$core$v1$DownwardAPIVolumeSource;
        fc?: Schemas.k8s$io$api$core$v1$FCVolumeSource;
        azureFile?: Schemas.k8s$io$api$core$v1$AzureFileVolumeSource;
        configMap?: Schemas.k8s$io$api$core$v1$ConfigMapVolumeSource;
        vsphereVolume?: Schemas.k8s$io$api$core$v1$VsphereVirtualDiskVolumeSource;
        quobyte?: Schemas.k8s$io$api$core$v1$QuobyteVolumeSource;
        azureDisk?: Schemas.k8s$io$api$core$v1$AzureDiskVolumeSource;
        photonPersistentDisk?: Schemas.k8s$io$api$core$v1$PhotonPersistentDiskVolumeSource;
        projected?: Schemas.k8s$io$api$core$v1$ProjectedVolumeSource;
        portworxVolume?: Schemas.k8s$io$api$core$v1$PortworxVolumeSource;
        scaleIO?: Schemas.k8s$io$api$core$v1$ScaleIOVolumeSource;
        storageos?: Schemas.k8s$io$api$core$v1$StorageOSVolumeSource;
        csi?: Schemas.k8s$io$api$core$v1$CSIVolumeSource;
        ephemeral?: Schemas.k8s$io$api$core$v1$EphemeralVolumeSource;
    }
    /** Represents a vSphere volume resource. */
    export interface k8s$io$api$core$v1$VsphereVirtualDiskVolumeSource {
        volumePath?: string;
        fsType?: string;
        storagePolicyName?: string;
        storagePolicyID?: string;
    }
    export interface k8s$io$api$core$v1$WeightedPodAffinityTerm {
        /**
         * weight associated with matching the corresponding podAffinityTerm,
         * in the range 1-100.
         */
        weight?: number;
        podAffinityTerm?: Schemas.k8s$io$api$core$v1$PodAffinityTerm;
    }
    /** WindowsSecurityContextOptions contain Windows-specific options and credentials. */
    export interface k8s$io$api$core$v1$WindowsSecurityContextOptions {
        gmsaCredentialSpecName?: string;
        gmsaCredentialSpec?: string;
        runAsUserName?: string;
    }
    /**
     * Quantity is a fixed-point representation of a number.
     * It provides convenient marshaling/unmarshaling in JSON and YAML,
     * in addition to String() and AsInt64() accessors.
     *
     * The serialization format is:
     *
     * <quantity>        ::= <signedNumber><suffix>
     *   (Note that <suffix> may be empty, from the \\"\\" case in <decimalSI>.)
     * <digit>           ::= 0 | 1 | ... | 9
     * <digits>          ::= <digit> | <digit><digits>
     * <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits>
     * <sign>            ::= \\"+\\" | \\"-\\"
     * <signedNumber>    ::= <number> | <sign><number>
     * <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI>
     * <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
     *   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
     * <decimalSI>       ::= m | \\"\\" | k | M | G | T | P | E
     *   (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
     * <decimalExponent> ::= \\"e\\" <signedNumber> | \\"E\\" <signedNumber>
     *
     * No matter which of the three exponent forms is used, no quantity may represent
     * a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal
     * places. Numbers larger or more precise will be capped or rounded up.
     * (E.g.: 0.1m will rounded up to 1m.)
     * This may be extended in the future if we require larger or smaller quantities.
     *
     * When a Quantity is parsed from a string, it will remember the type of suffix
     * it had, and will use the same type again when it is serialized.
     *
     * Before serializing, Quantity will be put in \\"canonical form\\".
     * This means that Exponent/suffix will be adjusted up or down (with a
     * corresponding increase or decrease in Mantissa) such that:
     *   a. No precision is lost
     *   b. No fractional digits will be emitted
     *   c. The exponent (or suffix) is as large as possible.
     * The sign will be omitted unless the number is negative.
     *
     * Examples:
     *   1.5 will be serialized as \\"1500m\\"
     *   1.5Gi will be serialized as \\"1536Mi\\"
     *
     * Note that the quantity will NEVER be internally represented by a
     * floating point number. That is the whole point of this exercise.
     *
     * Non-canonical values will still parse as long as they are well formed,
     * but will be re-emitted in their canonical form. (So always use canonical
     * form, or don't diff.)
     *
     * This format is intended to make it difficult to use these numbers without
     * writing some sort of special handling code in the hopes that that will
     * cause implementors to also use a fixed point implementation.
     *
     * +protobuf=true
     * +protobuf.embed=string
     * +protobuf.options.marshal=false
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * +k8s:deepcopy-gen=true
     * +k8s:openapi-gen=true
     */
    export interface k8s$io$apimachinery$pkg$api$resource$Quantity {
        string?: string;
    }
    /**
     * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
     *
     * Each key is either a '.' representing the field itself, and will always map to an empty set,
     * or a string representing a sub-field or item. The string will follow one of these four formats:
     * 'f:<name>', where <name> is the name of a field in a struct, or key in a map
     * 'v:<value>', where <value> is the exact json formatted value of a list item
     * 'i:<index>', where <index> is position of a item in a list
     * 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
     * If a key maps to an empty Fields value, the field that key represents is part of the set.
     *
     * The exact format is defined in sigs.k8s.io/structured-merge-diff
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$FieldsV1 {
        /** Raw is the underlying serialization of this object. */
        Raw?: string;
    }
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector {
        matchLabels?: {
            [key: string]: string;
        };
        matchExpressions?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelectorRequirement[];
    }
    /**
     * A label selector requirement is a selector that contains values, a key, and an operator that
     * relates the key and values.
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelectorRequirement {
        key?: string;
        /**
         * operator represents a key's relationship to a set of values.
         * Valid operators are In, NotIn, Exists and DoesNotExist.
         */
        operator?: string;
        values?: string[];
    }
    /**
     * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
     * that the fieldset applies to.
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$ManagedFieldsEntry {
        /** Manager is an identifier of the workflow managing these fields. */
        manager?: string;
        /**
         * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
         * The only valid values for this field are 'Apply' and 'Update'.
         */
        operation?: string;
        /**
         * APIVersion defines the version of this resource that this field set
         * applies to. The format is \\"group/version\\" just like the top-level
         * APIVersion field. It is necessary to track the version of a field
         * set because it cannot be automatically converted.
         */
        apiVersion?: string;
        time?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        fieldsType?: string;
        fieldsV1?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$FieldsV1;
    }
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects
     * users must create.
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta {
        name?: string;
        /**
         * GenerateName is an optional prefix, used by the server, to generate a unique
         * name ONLY IF the Name field has not been provided.
         * If this field is used, the name returned to the client will be different
         * than the name passed. This value will also be combined with a unique suffix.
         * The provided value has the same validation rules as the Name field,
         * and may be truncated by the length of the suffix required to make the value
         * unique on the server.
         *
         * If this field is specified and the generated name exists, the server will
         * NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
         * ServerTimeout indicating a unique name could not be found in the time allotted, and the client
         * should retry (optionally after the time indicated in the Retry-After header).
         *
         * Applied only if Name is not specified.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
         * +optional
         */
        generateName?: string;
        /**
         * Namespace defines the space within which each name must be unique. An empty namespace is
         * equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation.
         * Not all objects are required to be scoped to a namespace - the value of this field for
         * those objects will be empty.
         *
         * Must be a DNS_LABEL.
         * Cannot be updated.
         * More info: http://kubernetes.io/docs/user-guide/namespaces
         * +optional
         */
        namespace?: string;
        /**
         * SelfLink is a URL representing this object.
         * Populated by the system.
         * Read-only.
         *
         * DEPRECATED
         * Kubernetes will stop propagating this field in 1.20 release and the field is planned
         * to be removed in 1.21 release.
         * +optional
         */
        selfLink?: string;
        /**
         * UID is the unique in time and space value for this object. It is typically generated by
         * the server on successful creation of a resource and is not allowed to change on PUT
         * operations.
         *
         * Populated by the system.
         * Read-only.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
         * +optional
         */
        uid?: string;
        /**
         * An opaque value that represents the internal version of this object that can
         * be used by clients to determine when objects have changed. May be used for optimistic
         * concurrency, change detection, and the watch operation on a resource or set of resources.
         * Clients must treat these values as opaque and passed unmodified back to the server.
         * They may only be valid for a particular resource or set of resources.
         *
         * Populated by the system.
         * Read-only.
         * Value must be treated as opaque by clients and .
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
         * +optional
         */
        resourceVersion?: string;
        generation?: string;
        creationTimestamp?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        deletionTimestamp?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        deletionGracePeriodSeconds?: string;
        labels?: {
            [key: string]: string;
        };
        annotations?: {
            [key: string]: string;
        };
        ownerReferences?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$OwnerReference[];
        finalizers?: string[];
        clusterName?: string;
        /**
         * ManagedFields maps workflow-id and version to the set of fields
         * that are managed by that workflow. This is mostly for internal
         * housekeeping, and users typically shouldn't need to set or
         * understand this field. A workflow can be the user's name, a
         * controller's name, or the name of a specific apply path like
         * \\"ci-cd\\". The set of fields is always in the version that the
         * workflow used when modifying the object.
         *
         * +optional
         */
        managedFields?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ManagedFieldsEntry[];
    }
    /**
     * OwnerReference contains enough information to let you identify an owning
     * object. An owning object must be in the same namespace as the dependent, or
     * be cluster-scoped, so there is no namespace field.
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$OwnerReference {
        /** API version of the referent. */
        apiVersion?: string;
        kind?: string;
        name?: string;
        uid?: string;
        controller?: boolean;
        blockOwnerDeletion?: boolean;
    }
    /**
     * Time is a wrapper around time.Time which supports correct
     * marshaling to YAML and JSON.  Wrappers are provided for many
     * of the factory methods that the time package offers.
     *
     * +protobuf.options.marshal=false
     * +protobuf.as=Timestamp
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$Time {
        /**
         * Represents seconds of UTC time since Unix epoch
         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59Z inclusive.
         */
        seconds?: string;
        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive. This field may be limited in precision depending on context.
         */
        nanos?: number;
    }
    /**
     * +protobuf=true
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * +k8s:openapi-gen=true
     */
    export interface k8s$io$apimachinery$pkg$util$intstr$IntOrString {
        type?: string;
        intVal?: number;
        strVal?: string;
    }
    export interface rollout$AbortRolloutRequest {
        name?: string;
        namespace?: string;
    }
    export interface rollout$AnalysisRunInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        icon?: string;
        revision?: number;
        status?: string;
        successful?: number;
        failed?: number;
        inconclusive?: number;
        error?: number;
        jobs?: Schemas.rollout$JobInfo[];
    }
    export interface rollout$ContainerInfo {
        name?: string;
        image?: string;
    }
    export interface rollout$ExperimentInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        icon?: string;
        revision?: number;
        status?: string;
        message?: string;
        replicaSets?: Schemas.rollout$ReplicaSetInfo[];
        analysisRuns?: Schemas.rollout$AnalysisRunInfo[];
    }
    export interface rollout$JobInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        status?: string;
        icon?: string;
    }
    export interface rollout$NamespaceInfo {
        namespace?: string;
        availableNamespaces?: string[];
    }
    export interface rollout$PodInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        status?: string;
        icon?: string;
        ready?: string;
        restarts?: number;
    }
    export interface rollout$PromoteRolloutRequest {
        name?: string;
        namespace?: string;
        full?: boolean;
    }
    export interface rollout$ReplicaSetInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        status?: string;
        icon?: string;
        revision?: number;
        stable?: boolean;
        canary?: boolean;
        active?: boolean;
        preview?: boolean;
        replicas?: number;
        available?: number;
        template?: string;
        scaleDownDeadline?: string;
        images?: string[];
        pods?: Schemas.rollout$PodInfo[];
    }
    export interface rollout$RestartRolloutRequest {
        name?: string;
        namespace?: string;
    }
    export interface rollout$RetryRolloutRequest {
        name?: string;
        namespace?: string;
    }
    export interface rollout$RolloutInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        status?: string;
        message?: string;
        icon?: string;
        strategy?: string;
        step?: string;
        setWeight?: string;
        actualWeight?: string;
        ready?: number;
        current?: number;
        desired?: number;
        updated?: number;
        available?: number;
        restartedAt?: string;
        generation?: string;
        replicaSets?: Schemas.rollout$ReplicaSetInfo[];
        experiments?: Schemas.rollout$ExperimentInfo[];
        analysisRuns?: Schemas.rollout$AnalysisRunInfo[];
        containers?: Schemas.rollout$ContainerInfo[];
        steps?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStep[];
    }
    export interface rollout$RolloutInfoList {
        rollouts?: Schemas.rollout$RolloutInfo[];
    }
    export interface rollout$RolloutWatchEvent {
        type?: string;
        rolloutInfo?: Schemas.rollout$RolloutInfo;
    }
    export interface rollout$SetImageRequest {
        rollout?: string;
        container?: string;
        image?: string;
        tag?: string;
        namespace?: string;
    }
    export interface rollout$UndoRolloutRequest {
        rollout?: string;
        revision?: string;
        namespace?: string;
    }
    export interface rollout$VersionInfo {
        rolloutsVersion?: string;
    }
}
export interface Response$RolloutService_GetNamespace$Status$200 {
    \\"application/json\\": Schemas.rollout$NamespaceInfo;
}
export interface Response$RolloutService_GetNamespace$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_ListRolloutInfos {
    namespace: string;
}
export interface Response$RolloutService_ListRolloutInfos$Status$200 {
    \\"application/json\\": Schemas.rollout$RolloutInfoList;
}
export interface Response$RolloutService_ListRolloutInfos$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_WatchRolloutInfos {
    namespace: string;
}
export interface Response$RolloutService_WatchRolloutInfos$Status$200 {
    \\"application/json\\": {
        result?: Schemas.rollout$RolloutWatchEvent;
        error?: Schemas.grpc$gateway$runtime$StreamError;
    };
}
export interface Response$RolloutService_WatchRolloutInfos$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_AbortRollout {
    namespace: string;
    name: string;
}
export interface RequestBody$RolloutService_AbortRollout {
    \\"application/json\\": Schemas.rollout$AbortRolloutRequest;
}
export interface Response$RolloutService_AbortRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_AbortRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_GetRolloutInfo {
    namespace: string;
    name: string;
}
export interface Response$RolloutService_GetRolloutInfo$Status$200 {
    \\"application/json\\": Schemas.rollout$RolloutInfo;
}
export interface Response$RolloutService_GetRolloutInfo$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_WatchRolloutInfo {
    namespace: string;
    name: string;
}
export interface Response$RolloutService_WatchRolloutInfo$Status$200 {
    \\"application/json\\": {
        result?: Schemas.rollout$RolloutInfo;
        error?: Schemas.grpc$gateway$runtime$StreamError;
    };
}
export interface Response$RolloutService_WatchRolloutInfo$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_PromoteRollout {
    namespace: string;
    name: string;
}
export interface RequestBody$RolloutService_PromoteRollout {
    \\"application/json\\": Schemas.rollout$PromoteRolloutRequest;
}
export interface Response$RolloutService_PromoteRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_PromoteRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_RestartRollout {
    namespace: string;
    name: string;
}
export interface RequestBody$RolloutService_RestartRollout {
    \\"application/json\\": Schemas.rollout$RestartRolloutRequest;
}
export interface Response$RolloutService_RestartRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_RestartRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_RetryRollout {
    namespace: string;
    name: string;
}
export interface RequestBody$RolloutService_RetryRollout {
    \\"application/json\\": Schemas.rollout$RetryRolloutRequest;
}
export interface Response$RolloutService_RetryRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_RetryRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_SetRolloutImage {
    namespace: string;
    rollout: string;
    container: string;
    image: string;
    tag: string;
}
export interface RequestBody$RolloutService_SetRolloutImage {
    \\"application/json\\": Schemas.rollout$SetImageRequest;
}
export interface Response$RolloutService_SetRolloutImage$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_SetRolloutImage$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_UndoRollout {
    namespace: string;
    rollout: string;
    revision: string;
}
export interface RequestBody$RolloutService_UndoRollout {
    \\"application/json\\": Schemas.rollout$UndoRolloutRequest;
}
export interface Response$RolloutService_UndoRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_UndoRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Response$RolloutService_Version$Status$200 {
    \\"application/json\\": Schemas.rollout$VersionInfo;
}
export interface Response$RolloutService_Version$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export type ResponseContentType$RolloutService_GetNamespace = keyof Response$RolloutService_GetNamespace$Status$200;
export type ResponseContentType$RolloutService_ListRolloutInfos = keyof Response$RolloutService_ListRolloutInfos$Status$200;
export interface Params$RolloutService_ListRolloutInfos {
    parameter: Parameter$RolloutService_ListRolloutInfos;
}
export type ResponseContentType$RolloutService_WatchRolloutInfos = keyof Response$RolloutService_WatchRolloutInfos$Status$200;
export interface Params$RolloutService_WatchRolloutInfos {
    parameter: Parameter$RolloutService_WatchRolloutInfos;
}
export type RequestContentType$RolloutService_AbortRollout = keyof RequestBody$RolloutService_AbortRollout;
export type ResponseContentType$RolloutService_AbortRollout = keyof Response$RolloutService_AbortRollout$Status$200;
export interface Params$RolloutService_AbortRollout {
    parameter: Parameter$RolloutService_AbortRollout;
    requestBody: RequestBody$RolloutService_AbortRollout[\\"application/json\\"];
}
export type ResponseContentType$RolloutService_GetRolloutInfo = keyof Response$RolloutService_GetRolloutInfo$Status$200;
export interface Params$RolloutService_GetRolloutInfo {
    parameter: Parameter$RolloutService_GetRolloutInfo;
}
export type ResponseContentType$RolloutService_WatchRolloutInfo = keyof Response$RolloutService_WatchRolloutInfo$Status$200;
export interface Params$RolloutService_WatchRolloutInfo {
    parameter: Parameter$RolloutService_WatchRolloutInfo;
}
export type RequestContentType$RolloutService_PromoteRollout = keyof RequestBody$RolloutService_PromoteRollout;
export type ResponseContentType$RolloutService_PromoteRollout = keyof Response$RolloutService_PromoteRollout$Status$200;
export interface Params$RolloutService_PromoteRollout {
    parameter: Parameter$RolloutService_PromoteRollout;
    requestBody: RequestBody$RolloutService_PromoteRollout[\\"application/json\\"];
}
export type RequestContentType$RolloutService_RestartRollout = keyof RequestBody$RolloutService_RestartRollout;
export type ResponseContentType$RolloutService_RestartRollout = keyof Response$RolloutService_RestartRollout$Status$200;
export interface Params$RolloutService_RestartRollout {
    parameter: Parameter$RolloutService_RestartRollout;
    requestBody: RequestBody$RolloutService_RestartRollout[\\"application/json\\"];
}
export type RequestContentType$RolloutService_RetryRollout = keyof RequestBody$RolloutService_RetryRollout;
export type ResponseContentType$RolloutService_RetryRollout = keyof Response$RolloutService_RetryRollout$Status$200;
export interface Params$RolloutService_RetryRollout {
    parameter: Parameter$RolloutService_RetryRollout;
    requestBody: RequestBody$RolloutService_RetryRollout[\\"application/json\\"];
}
export type RequestContentType$RolloutService_SetRolloutImage = keyof RequestBody$RolloutService_SetRolloutImage;
export type ResponseContentType$RolloutService_SetRolloutImage = keyof Response$RolloutService_SetRolloutImage$Status$200;
export interface Params$RolloutService_SetRolloutImage {
    parameter: Parameter$RolloutService_SetRolloutImage;
    requestBody: RequestBody$RolloutService_SetRolloutImage[\\"application/json\\"];
}
export type RequestContentType$RolloutService_UndoRollout = keyof RequestBody$RolloutService_UndoRollout;
export type ResponseContentType$RolloutService_UndoRollout = keyof Response$RolloutService_UndoRollout$Status$200;
export interface Params$RolloutService_UndoRollout {
    parameter: Parameter$RolloutService_UndoRollout;
    requestBody: RequestBody$RolloutService_UndoRollout[\\"application/json\\"];
}
export type ResponseContentType$RolloutService_Version = keyof Response$RolloutService_Version$Status$200;
export type HttpMethod = \\"GET\\" | \\"PUT\\" | \\"POST\\" | \\"DELETE\\" | \\"OPTIONS\\" | \\"HEAD\\" | \\"PATCH\\" | \\"TRACE\\";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: \\"form\\" | \\"spaceDelimited\\" | \\"pipeDelimited\\" | \\"deepObject\\";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$RolloutService_GetNamespace$Status$200 | Response$RolloutService_ListRolloutInfos$Status$200 | Response$RolloutService_WatchRolloutInfos$Status$200 | Response$RolloutService_AbortRollout$Status$200 | Response$RolloutService_GetRolloutInfo$Status$200 | Response$RolloutService_WatchRolloutInfo$Status$200 | Response$RolloutService_PromoteRollout$Status$200 | Response$RolloutService_RestartRollout$Status$200 | Response$RolloutService_RetryRollout$Status$200 | Response$RolloutService_SetRolloutImage$Status$200 | Response$RolloutService_UndoRollout$Status$200 | Response$RolloutService_Version$Status$200;
export namespace ErrorResponse {
    export type RolloutService_GetNamespace = void;
    export type RolloutService_ListRolloutInfos = void;
    export type RolloutService_WatchRolloutInfos = void;
    export type RolloutService_AbortRollout = void;
    export type RolloutService_GetRolloutInfo = void;
    export type RolloutService_WatchRolloutInfo = void;
    export type RolloutService_PromoteRollout = void;
    export type RolloutService_RestartRollout = void;
    export type RolloutService_RetryRollout = void;
    export type RolloutService_SetRolloutImage = void;
    export type RolloutService_UndoRollout = void;
    export type RolloutService_Version = void;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\\\\/$/, \\"\\"); }
    public async RolloutService_GetNamespace(option?: RequestOption): Promise<Response$RolloutService_GetNamespace$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/namespace\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_ListRolloutInfos(params: Params$RolloutService_ListRolloutInfos, option?: RequestOption): Promise<Response$RolloutService_ListRolloutInfos$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/info\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_WatchRolloutInfos(params: Params$RolloutService_WatchRolloutInfos, option?: RequestOption): Promise<Response$RolloutService_WatchRolloutInfos$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/info/watch\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_AbortRollout(params: Params$RolloutService_AbortRollout, option?: RequestOption): Promise<Response$RolloutService_AbortRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/abort\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_GetRolloutInfo(params: Params$RolloutService_GetRolloutInfo, option?: RequestOption): Promise<Response$RolloutService_GetRolloutInfo$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/info\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_WatchRolloutInfo(params: Params$RolloutService_WatchRolloutInfo, option?: RequestOption): Promise<Response$RolloutService_WatchRolloutInfo$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/info/watch\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_PromoteRollout(params: Params$RolloutService_PromoteRollout, option?: RequestOption): Promise<Response$RolloutService_PromoteRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/promote\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_RestartRollout(params: Params$RolloutService_RestartRollout, option?: RequestOption): Promise<Response$RolloutService_RestartRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/restart\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_RetryRollout(params: Params$RolloutService_RetryRollout, option?: RequestOption): Promise<Response$RolloutService_RetryRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/retry\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_SetRolloutImage(params: Params$RolloutService_SetRolloutImage, option?: RequestOption): Promise<Response$RolloutService_SetRolloutImage$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.rollout}/set/\${params.parameter.container}/\${params.parameter.image}/\${params.parameter.tag}\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_UndoRollout(params: Params$RolloutService_UndoRollout, option?: RequestOption): Promise<Response$RolloutService_UndoRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.rollout}/undo/\${params.parameter.revision}\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_Version(option?: RequestOption): Promise<Response$RolloutService_Version$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/version\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
}
"
`;
