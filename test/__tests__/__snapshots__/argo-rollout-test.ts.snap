// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Argo Rollout client.ts 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.0.0
// 
// 


export namespace Schemas {
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ALBTrafficRouting {
        /** Ingress refers to the name of an \`Ingress\` resource in the same namespace as the \`Rollout\` */
        ingress?: string;
        /** ServicePort refers to the port that the Ingress action should route traffic to */
        servicePort?: number;
        /** RootService references the service in the ingress to the controller should add the action to */
        rootService?: string;
        /**
         * AnnotationPrefix has to match the configured annotation prefix on the alb ingress controller
         * +optional
         */
        annotationPrefix?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AmbassadorTrafficRouting {
        /**
         * Mappings refer to the name of the Ambassador Mappings used to route traffic to the
         * service
         */
        mappings?: string[];
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunArgument {
        /** Name argument name */
        name?: string;
        /** Value a hardcoded value for the argument. This field is a one of field with valueFrom */
        value?: string;
        valueFrom?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ArgumentValueFrom;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunStrategy {
        /** SuccessfulRunHistoryLimit limits the number of old successful analysis runs and experiments to be retained in a history */
        successfulRunHistoryLimit?: number;
        /**
         * UnsuccessfulRunHistoryLimit limits the number of old unsuccessful analysis runs and experiments to be retained in a history.
         * Stages for unsuccessful: \\"Error\\", \\"Failed\\", \\"Inconclusive\\"
         */
        unsuccessfulRunHistoryLimit?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AntiAffinity {
        preferredDuringSchedulingIgnoredDuringExecution?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PreferredDuringSchedulingIgnoredDuringExecution;
        requiredDuringSchedulingIgnoredDuringExecution?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RequiredDuringSchedulingIgnoredDuringExecution;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ArgumentValueFrom {
        /** PodTemplateHashValue gets the value from one of the children ReplicaSet's Pod Template Hash */
        podTemplateHashValue?: string;
        fieldRef?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$FieldRef;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$BlueGreenStatus {
        /**
         * PreviewSelector indicates which replicas set the preview service is serving traffic to
         * +optional
         */
        previewSelector?: string;
        /**
         * ActiveSelector indicates which replicas set the active service is serving traffic to
         * +optional
         */
        activeSelector?: string;
        /**
         * ScaleUpPreviewCheckPoint indicates that the Replicaset receiving traffic from the preview service is ready to be scaled up after the rollout is unpaused
         * +optional
         */
        scaleUpPreviewCheckPoint?: boolean;
        prePromotionAnalysisRunStatus?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus;
        postPromotionAnalysisRunStatus?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$BlueGreenStrategy {
        /** Name of the service that the rollout modifies as the active service. */
        activeService?: string;
        /**
         * Name of the service that the rollout modifies as the preview service.
         * +optional
         */
        previewService?: string;
        /**
         * PreviewReplicaCount is the number of replicas to run for the preview stack before the
         * switchover. Once the rollout is resumed the desired replicaset will be full scaled up before the switch occurs
         * +optional
         */
        previewReplicaCount?: number;
        /**
         * AutoPromotionEnabled indicates if the rollout should automatically promote the new ReplicaSet
         * to the active service or enter a paused state. If not specified, the default value is true.
         * +optional
         */
        autoPromotionEnabled?: boolean;
        /**
         * AutoPromotionSeconds is a duration in seconds in which to delay auto-promotion (default: 0).
         * The countdown begins after the preview ReplicaSet have reached full availability.
         * This option is ignored if autoPromotionEnabled is set to false.
         * +optional
         */
        autoPromotionSeconds?: number;
        maxUnavailable?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        /**
         * ScaleDownDelaySeconds adds a delay before scaling down the previous replicaset.
         * If omitted, the Rollout waits 30 seconds before scaling down the previous ReplicaSet.
         * A minimum of 30 seconds is recommended to ensure IP table propagation across the nodes in
         * a cluster. See https://github.com/argoproj/argo-rollouts/issues/19#issuecomment-476329960 for
         * more information
         * +optional
         */
        scaleDownDelaySeconds?: number;
        /**
         * ScaleDownDelayRevisionLimit limits the number of old RS that can run at one time before getting scaled down
         * +optional
         */
        scaleDownDelayRevisionLimit?: number;
        prePromotionAnalysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis;
        antiAffinity?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AntiAffinity;
        postPromotionAnalysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis;
        previewMetadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        activeMetadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        /**
         * AbortScaleDownDelaySeconds adds a delay in second before scaling down the preview replicaset
         * if update is aborted. 0 means not to scale down.
         * Default is 30 second
         * +optional
         */
        abortScaleDownDelaySeconds?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStatus {
        currentStepAnalysisRunStatus?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus;
        currentBackgroundAnalysisRunStatus?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus;
        /** CurrentExperiment indicates the running experiment */
        currentExperiment?: string;
    }
    /** CanaryStep defines a step of a canary deployment. */
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStep {
        /** SetWeight sets what percentage of the newRS should receive */
        setWeight?: number;
        pause?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutPause;
        experiment?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentStep;
        analysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis;
        setCanaryScale?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$SetCanaryScale;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStrategy {
        /**
         * CanaryService holds the name of a service which selects pods with canary version and don't select any pods with stable version.
         * +optional
         */
        canaryService?: string;
        /**
         * StableService holds the name of a service which selects pods with stable version and don't select any pods with canary version.
         * +optional
         */
        stableService?: string;
        /**
         * Steps define the order of phases to execute the canary deployment
         * +optional
         */
        steps?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStep[];
        trafficRouting?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutTrafficRouting;
        maxUnavailable?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        maxSurge?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        analysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisBackground;
        antiAffinity?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AntiAffinity;
        canaryMetadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        stableMetadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        /**
         * ScaleDownDelaySeconds adds a delay before scaling down the previous ReplicaSet when the
         * canary strategy is used with traffic routing (default 30 seconds). A delay in scaling down
         * the previous ReplicaSet is needed after switching the stable service selector to point to
         * the new ReplicaSet, in order to give time for traffic providers to re-target the new pods.
         * This value is ignored with basic, replica-weighted canary without traffic routing.
         * +optional
         */
        scaleDownDelaySeconds?: number;
        /**
         * ScaleDownDelayRevisionLimit limits the number of old RS that can run at one time before getting scaled down
         * +optional
         */
        scaleDownDelayRevisionLimit?: number;
        /**
         * AbortScaleDownDelaySeconds adds a delay in second before scaling down the canary pods when update
         * is aborted for canary strategy with traffic routing (not applicable for basic canary).
         * 0 means canary pods are not scaled down.
         * Default is 30 seconds.
         * +optional
         */
        abortScaleDownDelaySeconds?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$FieldRef {
        /** Required: Path of the field to select in the specified API version */
        fieldPath?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioDestinationRule {
        /** Name holds the name of the DestinationRule */
        name?: string;
        /** CanarySubsetName is the subset name to modify labels with canary ReplicaSet pod template hash value */
        canarySubsetName?: string;
        /** StableSubsetName is the subset name to modify labels with stable ReplicaSet pod template hash value */
        stableSubsetName?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioTrafficRouting {
        virtualService?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioVirtualService;
        destinationRule?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioDestinationRule;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioVirtualService {
        /** Name holds the name of the VirtualService */
        name?: string;
        /** Routes are list of routes within VirtualService to edit. If omitted, VirtualService must have a single route */
        routes?: string[];
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$NginxTrafficRouting {
        /**
         * AnnotationPrefix has to match the configured annotation prefix on the nginx ingress controller
         * +optional
         */
        annotationPrefix?: string;
        /** StableIngress refers to the name of an \`Ingress\` resource in the same namespace as the \`Rollout\` */
        stableIngress?: string;
        /** +optional */
        additionalIngressAnnotations?: {
            [key: string]: string;
        };
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ObjectRef {
        /** API Version of the referent */
        apiVersion?: string;
        /** Kind of the referent */
        kind?: string;
        /** Name of the referent */
        name?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PauseCondition {
        reason?: string;
        startTime?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata {
        /**
         * Labels Additional labels to add to the experiment
         * +optional
         */
        labels?: {
            [key: string]: string;
        };
        /**
         * Annotations additional annotations to add to the experiment
         * +optional
         */
        annotations?: {
            [key: string]: string;
        };
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PreferredDuringSchedulingIgnoredDuringExecution {
        /** Weight associated with matching the corresponding podAffinityTerm, in the range 1-100. */
        weight?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RequiredDuringSchedulingIgnoredDuringExecution {
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout {
        metadata?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        spec?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutSpec;
        status?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutStatus;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis {
        /** Templates reference to a list of analysis templates to combine for an AnalysisRun */
        templates?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisTemplate[];
        /**
         * Args the arguments that will be added to the AnalysisRuns
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        args?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunArgument[];
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisBackground {
        rolloutAnalysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysis;
        /**
         * StartingStep indicates which step the background analysis should start on
         * If not listed, controller defaults to 0
         */
        startingStep?: number;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisRunStatus {
        name?: string;
        status?: string;
        message?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutAnalysisTemplate {
        /**
         * TemplateName name of template to use in AnalysisRun
         * +optional
         */
        templateName?: string;
        /**
         * Whether to look for the templateName at cluster scope or namespace scope
         * +optional
         */
        clusterScope?: boolean;
    }
    /** RolloutCondition describes the state of a rollout at a certain point. */
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutCondition {
        /** Type of deployment condition. */
        type?: string;
        /** Phase of the condition, one of True, False, Unknown. */
        status?: string;
        lastUpdateTime?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        lastTransitionTime?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        /** The reason for the condition's last transition. */
        reason?: string;
        /** A human readable message indicating details about the transition. */
        message?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentStep {
        /**
         * Templates what templates that should be added to the experiment. Should be non-nil
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        templates?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentTemplate[];
        /**
         * Duration is a duration string (e.g. 30s, 5m, 1h) that the experiment should run for
         * +optional
         */
        duration?: string;
        /**
         * Analyses reference which analysis templates to run with the experiment
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        analyses?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentStepAnalysisTemplateRef[];
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentStepAnalysisTemplateRef {
        /** Name is a name for this analysis template invocation */
        name?: string;
        /** TemplateName reference of the AnalysisTemplate name used by the Experiment to create the run */
        templateName?: string;
        /**
         * Whether to look for the templateName at cluster scope or namespace scope
         * +optional
         */
        clusterScope?: boolean;
        /**
         * Args the arguments that will be added to the AnalysisRuns
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        args?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunArgument[];
        /** RequiredForCompletion blocks the Experiment from completing until the analysis has completed */
        requiredForCompletion?: boolean;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutExperimentTemplate {
        /** Name description of template that passed to the template */
        name?: string;
        /** SpecRef indicates where the rollout should get the RS template from */
        specRef?: string;
        /**
         * Replicas replica count for the template
         * +optional
         */
        replicas?: number;
        metadata?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PodTemplateMetadata;
        selector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutPause {
        duration?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutSpec {
        /**
         * Number of desired pods. This is a pointer to distinguish between explicit
         * zero and not specified. Defaults to 1.
         * +optional
         */
        replicas?: number;
        selector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
        template?: Schemas.k8s$io$api$core$v1$PodTemplateSpec;
        workloadRef?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ObjectRef;
        /**
         * Minimum number of seconds for which a newly created pod should be ready
         * without any of its container crashing, for it to be considered available.
         * Defaults to 0 (pod will be considered available as soon as it is ready)
         * +optional
         */
        minReadySeconds?: number;
        strategy?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutStrategy;
        /** The number of old ReplicaSets to retain. If unspecified, will retain 10 old ReplicaSets */
        revisionHistoryLimit?: number;
        /** Paused pauses the rollout at its current step. */
        paused?: boolean;
        /**
         * ProgressDeadlineSeconds The maximum time in seconds for a rollout to
         * make progress before it is considered to be failed. Argo Rollouts will
         * continue to process failed rollouts and a condition with a
         * ProgressDeadlineExceeded reason will be surfaced in the rollout status.
         * Note that progress will not be estimated during the time a rollout is paused.
         * Defaults to 600s.
         */
        progressDeadlineSeconds?: number;
        restartAt?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        analysis?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AnalysisRunStrategy;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutStatus {
        /** Abort cancel the current rollout progression */
        abort?: boolean;
        /** PauseConditions indicates why the rollout is currently paused */
        pauseConditions?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$PauseCondition[];
        /**
         * ControllerPause indicates the controller has paused the rollout. It is set to true when
         * the controller adds a pause condition. This field helps to discern the scenario where a
         * rollout was resumed after being paused by the controller (e.g. via the plugin). In that
         * situation, the pauseConditions would have been cleared , but controllerPause would still be
         * set to true.
         */
        controllerPause?: boolean;
        abortedAt?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        /**
         * CurrentPodHash the hash of the current pod template
         * +optional
         */
        currentPodHash?: string;
        /**
         * CurrentStepHash the hash of the current list of steps for the current strategy. This is used to detect when the
         * list of current steps change
         * +optional
         */
        currentStepHash?: string;
        /**
         * Total number of non-terminated pods targeted by this rollout (their labels match the selector).
         * +optional
         */
        replicas?: number;
        /**
         * Total number of non-terminated pods targeted by this rollout that have the desired template spec.
         * +optional
         */
        updatedReplicas?: number;
        /**
         * Total number of ready pods targeted by this rollout.
         * +optional
         */
        readyReplicas?: number;
        /**
         * Total number of available pods (ready for at least minReadySeconds) targeted by this rollout.
         * +optional
         */
        availableReplicas?: number;
        /**
         * CurrentStepIndex defines the current step of the rollout is on. If the current step index is null, the
         * controller will execute the rollout.
         * +optional
         */
        currentStepIndex?: number;
        /**
         * Count of hash collisions for the Rollout. The Rollout controller uses this
         * field as a collision avoidance mechanism when it needs to create the name for the
         * newest ReplicaSet.
         * +optional
         */
        collisionCount?: number;
        /**
         * The generation observed by the rollout controller from metadata.generation
         * +optional
         */
        observedGeneration?: string;
        /**
         * The generation of referenced workload observed by the rollout controller
         * +optional
         */
        workloadObservedGeneration?: string;
        /**
         * Conditions a list of conditions a rollout can have.
         * +optional
         */
        conditions?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutCondition[];
        canary?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStatus;
        blueGreen?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$BlueGreenStatus;
        /**
         * HPAReplicas the number of non-terminated replicas that are receiving active traffic
         * +optional
         */
        HPAReplicas?: number;
        /**
         * Selector that identifies the pods that are receiving active traffic
         * +optional
         */
        selector?: string;
        /**
         * StableRS indicates the replicaset that has successfully rolled out
         * +optional
         */
        stableRS?: string;
        restartedAt?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        /** PromoteFull indicates if the rollout should perform a full promotion, skipping analysis and pauses. */
        promoteFull?: boolean;
        /** Phase is the rollout phase. Clients should only rely on the value if status.observedGeneration equals metadata.generation */
        phase?: string;
        /** Message provides details on why the rollout is in its current phase */
        message?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutStrategy {
        blueGreen?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$BlueGreenStrategy;
        canary?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStrategy;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$RolloutTrafficRouting {
        istio?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$IstioTrafficRouting;
        nginx?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$NginxTrafficRouting;
        alb?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$ALBTrafficRouting;
        smi?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$SMITrafficRouting;
        ambassador?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$AmbassadorTrafficRouting;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$SMITrafficRouting {
        /**
         * RootService holds the name of that clients use to communicate.
         * +optional
         */
        rootService?: string;
        /**
         * TrafficSplitName holds the name of the TrafficSplit.
         * +optional
         */
        trafficSplitName?: string;
    }
    export interface github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$SetCanaryScale {
        /**
         * Weight sets the percentage of replicas the newRS should have
         * +optional
         */
        weight?: number;
        /**
         * Replicas sets the number of replicas the newRS should have
         * +optional
         */
        replicas?: number;
        /**
         * MatchTrafficWeight cancels out previously set Replicas or Weight, effectively activating SetWeight
         * +optional
         */
        matchTrafficWeight?: boolean;
    }
    export interface google$protobuf$Any {
        type_url?: string;
        value?: string;
    }
    export interface grpc$gateway$runtime$Error {
        error?: string;
        code?: number;
        message?: string;
        details?: Schemas.google$protobuf$Any[];
    }
    export interface grpc$gateway$runtime$StreamError {
        grpc_code?: number;
        http_code?: number;
        message?: string;
        http_status?: string;
        details?: Schemas.google$protobuf$Any[];
    }
    /**
     * Represents a Persistent Disk resource in AWS.
     *
     * An AWS EBS disk must exist before mounting to a container. The disk
     * must also be in the same AWS zone as the kubelet. An AWS EBS disk
     * can only be mounted as read/write once. AWS EBS volumes support
     * ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$AWSElasticBlockStoreVolumeSource {
        /**
         * Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
         */
        volumeID?: string;
        /**
         * Filesystem type of the volume that you want to mount.
         * Tip: Ensure that the filesystem type is supported by the host operating system.
         * Examples: \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
         * TODO: how do we prevent errors in the filesystem from compromising the machine
         * +optional
         */
        fsType?: string;
        /**
         * The partition in the volume that you want to mount.
         * If omitted, the default is to mount by volume name.
         * Examples: For volume /dev/sda1, you specify the partition as \\"1\\".
         * Similarly, the volume partition for /dev/sda is \\"0\\" (or you can leave the property empty).
         * +optional
         */
        partition?: number;
        /**
         * Specify \\"true\\" to force and set the ReadOnly property in VolumeMounts to \\"true\\".
         * If omitted, the default is \\"false\\".
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
         * +optional
         */
        readOnly?: boolean;
    }
    /** Affinity is a group of affinity scheduling rules. */
    export interface k8s$io$api$core$v1$Affinity {
        nodeAffinity?: Schemas.k8s$io$api$core$v1$NodeAffinity;
        podAffinity?: Schemas.k8s$io$api$core$v1$PodAffinity;
        podAntiAffinity?: Schemas.k8s$io$api$core$v1$PodAntiAffinity;
    }
    /** AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. */
    export interface k8s$io$api$core$v1$AzureDiskVolumeSource {
        /** The Name of the data disk in the blob storage */
        diskName?: string;
        /** The URI the data disk in the blob storage */
        diskURI?: string;
        /**
         * Host Caching mode: None, Read Only, Read Write.
         * +optional
         */
        cachingMode?: string;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * +optional
         */
        fsType?: string;
        /**
         * Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * +optional
         */
        readOnly?: boolean;
        /** Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared */
        kind?: string;
    }
    /** AzureFile represents an Azure File Service mount on the host and bind mount to the pod. */
    export interface k8s$io$api$core$v1$AzureFileVolumeSource {
        /** the name of secret that contains Azure Storage Account Name and Key */
        secretName?: string;
        /** Share Name */
        shareName?: string;
        /**
         * Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * +optional
         */
        readOnly?: boolean;
    }
    export interface k8s$io$api$core$v1$CSIVolumeSource {
        /**
         * Driver is the name of the CSI driver that handles this volume.
         * Consult with your admin for the correct name as registered in the cluster.
         */
        driver?: string;
        /**
         * Specifies a read-only configuration for the volume.
         * Defaults to false (read/write).
         * +optional
         */
        readOnly?: boolean;
        /**
         * Filesystem type to mount. Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\".
         * If not provided, the empty value is passed to the associated CSI driver
         * which will determine the default filesystem to apply.
         * +optional
         */
        fsType?: string;
        /**
         * VolumeAttributes stores driver-specific properties that are passed to the CSI
         * driver. Consult your driver's documentation for supported values.
         * +optional
         */
        volumeAttributes?: {
            [key: string]: string;
        };
        nodePublishSecretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
    }
    /** Adds and removes POSIX capabilities from running containers. */
    export interface k8s$io$api$core$v1$Capabilities {
        /**
         * Added capabilities
         * +optional
         */
        add?: string[];
        /**
         * Removed capabilities
         * +optional
         */
        drop?: string[];
    }
    /**
     * Represents a Ceph Filesystem mount that lasts the lifetime of a pod
     * Cephfs volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$CephFSVolumeSource {
        /**
         * Required: Monitors is a collection of Ceph monitors
         * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
         */
        monitors?: string[];
        /**
         * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
         * +optional
         */
        path?: string;
        /**
         * Optional: User is the rados user name, default is admin
         * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
         * +optional
         */
        user?: string;
        /**
         * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
         * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
         * +optional
         */
        secretFile?: string;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * Optional: Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
         * +optional
         */
        readOnly?: boolean;
    }
    /**
     * Represents a cinder volume resource in Openstack.
     * A Cinder volume must exist before mounting to a container.
     * The volume must also be in the same region as the kubelet.
     * Cinder volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$CinderVolumeSource {
        /**
         * volume id used to identify the volume in cinder.
         * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
         */
        volumeID?: string;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Examples: \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
         * +optional
         */
        fsType?: string;
        /**
         * Optional: Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
         * +optional
         */
        readOnly?: boolean;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
    }
    /**
     * ConfigMapEnvSource selects a ConfigMap to populate the environment
     * variables with.
     *
     * The contents of the target ConfigMap's Data field will represent the
     * key-value pairs as environment variables.
     */
    export interface k8s$io$api$core$v1$ConfigMapEnvSource {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * Specify whether the ConfigMap must be defined
         * +optional
         */
        optional?: boolean;
    }
    /** Selects a key from a ConfigMap. */
    export interface k8s$io$api$core$v1$ConfigMapKeySelector {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /** The key to select. */
        key?: string;
        /**
         * Specify whether the ConfigMap or its key must be defined
         * +optional
         */
        optional?: boolean;
    }
    /**
     * Adapts a ConfigMap into a projected volume.
     *
     * The contents of the target ConfigMap's Data field will be presented in a
     * projected volume as files using the keys in the Data field as the file names,
     * unless the items element is populated with specific mappings of keys to paths.
     * Note that this is identical to a configmap volume source without the default
     * mode.
     */
    export interface k8s$io$api$core$v1$ConfigMapProjection {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * If unspecified, each key-value pair in the Data field of the referenced
         * ConfigMap will be projected into the volume as a file whose name is the
         * key and content is the value. If specified, the listed keys will be
         * projected into the specified paths, and unlisted keys will not be
         * present. If a key is specified which is not present in the ConfigMap,
         * the volume setup will error unless it is marked optional. Paths must be
         * relative and may not contain the '..' path or start with '..'.
         * +optional
         */
        items?: Schemas.k8s$io$api$core$v1$KeyToPath[];
        /**
         * Specify whether the ConfigMap or its keys must be defined
         * +optional
         */
        optional?: boolean;
    }
    /**
     * Adapts a ConfigMap into a volume.
     *
     * The contents of the target ConfigMap's Data field will be presented in a
     * volume as files using the keys in the Data field as the file names, unless
     * the items element is populated with specific mappings of keys to paths.
     * ConfigMap volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$ConfigMapVolumeSource {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * If unspecified, each key-value pair in the Data field of the referenced
         * ConfigMap will be projected into the volume as a file whose name is the
         * key and content is the value. If specified, the listed keys will be
         * projected into the specified paths, and unlisted keys will not be
         * present. If a key is specified which is not present in the ConfigMap,
         * the volume setup will error unless it is marked optional. Paths must be
         * relative and may not contain the '..' path or start with '..'.
         * +optional
         */
        items?: Schemas.k8s$io$api$core$v1$KeyToPath[];
        /**
         * Optional: mode bits used to set permissions on created files by default.
         * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
         * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
         * Defaults to 0644.
         * Directories within the path are not affected by this setting.
         * This might be in conflict with other options that affect the file
         * mode, like fsGroup, and the result can be other mode bits set.
         * +optional
         */
        defaultMode?: number;
        /**
         * Specify whether the ConfigMap or its keys must be defined
         * +optional
         */
        optional?: boolean;
    }
    /** A single application container that you want to run within a pod. */
    export interface k8s$io$api$core$v1$Container {
        /**
         * Name of the container specified as a DNS_LABEL.
         * Each container in a pod must have a unique name (DNS_LABEL).
         * Cannot be updated.
         */
        name?: string;
        /**
         * Docker image name.
         * More info: https://kubernetes.io/docs/concepts/containers/images
         * This field is optional to allow higher level config management to default or override
         * container images in workload controllers like Deployments and StatefulSets.
         * +optional
         */
        image?: string;
        /**
         * Entrypoint array. Not executed within a shell.
         * The docker image's ENTRYPOINT is used if this is not provided.
         * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
         * cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
         * can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
         * regardless of whether the variable exists or not.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
         * +optional
         */
        command?: string[];
        /**
         * Arguments to the entrypoint.
         * The docker image's CMD is used if this is not provided.
         * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
         * cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
         * can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
         * regardless of whether the variable exists or not.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
         * +optional
         */
        args?: string[];
        /**
         * Container's working directory.
         * If not specified, the container runtime's default will be used, which
         * might be configured in the container image.
         * Cannot be updated.
         * +optional
         */
        workingDir?: string;
        /**
         * List of ports to expose from the container. Exposing a port here gives
         * the system additional information about the network connections a
         * container uses, but is primarily informational. Not specifying a port here
         * DOES NOT prevent that port from being exposed. Any port which is
         * listening on the default \\"0.0.0.0\\" address inside a container will be
         * accessible from the network.
         * Cannot be updated.
         * +optional
         * +patchMergeKey=containerPort
         * +patchStrategy=merge
         * +listType=map
         * +listMapKey=containerPort
         * +listMapKey=protocol
         */
        ports?: Schemas.k8s$io$api$core$v1$ContainerPort[];
        /**
         * List of sources to populate environment variables in the container.
         * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
         * will be reported as an event when the container is starting. When a key exists in multiple
         * sources, the value associated with the last source will take precedence.
         * Values defined by an Env with a duplicate key will take precedence.
         * Cannot be updated.
         * +optional
         */
        envFrom?: Schemas.k8s$io$api$core$v1$EnvFromSource[];
        /**
         * List of environment variables to set in the container.
         * Cannot be updated.
         * +optional
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        env?: Schemas.k8s$io$api$core$v1$EnvVar[];
        resources?: Schemas.k8s$io$api$core$v1$ResourceRequirements;
        /**
         * Pod volumes to mount into the container's filesystem.
         * Cannot be updated.
         * +optional
         * +patchMergeKey=mountPath
         * +patchStrategy=merge
         */
        volumeMounts?: Schemas.k8s$io$api$core$v1$VolumeMount[];
        /**
         * volumeDevices is the list of block devices to be used by the container.
         * +patchMergeKey=devicePath
         * +patchStrategy=merge
         * +optional
         */
        volumeDevices?: Schemas.k8s$io$api$core$v1$VolumeDevice[];
        livenessProbe?: Schemas.k8s$io$api$core$v1$Probe;
        readinessProbe?: Schemas.k8s$io$api$core$v1$Probe;
        startupProbe?: Schemas.k8s$io$api$core$v1$Probe;
        lifecycle?: Schemas.k8s$io$api$core$v1$Lifecycle;
        /**
         * Optional: Path at which the file to which the container's termination message
         * will be written is mounted into the container's filesystem.
         * Message written is intended to be brief final status, such as an assertion failure message.
         * Will be truncated by the node if greater than 4096 bytes. The total message length across
         * all containers will be limited to 12kb.
         * Defaults to /dev/termination-log.
         * Cannot be updated.
         * +optional
         */
        terminationMessagePath?: string;
        /**
         * Indicate how the termination message should be populated. File will use the contents of
         * terminationMessagePath to populate the container status message on both success and failure.
         * FallbackToLogsOnError will use the last chunk of container log output if the termination
         * message file is empty and the container exited with an error.
         * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
         * Defaults to File.
         * Cannot be updated.
         * +optional
         */
        terminationMessagePolicy?: string;
        /**
         * Image pull policy.
         * One of Always, Never, IfNotPresent.
         * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
         * +optional
         */
        imagePullPolicy?: string;
        securityContext?: Schemas.k8s$io$api$core$v1$SecurityContext;
        /**
         * Whether this container should allocate a buffer for stdin in the container runtime. If this
         * is not set, reads from stdin in the container will always result in EOF.
         * Default is false.
         * +optional
         */
        stdin?: boolean;
        /**
         * Whether the container runtime should close the stdin channel after it has been opened by
         * a single attach. When stdin is true the stdin stream will remain open across multiple attach
         * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
         * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
         * at which time stdin is closed and remains closed until the container is restarted. If this
         * flag is false, a container processes that reads from stdin will never receive an EOF.
         * Default is false
         * +optional
         */
        stdinOnce?: boolean;
        /**
         * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
         * Default is false.
         * +optional
         */
        tty?: boolean;
    }
    /** ContainerPort represents a network port in a single container. */
    export interface k8s$io$api$core$v1$ContainerPort {
        /**
         * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
         * named port in a pod must have a unique name. Name for the port that can be
         * referred to by services.
         * +optional
         */
        name?: string;
        /**
         * Number of port to expose on the host.
         * If specified, this must be a valid port number, 0 < x < 65536.
         * If HostNetwork is specified, this must match ContainerPort.
         * Most containers do not need this.
         * +optional
         */
        hostPort?: number;
        /**
         * Number of port to expose on the pod's IP address.
         * This must be a valid port number, 0 < x < 65536.
         */
        containerPort?: number;
        /**
         * Protocol for port. Must be UDP, TCP, or SCTP.
         * Defaults to \\"TCP\\".
         * +optional
         * +default=\\"TCP\\"
         */
        protocol?: string;
        /**
         * What host IP to bind the external port to.
         * +optional
         */
        hostIP?: string;
    }
    /**
     * Represents downward API info for projecting into a projected volume.
     * Note that this is identical to a downwardAPI volume source without the default
     * mode.
     */
    export interface k8s$io$api$core$v1$DownwardAPIProjection {
        /**
         * Items is a list of DownwardAPIVolume file
         * +optional
         */
        items?: Schemas.k8s$io$api$core$v1$DownwardAPIVolumeFile[];
    }
    export interface k8s$io$api$core$v1$DownwardAPIVolumeFile {
        /** Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..' */
        path?: string;
        fieldRef?: Schemas.k8s$io$api$core$v1$ObjectFieldSelector;
        resourceFieldRef?: Schemas.k8s$io$api$core$v1$ResourceFieldSelector;
        /**
         * Optional: mode bits used to set permissions on this file, must be an octal value
         * between 0000 and 0777 or a decimal value between 0 and 511.
         * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
         * If not specified, the volume defaultMode will be used.
         * This might be in conflict with other options that affect the file
         * mode, like fsGroup, and the result can be other mode bits set.
         * +optional
         */
        mode?: number;
    }
    /**
     * DownwardAPIVolumeSource represents a volume containing downward API info.
     * Downward API volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$DownwardAPIVolumeSource {
        /**
         * Items is a list of downward API volume file
         * +optional
         */
        items?: Schemas.k8s$io$api$core$v1$DownwardAPIVolumeFile[];
        /**
         * Optional: mode bits to use on created files by default. Must be a
         * Optional: mode bits used to set permissions on created files by default.
         * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
         * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
         * Defaults to 0644.
         * Directories within the path are not affected by this setting.
         * This might be in conflict with other options that affect the file
         * mode, like fsGroup, and the result can be other mode bits set.
         * +optional
         */
        defaultMode?: number;
    }
    /**
     * Represents an empty directory for a pod.
     * Empty directory volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$EmptyDirVolumeSource {
        /**
         * What type of storage medium should back this directory.
         * The default is \\"\\" which means to use the node's default medium.
         * Must be an empty string (default) or Memory.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
         * +optional
         */
        medium?: string;
        sizeLimit?: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
    }
    export interface k8s$io$api$core$v1$EnvFromSource {
        /**
         * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
         * +optional
         */
        prefix?: string;
        configMapRef?: Schemas.k8s$io$api$core$v1$ConfigMapEnvSource;
        secretRef?: Schemas.k8s$io$api$core$v1$SecretEnvSource;
    }
    /** EnvVar represents an environment variable present in a Container. */
    export interface k8s$io$api$core$v1$EnvVar {
        /** Name of the environment variable. Must be a C_IDENTIFIER. */
        name?: string;
        /**
         * Variable references $(VAR_NAME) are expanded
         * using the previous defined environment variables in the container and
         * any service environment variables. If a variable cannot be resolved,
         * the reference in the input string will be unchanged. The $(VAR_NAME)
         * syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
         * references will never be expanded, regardless of whether the variable
         * exists or not.
         * Defaults to \\"\\".
         * +optional
         */
        value?: string;
        valueFrom?: Schemas.k8s$io$api$core$v1$EnvVarSource;
    }
    /** EnvVarSource represents a source for the value of an EnvVar. */
    export interface k8s$io$api$core$v1$EnvVarSource {
        fieldRef?: Schemas.k8s$io$api$core$v1$ObjectFieldSelector;
        resourceFieldRef?: Schemas.k8s$io$api$core$v1$ResourceFieldSelector;
        configMapKeyRef?: Schemas.k8s$io$api$core$v1$ConfigMapKeySelector;
        secretKeyRef?: Schemas.k8s$io$api$core$v1$SecretKeySelector;
    }
    /**
     * An EphemeralContainer is a container that may be added temporarily to an existing pod for
     * user-initiated activities such as debugging. Ephemeral containers have no resource or
     * scheduling guarantees, and they will not be restarted when they exit or when a pod is
     * removed or restarted. If an ephemeral container causes a pod to exceed its resource
     * allocation, the pod may be evicted.
     * Ephemeral containers may not be added by directly updating the pod spec. They must be added
     * via the pod's ephemeralcontainers subresource, and they will appear in the pod spec
     * once added.
     * This is an alpha feature enabled by the EphemeralContainers feature flag.
     */
    export interface k8s$io$api$core$v1$EphemeralContainer {
        ephemeralContainerCommon?: Schemas.k8s$io$api$core$v1$EphemeralContainerCommon;
        /**
         * If set, the name of the container from PodSpec that this ephemeral container targets.
         * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
         * If not set then the ephemeral container is run in whatever namespaces are shared
         * for the pod. Note that the container runtime must support this feature.
         * +optional
         */
        targetContainerName?: string;
    }
    /**
     * EphemeralContainerCommon is a copy of all fields in Container to be inlined in
     * EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
     * to Container and allows separate documentation for the fields of EphemeralContainer.
     * When a new field is added to Container it must be added here as well.
     */
    export interface k8s$io$api$core$v1$EphemeralContainerCommon {
        /**
         * Name of the ephemeral container specified as a DNS_LABEL.
         * This name must be unique among all containers, init containers and ephemeral containers.
         */
        name?: string;
        /**
         * Docker image name.
         * More info: https://kubernetes.io/docs/concepts/containers/images
         */
        image?: string;
        /**
         * Entrypoint array. Not executed within a shell.
         * The docker image's ENTRYPOINT is used if this is not provided.
         * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
         * cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
         * can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
         * regardless of whether the variable exists or not.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
         * +optional
         */
        command?: string[];
        /**
         * Arguments to the entrypoint.
         * The docker image's CMD is used if this is not provided.
         * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
         * cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
         * can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
         * regardless of whether the variable exists or not.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
         * +optional
         */
        args?: string[];
        /**
         * Container's working directory.
         * If not specified, the container runtime's default will be used, which
         * might be configured in the container image.
         * Cannot be updated.
         * +optional
         */
        workingDir?: string;
        /** Ports are not allowed for ephemeral containers. */
        ports?: Schemas.k8s$io$api$core$v1$ContainerPort[];
        /**
         * List of sources to populate environment variables in the container.
         * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
         * will be reported as an event when the container is starting. When a key exists in multiple
         * sources, the value associated with the last source will take precedence.
         * Values defined by an Env with a duplicate key will take precedence.
         * Cannot be updated.
         * +optional
         */
        envFrom?: Schemas.k8s$io$api$core$v1$EnvFromSource[];
        /**
         * List of environment variables to set in the container.
         * Cannot be updated.
         * +optional
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        env?: Schemas.k8s$io$api$core$v1$EnvVar[];
        resources?: Schemas.k8s$io$api$core$v1$ResourceRequirements;
        /**
         * Pod volumes to mount into the container's filesystem.
         * Cannot be updated.
         * +optional
         * +patchMergeKey=mountPath
         * +patchStrategy=merge
         */
        volumeMounts?: Schemas.k8s$io$api$core$v1$VolumeMount[];
        /**
         * volumeDevices is the list of block devices to be used by the container.
         * +patchMergeKey=devicePath
         * +patchStrategy=merge
         * +optional
         */
        volumeDevices?: Schemas.k8s$io$api$core$v1$VolumeDevice[];
        livenessProbe?: Schemas.k8s$io$api$core$v1$Probe;
        readinessProbe?: Schemas.k8s$io$api$core$v1$Probe;
        startupProbe?: Schemas.k8s$io$api$core$v1$Probe;
        lifecycle?: Schemas.k8s$io$api$core$v1$Lifecycle;
        /**
         * Optional: Path at which the file to which the container's termination message
         * will be written is mounted into the container's filesystem.
         * Message written is intended to be brief final status, such as an assertion failure message.
         * Will be truncated by the node if greater than 4096 bytes. The total message length across
         * all containers will be limited to 12kb.
         * Defaults to /dev/termination-log.
         * Cannot be updated.
         * +optional
         */
        terminationMessagePath?: string;
        /**
         * Indicate how the termination message should be populated. File will use the contents of
         * terminationMessagePath to populate the container status message on both success and failure.
         * FallbackToLogsOnError will use the last chunk of container log output if the termination
         * message file is empty and the container exited with an error.
         * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
         * Defaults to File.
         * Cannot be updated.
         * +optional
         */
        terminationMessagePolicy?: string;
        /**
         * Image pull policy.
         * One of Always, Never, IfNotPresent.
         * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
         * +optional
         */
        imagePullPolicy?: string;
        securityContext?: Schemas.k8s$io$api$core$v1$SecurityContext;
        /**
         * Whether this container should allocate a buffer for stdin in the container runtime. If this
         * is not set, reads from stdin in the container will always result in EOF.
         * Default is false.
         * +optional
         */
        stdin?: boolean;
        /**
         * Whether the container runtime should close the stdin channel after it has been opened by
         * a single attach. When stdin is true the stdin stream will remain open across multiple attach
         * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
         * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
         * at which time stdin is closed and remains closed until the container is restarted. If this
         * flag is false, a container processes that reads from stdin will never receive an EOF.
         * Default is false
         * +optional
         */
        stdinOnce?: boolean;
        /**
         * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
         * Default is false.
         * +optional
         */
        tty?: boolean;
    }
    /** Represents an ephemeral volume that is handled by a normal storage driver. */
    export interface k8s$io$api$core$v1$EphemeralVolumeSource {
        volumeClaimTemplate?: Schemas.k8s$io$api$core$v1$PersistentVolumeClaimTemplate;
        /**
         * Specifies a read-only configuration for the volume.
         * Defaults to false (read/write).
         * +optional
         */
        readOnly?: boolean;
    }
    /** ExecAction describes a \\"run in container\\" action. */
    export interface k8s$io$api$core$v1$ExecAction {
        /**
         * Command is the command line to execute inside the container, the working directory for the
         * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
         * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
         * a shell, you need to explicitly call out to that shell.
         * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
         * +optional
         */
        command?: string[];
    }
    /**
     * Represents a Fibre Channel volume.
     * Fibre Channel volumes can only be mounted as read/write once.
     * Fibre Channel volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$FCVolumeSource {
        /**
         * Optional: FC target worldwide names (WWNs)
         * +optional
         */
        targetWWNs?: string[];
        /**
         * Optional: FC target lun number
         * +optional
         */
        lun?: number;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * TODO: how do we prevent errors in the filesystem from compromising the machine
         * +optional
         */
        fsType?: string;
        /**
         * Optional: Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * +optional
         */
        readOnly?: boolean;
        /**
         * Optional: FC volume world wide identifiers (wwids)
         * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
         * +optional
         */
        wwids?: string[];
    }
    /**
     * FlexVolume represents a generic volume resource that is
     * provisioned/attached using an exec based plugin.
     */
    export interface k8s$io$api$core$v1$FlexVolumeSource {
        /** Driver is the name of the driver to use for this volume. */
        driver?: string;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\". The default filesystem depends on FlexVolume script.
         * +optional
         */
        fsType?: string;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * Optional: Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * +optional
         */
        readOnly?: boolean;
        /**
         * Optional: Extra command options if any.
         * +optional
         */
        options?: {
            [key: string]: string;
        };
    }
    /**
     * Represents a Flocker volume mounted by the Flocker agent.
     * One and only one of datasetName and datasetUUID should be set.
     * Flocker volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$FlockerVolumeSource {
        /**
         * Name of the dataset stored as metadata -> name on the dataset for Flocker
         * should be considered as deprecated
         * +optional
         */
        datasetName?: string;
        /**
         * UUID of the dataset. This is unique identifier of a Flocker dataset
         * +optional
         */
        datasetUUID?: string;
    }
    /**
     * Represents a Persistent Disk resource in Google Compute Engine.
     *
     * A GCE PD must exist before mounting to a container. The disk must
     * also be in the same GCE project and zone as the kubelet. A GCE PD
     * can only be mounted as read/write once or read-only many times. GCE
     * PDs support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$GCEPersistentDiskVolumeSource {
        /**
         * Unique name of the PD resource in GCE. Used to identify the disk in GCE.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
         */
        pdName?: string;
        /**
         * Filesystem type of the volume that you want to mount.
         * Tip: Ensure that the filesystem type is supported by the host operating system.
         * Examples: \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
         * TODO: how do we prevent errors in the filesystem from compromising the machine
         * +optional
         */
        fsType?: string;
        /**
         * The partition in the volume that you want to mount.
         * If omitted, the default is to mount by volume name.
         * Examples: For volume /dev/sda1, you specify the partition as \\"1\\".
         * Similarly, the volume partition for /dev/sda is \\"0\\" (or you can leave the property empty).
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
         * +optional
         */
        partition?: number;
        /**
         * ReadOnly here will force the ReadOnly setting in VolumeMounts.
         * Defaults to false.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
         * +optional
         */
        readOnly?: boolean;
    }
    /**
     * Represents a volume that is populated with the contents of a git repository.
     * Git repo volumes do not support ownership management.
     * Git repo volumes support SELinux relabeling.
     *
     * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
     * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
     * into the Pod's container.
     */
    export interface k8s$io$api$core$v1$GitRepoVolumeSource {
        /** Repository URL */
        repository?: string;
        /**
         * Commit hash for the specified revision.
         * +optional
         */
        revision?: string;
        /**
         * Target directory name.
         * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
         * git repository.  Otherwise, if specified, the volume will contain the git repository in
         * the subdirectory with the given name.
         * +optional
         */
        directory?: string;
    }
    /**
     * Represents a Glusterfs mount that lasts the lifetime of a pod.
     * Glusterfs volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$GlusterfsVolumeSource {
        /**
         * EndpointsName is the endpoint name that details Glusterfs topology.
         * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
         */
        endpoints?: string;
        /**
         * Path is the Glusterfs volume path.
         * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
         */
        path?: string;
        /**
         * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
         * Defaults to false.
         * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
         * +optional
         */
        readOnly?: boolean;
    }
    /** HTTPGetAction describes an action based on HTTP Get requests. */
    export interface k8s$io$api$core$v1$HTTPGetAction {
        /**
         * Path to access on the HTTP server.
         * +optional
         */
        path?: string;
        port?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        /**
         * Host name to connect to, defaults to the pod IP. You probably want to set
         * \\"Host\\" in httpHeaders instead.
         * +optional
         */
        host?: string;
        /**
         * Scheme to use for connecting to the host.
         * Defaults to HTTP.
         * +optional
         */
        scheme?: string;
        /**
         * Custom headers to set in the request. HTTP allows repeated headers.
         * +optional
         */
        httpHeaders?: Schemas.k8s$io$api$core$v1$HTTPHeader[];
    }
    export interface k8s$io$api$core$v1$HTTPHeader {
        /** The header field name */
        name?: string;
        /** The header field value */
        value?: string;
    }
    /**
     * Handler defines a specific action that should be taken
     * TODO: pass structured data to these actions, and document that data here.
     */
    export interface k8s$io$api$core$v1$Handler {
        exec?: Schemas.k8s$io$api$core$v1$ExecAction;
        httpGet?: Schemas.k8s$io$api$core$v1$HTTPGetAction;
        tcpSocket?: Schemas.k8s$io$api$core$v1$TCPSocketAction;
    }
    /**
     * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
     * pod's hosts file.
     */
    export interface k8s$io$api$core$v1$HostAlias {
        /** IP address of the host file entry. */
        ip?: string;
        /** Hostnames for the above IP address. */
        hostnames?: string[];
    }
    /**
     * Represents a host path mapped into a pod.
     * Host path volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$HostPathVolumeSource {
        /**
         * Path of the directory on the host.
         * If the path is a symlink, it will follow the link to the real path.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
         */
        path?: string;
        /**
         * Type for HostPath Volume
         * Defaults to \\"\\"
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
         * +optional
         */
        type?: string;
    }
    /**
     * Represents an ISCSI disk.
     * ISCSI volumes can only be mounted as read/write once.
     * ISCSI volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$ISCSIVolumeSource {
        /**
         * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
         * is other than default (typically TCP ports 860 and 3260).
         */
        targetPortal?: string;
        /** Target iSCSI Qualified Name. */
        iqn?: string;
        /** iSCSI Target Lun number. */
        lun?: number;
        /**
         * iSCSI Interface Name that uses an iSCSI transport.
         * Defaults to 'default' (tcp).
         * +optional
         */
        iscsiInterface?: string;
        /**
         * Filesystem type of the volume that you want to mount.
         * Tip: Ensure that the filesystem type is supported by the host operating system.
         * Examples: \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
         * TODO: how do we prevent errors in the filesystem from compromising the machine
         * +optional
         */
        fsType?: string;
        /**
         * ReadOnly here will force the ReadOnly setting in VolumeMounts.
         * Defaults to false.
         * +optional
         */
        readOnly?: boolean;
        /**
         * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
         * is other than default (typically TCP ports 860 and 3260).
         * +optional
         */
        portals?: string[];
        /**
         * whether support iSCSI Discovery CHAP authentication
         * +optional
         */
        chapAuthDiscovery?: boolean;
        /**
         * whether support iSCSI Session CHAP authentication
         * +optional
         */
        chapAuthSession?: boolean;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * Custom iSCSI Initiator Name.
         * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
         * <target portal>:<volume name> will be created for the connection.
         * +optional
         */
        initiatorName?: string;
    }
    /** Maps a string key to a path within a volume. */
    export interface k8s$io$api$core$v1$KeyToPath {
        /** The key to project. */
        key?: string;
        /**
         * The relative path of the file to map the key to.
         * May not be an absolute path.
         * May not contain the path element '..'.
         * May not start with the string '..'.
         */
        path?: string;
        /**
         * Optional: mode bits used to set permissions on this file.
         * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
         * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
         * If not specified, the volume defaultMode will be used.
         * This might be in conflict with other options that affect the file
         * mode, like fsGroup, and the result can be other mode bits set.
         * +optional
         */
        mode?: number;
    }
    /**
     * Lifecycle describes actions that the management system should take in response to container lifecycle
     * events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
     * until the action is complete, unless the container process fails, in which case the handler is aborted.
     */
    export interface k8s$io$api$core$v1$Lifecycle {
        postStart?: Schemas.k8s$io$api$core$v1$Handler;
        preStop?: Schemas.k8s$io$api$core$v1$Handler;
    }
    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface k8s$io$api$core$v1$LocalObjectReference {
        /**
         * Name of the referent.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
         * TODO: Add other useful fields. apiVersion, kind, uid?
         * +optional
         */
        name?: string;
    }
    /**
     * Represents an NFS mount that lasts the lifetime of a pod.
     * NFS volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$NFSVolumeSource {
        /**
         * Server is the hostname or IP address of the NFS server.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
         */
        server?: string;
        /**
         * Path that is exported by the NFS server.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
         */
        path?: string;
        /**
         * ReadOnly here will force
         * the NFS export to be mounted with read-only permissions.
         * Defaults to false.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
         * +optional
         */
        readOnly?: boolean;
    }
    /** Node affinity is a group of node affinity scheduling rules. */
    export interface k8s$io$api$core$v1$NodeAffinity {
        requiredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$NodeSelector;
        /**
         * The scheduler will prefer to schedule pods to nodes that satisfy
         * the affinity expressions specified by this field, but it may choose
         * a node that violates one or more of the expressions. The node that is
         * most preferred is the one with the greatest sum of weights, i.e.
         * for each node that meets all of the scheduling requirements (resource
         * request, requiredDuringScheduling affinity expressions, etc.),
         * compute a sum by iterating through the elements of this field and adding
         * \\"weight\\" to the sum if the node matches the corresponding matchExpressions; the
         * node(s) with the highest sum are the most preferred.
         * +optional
         */
        preferredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$PreferredSchedulingTerm[];
    }
    /**
     * A node selector represents the union of the results of one or more label queries
     * over a set of nodes; that is, it represents the OR of the selectors represented
     * by the node selector terms.
     */
    export interface k8s$io$api$core$v1$NodeSelector {
        /** Required. A list of node selector terms. The terms are ORed. */
        nodeSelectorTerms?: Schemas.k8s$io$api$core$v1$NodeSelectorTerm[];
    }
    /**
     * A node selector requirement is a selector that contains values, a key, and an operator
     * that relates the key and values.
     */
    export interface k8s$io$api$core$v1$NodeSelectorRequirement {
        /** The label key that the selector applies to. */
        key?: string;
        /**
         * Represents a key's relationship to a set of values.
         * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
         */
        operator?: string;
        /**
         * An array of string values. If the operator is In or NotIn,
         * the values array must be non-empty. If the operator is Exists or DoesNotExist,
         * the values array must be empty. If the operator is Gt or Lt, the values
         * array must have a single element, which will be interpreted as an integer.
         * This array is replaced during a strategic merge patch.
         * +optional
         */
        values?: string[];
    }
    /**
     * A null or empty node selector term matches no objects. The requirements of
     * them are ANDed.
     * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
     */
    export interface k8s$io$api$core$v1$NodeSelectorTerm {
        /**
         * A list of node selector requirements by node's labels.
         * +optional
         */
        matchExpressions?: Schemas.k8s$io$api$core$v1$NodeSelectorRequirement[];
        /**
         * A list of node selector requirements by node's fields.
         * +optional
         */
        matchFields?: Schemas.k8s$io$api$core$v1$NodeSelectorRequirement[];
    }
    /** ObjectFieldSelector selects an APIVersioned field of an object. */
    export interface k8s$io$api$core$v1$ObjectFieldSelector {
        /**
         * Version of the schema the FieldPath is written in terms of, defaults to \\"v1\\".
         * +optional
         */
        apiVersion?: string;
        /** Path of the field to select in the specified API version. */
        fieldPath?: string;
    }
    export interface k8s$io$api$core$v1$PersistentVolumeClaimSpec {
        /**
         * AccessModes contains the desired access modes the volume should have.
         * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
         * +optional
         */
        accessModes?: string[];
        selector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
        resources?: Schemas.k8s$io$api$core$v1$ResourceRequirements;
        /**
         * VolumeName is the binding reference to the PersistentVolume backing this claim.
         * +optional
         */
        volumeName?: string;
        /**
         * Name of the StorageClass required by the claim.
         * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
         * +optional
         */
        storageClassName?: string;
        /**
         * volumeMode defines what type of volume is required by the claim.
         * Value of Filesystem is implied when not included in claim spec.
         * +optional
         */
        volumeMode?: string;
        dataSource?: Schemas.k8s$io$api$core$v1$TypedLocalObjectReference;
    }
    /**
     * PersistentVolumeClaimTemplate is used to produce
     * PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
     */
    export interface k8s$io$api$core$v1$PersistentVolumeClaimTemplate {
        metadata?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        spec?: Schemas.k8s$io$api$core$v1$PersistentVolumeClaimSpec;
    }
    /**
     * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
     * This volume finds the bound PV and mounts that volume for the pod. A
     * PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
     * type of volume that is owned by someone else (the system).
     */
    export interface k8s$io$api$core$v1$PersistentVolumeClaimVolumeSource {
        /**
         * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
         * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
         */
        claimName?: string;
        /**
         * Will force the ReadOnly setting in VolumeMounts.
         * Default false.
         * +optional
         */
        readOnly?: boolean;
    }
    /** Represents a Photon Controller persistent disk resource. */
    export interface k8s$io$api$core$v1$PhotonPersistentDiskVolumeSource {
        /** ID that identifies Photon Controller persistent disk */
        pdID?: string;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         */
        fsType?: string;
    }
    /** Pod affinity is a group of inter pod affinity scheduling rules. */
    export interface k8s$io$api$core$v1$PodAffinity {
        /**
         * If the affinity requirements specified by this field are not met at
         * scheduling time, the pod will not be scheduled onto the node.
         * If the affinity requirements specified by this field cease to be met
         * at some point during pod execution (e.g. due to a pod label update), the
         * system may or may not try to eventually evict the pod from its node.
         * When there are multiple elements, the lists of nodes corresponding to each
         * podAffinityTerm are intersected, i.e. all terms must be satisfied.
         * +optional
         */
        requiredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$PodAffinityTerm[];
        /**
         * The scheduler will prefer to schedule pods to nodes that satisfy
         * the affinity expressions specified by this field, but it may choose
         * a node that violates one or more of the expressions. The node that is
         * most preferred is the one with the greatest sum of weights, i.e.
         * for each node that meets all of the scheduling requirements (resource
         * request, requiredDuringScheduling affinity expressions, etc.),
         * compute a sum by iterating through the elements of this field and adding
         * \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
         * node(s) with the highest sum are the most preferred.
         * +optional
         */
        preferredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$WeightedPodAffinityTerm[];
    }
    export interface k8s$io$api$core$v1$PodAffinityTerm {
        labelSelector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
        /**
         * namespaces specifies which namespaces the labelSelector applies to (matches against);
         * null or empty list means \\"this pod's namespace\\"
         * +optional
         */
        namespaces?: string[];
        /**
         * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
         * the labelSelector in the specified namespaces, where co-located is defined as running on a node
         * whose value of the label with key topologyKey matches that of any node on which any of the
         * selected pods is running.
         * Empty topologyKey is not allowed.
         */
        topologyKey?: string;
    }
    /** Pod anti affinity is a group of inter pod anti affinity scheduling rules. */
    export interface k8s$io$api$core$v1$PodAntiAffinity {
        /**
         * If the anti-affinity requirements specified by this field are not met at
         * scheduling time, the pod will not be scheduled onto the node.
         * If the anti-affinity requirements specified by this field cease to be met
         * at some point during pod execution (e.g. due to a pod label update), the
         * system may or may not try to eventually evict the pod from its node.
         * When there are multiple elements, the lists of nodes corresponding to each
         * podAffinityTerm are intersected, i.e. all terms must be satisfied.
         * +optional
         */
        requiredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$PodAffinityTerm[];
        /**
         * The scheduler will prefer to schedule pods to nodes that satisfy
         * the anti-affinity expressions specified by this field, but it may choose
         * a node that violates one or more of the expressions. The node that is
         * most preferred is the one with the greatest sum of weights, i.e.
         * for each node that meets all of the scheduling requirements (resource
         * request, requiredDuringScheduling anti-affinity expressions, etc.),
         * compute a sum by iterating through the elements of this field and adding
         * \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
         * node(s) with the highest sum are the most preferred.
         * +optional
         */
        preferredDuringSchedulingIgnoredDuringExecution?: Schemas.k8s$io$api$core$v1$WeightedPodAffinityTerm[];
    }
    /**
     * PodDNSConfig defines the DNS parameters of a pod in addition to
     * those generated from DNSPolicy.
     */
    export interface k8s$io$api$core$v1$PodDNSConfig {
        /**
         * A list of DNS name server IP addresses.
         * This will be appended to the base nameservers generated from DNSPolicy.
         * Duplicated nameservers will be removed.
         * +optional
         */
        nameservers?: string[];
        /**
         * A list of DNS search domains for host-name lookup.
         * This will be appended to the base search paths generated from DNSPolicy.
         * Duplicated search paths will be removed.
         * +optional
         */
        searches?: string[];
        /**
         * A list of DNS resolver options.
         * This will be merged with the base options generated from DNSPolicy.
         * Duplicated entries will be removed. Resolution options given in Options
         * will override those that appear in the base DNSPolicy.
         * +optional
         */
        options?: Schemas.k8s$io$api$core$v1$PodDNSConfigOption[];
    }
    /** PodDNSConfigOption defines DNS resolver options of a pod. */
    export interface k8s$io$api$core$v1$PodDNSConfigOption {
        /** Required. */
        name?: string;
        /** +optional */
        value?: string;
    }
    export interface k8s$io$api$core$v1$PodReadinessGate {
        /** ConditionType refers to a condition in the pod's condition list with matching type. */
        conditionType?: string;
    }
    /**
     * PodSecurityContext holds pod-level security attributes and common container settings.
     * Some fields are also present in container.securityContext.  Field values of
     * container.securityContext take precedence over field values of PodSecurityContext.
     */
    export interface k8s$io$api$core$v1$PodSecurityContext {
        seLinuxOptions?: Schemas.k8s$io$api$core$v1$SELinuxOptions;
        windowsOptions?: Schemas.k8s$io$api$core$v1$WindowsSecurityContextOptions;
        /**
         * The UID to run the entrypoint of the container process.
         * Defaults to user specified in image metadata if unspecified.
         * May also be set in SecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence
         * for that container.
         * +optional
         */
        runAsUser?: string;
        /**
         * The GID to run the entrypoint of the container process.
         * Uses runtime default if unset.
         * May also be set in SecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence
         * for that container.
         * +optional
         */
        runAsGroup?: string;
        /**
         * Indicates that the container must run as a non-root user.
         * If true, the Kubelet will validate the image at runtime to ensure that it
         * does not run as UID 0 (root) and fail to start the container if it does.
         * If unset or false, no such validation will be performed.
         * May also be set in SecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * +optional
         */
        runAsNonRoot?: boolean;
        /**
         * A list of groups applied to the first process run in each container, in addition
         * to the container's primary GID.  If unspecified, no groups will be added to
         * any container.
         * +optional
         */
        supplementalGroups?: string[];
        /**
         * A special supplemental group that applies to all containers in a pod.
         * Some volume types allow the Kubelet to change the ownership of that volume
         * to be owned by the pod:
         *
         * 1. The owning GID will be the FSGroup
         * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
         * 3. The permission bits are OR'd with rw-rw----
         *
         * If unset, the Kubelet will not modify the ownership and permissions of any volume.
         * +optional
         */
        fsGroup?: string;
        /**
         * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
         * sysctls (by the container runtime) might fail to launch.
         * +optional
         */
        sysctls?: Schemas.k8s$io$api$core$v1$Sysctl[];
        /**
         * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
         * before being exposed inside Pod. This field will only apply to
         * volume types which support fsGroup based ownership(and permissions).
         * It will have no effect on ephemeral volume types such as: secret, configmaps
         * and emptydir.
         * Valid values are \\"OnRootMismatch\\" and \\"Always\\". If not specified, \\"Always\\" is used.
         * +optional
         */
        fsGroupChangePolicy?: string;
        seccompProfile?: Schemas.k8s$io$api$core$v1$SeccompProfile;
    }
    /** PodSpec is a description of a pod. */
    export interface k8s$io$api$core$v1$PodSpec {
        /**
         * List of volumes that can be mounted by containers belonging to the pod.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes
         * +optional
         * +patchMergeKey=name
         * +patchStrategy=merge,retainKeys
         */
        volumes?: Schemas.k8s$io$api$core$v1$Volume[];
        /**
         * List of initialization containers belonging to the pod.
         * Init containers are executed in order prior to containers being started. If any
         * init container fails, the pod is considered to have failed and is handled according
         * to its restartPolicy. The name for an init container or normal container must be
         * unique among all containers.
         * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
         * The resourceRequirements of an init container are taken into account during scheduling
         * by finding the highest request/limit for each resource type, and then using the max of
         * of that value or the sum of the normal containers. Limits are applied to init containers
         * in a similar fashion.
         * Init containers cannot currently be added or removed.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        initContainers?: Schemas.k8s$io$api$core$v1$Container[];
        /**
         * List of containers belonging to the pod.
         * Containers cannot currently be added or removed.
         * There must be at least one container in a Pod.
         * Cannot be updated.
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        containers?: Schemas.k8s$io$api$core$v1$Container[];
        /**
         * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
         * pod to perform user-initiated actions such as debugging. This list cannot be specified when
         * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
         * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
         * This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.
         * +optional
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        ephemeralContainers?: Schemas.k8s$io$api$core$v1$EphemeralContainer[];
        /**
         * Restart policy for all containers within the pod.
         * One of Always, OnFailure, Never.
         * Default to Always.
         * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
         * +optional
         */
        restartPolicy?: string;
        /**
         * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
         * Value must be non-negative integer. The value zero indicates delete immediately.
         * If this value is nil, the default grace period will be used instead.
         * The grace period is the duration in seconds after the processes running in the pod are sent
         * a termination signal and the time when the processes are forcibly halted with a kill signal.
         * Set this value longer than the expected cleanup time for your process.
         * Defaults to 30 seconds.
         * +optional
         */
        terminationGracePeriodSeconds?: string;
        /**
         * Optional duration in seconds the pod may be active on the node relative to
         * StartTime before the system will actively try to mark it failed and kill associated containers.
         * Value must be a positive integer.
         * +optional
         */
        activeDeadlineSeconds?: string;
        /**
         * Set DNS policy for the pod.
         * Defaults to \\"ClusterFirst\\".
         * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
         * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
         * To have DNS options set along with hostNetwork, you have to specify DNS policy
         * explicitly to 'ClusterFirstWithHostNet'.
         * +optional
         */
        dnsPolicy?: string;
        /**
         * NodeSelector is a selector which must be true for the pod to fit on a node.
         * Selector which must match a node's labels for the pod to be scheduled on that node.
         * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
         * +optional
         */
        nodeSelector?: {
            [key: string]: string;
        };
        /**
         * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
         * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
         * +optional
         */
        serviceAccountName?: string;
        /**
         * DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
         * Deprecated: Use serviceAccountName instead.
         * +k8s:conversion-gen=false
         * +optional
         */
        serviceAccount?: string;
        /**
         * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
         * +optional
         */
        automountServiceAccountToken?: boolean;
        /**
         * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
         * the scheduler simply schedules this pod onto that node, assuming that it fits resource
         * requirements.
         * +optional
         */
        nodeName?: string;
        /**
         * Host networking requested for this pod. Use the host's network namespace.
         * If this option is set, the ports that will be used must be specified.
         * Default to false.
         * +k8s:conversion-gen=false
         * +optional
         */
        hostNetwork?: boolean;
        /**
         * Use the host's pid namespace.
         * Optional: Default to false.
         * +k8s:conversion-gen=false
         * +optional
         */
        hostPID?: boolean;
        /**
         * Use the host's ipc namespace.
         * Optional: Default to false.
         * +k8s:conversion-gen=false
         * +optional
         */
        hostIPC?: boolean;
        /**
         * Share a single process namespace between all of the containers in a pod.
         * When this is set containers will be able to view and signal processes from other containers
         * in the same pod, and the first process in each container will not be assigned PID 1.
         * HostPID and ShareProcessNamespace cannot both be set.
         * Optional: Default to false.
         * +k8s:conversion-gen=false
         * +optional
         */
        shareProcessNamespace?: boolean;
        securityContext?: Schemas.k8s$io$api$core$v1$PodSecurityContext;
        /**
         * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
         * If specified, these secrets will be passed to individual puller implementations for them to use. For example,
         * in the case of docker, only DockerConfig type secrets are honored.
         * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
         * +optional
         * +patchMergeKey=name
         * +patchStrategy=merge
         */
        imagePullSecrets?: Schemas.k8s$io$api$core$v1$LocalObjectReference[];
        /**
         * Specifies the hostname of the Pod
         * If not specified, the pod's hostname will be set to a system-defined value.
         * +optional
         */
        hostname?: string;
        /**
         * If specified, the fully qualified Pod hostname will be \\"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\\".
         * If not specified, the pod will not have a domainname at all.
         * +optional
         */
        subdomain?: string;
        affinity?: Schemas.k8s$io$api$core$v1$Affinity;
        /**
         * If specified, the pod will be dispatched by specified scheduler.
         * If not specified, the pod will be dispatched by default scheduler.
         * +optional
         */
        schedulerName?: string;
        /**
         * If specified, the pod's tolerations.
         * +optional
         */
        tolerations?: Schemas.k8s$io$api$core$v1$Toleration[];
        /**
         * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
         * file if specified. This is only valid for non-hostNetwork pods.
         * +optional
         * +patchMergeKey=ip
         * +patchStrategy=merge
         */
        hostAliases?: Schemas.k8s$io$api$core$v1$HostAlias[];
        /**
         * If specified, indicates the pod's priority. \\"system-node-critical\\" and
         * \\"system-cluster-critical\\" are two special keywords which indicate the
         * highest priorities with the former being the highest priority. Any other
         * name must be defined by creating a PriorityClass object with that name.
         * If not specified, the pod priority will be default or zero if there is no
         * default.
         * +optional
         */
        priorityClassName?: string;
        /**
         * The priority value. Various system components use this field to find the
         * priority of the pod. When Priority Admission Controller is enabled, it
         * prevents users from setting this field. The admission controller populates
         * this field from PriorityClassName.
         * The higher the value, the higher the priority.
         * +optional
         */
        priority?: number;
        dnsConfig?: Schemas.k8s$io$api$core$v1$PodDNSConfig;
        /**
         * If specified, all readiness gates will be evaluated for pod readiness.
         * A pod is ready when all its containers are ready AND
         * all conditions specified in the readiness gates have status equal to \\"True\\"
         * More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
         * +optional
         */
        readinessGates?: Schemas.k8s$io$api$core$v1$PodReadinessGate[];
        /**
         * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
         * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
         * If unset or empty, the \\"legacy\\" RuntimeClass will be used, which is an implicit class with an
         * empty definition that uses the default runtime handler.
         * More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
         * This is a beta feature as of Kubernetes v1.14.
         * +optional
         */
        runtimeClassName?: string;
        /**
         * EnableServiceLinks indicates whether information about services should be injected into pod's
         * environment variables, matching the syntax of Docker links.
         * Optional: Defaults to true.
         * +optional
         */
        enableServiceLinks?: boolean;
        /**
         * PreemptionPolicy is the Policy for preempting pods with lower priority.
         * One of Never, PreemptLowerPriority.
         * Defaults to PreemptLowerPriority if unset.
         * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
         * +optional
         */
        preemptionPolicy?: string;
        /**
         * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
         * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
         * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
         * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
         * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
         * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
         * More info: https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md
         * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the PodOverhead feature.
         * +optional
         */
        overhead?: {
            [key: string]: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
        };
        /**
         * TopologySpreadConstraints describes how a group of pods ought to spread across topology
         * domains. Scheduler will schedule pods in a way which abides by the constraints.
         * All topologySpreadConstraints are ANDed.
         * +optional
         * +patchMergeKey=topologyKey
         * +patchStrategy=merge
         * +listType=map
         * +listMapKey=topologyKey
         * +listMapKey=whenUnsatisfiable
         */
        topologySpreadConstraints?: Schemas.k8s$io$api$core$v1$TopologySpreadConstraint[];
        /**
         * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
         * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
         * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\\\\\SYSTEM\\\\\\\\CurrentControlSet\\\\\\\\Services\\\\\\\\Tcpip\\\\\\\\Parameters to FQDN.
         * If a pod does not have FQDN, this has no effect.
         * Default to false.
         * +optional
         */
        setHostnameAsFQDN?: boolean;
    }
    export interface k8s$io$api$core$v1$PodTemplateSpec {
        metadata?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        spec?: Schemas.k8s$io$api$core$v1$PodSpec;
    }
    /** PortworxVolumeSource represents a Portworx volume resource. */
    export interface k8s$io$api$core$v1$PortworxVolumeSource {
        /** VolumeID uniquely identifies a Portworx volume */
        volumeID?: string;
        /**
         * FSType represents the filesystem type to mount
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         */
        fsType?: string;
        /**
         * Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * +optional
         */
        readOnly?: boolean;
    }
    /**
     * An empty preferred scheduling term matches all objects with implicit weight 0
     * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
     */
    export interface k8s$io$api$core$v1$PreferredSchedulingTerm {
        /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
        weight?: number;
        preference?: Schemas.k8s$io$api$core$v1$NodeSelectorTerm;
    }
    /**
     * Probe describes a health check to be performed against a container to determine whether it is
     * alive or ready to receive traffic.
     */
    export interface k8s$io$api$core$v1$Probe {
        handler?: Schemas.k8s$io$api$core$v1$Handler;
        /**
         * Number of seconds after the container has started before liveness probes are initiated.
         * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         * +optional
         */
        initialDelaySeconds?: number;
        /**
         * Number of seconds after which the probe times out.
         * Defaults to 1 second. Minimum value is 1.
         * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         * +optional
         */
        timeoutSeconds?: number;
        /**
         * How often (in seconds) to perform the probe.
         * Default to 10 seconds. Minimum value is 1.
         * +optional
         */
        periodSeconds?: number;
        /**
         * Minimum consecutive successes for the probe to be considered successful after having failed.
         * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
         * +optional
         */
        successThreshold?: number;
        /**
         * Minimum consecutive failures for the probe to be considered failed after having succeeded.
         * Defaults to 3. Minimum value is 1.
         * +optional
         */
        failureThreshold?: number;
    }
    export interface k8s$io$api$core$v1$ProjectedVolumeSource {
        /**
         * list of volume projections
         * +optional
         */
        sources?: Schemas.k8s$io$api$core$v1$VolumeProjection[];
        /**
         * Mode bits used to set permissions on created files by default.
         * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
         * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
         * Directories within the path are not affected by this setting.
         * This might be in conflict with other options that affect the file
         * mode, like fsGroup, and the result can be other mode bits set.
         * +optional
         */
        defaultMode?: number;
    }
    /**
     * Represents a Quobyte mount that lasts the lifetime of a pod.
     * Quobyte volumes do not support ownership management or SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$QuobyteVolumeSource {
        /**
         * Registry represents a single or multiple Quobyte Registry services
         * specified as a string as host:port pair (multiple entries are separated with commas)
         * which acts as the central registry for volumes
         */
        registry?: string;
        /** Volume is a string that references an already created Quobyte volume by name. */
        volume?: string;
        /**
         * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
         * Defaults to false.
         * +optional
         */
        readOnly?: boolean;
        /**
         * User to map volume access to
         * Defaults to serivceaccount user
         * +optional
         */
        user?: string;
        /**
         * Group to map volume access to
         * Default is no group
         * +optional
         */
        group?: string;
        /**
         * Tenant owning the given Quobyte volume in the Backend
         * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
         * +optional
         */
        tenant?: string;
    }
    /**
     * Represents a Rados Block Device mount that lasts the lifetime of a pod.
     * RBD volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$RBDVolumeSource {
        /**
         * A collection of Ceph monitors.
         * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
         */
        monitors?: string[];
        /**
         * The rados image name.
         * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
         */
        image?: string;
        /**
         * Filesystem type of the volume that you want to mount.
         * Tip: Ensure that the filesystem type is supported by the host operating system.
         * Examples: \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
         * TODO: how do we prevent errors in the filesystem from compromising the machine
         * +optional
         */
        fsType?: string;
        /**
         * The rados pool name.
         * Default is rbd.
         * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
         * +optional
         */
        pool?: string;
        /**
         * The rados user name.
         * Default is admin.
         * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
         * +optional
         */
        user?: string;
        /**
         * Keyring is the path to key ring for RBDUser.
         * Default is /etc/ceph/keyring.
         * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
         * +optional
         */
        keyring?: string;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * ReadOnly here will force the ReadOnly setting in VolumeMounts.
         * Defaults to false.
         * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
         * +optional
         */
        readOnly?: boolean;
    }
    export interface k8s$io$api$core$v1$ResourceFieldSelector {
        /**
         * Container name: required for volumes, optional for env vars
         * +optional
         */
        containerName?: string;
        /** Required: resource to select */
        resource?: string;
        divisor?: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
    }
    /** ResourceRequirements describes the compute resource requirements. */
    export interface k8s$io$api$core$v1$ResourceRequirements {
        /**
         * Limits describes the maximum amount of compute resources allowed.
         * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
         * +optional
         */
        limits?: {
            [key: string]: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
        };
        /**
         * Requests describes the minimum amount of compute resources required.
         * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
         * otherwise to an implementation-defined value.
         * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
         * +optional
         */
        requests?: {
            [key: string]: Schemas.k8s$io$apimachinery$pkg$api$resource$Quantity;
        };
    }
    export interface k8s$io$api$core$v1$SELinuxOptions {
        /**
         * User is a SELinux user label that applies to the container.
         * +optional
         */
        user?: string;
        /**
         * Role is a SELinux role label that applies to the container.
         * +optional
         */
        role?: string;
        /**
         * Type is a SELinux type label that applies to the container.
         * +optional
         */
        type?: string;
        /**
         * Level is SELinux level label that applies to the container.
         * +optional
         */
        level?: string;
    }
    export interface k8s$io$api$core$v1$ScaleIOVolumeSource {
        /** The host address of the ScaleIO API Gateway. */
        gateway?: string;
        /** The name of the storage system as configured in ScaleIO. */
        system?: string;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * Flag to enable/disable SSL communication with Gateway, default false
         * +optional
         */
        sslEnabled?: boolean;
        /**
         * The name of the ScaleIO Protection Domain for the configured storage.
         * +optional
         */
        protectionDomain?: string;
        /**
         * The ScaleIO Storage Pool associated with the protection domain.
         * +optional
         */
        storagePool?: string;
        /**
         * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
         * Default is ThinProvisioned.
         * +optional
         */
        storageMode?: string;
        /**
         * The name of a volume already created in the ScaleIO system
         * that is associated with this volume source.
         */
        volumeName?: string;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\".
         * Default is \\"xfs\\".
         * +optional
         */
        fsType?: string;
        /**
         * Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * +optional
         */
        readOnly?: boolean;
    }
    export interface k8s$io$api$core$v1$SeccompProfile {
        /**
         * type indicates which kind of seccomp profile will be applied.
         * Valid options are:
         *
         * Localhost - a profile defined in a file on the node should be used.
         * RuntimeDefault - the container runtime default profile should be used.
         * Unconfined - no profile should be applied.
         * +unionDiscriminator
         */
        type?: string;
        /**
         * localhostProfile indicates a profile defined in a file on the node should be used.
         * The profile must be preconfigured on the node to work.
         * Must be a descending path, relative to the kubelet's configured seccomp profile location.
         * Must only be set if type is \\"Localhost\\".
         * +optional
         */
        localhostProfile?: string;
    }
    /**
     * SecretEnvSource selects a Secret to populate the environment
     * variables with.
     *
     * The contents of the target Secret's Data field will represent the
     * key-value pairs as environment variables.
     */
    export interface k8s$io$api$core$v1$SecretEnvSource {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * Specify whether the Secret must be defined
         * +optional
         */
        optional?: boolean;
    }
    /** SecretKeySelector selects a key of a Secret. */
    export interface k8s$io$api$core$v1$SecretKeySelector {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /** The key of the secret to select from.  Must be a valid secret key. */
        key?: string;
        /**
         * Specify whether the Secret or its key must be defined
         * +optional
         */
        optional?: boolean;
    }
    /**
     * Adapts a secret into a projected volume.
     *
     * The contents of the target Secret's Data field will be presented in a
     * projected volume as files using the keys in the Data field as the file names.
     * Note that this is identical to a secret volume source without the default
     * mode.
     */
    export interface k8s$io$api$core$v1$SecretProjection {
        localObjectReference?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
        /**
         * If unspecified, each key-value pair in the Data field of the referenced
         * Secret will be projected into the volume as a file whose name is the
         * key and content is the value. If specified, the listed keys will be
         * projected into the specified paths, and unlisted keys will not be
         * present. If a key is specified which is not present in the Secret,
         * the volume setup will error unless it is marked optional. Paths must be
         * relative and may not contain the '..' path or start with '..'.
         * +optional
         */
        items?: Schemas.k8s$io$api$core$v1$KeyToPath[];
        /**
         * Specify whether the Secret or its key must be defined
         * +optional
         */
        optional?: boolean;
    }
    /**
     * Adapts a Secret into a volume.
     *
     * The contents of the target Secret's Data field will be presented in a volume
     * as files using the keys in the Data field as the file names.
     * Secret volumes support ownership management and SELinux relabeling.
     */
    export interface k8s$io$api$core$v1$SecretVolumeSource {
        /**
         * Name of the secret in the pod's namespace to use.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
         * +optional
         */
        secretName?: string;
        /**
         * If unspecified, each key-value pair in the Data field of the referenced
         * Secret will be projected into the volume as a file whose name is the
         * key and content is the value. If specified, the listed keys will be
         * projected into the specified paths, and unlisted keys will not be
         * present. If a key is specified which is not present in the Secret,
         * the volume setup will error unless it is marked optional. Paths must be
         * relative and may not contain the '..' path or start with '..'.
         * +optional
         */
        items?: Schemas.k8s$io$api$core$v1$KeyToPath[];
        /**
         * Optional: mode bits used to set permissions on created files by default.
         * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
         * YAML accepts both octal and decimal values, JSON requires decimal values
         * for mode bits. Defaults to 0644.
         * Directories within the path are not affected by this setting.
         * This might be in conflict with other options that affect the file
         * mode, like fsGroup, and the result can be other mode bits set.
         * +optional
         */
        defaultMode?: number;
        /**
         * Specify whether the Secret or its keys must be defined
         * +optional
         */
        optional?: boolean;
    }
    /**
     * SecurityContext holds security configuration that will be applied to a container.
     * Some fields are present in both SecurityContext and PodSecurityContext.  When both
     * are set, the values in SecurityContext take precedence.
     */
    export interface k8s$io$api$core$v1$SecurityContext {
        capabilities?: Schemas.k8s$io$api$core$v1$Capabilities;
        /**
         * Run container in privileged mode.
         * Processes in privileged containers are essentially equivalent to root on the host.
         * Defaults to false.
         * +optional
         */
        privileged?: boolean;
        seLinuxOptions?: Schemas.k8s$io$api$core$v1$SELinuxOptions;
        windowsOptions?: Schemas.k8s$io$api$core$v1$WindowsSecurityContextOptions;
        /**
         * The UID to run the entrypoint of the container process.
         * Defaults to user specified in image metadata if unspecified.
         * May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * +optional
         */
        runAsUser?: string;
        /**
         * The GID to run the entrypoint of the container process.
         * Uses runtime default if unset.
         * May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * +optional
         */
        runAsGroup?: string;
        /**
         * Indicates that the container must run as a non-root user.
         * If true, the Kubelet will validate the image at runtime to ensure that it
         * does not run as UID 0 (root) and fail to start the container if it does.
         * If unset or false, no such validation will be performed.
         * May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * +optional
         */
        runAsNonRoot?: boolean;
        /**
         * Whether this container has a read-only root filesystem.
         * Default is false.
         * +optional
         */
        readOnlyRootFilesystem?: boolean;
        /**
         * AllowPrivilegeEscalation controls whether a process can gain more
         * privileges than its parent process. This bool directly controls if
         * the no_new_privs flag will be set on the container process.
         * AllowPrivilegeEscalation is true always when the container is:
         * 1) run as Privileged
         * 2) has CAP_SYS_ADMIN
         * +optional
         */
        allowPrivilegeEscalation?: boolean;
        /**
         * procMount denotes the type of proc mount to use for the containers.
         * The default is DefaultProcMount which uses the container runtime defaults for
         * readonly paths and masked paths.
         * This requires the ProcMountType feature flag to be enabled.
         * +optional
         */
        procMount?: string;
        seccompProfile?: Schemas.k8s$io$api$core$v1$SeccompProfile;
    }
    /**
     * ServiceAccountTokenProjection represents a projected service account token
     * volume. This projection can be used to insert a service account token into
     * the pods runtime filesystem for use against APIs (Kubernetes API Server or
     * otherwise).
     */
    export interface k8s$io$api$core$v1$ServiceAccountTokenProjection {
        /**
         * Audience is the intended audience of the token. A recipient of a token
         * must identify itself with an identifier specified in the audience of the
         * token, and otherwise should reject the token. The audience defaults to the
         * identifier of the apiserver.
         * +optional
         */
        audience?: string;
        /**
         * ExpirationSeconds is the requested duration of validity of the service
         * account token. As the token approaches expiration, the kubelet volume
         * plugin will proactively rotate the service account token. The kubelet will
         * start trying to rotate the token if the token is older than 80 percent of
         * its time to live or if the token is older than 24 hours.Defaults to 1 hour
         * and must be at least 10 minutes.
         * +optional
         */
        expirationSeconds?: string;
        /**
         * Path is the path relative to the mount point of the file to project the
         * token into.
         */
        path?: string;
    }
    /** Represents a StorageOS persistent volume resource. */
    export interface k8s$io$api$core$v1$StorageOSVolumeSource {
        /**
         * VolumeName is the human-readable name of the StorageOS volume.  Volume
         * names are only unique within a namespace.
         */
        volumeName?: string;
        /**
         * VolumeNamespace specifies the scope of the volume within StorageOS.  If no
         * namespace is specified then the Pod's namespace will be used.  This allows the
         * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
         * Set VolumeName to any name to override the default behaviour.
         * Set to \\"default\\" if you are not using namespaces within StorageOS.
         * Namespaces that do not pre-exist within StorageOS will be created.
         * +optional
         */
        volumeNamespace?: string;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * +optional
         */
        fsType?: string;
        /**
         * Defaults to false (read/write). ReadOnly here will force
         * the ReadOnly setting in VolumeMounts.
         * +optional
         */
        readOnly?: boolean;
        secretRef?: Schemas.k8s$io$api$core$v1$LocalObjectReference;
    }
    export interface k8s$io$api$core$v1$Sysctl {
        /** Name of a property to set */
        name?: string;
        /** Value of a property to set */
        value?: string;
    }
    export interface k8s$io$api$core$v1$TCPSocketAction {
        port?: Schemas.k8s$io$apimachinery$pkg$util$intstr$IntOrString;
        /**
         * Optional: Host name to connect to, defaults to the pod IP.
         * +optional
         */
        host?: string;
    }
    /**
     * The pod this Toleration is attached to tolerates any taint that matches
     * the triple <key,value,effect> using the matching operator <operator>.
     */
    export interface k8s$io$api$core$v1$Toleration {
        /**
         * Key is the taint key that the toleration applies to. Empty means match all taint keys.
         * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
         * +optional
         */
        key?: string;
        /**
         * Operator represents a key's relationship to the value.
         * Valid operators are Exists and Equal. Defaults to Equal.
         * Exists is equivalent to wildcard for value, so that a pod can
         * tolerate all taints of a particular category.
         * +optional
         */
        operator?: string;
        /**
         * Value is the taint value the toleration matches to.
         * If the operator is Exists, the value should be empty, otherwise just a regular string.
         * +optional
         */
        value?: string;
        /**
         * Effect indicates the taint effect to match. Empty means match all taint effects.
         * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
         * +optional
         */
        effect?: string;
        /**
         * TolerationSeconds represents the period of time the toleration (which must be
         * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
         * it is not set, which means tolerate the taint forever (do not evict). Zero and
         * negative values will be treated as 0 (evict immediately) by the system.
         * +optional
         */
        tolerationSeconds?: string;
    }
    /** TopologySpreadConstraint specifies how to spread matching pods among the given topology. */
    export interface k8s$io$api$core$v1$TopologySpreadConstraint {
        /**
         * MaxSkew describes the degree to which pods may be unevenly distributed.
         * When \`whenUnsatisfiable=DoNotSchedule\`, it is the maximum permitted difference
         * between the number of matching pods in the target topology and the global minimum.
         * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
         * labelSelector spread as 1/1/0:
         * +-------+-------+-------+
         * | zone1 | zone2 | zone3 |
         * +-------+-------+-------+
         * |   P   |   P   |       |
         * +-------+-------+-------+
         * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
         * scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
         * violate MaxSkew(1).
         * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
         * When \`whenUnsatisfiable=ScheduleAnyway\`, it is used to give higher precedence
         * to topologies that satisfy it.
         * It's a required field. Default value is 1 and 0 is not allowed.
         */
        maxSkew?: number;
        /**
         * TopologyKey is the key of node labels. Nodes that have a label with this key
         * and identical values are considered to be in the same topology.
         * We consider each <key, value> as a \\"bucket\\", and try to put balanced number
         * of pods into each bucket.
         * It's a required field.
         */
        topologyKey?: string;
        /**
         * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
         * the spread constraint.
         * - DoNotSchedule (default) tells the scheduler not to schedule it.
         * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
         *   but giving higher precedence to topologies that would help reduce the
         *   skew.
         * A constraint is considered \\"Unsatisfiable\\" for an incoming pod
         * if and only if every possible node assigment for that pod would violate
         * \\"MaxSkew\\" on some topology.
         * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
         * labelSelector spread as 3/1/1:
         * +-------+-------+-------+
         * | zone1 | zone2 | zone3 |
         * +-------+-------+-------+
         * | P P P |   P   |   P   |
         * +-------+-------+-------+
         * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
         * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
         * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
         * won't make it *more* imbalanced.
         * It's a required field.
         */
        whenUnsatisfiable?: string;
        labelSelector?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector;
    }
    /**
     * TypedLocalObjectReference contains enough information to let you locate the
     * typed referenced object inside the same namespace.
     */
    export interface k8s$io$api$core$v1$TypedLocalObjectReference {
        /**
         * APIGroup is the group for the resource being referenced.
         * If APIGroup is not specified, the specified Kind must be in the core API group.
         * For any other third-party types, APIGroup is required.
         * +optional
         */
        apiGroup?: string;
        /** Kind is the type of resource being referenced */
        kind?: string;
        /** Name is the name of resource being referenced */
        name?: string;
    }
    /** Volume represents a named volume in a pod that may be accessed by any container in the pod. */
    export interface k8s$io$api$core$v1$Volume {
        /**
         * Volume's name.
         * Must be a DNS_LABEL and unique within the pod.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
         */
        name?: string;
        volumeSource?: Schemas.k8s$io$api$core$v1$VolumeSource;
    }
    /** volumeDevice describes a mapping of a raw block device within a container. */
    export interface k8s$io$api$core$v1$VolumeDevice {
        /** name must match the name of a persistentVolumeClaim in the pod */
        name?: string;
        /** devicePath is the path inside of the container that the device will be mapped to. */
        devicePath?: string;
    }
    /** VolumeMount describes a mounting of a Volume within a container. */
    export interface k8s$io$api$core$v1$VolumeMount {
        /** This must match the Name of a Volume. */
        name?: string;
        /**
         * Mounted read-only if true, read-write otherwise (false or unspecified).
         * Defaults to false.
         * +optional
         */
        readOnly?: boolean;
        /**
         * Path within the container at which the volume should be mounted.  Must
         * not contain ':'.
         */
        mountPath?: string;
        /**
         * Path within the volume from which the container's volume should be mounted.
         * Defaults to \\"\\" (volume's root).
         * +optional
         */
        subPath?: string;
        /**
         * mountPropagation determines how mounts are propagated from the host
         * to container and the other way around.
         * When not set, MountPropagationNone is used.
         * This field is beta in 1.10.
         * +optional
         */
        mountPropagation?: string;
        /**
         * Expanded path within the volume from which the container's volume should be mounted.
         * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
         * Defaults to \\"\\" (volume's root).
         * SubPathExpr and SubPath are mutually exclusive.
         * +optional
         */
        subPathExpr?: string;
    }
    export interface k8s$io$api$core$v1$VolumeProjection {
        secret?: Schemas.k8s$io$api$core$v1$SecretProjection;
        downwardAPI?: Schemas.k8s$io$api$core$v1$DownwardAPIProjection;
        configMap?: Schemas.k8s$io$api$core$v1$ConfigMapProjection;
        serviceAccountToken?: Schemas.k8s$io$api$core$v1$ServiceAccountTokenProjection;
    }
    /**
     * Represents the source of a volume to mount.
     * Only one of its members may be specified.
     */
    export interface k8s$io$api$core$v1$VolumeSource {
        hostPath?: Schemas.k8s$io$api$core$v1$HostPathVolumeSource;
        emptyDir?: Schemas.k8s$io$api$core$v1$EmptyDirVolumeSource;
        gcePersistentDisk?: Schemas.k8s$io$api$core$v1$GCEPersistentDiskVolumeSource;
        awsElasticBlockStore?: Schemas.k8s$io$api$core$v1$AWSElasticBlockStoreVolumeSource;
        gitRepo?: Schemas.k8s$io$api$core$v1$GitRepoVolumeSource;
        secret?: Schemas.k8s$io$api$core$v1$SecretVolumeSource;
        nfs?: Schemas.k8s$io$api$core$v1$NFSVolumeSource;
        iscsi?: Schemas.k8s$io$api$core$v1$ISCSIVolumeSource;
        glusterfs?: Schemas.k8s$io$api$core$v1$GlusterfsVolumeSource;
        persistentVolumeClaim?: Schemas.k8s$io$api$core$v1$PersistentVolumeClaimVolumeSource;
        rbd?: Schemas.k8s$io$api$core$v1$RBDVolumeSource;
        flexVolume?: Schemas.k8s$io$api$core$v1$FlexVolumeSource;
        cinder?: Schemas.k8s$io$api$core$v1$CinderVolumeSource;
        cephfs?: Schemas.k8s$io$api$core$v1$CephFSVolumeSource;
        flocker?: Schemas.k8s$io$api$core$v1$FlockerVolumeSource;
        downwardAPI?: Schemas.k8s$io$api$core$v1$DownwardAPIVolumeSource;
        fc?: Schemas.k8s$io$api$core$v1$FCVolumeSource;
        azureFile?: Schemas.k8s$io$api$core$v1$AzureFileVolumeSource;
        configMap?: Schemas.k8s$io$api$core$v1$ConfigMapVolumeSource;
        vsphereVolume?: Schemas.k8s$io$api$core$v1$VsphereVirtualDiskVolumeSource;
        quobyte?: Schemas.k8s$io$api$core$v1$QuobyteVolumeSource;
        azureDisk?: Schemas.k8s$io$api$core$v1$AzureDiskVolumeSource;
        photonPersistentDisk?: Schemas.k8s$io$api$core$v1$PhotonPersistentDiskVolumeSource;
        projected?: Schemas.k8s$io$api$core$v1$ProjectedVolumeSource;
        portworxVolume?: Schemas.k8s$io$api$core$v1$PortworxVolumeSource;
        scaleIO?: Schemas.k8s$io$api$core$v1$ScaleIOVolumeSource;
        storageos?: Schemas.k8s$io$api$core$v1$StorageOSVolumeSource;
        csi?: Schemas.k8s$io$api$core$v1$CSIVolumeSource;
        ephemeral?: Schemas.k8s$io$api$core$v1$EphemeralVolumeSource;
    }
    /** Represents a vSphere volume resource. */
    export interface k8s$io$api$core$v1$VsphereVirtualDiskVolumeSource {
        /** Path that identifies vSphere volume vmdk */
        volumePath?: string;
        /**
         * Filesystem type to mount.
         * Must be a filesystem type supported by the host operating system.
         * Ex. \\"ext4\\", \\"xfs\\", \\"ntfs\\". Implicitly inferred to be \\"ext4\\" if unspecified.
         * +optional
         */
        fsType?: string;
        /**
         * Storage Policy Based Management (SPBM) profile name.
         * +optional
         */
        storagePolicyName?: string;
        /**
         * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
         * +optional
         */
        storagePolicyID?: string;
    }
    export interface k8s$io$api$core$v1$WeightedPodAffinityTerm {
        /**
         * weight associated with matching the corresponding podAffinityTerm,
         * in the range 1-100.
         */
        weight?: number;
        podAffinityTerm?: Schemas.k8s$io$api$core$v1$PodAffinityTerm;
    }
    /** WindowsSecurityContextOptions contain Windows-specific options and credentials. */
    export interface k8s$io$api$core$v1$WindowsSecurityContextOptions {
        /**
         * GMSACredentialSpecName is the name of the GMSA credential spec to use.
         * +optional
         */
        gmsaCredentialSpecName?: string;
        /**
         * GMSACredentialSpec is where the GMSA admission webhook
         * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
         * GMSA credential spec named by the GMSACredentialSpecName field.
         * +optional
         */
        gmsaCredentialSpec?: string;
        /**
         * The UserName in Windows to run the entrypoint of the container process.
         * Defaults to the user specified in image metadata if unspecified.
         * May also be set in PodSecurityContext. If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * +optional
         */
        runAsUserName?: string;
    }
    /**
     * Quantity is a fixed-point representation of a number.
     * It provides convenient marshaling/unmarshaling in JSON and YAML,
     * in addition to String() and AsInt64() accessors.
     *
     * The serialization format is:
     *
     * <quantity>        ::= <signedNumber><suffix>
     *   (Note that <suffix> may be empty, from the \\"\\" case in <decimalSI>.)
     * <digit>           ::= 0 | 1 | ... | 9
     * <digits>          ::= <digit> | <digit><digits>
     * <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits>
     * <sign>            ::= \\"+\\" | \\"-\\"
     * <signedNumber>    ::= <number> | <sign><number>
     * <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI>
     * <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
     *   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
     * <decimalSI>       ::= m | \\"\\" | k | M | G | T | P | E
     *   (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
     * <decimalExponent> ::= \\"e\\" <signedNumber> | \\"E\\" <signedNumber>
     *
     * No matter which of the three exponent forms is used, no quantity may represent
     * a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal
     * places. Numbers larger or more precise will be capped or rounded up.
     * (E.g.: 0.1m will rounded up to 1m.)
     * This may be extended in the future if we require larger or smaller quantities.
     *
     * When a Quantity is parsed from a string, it will remember the type of suffix
     * it had, and will use the same type again when it is serialized.
     *
     * Before serializing, Quantity will be put in \\"canonical form\\".
     * This means that Exponent/suffix will be adjusted up or down (with a
     * corresponding increase or decrease in Mantissa) such that:
     *   a. No precision is lost
     *   b. No fractional digits will be emitted
     *   c. The exponent (or suffix) is as large as possible.
     * The sign will be omitted unless the number is negative.
     *
     * Examples:
     *   1.5 will be serialized as \\"1500m\\"
     *   1.5Gi will be serialized as \\"1536Mi\\"
     *
     * Note that the quantity will NEVER be internally represented by a
     * floating point number. That is the whole point of this exercise.
     *
     * Non-canonical values will still parse as long as they are well formed,
     * but will be re-emitted in their canonical form. (So always use canonical
     * form, or don't diff.)
     *
     * This format is intended to make it difficult to use these numbers without
     * writing some sort of special handling code in the hopes that that will
     * cause implementors to also use a fixed point implementation.
     *
     * +protobuf=true
     * +protobuf.embed=string
     * +protobuf.options.marshal=false
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * +k8s:deepcopy-gen=true
     * +k8s:openapi-gen=true
     */
    export interface k8s$io$apimachinery$pkg$api$resource$Quantity {
        string?: string;
    }
    /**
     * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
     *
     * Each key is either a '.' representing the field itself, and will always map to an empty set,
     * or a string representing a sub-field or item. The string will follow one of these four formats:
     * 'f:<name>', where <name> is the name of a field in a struct, or key in a map
     * 'v:<value>', where <value> is the exact json formatted value of a list item
     * 'i:<index>', where <index> is position of a item in a list
     * 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
     * If a key maps to an empty Fields value, the field that key represents is part of the set.
     *
     * The exact format is defined in sigs.k8s.io/structured-merge-diff
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$FieldsV1 {
        /** Raw is the underlying serialization of this object. */
        Raw?: string;
    }
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelector {
        /**
         * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
         * map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the
         * operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
         * +optional
         */
        matchLabels?: {
            [key: string]: string;
        };
        /**
         * matchExpressions is a list of label selector requirements. The requirements are ANDed.
         * +optional
         */
        matchExpressions?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelectorRequirement[];
    }
    /**
     * A label selector requirement is a selector that contains values, a key, and an operator that
     * relates the key and values.
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$LabelSelectorRequirement {
        /**
         * key is the label key that the selector applies to.
         * +patchMergeKey=key
         * +patchStrategy=merge
         */
        key?: string;
        /**
         * operator represents a key's relationship to a set of values.
         * Valid operators are In, NotIn, Exists and DoesNotExist.
         */
        operator?: string;
        /**
         * values is an array of string values. If the operator is In or NotIn,
         * the values array must be non-empty. If the operator is Exists or DoesNotExist,
         * the values array must be empty. This array is replaced during a strategic
         * merge patch.
         * +optional
         */
        values?: string[];
    }
    /**
     * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
     * that the fieldset applies to.
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$ManagedFieldsEntry {
        /** Manager is an identifier of the workflow managing these fields. */
        manager?: string;
        /**
         * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
         * The only valid values for this field are 'Apply' and 'Update'.
         */
        operation?: string;
        /**
         * APIVersion defines the version of this resource that this field set
         * applies to. The format is \\"group/version\\" just like the top-level
         * APIVersion field. It is necessary to track the version of a field
         * set because it cannot be automatically converted.
         */
        apiVersion?: string;
        time?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        /**
         * FieldsType is the discriminator for the different fields format and version.
         * There is currently only one possible value: \\"FieldsV1\\"
         */
        fieldsType?: string;
        fieldsV1?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$FieldsV1;
    }
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects
     * users must create.
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta {
        /**
         * Name must be unique within a namespace. Is required when creating resources, although
         * some resources may allow a client to request the generation of an appropriate name
         * automatically. Name is primarily intended for creation idempotence and configuration
         * definition.
         * Cannot be updated.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#names
         * +optional
         */
        name?: string;
        /**
         * GenerateName is an optional prefix, used by the server, to generate a unique
         * name ONLY IF the Name field has not been provided.
         * If this field is used, the name returned to the client will be different
         * than the name passed. This value will also be combined with a unique suffix.
         * The provided value has the same validation rules as the Name field,
         * and may be truncated by the length of the suffix required to make the value
         * unique on the server.
         *
         * If this field is specified and the generated name exists, the server will
         * NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
         * ServerTimeout indicating a unique name could not be found in the time allotted, and the client
         * should retry (optionally after the time indicated in the Retry-After header).
         *
         * Applied only if Name is not specified.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
         * +optional
         */
        generateName?: string;
        /**
         * Namespace defines the space within which each name must be unique. An empty namespace is
         * equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation.
         * Not all objects are required to be scoped to a namespace - the value of this field for
         * those objects will be empty.
         *
         * Must be a DNS_LABEL.
         * Cannot be updated.
         * More info: http://kubernetes.io/docs/user-guide/namespaces
         * +optional
         */
        namespace?: string;
        /**
         * SelfLink is a URL representing this object.
         * Populated by the system.
         * Read-only.
         *
         * DEPRECATED
         * Kubernetes will stop propagating this field in 1.20 release and the field is planned
         * to be removed in 1.21 release.
         * +optional
         */
        selfLink?: string;
        /**
         * UID is the unique in time and space value for this object. It is typically generated by
         * the server on successful creation of a resource and is not allowed to change on PUT
         * operations.
         *
         * Populated by the system.
         * Read-only.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
         * +optional
         */
        uid?: string;
        /**
         * An opaque value that represents the internal version of this object that can
         * be used by clients to determine when objects have changed. May be used for optimistic
         * concurrency, change detection, and the watch operation on a resource or set of resources.
         * Clients must treat these values as opaque and passed unmodified back to the server.
         * They may only be valid for a particular resource or set of resources.
         *
         * Populated by the system.
         * Read-only.
         * Value must be treated as opaque by clients and .
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
         * +optional
         */
        resourceVersion?: string;
        /**
         * A sequence number representing a specific generation of the desired state.
         * Populated by the system. Read-only.
         * +optional
         */
        generation?: string;
        creationTimestamp?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        deletionTimestamp?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$Time;
        /**
         * Number of seconds allowed for this object to gracefully terminate before
         * it will be removed from the system. Only set when deletionTimestamp is also set.
         * May only be shortened.
         * Read-only.
         * +optional
         */
        deletionGracePeriodSeconds?: string;
        /**
         * Map of string keys and values that can be used to organize and categorize
         * (scope and select) objects. May match selectors of replication controllers
         * and services.
         * More info: http://kubernetes.io/docs/user-guide/labels
         * +optional
         */
        labels?: {
            [key: string]: string;
        };
        /**
         * Annotations is an unstructured key value map stored with a resource that may be
         * set by external tools to store and retrieve arbitrary metadata. They are not
         * queryable and should be preserved when modifying objects.
         * More info: http://kubernetes.io/docs/user-guide/annotations
         * +optional
         */
        annotations?: {
            [key: string]: string;
        };
        /**
         * List of objects depended by this object. If ALL objects in the list have
         * been deleted, this object will be garbage collected. If this object is managed by a controller,
         * then an entry in this list will point to this controller, with the controller field set to true.
         * There cannot be more than one managing controller.
         * +optional
         * +patchMergeKey=uid
         * +patchStrategy=merge
         */
        ownerReferences?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$OwnerReference[];
        /**
         * Must be empty before the object is deleted from the registry. Each entry
         * is an identifier for the responsible component that will remove the entry
         * from the list. If the deletionTimestamp of the object is non-nil, entries
         * in this list can only be removed.
         * Finalizers may be processed and removed in any order.  Order is NOT enforced
         * because it introduces significant risk of stuck finalizers.
         * finalizers is a shared field, any actor with permission can reorder it.
         * If the finalizer list is processed in order, then this can lead to a situation
         * in which the component responsible for the first finalizer in the list is
         * waiting for a signal (field value, external system, or other) produced by a
         * component responsible for a finalizer later in the list, resulting in a deadlock.
         * Without enforced ordering finalizers are free to order amongst themselves and
         * are not vulnerable to ordering changes in the list.
         * +optional
         * +patchStrategy=merge
         */
        finalizers?: string[];
        /**
         * The name of the cluster which the object belongs to.
         * This is used to distinguish resources with same name and namespace in different clusters.
         * This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
         * +optional
         */
        clusterName?: string;
        /**
         * ManagedFields maps workflow-id and version to the set of fields
         * that are managed by that workflow. This is mostly for internal
         * housekeeping, and users typically shouldn't need to set or
         * understand this field. A workflow can be the user's name, a
         * controller's name, or the name of a specific apply path like
         * \\"ci-cd\\". The set of fields is always in the version that the
         * workflow used when modifying the object.
         *
         * +optional
         */
        managedFields?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ManagedFieldsEntry[];
    }
    /**
     * OwnerReference contains enough information to let you identify an owning
     * object. An owning object must be in the same namespace as the dependent, or
     * be cluster-scoped, so there is no namespace field.
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$OwnerReference {
        /** API version of the referent. */
        apiVersion?: string;
        /**
         * Kind of the referent.
         * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
         */
        kind?: string;
        /**
         * Name of the referent.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#names
         */
        name?: string;
        /**
         * UID of the referent.
         * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
         */
        uid?: string;
        /**
         * If true, this reference points to the managing controller.
         * +optional
         */
        controller?: boolean;
        /**
         * If true, AND if the owner has the \\"foregroundDeletion\\" finalizer, then
         * the owner cannot be deleted from the key-value store until this
         * reference is removed.
         * Defaults to false.
         * To set this field, a user needs \\"delete\\" permission of the owner,
         * otherwise 422 (Unprocessable Entity) will be returned.
         * +optional
         */
        blockOwnerDeletion?: boolean;
    }
    /**
     * Time is a wrapper around time.Time which supports correct
     * marshaling to YAML and JSON.  Wrappers are provided for many
     * of the factory methods that the time package offers.
     *
     * +protobuf.options.marshal=false
     * +protobuf.as=Timestamp
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     */
    export interface k8s$io$apimachinery$pkg$apis$meta$v1$Time {
        /**
         * Represents seconds of UTC time since Unix epoch
         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59Z inclusive.
         */
        seconds?: string;
        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive. This field may be limited in precision depending on context.
         */
        nanos?: number;
    }
    /**
     * +protobuf=true
     * +protobuf.options.(gogoproto.goproto_stringer)=false
     * +k8s:openapi-gen=true
     */
    export interface k8s$io$apimachinery$pkg$util$intstr$IntOrString {
        type?: string;
        intVal?: number;
        strVal?: string;
    }
    export interface rollout$AbortRolloutRequest {
        name?: string;
        namespace?: string;
    }
    export interface rollout$AnalysisRunInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        icon?: string;
        revision?: number;
        status?: string;
        successful?: number;
        failed?: number;
        inconclusive?: number;
        error?: number;
        jobs?: Schemas.rollout$JobInfo[];
    }
    export interface rollout$ContainerInfo {
        name?: string;
        image?: string;
    }
    export interface rollout$ExperimentInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        icon?: string;
        revision?: number;
        status?: string;
        message?: string;
        replicaSets?: Schemas.rollout$ReplicaSetInfo[];
        analysisRuns?: Schemas.rollout$AnalysisRunInfo[];
    }
    export interface rollout$JobInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        status?: string;
        icon?: string;
    }
    export interface rollout$NamespaceInfo {
        namespace?: string;
        availableNamespaces?: string[];
    }
    export interface rollout$PodInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        status?: string;
        icon?: string;
        ready?: string;
        restarts?: number;
    }
    export interface rollout$PromoteRolloutRequest {
        name?: string;
        namespace?: string;
        full?: boolean;
    }
    export interface rollout$ReplicaSetInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        status?: string;
        icon?: string;
        revision?: number;
        stable?: boolean;
        canary?: boolean;
        active?: boolean;
        preview?: boolean;
        replicas?: number;
        available?: number;
        template?: string;
        scaleDownDeadline?: string;
        images?: string[];
        pods?: Schemas.rollout$PodInfo[];
    }
    export interface rollout$RestartRolloutRequest {
        name?: string;
        namespace?: string;
    }
    export interface rollout$RetryRolloutRequest {
        name?: string;
        namespace?: string;
    }
    export interface rollout$RolloutInfo {
        objectMeta?: Schemas.k8s$io$apimachinery$pkg$apis$meta$v1$ObjectMeta;
        status?: string;
        message?: string;
        icon?: string;
        strategy?: string;
        step?: string;
        setWeight?: string;
        actualWeight?: string;
        ready?: number;
        current?: number;
        desired?: number;
        updated?: number;
        available?: number;
        restartedAt?: string;
        generation?: string;
        replicaSets?: Schemas.rollout$ReplicaSetInfo[];
        experiments?: Schemas.rollout$ExperimentInfo[];
        analysisRuns?: Schemas.rollout$AnalysisRunInfo[];
        containers?: Schemas.rollout$ContainerInfo[];
        steps?: Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$CanaryStep[];
    }
    export interface rollout$RolloutInfoList {
        rollouts?: Schemas.rollout$RolloutInfo[];
    }
    export interface rollout$RolloutWatchEvent {
        type?: string;
        rolloutInfo?: Schemas.rollout$RolloutInfo;
    }
    export interface rollout$SetImageRequest {
        rollout?: string;
        container?: string;
        image?: string;
        tag?: string;
        namespace?: string;
    }
    export interface rollout$UndoRolloutRequest {
        rollout?: string;
        revision?: string;
        namespace?: string;
    }
    export interface rollout$VersionInfo {
        rolloutsVersion?: string;
    }
}
export interface Response$RolloutService_GetNamespace$Status$200 {
    \\"application/json\\": Schemas.rollout$NamespaceInfo;
}
export interface Response$RolloutService_GetNamespace$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_ListRolloutInfos {
    namespace: string;
}
export interface Response$RolloutService_ListRolloutInfos$Status$200 {
    \\"application/json\\": Schemas.rollout$RolloutInfoList;
}
export interface Response$RolloutService_ListRolloutInfos$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_WatchRolloutInfos {
    namespace: string;
}
export interface Response$RolloutService_WatchRolloutInfos$Status$200 {
    \\"application/json\\": {
        result?: Schemas.rollout$RolloutWatchEvent;
        error?: Schemas.grpc$gateway$runtime$StreamError;
    };
}
export interface Response$RolloutService_WatchRolloutInfos$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_AbortRollout {
    namespace: string;
    name: string;
}
export interface RequestBody$RolloutService_AbortRollout {
    \\"application/json\\": Schemas.rollout$AbortRolloutRequest;
}
export interface Response$RolloutService_AbortRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_AbortRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_GetRolloutInfo {
    namespace: string;
    name: string;
}
export interface Response$RolloutService_GetRolloutInfo$Status$200 {
    \\"application/json\\": Schemas.rollout$RolloutInfo;
}
export interface Response$RolloutService_GetRolloutInfo$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_WatchRolloutInfo {
    namespace: string;
    name: string;
}
export interface Response$RolloutService_WatchRolloutInfo$Status$200 {
    \\"application/json\\": {
        result?: Schemas.rollout$RolloutInfo;
        error?: Schemas.grpc$gateway$runtime$StreamError;
    };
}
export interface Response$RolloutService_WatchRolloutInfo$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_PromoteRollout {
    namespace: string;
    name: string;
}
export interface RequestBody$RolloutService_PromoteRollout {
    \\"application/json\\": Schemas.rollout$PromoteRolloutRequest;
}
export interface Response$RolloutService_PromoteRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_PromoteRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_RestartRollout {
    namespace: string;
    name: string;
}
export interface RequestBody$RolloutService_RestartRollout {
    \\"application/json\\": Schemas.rollout$RestartRolloutRequest;
}
export interface Response$RolloutService_RestartRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_RestartRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_RetryRollout {
    namespace: string;
    name: string;
}
export interface RequestBody$RolloutService_RetryRollout {
    \\"application/json\\": Schemas.rollout$RetryRolloutRequest;
}
export interface Response$RolloutService_RetryRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_RetryRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_SetRolloutImage {
    namespace: string;
    rollout: string;
    container: string;
    image: string;
    tag: string;
}
export interface RequestBody$RolloutService_SetRolloutImage {
    \\"application/json\\": Schemas.rollout$SetImageRequest;
}
export interface Response$RolloutService_SetRolloutImage$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_SetRolloutImage$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Parameter$RolloutService_UndoRollout {
    namespace: string;
    rollout: string;
    revision: string;
}
export interface RequestBody$RolloutService_UndoRollout {
    \\"application/json\\": Schemas.rollout$UndoRolloutRequest;
}
export interface Response$RolloutService_UndoRollout$Status$200 {
    \\"application/json\\": Schemas.github$com$argoproj$argo_rollouts$pkg$apis$rollouts$v1alpha1$Rollout;
}
export interface Response$RolloutService_UndoRollout$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export interface Response$RolloutService_Version$Status$200 {
    \\"application/json\\": Schemas.rollout$VersionInfo;
}
export interface Response$RolloutService_Version$Status$default {
    \\"application/json\\": Schemas.grpc$gateway$runtime$Error;
}
export type ResponseContentType$RolloutService_GetNamespace = keyof Response$RolloutService_GetNamespace$Status$200;
export type ResponseContentType$RolloutService_ListRolloutInfos = keyof Response$RolloutService_ListRolloutInfos$Status$200;
export interface Params$RolloutService_ListRolloutInfos {
    parameter: Parameter$RolloutService_ListRolloutInfos;
}
export type ResponseContentType$RolloutService_WatchRolloutInfos = keyof Response$RolloutService_WatchRolloutInfos$Status$200;
export interface Params$RolloutService_WatchRolloutInfos {
    parameter: Parameter$RolloutService_WatchRolloutInfos;
}
export type RequestContentType$RolloutService_AbortRollout = keyof RequestBody$RolloutService_AbortRollout;
export type ResponseContentType$RolloutService_AbortRollout = keyof Response$RolloutService_AbortRollout$Status$200;
export interface Params$RolloutService_AbortRollout {
    parameter: Parameter$RolloutService_AbortRollout;
    requestBody: RequestBody$RolloutService_AbortRollout[\\"application/json\\"];
}
export type ResponseContentType$RolloutService_GetRolloutInfo = keyof Response$RolloutService_GetRolloutInfo$Status$200;
export interface Params$RolloutService_GetRolloutInfo {
    parameter: Parameter$RolloutService_GetRolloutInfo;
}
export type ResponseContentType$RolloutService_WatchRolloutInfo = keyof Response$RolloutService_WatchRolloutInfo$Status$200;
export interface Params$RolloutService_WatchRolloutInfo {
    parameter: Parameter$RolloutService_WatchRolloutInfo;
}
export type RequestContentType$RolloutService_PromoteRollout = keyof RequestBody$RolloutService_PromoteRollout;
export type ResponseContentType$RolloutService_PromoteRollout = keyof Response$RolloutService_PromoteRollout$Status$200;
export interface Params$RolloutService_PromoteRollout {
    parameter: Parameter$RolloutService_PromoteRollout;
    requestBody: RequestBody$RolloutService_PromoteRollout[\\"application/json\\"];
}
export type RequestContentType$RolloutService_RestartRollout = keyof RequestBody$RolloutService_RestartRollout;
export type ResponseContentType$RolloutService_RestartRollout = keyof Response$RolloutService_RestartRollout$Status$200;
export interface Params$RolloutService_RestartRollout {
    parameter: Parameter$RolloutService_RestartRollout;
    requestBody: RequestBody$RolloutService_RestartRollout[\\"application/json\\"];
}
export type RequestContentType$RolloutService_RetryRollout = keyof RequestBody$RolloutService_RetryRollout;
export type ResponseContentType$RolloutService_RetryRollout = keyof Response$RolloutService_RetryRollout$Status$200;
export interface Params$RolloutService_RetryRollout {
    parameter: Parameter$RolloutService_RetryRollout;
    requestBody: RequestBody$RolloutService_RetryRollout[\\"application/json\\"];
}
export type RequestContentType$RolloutService_SetRolloutImage = keyof RequestBody$RolloutService_SetRolloutImage;
export type ResponseContentType$RolloutService_SetRolloutImage = keyof Response$RolloutService_SetRolloutImage$Status$200;
export interface Params$RolloutService_SetRolloutImage {
    parameter: Parameter$RolloutService_SetRolloutImage;
    requestBody: RequestBody$RolloutService_SetRolloutImage[\\"application/json\\"];
}
export type RequestContentType$RolloutService_UndoRollout = keyof RequestBody$RolloutService_UndoRollout;
export type ResponseContentType$RolloutService_UndoRollout = keyof Response$RolloutService_UndoRollout$Status$200;
export interface Params$RolloutService_UndoRollout {
    parameter: Parameter$RolloutService_UndoRollout;
    requestBody: RequestBody$RolloutService_UndoRollout[\\"application/json\\"];
}
export type ResponseContentType$RolloutService_Version = keyof Response$RolloutService_Version$Status$200;
export type HttpMethod = \\"GET\\" | \\"PUT\\" | \\"POST\\" | \\"DELETE\\" | \\"OPTIONS\\" | \\"HEAD\\" | \\"PATCH\\" | \\"TRACE\\";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: \\"form\\" | \\"spaceDelimited\\" | \\"pipeDelimited\\" | \\"deepObject\\";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$RolloutService_GetNamespace$Status$200 | Response$RolloutService_ListRolloutInfos$Status$200 | Response$RolloutService_WatchRolloutInfos$Status$200 | Response$RolloutService_AbortRollout$Status$200 | Response$RolloutService_GetRolloutInfo$Status$200 | Response$RolloutService_WatchRolloutInfo$Status$200 | Response$RolloutService_PromoteRollout$Status$200 | Response$RolloutService_RestartRollout$Status$200 | Response$RolloutService_RetryRollout$Status$200 | Response$RolloutService_SetRolloutImage$Status$200 | Response$RolloutService_UndoRollout$Status$200 | Response$RolloutService_Version$Status$200;
export namespace ErrorResponse {
    export type RolloutService_GetNamespace = void;
    export type RolloutService_ListRolloutInfos = void;
    export type RolloutService_WatchRolloutInfos = void;
    export type RolloutService_AbortRollout = void;
    export type RolloutService_GetRolloutInfo = void;
    export type RolloutService_WatchRolloutInfo = void;
    export type RolloutService_PromoteRollout = void;
    export type RolloutService_RestartRollout = void;
    export type RolloutService_RetryRollout = void;
    export type RolloutService_SetRolloutImage = void;
    export type RolloutService_UndoRollout = void;
    export type RolloutService_Version = void;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\\\\/$/, \\"\\"); }
    public async RolloutService_GetNamespace(option?: RequestOption): Promise<Response$RolloutService_GetNamespace$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/namespace\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_ListRolloutInfos(params: Params$RolloutService_ListRolloutInfos, option?: RequestOption): Promise<Response$RolloutService_ListRolloutInfos$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/info\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_WatchRolloutInfos(params: Params$RolloutService_WatchRolloutInfos, option?: RequestOption): Promise<Response$RolloutService_WatchRolloutInfos$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/info/watch\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_AbortRollout(params: Params$RolloutService_AbortRollout, option?: RequestOption): Promise<Response$RolloutService_AbortRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/abort\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_GetRolloutInfo(params: Params$RolloutService_GetRolloutInfo, option?: RequestOption): Promise<Response$RolloutService_GetRolloutInfo$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/info\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_WatchRolloutInfo(params: Params$RolloutService_WatchRolloutInfo, option?: RequestOption): Promise<Response$RolloutService_WatchRolloutInfo$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/info/watch\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async RolloutService_PromoteRollout(params: Params$RolloutService_PromoteRollout, option?: RequestOption): Promise<Response$RolloutService_PromoteRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/promote\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_RestartRollout(params: Params$RolloutService_RestartRollout, option?: RequestOption): Promise<Response$RolloutService_RestartRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/restart\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_RetryRollout(params: Params$RolloutService_RetryRollout, option?: RequestOption): Promise<Response$RolloutService_RetryRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.name}/retry\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_SetRolloutImage(params: Params$RolloutService_SetRolloutImage, option?: RequestOption): Promise<Response$RolloutService_SetRolloutImage$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.rollout}/set/\${params.parameter.container}/\${params.parameter.image}/\${params.parameter.tag}\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_UndoRollout(params: Params$RolloutService_UndoRollout, option?: RequestOption): Promise<Response$RolloutService_UndoRollout$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/rollouts/\${params.parameter.namespace}/\${params.parameter.rollout}/undo/\${params.parameter.revision}\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\",
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"PUT\\", url, headers, params.requestBody, undefined, option);
    }
    public async RolloutService_Version(option?: RequestOption): Promise<Response$RolloutService_Version$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/api/v1/version\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
}
"
`;
