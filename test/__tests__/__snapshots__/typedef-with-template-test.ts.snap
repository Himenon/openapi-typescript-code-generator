// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Typedef with template api.test.domain 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.1.0
// 
// License  : MIT
// 


export namespace Schemas {
    /** String Literal */
    export type StringType = string;
    export type StringHasEnumType = \\"a\\" | \\"A\\" | \\"b\\" | \\"B\\" | \\"c\\" | \\"C\\";
    export type StringDateType = string;
    export type StringDateTimeType = string;
    export type StringPasswordType = string;
    export type StringByteType = string;
    export type StringBinaryType = string;
    export type StringWithPatternType = string;
    /** Number Literal */
    export type NumberType = number;
    export type NumberHasEnumType = 1 | 2 | 3 | 100 | 123 | 0.1 | -0.1 | 0;
    export type NumberInt32Type = number;
    export type NumberInt64Type = number;
    export type NumberFloat = number;
    export type NumberDouble = number;
    /** Boolean Literal */
    export type BooleanType = boolean;
    export type BooleanEnumType = true;
    export type BooleanEnumType2 = false;
    export type BooleanEnumType3 = true | false;
    export type ArrayStringType = string[];
    export type ArrayNumberType = number[];
    export type ArrayBooleanType = boolean[];
    export interface ObjectEmptyPropertiesType {
    }
    export interface ObjectHasPropertiesType {
        stringType?: string;
        numberType?: number;
        booleanType?: boolean;
        arrayType?: string;
        objectType?: {
            requiredStringType: string;
        };
    }
    export type OneOfType = string | number | {};
    export type AllOfType = {
        A?: string;
    } & {
        B?: string;
    };
    export type LocalRefStringType = Schemas.StringType;
    export type LocalRefNumberType = Schemas.NumberType;
    export type LocalRefBooleanType = Schemas.BooleanType;
    export type LocalRefArrayStringType = Schemas.BooleanType;
    export type LocalRefObjectHasPropertiesType = Schemas.ObjectHasPropertiesType;
    export interface LocalRefObjectProperties {
        stringType: Schemas.StringType;
        numberType: Schemas.NumberType;
        booleanType: Schemas.BooleanType;
        arrayType: Schemas.BooleanType;
        objectType: Schemas.ObjectHasPropertiesType;
    }
    export type LocalRefOneOfType = Schemas.StringType | Schemas.NumberType | Schemas.ObjectHasPropertiesType | Schemas.LocalRefObjectProperties;
    export type LocalRefAllOfType = Schemas.StringType & Schemas.NumberType & Schemas.ObjectHasPropertiesType & Schemas.LocalRefObjectProperties;
    export type LocalReferenceBeforeResolvedSchema1 = Schemas.UnresolvedTarget1;
    export type UnresolvedTarget1 = boolean;
    export type LocalReferenceBeforeResolvedSchema2 = Schemas.UnresolvedTarget2;
    export type UnresolvedTarget2 = Schemas.UnresolvedTarget3;
    export type UnresolvedTarget3 = number;
    export interface LocalReferenceBeforeResolvedSchema3 {
        unresolvedTarget4?: Schemas.UnresolvedTarget4;
    }
    export interface UnresolvedTarget4 {
        unresolvedTarget5?: Schemas.UnresolvedTarget5;
    }
    export type UnresolvedTarget5 = string;
    export type RemoteString = string;
    export type RemoteRefString = Schemas.RemoteString;
    export namespace Level1 {
        /** Level 1 */
        export type RemoteBoolean = boolean;
        export namespace Level2 {
            /** Level 2 */
            export type RemoteNumber = number;
            export namespace Level3 {
                /** Level 3 */
                export type RemoteArray = string[];
                export namespace Level4 {
                    /** Level 4 */
                    export interface RemoteObject {
                        A?: string;
                        B?: number;
                    }
                }
            }
        }
    }
    /** Level 1 */
    export type RemoteRefBoolean = Schemas.Level1.RemoteBoolean;
    /** Level 2 */
    export type RemoteRefNumber = Schemas.Level1.Level2.RemoteNumber;
    /** Level 3 */
    export type RemoteRefArray = Schemas.Level1.Level2.Level3.RemoteArray;
    /** Level 4 */
    export type RemoteRefObject = Schemas.Level1.Level2.Level3.Level4.RemoteObject;
    export namespace DirectRef {
        export type ForHeader = string;
        export interface ForResponse {
            forResponse?: string;
        }
        export type ForParameters = string;
        export interface ForRequestBody {
            a?: string;
        }
    }
    export namespace FullRemoteReference {
        export type ForParameters = string;
    }
    export interface Child {
        id: string;
        /** child name */
        name: string;
    }
    export interface Item {
        name: string;
        children: Child[];
    }
}
export namespace Headers {
    export type StringHeader = string;
    export type A = number;
    export namespace Level1 {
        export type B = string;
    }
    export type ReferenceOfHeaderToSchema = Schemas.DirectRef.ForHeader;
}
export namespace Responses {
    /**
     * Status Code 100
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100
     */
    export namespace Continue { }
    /**
     * Status Code 101
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101
     */
    export namespace SwitchingProtocol { }
    /** Type Reference - string */
    export namespace LocalReferenceStringDateTimeType {
        export interface Content {
            \\"application/json\\": Schemas.StringDateTimeType;
        }
    }
    /** Local Reference - object */
    export namespace LocalReferenceObjectType {
        export interface Content {
            \\"application/json\\": Schemas.ObjectHasPropertiesType;
        }
    }
    /** Response -> Schema */
    export namespace ReferenceOfResponseToSchema {
        export interface Content {
            \\"application/json\\": Schemas.DirectRef.ForResponse;
        }
    }
    /** response A definition */
    export namespace ResponseA {
        export interface Header {
            HeaderA: Headers.A;
            HeaderB: string;
        }
        export interface Content {
            \\"application/json\\": {
                /** responseA description */
                name?: \\"responseA\\";
            };
        }
    }
    export namespace Level1 {
        /** response B definition */
        export namespace ResponseB {
            export interface Content {
                \\"application/json\\": {
                    name?: \\"responseB\\";
                };
            }
        }
        export namespace Level2 {
            /** response C definition */
            export namespace ResponseC {
                export interface Content {
                    \\"application/json\\": {
                        name?: \\"responseC\\";
                    };
                }
            }
        }
    }
    export namespace ForPathItems {
        /** response A definition */
        export namespace FullRemoteReference {
            export interface Header {
                HeaderA: Headers.A;
                HeaderB: string;
            }
            export interface Content {
                \\"application/json\\": {
                    /** responseA description */
                    name?: \\"responseA\\";
                };
            }
        }
    }
}
export namespace Parameters {
    /** parameters.StringQueryParams */
    export type StringQueryParams = string;
    /** parameters.NumberQueryParams */
    export type NumberQueryParams = number;
    /** parameters.StringQueryParams */
    export type StringHeaderParams = string;
    export type A = number;
    export type RemoteReferenceA = Parameters.A;
    export namespace level1 {
        export type B = string;
    }
    export type RemoteReferenceB = Parameters.level1.B;
    /** parameters -> schemas */
    export type ReferenceOfParameterToSchema = Schemas.DirectRef.ForParameters;
    /** deepObject */
    export type DeepObjectParameter = {
        [key: string]: {
            gt?: string;
            gte?: string;
            lt?: string;
            lte?: string;
            any?: string | number | boolean;
        };
    };
}
export namespace RequestBodies {
    /** Request body string type */
    export namespace StringType {
        export interface Content {
            \\"application/json\\": string;
        }
    }
    /** Request body Local reference string type */
    export namespace LocalReferenceStringType {
        export interface Content {
            \\"application/json\\": Schemas.StringHasEnumType;
        }
    }
    /** requestBodies -> schemas */
    export namespace ReferenceOfRequestBodyToSchema {
        export interface Content {
            \\"application/json\\": Schemas.DirectRef.ForRequestBody;
        }
    }
    /** Remote Request body A */
    export namespace RequestBodyA {
        export interface Content {
            \\"application/json\\": {
                body?: string;
            };
        }
    }
    export namespace Level1 {
        /** Remote Request body B */
        export namespace RequestBodyB {
            export interface Content {
                \\"application/json\\": {
                    body?: string;
                };
            }
        }
        export namespace Level2 {
            /** Remote Request body C */
            export namespace RequestBodyC {
                export interface Content {
                    \\"application/json\\": {
                        body?: string;
                    };
                }
            }
        }
    }
}
export interface Parameter$getIncludeLocalReference {
    /** parameters.StringQueryParams */
    StringQuery: string;
}
export interface Response$getIncludeLocalReference$Status$200 {
    \\"application/json\\": {
        meta: string;
    };
}
export interface Parameter$getIncludeRemoteReference {
    /** remote reference parameter */
    IncludeRemoteReference: number;
}
export interface RequestBody$getIncludeRemoteReference {
    \\"application/json\\": string;
}
export interface Parameter$getFullRemoteReference {
    /** Full Remote Reference */
    FullRemoteReferenceQuery: Schemas.FullRemoteReference.ForParameters;
}
export interface Response$getFullRemoteReference$Status$200 {
    \\"application/json\\": {
        /** responseA description */
        name?: \\"responseA\\";
    };
}
export interface Response$i$have$dot$Status$200 {
    \\"application/json\\": {
        books?: Schemas.Item[];
    };
}
export interface Response$getReferenceItems$Status$200 {
    \\"application/json\\": {
        books?: Schemas.Item[];
    };
}
export interface Parameter$searchBook {
    \\"book.name\\": string;
    \\"from.publishedAt\\"?: number;
}
export interface Response$searchBook$Status$200 {
    \\"application/json\\": {
        id?: number;
        bookTitle?: string;
    };
}
export interface Parameter$getBookById {
    /** Book ID */
    id: string;
}
export interface Response$getBookById$Status$200 {
    \\"application/json\\": Schemas.ObjectHasPropertiesType;
}
export interface Parameter$deleteBook {
    /** Number Book ID */
    id: number;
}
export interface Response$deleteBook$Status$200 {
    \\"application/json\\": {
        status?: \\"ok\\";
    };
}
export type ResponseContentType$getIncludeLocalReference = keyof Response$getIncludeLocalReference$Status$200;
export interface Params$getIncludeLocalReference {
    parameter: Parameter$getIncludeLocalReference;
}
export type RequestContentType$getIncludeRemoteReference = keyof RequestBody$getIncludeRemoteReference;
export interface Params$getIncludeRemoteReference {
    parameter: Parameter$getIncludeRemoteReference;
    requestBody: RequestBody$getIncludeRemoteReference[\\"application/json\\"];
}
export type ResponseContentType$getFullRemoteReference = keyof Response$getFullRemoteReference$Status$200;
export interface Params$getFullRemoteReference {
    parameter: Parameter$getFullRemoteReference;
}
export type ResponseContentType$i$have$dot = keyof Response$i$have$dot$Status$200;
export type ResponseContentType$getReferenceItems = keyof Response$getReferenceItems$Status$200;
export type ResponseContentType$searchBook = keyof Response$searchBook$Status$200;
export interface Params$searchBook {
    parameter: Parameter$searchBook;
}
export type ResponseContentType$getBookById = keyof Response$getBookById$Status$200;
export interface Params$getBookById {
    parameter: Parameter$getBookById;
}
export type ResponseContentType$deleteBook = keyof Response$deleteBook$Status$200;
export interface Params$deleteBook {
    parameter: Parameter$deleteBook;
}
export type HttpMethod = \\"GET\\" | \\"PUT\\" | \\"POST\\" | \\"DELETE\\" | \\"OPTIONS\\" | \\"HEAD\\" | \\"PATCH\\" | \\"TRACE\\";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: \\"form\\" | \\"spaceDelimited\\" | \\"pipeDelimited\\" | \\"deepObject\\";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$getIncludeLocalReference$Status$200 | Response$getFullRemoteReference$Status$200 | Response$i$have$dot$Status$200 | Response$getReferenceItems$Status$200 | Response$searchBook$Status$200 | Response$getBookById$Status$200 | Response$deleteBook$Status$200;
export namespace ErrorResponse {
    export type getIncludeLocalReference = void;
    export type getIncludeRemoteReference = void;
    export type getFullRemoteReference = void;
    export type i$have$dot = void;
    export type getReferenceItems = void;
    export type searchBook = void;
    export type getBookById = void;
    export type deleteBook = void;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\\\\/$/, \\"\\"); }
    public async getIncludeLocalReference(params: Params$getIncludeLocalReference, option?: RequestOption): Promise<Response$getIncludeLocalReference$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/IncludeLocalReference\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            StringQuery: { value: params.parameter.StringQuery, explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, queryParameters, option);
    }
    public async getIncludeRemoteReference(params: Params$getIncludeRemoteReference, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + \`/get/IncludeRemoteReference\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            IncludeRemoteReference: { value: params.parameter.IncludeRemoteReference, explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, params.requestBody, queryParameters, option);
    }
    public async getFullRemoteReference(params: Params$getFullRemoteReference, option?: RequestOption): Promise<Response$getFullRemoteReference$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/FullRemoteReference\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            FullRemoteReferenceQuery: { value: params.parameter.FullRemoteReferenceQuery, explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, queryParameters, option);
    }
    public async i$have$dot(option?: RequestOption): Promise<Response$i$have$dot$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/i/have/dot\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async getReferenceItems(option?: RequestOption): Promise<Response$getReferenceItems$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/reference/items\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async searchBook(params: Params$searchBook, option?: RequestOption): Promise<Response$searchBook$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/search/\${params.parameter[\\"book.name\\"]}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            \\"from.publishedAt\\": { value: params.parameter[\\"from.publishedAt\\"], explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, queryParameters, option);
    }
    public async getBookById(params: Params$getBookById, option?: RequestOption): Promise<Response$getBookById$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/books/\${params.parameter.id}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async deleteBook(params: Params$deleteBook, option?: RequestOption): Promise<Response$deleteBook$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/books/\${params.parameter.id}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"DELETE\\", url, headers, undefined, undefined, option);
    }
}
"
`;

exports[`Typedef with template api.v2.domain 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.1.0
// 
// License  : MIT
// 


export namespace Schemas {
    export type Message = \\"hello\\" | \\"world\\";
    export type QueryParams = \\"a\\" | \\"b\\" | \\"c\\";
}
export interface Parameter$getHelloWorld {
    /** query word */
    word: Schemas.QueryParams;
}
export interface Response$getHelloWorld$Status$200 {
    \\"application/json\\": {
        message?: Schemas.Message;
    };
}
export type ResponseContentType$getHelloWorld = keyof Response$getHelloWorld$Status$200;
export interface Params$getHelloWorld {
    parameter: Parameter$getHelloWorld;
}
export type HttpMethod = \\"GET\\" | \\"PUT\\" | \\"POST\\" | \\"DELETE\\" | \\"OPTIONS\\" | \\"HEAD\\" | \\"PATCH\\" | \\"TRACE\\";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: \\"form\\" | \\"spaceDelimited\\" | \\"pipeDelimited\\" | \\"deepObject\\";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$getHelloWorld$Status$200;
export namespace ErrorResponse {
    export type getHelloWorld = void;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\\\\/$/, \\"\\"); }
    public async getHelloWorld(params: Params$getHelloWorld, option?: RequestOption): Promise<Response$getHelloWorld$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/hello/world\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            word: { value: params.parameter.word, explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, queryParameters, option);
    }
}
"
`;

exports[`Typedef with template async-api.test.domain 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.1.0
// 
// License  : MIT
// 


export namespace Schemas {
    /** String Literal */
    export type StringType = string;
    export type StringHasEnumType = \\"a\\" | \\"A\\" | \\"b\\" | \\"B\\" | \\"c\\" | \\"C\\";
    export type StringDateType = string;
    export type StringDateTimeType = string;
    export type StringPasswordType = string;
    export type StringByteType = string;
    export type StringBinaryType = string;
    export type StringWithPatternType = string;
    /** Number Literal */
    export type NumberType = number;
    export type NumberHasEnumType = 1 | 2 | 3 | 100 | 123 | 0.1 | -0.1 | 0;
    export type NumberInt32Type = number;
    export type NumberInt64Type = number;
    export type NumberFloat = number;
    export type NumberDouble = number;
    /** Boolean Literal */
    export type BooleanType = boolean;
    export type BooleanEnumType = true;
    export type BooleanEnumType2 = false;
    export type BooleanEnumType3 = true | false;
    export type ArrayStringType = string[];
    export type ArrayNumberType = number[];
    export type ArrayBooleanType = boolean[];
    export interface ObjectEmptyPropertiesType {
    }
    export interface ObjectHasPropertiesType {
        stringType?: string;
        numberType?: number;
        booleanType?: boolean;
        arrayType?: string;
        objectType?: {
            requiredStringType: string;
        };
    }
    export type OneOfType = string | number | {};
    export type AllOfType = {
        A?: string;
    } & {
        B?: string;
    };
    export type LocalRefStringType = Schemas.StringType;
    export type LocalRefNumberType = Schemas.NumberType;
    export type LocalRefBooleanType = Schemas.BooleanType;
    export type LocalRefArrayStringType = Schemas.BooleanType;
    export type LocalRefObjectHasPropertiesType = Schemas.ObjectHasPropertiesType;
    export interface LocalRefObjectProperties {
        stringType: Schemas.StringType;
        numberType: Schemas.NumberType;
        booleanType: Schemas.BooleanType;
        arrayType: Schemas.BooleanType;
        objectType: Schemas.ObjectHasPropertiesType;
    }
    export type LocalRefOneOfType = Schemas.StringType | Schemas.NumberType | Schemas.ObjectHasPropertiesType | Schemas.LocalRefObjectProperties;
    export type LocalRefAllOfType = Schemas.StringType & Schemas.NumberType & Schemas.ObjectHasPropertiesType & Schemas.LocalRefObjectProperties;
    export type LocalReferenceBeforeResolvedSchema1 = Schemas.UnresolvedTarget1;
    export type UnresolvedTarget1 = boolean;
    export type LocalReferenceBeforeResolvedSchema2 = Schemas.UnresolvedTarget2;
    export type UnresolvedTarget2 = Schemas.UnresolvedTarget3;
    export type UnresolvedTarget3 = number;
    export interface LocalReferenceBeforeResolvedSchema3 {
        unresolvedTarget4?: Schemas.UnresolvedTarget4;
    }
    export interface UnresolvedTarget4 {
        unresolvedTarget5?: Schemas.UnresolvedTarget5;
    }
    export type UnresolvedTarget5 = string;
    export type RemoteString = string;
    export type RemoteRefString = Schemas.RemoteString;
    export namespace Level1 {
        /** Level 1 */
        export type RemoteBoolean = boolean;
        export namespace Level2 {
            /** Level 2 */
            export type RemoteNumber = number;
            export namespace Level3 {
                /** Level 3 */
                export type RemoteArray = string[];
                export namespace Level4 {
                    /** Level 4 */
                    export interface RemoteObject {
                        A?: string;
                        B?: number;
                    }
                }
            }
        }
    }
    /** Level 1 */
    export type RemoteRefBoolean = Schemas.Level1.RemoteBoolean;
    /** Level 2 */
    export type RemoteRefNumber = Schemas.Level1.Level2.RemoteNumber;
    /** Level 3 */
    export type RemoteRefArray = Schemas.Level1.Level2.Level3.RemoteArray;
    /** Level 4 */
    export type RemoteRefObject = Schemas.Level1.Level2.Level3.Level4.RemoteObject;
    export namespace DirectRef {
        export type ForHeader = string;
        export interface ForResponse {
            forResponse?: string;
        }
        export type ForParameters = string;
        export interface ForRequestBody {
            a?: string;
        }
    }
    export namespace FullRemoteReference {
        export type ForParameters = string;
    }
    export interface Child {
        id: string;
        /** child name */
        name: string;
    }
    export interface Item {
        name: string;
        children: Child[];
    }
}
export namespace Headers {
    export type StringHeader = string;
    export type A = number;
    export namespace Level1 {
        export type B = string;
    }
    export type ReferenceOfHeaderToSchema = Schemas.DirectRef.ForHeader;
}
export namespace Responses {
    /**
     * Status Code 100
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100
     */
    export namespace Continue { }
    /**
     * Status Code 101
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101
     */
    export namespace SwitchingProtocol { }
    /** Type Reference - string */
    export namespace LocalReferenceStringDateTimeType {
        export interface Content {
            \\"application/json\\": Schemas.StringDateTimeType;
        }
    }
    /** Local Reference - object */
    export namespace LocalReferenceObjectType {
        export interface Content {
            \\"application/json\\": Schemas.ObjectHasPropertiesType;
        }
    }
    /** Response -> Schema */
    export namespace ReferenceOfResponseToSchema {
        export interface Content {
            \\"application/json\\": Schemas.DirectRef.ForResponse;
        }
    }
    /** response A definition */
    export namespace ResponseA {
        export interface Header {
            HeaderA: Headers.A;
            HeaderB: string;
        }
        export interface Content {
            \\"application/json\\": {
                /** responseA description */
                name?: \\"responseA\\";
            };
        }
    }
    export namespace Level1 {
        /** response B definition */
        export namespace ResponseB {
            export interface Content {
                \\"application/json\\": {
                    name?: \\"responseB\\";
                };
            }
        }
        export namespace Level2 {
            /** response C definition */
            export namespace ResponseC {
                export interface Content {
                    \\"application/json\\": {
                        name?: \\"responseC\\";
                    };
                }
            }
        }
    }
    export namespace ForPathItems {
        /** response A definition */
        export namespace FullRemoteReference {
            export interface Header {
                HeaderA: Headers.A;
                HeaderB: string;
            }
            export interface Content {
                \\"application/json\\": {
                    /** responseA description */
                    name?: \\"responseA\\";
                };
            }
        }
    }
}
export namespace Parameters {
    /** parameters.StringQueryParams */
    export type StringQueryParams = string;
    /** parameters.NumberQueryParams */
    export type NumberQueryParams = number;
    /** parameters.StringQueryParams */
    export type StringHeaderParams = string;
    export type A = number;
    export type RemoteReferenceA = Parameters.A;
    export namespace level1 {
        export type B = string;
    }
    export type RemoteReferenceB = Parameters.level1.B;
    /** parameters -> schemas */
    export type ReferenceOfParameterToSchema = Schemas.DirectRef.ForParameters;
    /** deepObject */
    export type DeepObjectParameter = {
        [key: string]: {
            gt?: string;
            gte?: string;
            lt?: string;
            lte?: string;
            any?: string | number | boolean;
        };
    };
}
export namespace RequestBodies {
    /** Request body string type */
    export namespace StringType {
        export interface Content {
            \\"application/json\\": string;
        }
    }
    /** Request body Local reference string type */
    export namespace LocalReferenceStringType {
        export interface Content {
            \\"application/json\\": Schemas.StringHasEnumType;
        }
    }
    /** requestBodies -> schemas */
    export namespace ReferenceOfRequestBodyToSchema {
        export interface Content {
            \\"application/json\\": Schemas.DirectRef.ForRequestBody;
        }
    }
    /** Remote Request body A */
    export namespace RequestBodyA {
        export interface Content {
            \\"application/json\\": {
                body?: string;
            };
        }
    }
    export namespace Level1 {
        /** Remote Request body B */
        export namespace RequestBodyB {
            export interface Content {
                \\"application/json\\": {
                    body?: string;
                };
            }
        }
        export namespace Level2 {
            /** Remote Request body C */
            export namespace RequestBodyC {
                export interface Content {
                    \\"application/json\\": {
                        body?: string;
                    };
                }
            }
        }
    }
}
export interface Parameter$getIncludeLocalReference {
    /** parameters.StringQueryParams */
    StringQuery: string;
}
export interface Response$getIncludeLocalReference$Status$200 {
    \\"application/json\\": {
        meta: string;
    };
}
export interface Parameter$getIncludeRemoteReference {
    /** remote reference parameter */
    IncludeRemoteReference: number;
}
export interface RequestBody$getIncludeRemoteReference {
    \\"application/json\\": string;
}
export interface Parameter$getFullRemoteReference {
    /** Full Remote Reference */
    FullRemoteReferenceQuery: Schemas.FullRemoteReference.ForParameters;
}
export interface Response$getFullRemoteReference$Status$200 {
    \\"application/json\\": {
        /** responseA description */
        name?: \\"responseA\\";
    };
}
export interface Response$i$have$dot$Status$200 {
    \\"application/json\\": {
        books?: Schemas.Item[];
    };
}
export interface Response$getReferenceItems$Status$200 {
    \\"application/json\\": {
        books?: Schemas.Item[];
    };
}
export interface Parameter$searchBook {
    \\"book.name\\": string;
    \\"from.publishedAt\\"?: number;
}
export interface Response$searchBook$Status$200 {
    \\"application/json\\": {
        id?: number;
        bookTitle?: string;
    };
}
export interface Parameter$getBookById {
    /** Book ID */
    id: string;
}
export interface Response$getBookById$Status$200 {
    \\"application/json\\": Schemas.ObjectHasPropertiesType;
}
export interface Parameter$deleteBook {
    /** Number Book ID */
    id: number;
}
export interface Response$deleteBook$Status$200 {
    \\"application/json\\": {
        status?: \\"ok\\";
    };
}
export type ResponseContentType$getIncludeLocalReference = keyof Response$getIncludeLocalReference$Status$200;
export interface Params$getIncludeLocalReference {
    parameter: Parameter$getIncludeLocalReference;
}
export type RequestContentType$getIncludeRemoteReference = keyof RequestBody$getIncludeRemoteReference;
export interface Params$getIncludeRemoteReference {
    parameter: Parameter$getIncludeRemoteReference;
    requestBody: RequestBody$getIncludeRemoteReference[\\"application/json\\"];
}
export type ResponseContentType$getFullRemoteReference = keyof Response$getFullRemoteReference$Status$200;
export interface Params$getFullRemoteReference {
    parameter: Parameter$getFullRemoteReference;
}
export type ResponseContentType$i$have$dot = keyof Response$i$have$dot$Status$200;
export type ResponseContentType$getReferenceItems = keyof Response$getReferenceItems$Status$200;
export type ResponseContentType$searchBook = keyof Response$searchBook$Status$200;
export interface Params$searchBook {
    parameter: Parameter$searchBook;
}
export type ResponseContentType$getBookById = keyof Response$getBookById$Status$200;
export interface Params$getBookById {
    parameter: Parameter$getBookById;
}
export type ResponseContentType$deleteBook = keyof Response$deleteBook$Status$200;
export interface Params$deleteBook {
    parameter: Parameter$deleteBook;
}
export type HttpMethod = \\"GET\\" | \\"PUT\\" | \\"POST\\" | \\"DELETE\\" | \\"OPTIONS\\" | \\"HEAD\\" | \\"PATCH\\" | \\"TRACE\\";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: \\"form\\" | \\"spaceDelimited\\" | \\"pipeDelimited\\" | \\"deepObject\\";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$getIncludeLocalReference$Status$200 | Response$getFullRemoteReference$Status$200 | Response$i$have$dot$Status$200 | Response$getReferenceItems$Status$200 | Response$searchBook$Status$200 | Response$getBookById$Status$200 | Response$deleteBook$Status$200;
export namespace ErrorResponse {
    export type getIncludeLocalReference = void;
    export type getIncludeRemoteReference = void;
    export type getFullRemoteReference = void;
    export type i$have$dot = void;
    export type getReferenceItems = void;
    export type searchBook = void;
    export type getBookById = void;
    export type deleteBook = void;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => T;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\\\\/$/, \\"\\"); }
    public getIncludeLocalReference(params: Params$getIncludeLocalReference, option?: RequestOption): Response$getIncludeLocalReference$Status$200[\\"application/json\\"] {
        const url = this.baseUrl + \`/get/IncludeLocalReference\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            StringQuery: { value: params.parameter.StringQuery, explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, queryParameters, option);
    }
    public getIncludeRemoteReference(params: Params$getIncludeRemoteReference, option?: RequestOption): void {
        const url = this.baseUrl + \`/get/IncludeRemoteReference\`;
        const headers = {
            \\"Content-Type\\": \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            IncludeRemoteReference: { value: params.parameter.IncludeRemoteReference, explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, params.requestBody, queryParameters, option);
    }
    public getFullRemoteReference(params: Params$getFullRemoteReference, option?: RequestOption): Response$getFullRemoteReference$Status$200[\\"application/json\\"] {
        const url = this.baseUrl + \`/FullRemoteReference\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            FullRemoteReferenceQuery: { value: params.parameter.FullRemoteReferenceQuery, explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, queryParameters, option);
    }
    public i$have$dot(option?: RequestOption): Response$i$have$dot$Status$200[\\"application/json\\"] {
        const url = this.baseUrl + \`/i/have/dot\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public getReferenceItems(option?: RequestOption): Response$getReferenceItems$Status$200[\\"application/json\\"] {
        const url = this.baseUrl + \`/get/reference/items\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public searchBook(params: Params$searchBook, option?: RequestOption): Response$searchBook$Status$200[\\"application/json\\"] {
        const url = this.baseUrl + \`/get/search/\${params.parameter[\\"book.name\\"]}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        const queryParameters: QueryParameters = {
            \\"from.publishedAt\\": { value: params.parameter[\\"from.publishedAt\\"], explode: false }
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, queryParameters, option);
    }
    public getBookById(params: Params$getBookById, option?: RequestOption): Response$getBookById$Status$200[\\"application/json\\"] {
        const url = this.baseUrl + \`/get/books/\${params.parameter.id}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public deleteBook(params: Params$deleteBook, option?: RequestOption): Response$deleteBook$Status$200[\\"application/json\\"] {
        const url = this.baseUrl + \`/get/books/\${params.parameter.id}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"DELETE\\", url, headers, undefined, undefined, option);
    }
}
"
`;

exports[`Typedef with template infer.domain 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.1.0
// 
// License  : MIT
// 


export namespace Schemas {
    export type InferArrayEmptyItems = {}[];
    export type InferArrayType = string[];
    export interface InferObjectItem {
        description: any;
    }
    export interface InferObjectHasAnyProp {
        filed?: any;
    }
    export interface InferObject {
        filed?: string;
    }
    export type InferStringEnum = \\"a\\" | \\"b\\" | \\"c\\";
    export type InferAnyNullable = null;
    export interface OptionalPropertiesAndAdditionalProperties {
        body?: {
            key?: string;
            description?: string;
        } & {
            [key: string]: string;
        };
    }
}
export type HttpMethod = \\"GET\\" | \\"PUT\\" | \\"POST\\" | \\"DELETE\\" | \\"OPTIONS\\" | \\"HEAD\\" | \\"PATCH\\" | \\"TRACE\\";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: \\"form\\" | \\"spaceDelimited\\" | \\"pipeDelimited\\" | \\"deepObject\\";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = void;
export namespace ErrorResponse { }
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\\\\/$/, \\"\\"); }
}
"
`;

exports[`Typedef with template ref-access 1`] = `
"// 
// Generated by @himenon/openapi-typescript-code-generator
// 
// OpenApi : 3.1.0
// 
// License  : MIT
// 


export namespace Schemas {
    export interface Book {
        author?: {
            name?: string;
            age?: string;
        };
        publisher?: {
            name?: any;
            address?: string;
        };
        metadata: {
            description: string;
        };
    }
    export type Author = {
        name?: string;
        age?: string;
    };
    export type Publisher = {
        name?: any;
        address?: string;
    };
}
export interface Parameter$getBook {
    /** Book ID */
    id: string;
}
export interface Response$getBook$Status$200 {
    \\"application/json\\": Schemas.Book;
}
export interface Parameter$getDescription {
    /** Book ID */
    id: string;
}
export interface Response$getDescription$Status$200 {
    \\"application/json\\": string;
}
export interface Parameter$getAuthor {
    /** Author Id */
    id: string;
}
export interface Response$getAuthor$Status$200 {
    \\"application/json\\": {
        name?: string;
        age?: string;
    };
}
export interface Parameter$getPublisher {
    /** Publisher ID */
    id: string;
}
export interface Response$getPublisher$Status$200 {
    \\"application/json\\": Schemas.Publisher;
}
export type ResponseContentType$getBook = keyof Response$getBook$Status$200;
export interface Params$getBook {
    parameter: Parameter$getBook;
}
export type ResponseContentType$getDescription = keyof Response$getDescription$Status$200;
export interface Params$getDescription {
    parameter: Parameter$getDescription;
}
export type ResponseContentType$getAuthor = keyof Response$getAuthor$Status$200;
export interface Params$getAuthor {
    parameter: Parameter$getAuthor;
}
export type ResponseContentType$getPublisher = keyof Response$getPublisher$Status$200;
export interface Params$getPublisher {
    parameter: Parameter$getPublisher;
}
export type HttpMethod = \\"GET\\" | \\"PUT\\" | \\"POST\\" | \\"DELETE\\" | \\"OPTIONS\\" | \\"HEAD\\" | \\"PATCH\\" | \\"TRACE\\";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: \\"form\\" | \\"spaceDelimited\\" | \\"pipeDelimited\\" | \\"deepObject\\";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$getBook$Status$200 | Response$getDescription$Status$200 | Response$getAuthor$Status$200 | Response$getPublisher$Status$200;
export namespace ErrorResponse {
    export type getBook = void;
    export type getDescription = void;
    export type getAuthor = void;
    export type getPublisher = void;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\\\\/$/, \\"\\"); }
    public async getBook(params: Params$getBook, option?: RequestOption): Promise<Response$getBook$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/book/\${params.parameter.id}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async getDescription(params: Params$getDescription, option?: RequestOption): Promise<Response$getDescription$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/book/\${params.parameter.id}/description\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async getAuthor(params: Params$getAuthor, option?: RequestOption): Promise<Response$getAuthor$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/author/\${params.parameter.id}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
    public async getPublisher(params: Params$getPublisher, option?: RequestOption): Promise<Response$getPublisher$Status$200[\\"application/json\\"]> {
        const url = this.baseUrl + \`/get/publisher/\${params.parameter.id}\`;
        const headers = {
            Accept: \\"application/json\\"
        };
        return this.apiClient.request(\\"GET\\", url, headers, undefined, undefined, option);
    }
}
"
`;
