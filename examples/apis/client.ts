//
// Generated by @himenon/openapi-typescript-code-generator v1.0.2
//
// OpenApi : 3.0.3
//
// License  : MIT
//

export namespace Schemas {
  export interface Author {
    id: string;
    /** author name */
    name: string;
  }
  export interface Book {
    title: string;
    author: Author;
    ISBN: string;
    publishAt: string;
    updatedAt: string;
  }
}
export namespace Responses {
  /** Get Books */
  export namespace Books {
    export interface Content {
      "application/json": {
        books: Schemas.Book[];
      };
    }
  }
}
export interface Response$getBooks$Status$200 {
  "application/json": {
    books: Schemas.Book[];
  };
}
export interface Parameter$searchBooks {
  filter?: {
    title: string;
    author: string;
    [key: string]: string;
  };
}
export interface Response$searchBooks$Status$200 {
  "application/json": {
    books?: Schemas.Book[];
  };
}
export type ResponseContentType$getBooks = keyof Response$getBooks$Status$200;
export type ResponseContentType$searchBooks = keyof Response$searchBooks$Status$200;
export interface Params$searchBooks {
  parameter: Parameter$searchBooks;
}
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
  [key: string]: any;
}
export interface QueryParameter {
  value: any;
  style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
  explode: boolean;
}
export interface QueryParameters {
  [key: string]: QueryParameter;
}
export type SuccessResponses = Response$getBooks$Status$200 | Response$searchBooks$Status$200;
export namespace ErrorResponse {
  export type getBooks = void;
  export type searchBooks = void;
}
export interface Encoding {
  readonly contentType?: string;
  headers?: Record<string, any>;
  readonly style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
  readonly explode?: boolean;
  readonly allowReserved?: boolean;
}
export interface RequestArgs {
  readonly httpMethod: HttpMethod;
  readonly url: string;
  headers: ObjectLike | any;
  requestBody?: ObjectLike | any;
  requestBodyEncoding?: Record<string, Encoding>;
  queryParameters?: QueryParameters | undefined;
}
export interface ApiClient<RequestOption> {
  request: <T = SuccessResponses>(requestArgs: RequestArgs, options?: RequestOption) => Promise<T>;
}
export const createClient = <RequestOption>(apiClient: ApiClient<RequestOption>, baseUrl: string) => {
  const _baseUrl = baseUrl.replace(/\/$/, "");
  return {
    getBooks: (option?: RequestOption): Promise<Response$getBooks$Status$200["application/json"]> => {
      const url = _baseUrl + `/get/books`;
      const headers = {
        Accept: "application/json",
      };
      return apiClient.request(
        {
          httpMethod: "GET",
          url,
          headers,
        },
        option,
      );
    },
    searchBooks: (params: Params$searchBooks, option?: RequestOption): Promise<Response$searchBooks$Status$200["application/json"]> => {
      const url = _baseUrl + `/search/books`;
      const headers = {
        Accept: "application/json",
      };
      const queryParameters: QueryParameters = {
        filter: { value: params.parameter.filter, style: "deepObject", explode: true },
      };
      return apiClient.request(
        {
          httpMethod: "GET",
          url,
          headers,
          queryParameters: queryParameters,
        },
        option,
      );
    },
  };
};
type ClientFunction<RequestOption> = typeof createClient<RequestOption>;
export type Client<RequestOption> = ReturnType<ClientFunction<RequestOption>>;
