import { EOL } from "os";
import ts from "typescript";
import * as TypeScriptCodeGenerator from "../../TypeScriptCodeGenerator";
import { OpenApi } from "./types";
import * as Parameters from "./Parameters";
import * as Schemas from "./Schemas";
import * as Responses from "./Responses";
import * as RequestBodies from "./RequestBodies";
import * as Headers from "./Headers";
import * as SecuritySchemas from "./SecuritySchemas";
import * as PathItems from "./PathItems";
import * as ToTypeNode from "./toTypeNode";
import { Store } from "./store";

export { OpenApi };

const generateLeadingComment = (schema: OpenApi.RootTypes): string => {
  const messages: string[] = [];
  messages.push("");
  messages.push("Generated by @himenon/openapi-typescript-ast-codegen v0.1.0");
  messages.push("");
  messages.push(`OpenApi : ${schema.openapi}`);
  messages.push("");
  if (schema.info.license) {
    if (schema.info.license.name) {
      messages.push(`License  : ${schema.info.license.name}`);
    }
    if (schema.info.license.url) {
      messages.push(`Url      : ${schema.info.license.url}`);
    }
  }
  if (schema.info.contact) {
    messages.push(`Contact:`);
    if (schema.info.contact.name) {
      messages.push(`  Name  : ${schema.info.contact.name}`);
    }
    if (schema.info.contact.email) {
      messages.push(`  Email : ${schema.info.contact.email}`);
    }
    if (schema.info.contact.url) {
      messages.push(`  Url   : ${schema.info.contact.url}`);
    }
    messages.push("");
  }
  if (schema.externalDocs) {
    messages.push(`Document:`);
    if (schema.externalDocs.description) {
      messages.push(`  Description : ${schema.externalDocs.description}`);
    }
    if (schema.externalDocs.url) {
      messages.push(`  Url         : ${schema.externalDocs.url}`);
    }
  }
  messages.push("");
  return messages
    .map(message => {
      return `// ${message}`;
    })
    .join(EOL);
};

export interface Converter {
  generateLeadingComment: () => string;
  createFunction: TypeScriptCodeGenerator.CreateFunction;
}

export const create = (entryPoint: string, rootSchema: OpenApi.RootTypes): Converter => {
  const currentPoint = entryPoint;
  const createFunction = (context: ts.TransformationContext): ts.Statement[] => {
    const factory = TypeScriptCodeGenerator.Factory.create(context);
    const store = Store.create(factory);

    const setReference: ToTypeNode.SetReferenceCallback = reference => {
      console.log("なんか来た\n" + JSON.stringify(reference, null, 2));
      store.hasStatement();
    };

    if (rootSchema.components) {
      if (rootSchema.components.schemas) {
        Schemas.generateNamespace(entryPoint, currentPoint, store, factory, rootSchema.components.schemas, setReference);
      }
      if (rootSchema.components.headers) {
        Headers.generateNamespace(entryPoint, currentPoint, store, factory, rootSchema.components.headers, setReference);
      }
      if (rootSchema.components.responses) {
        Responses.generateNamespace(entryPoint, currentPoint, store, factory, rootSchema.components.responses, setReference);
      }
      if (rootSchema.components.parameters) {
        Parameters.generateNamespace(entryPoint, currentPoint, store, factory, rootSchema.components.parameters, setReference);
      }
      if (rootSchema.components.requestBodies) {
        RequestBodies.generateNamespace(entryPoint, currentPoint, store, factory, rootSchema.components.requestBodies, setReference);
      }
      if (rootSchema.components.securitySchemes) {
        SecuritySchemas.generateNamespace(entryPoint, currentPoint, store, factory, rootSchema.components.securitySchemes);
      }
      if (rootSchema.components.pathItems) {
        PathItems.generateNamespace(entryPoint, currentPoint, store, factory, rootSchema.components.pathItems, setReference);
      }
      // TODO
      // if (rootSchema.components.links) {
      //   statements.push(Links.generateNamespace(entryPoint, currentPoint, factory, rootSchema.components.links));
      // }

      // TODO
      // if (rootSchema.components.callbacks) {
      //   statements.push(Callbacks.generateNamespace(entryPoint, currentPoint, factory, rootSchema.components.callbacks));
      // }
    }
    return store.getRootStatements();
  };

  return {
    createFunction,
    generateLeadingComment: () => generateLeadingComment(rootSchema),
  };
};
